// Beyond Bell: Full Space Shooter Game
// With Levels, Crafting, RPG Elements, and Survival Mechanics

// Audio Manager Class - Handles all game audio using HTML5 Audio (works with file://)
class AudioManager {
    constructor() {
        // Volume settings (0.0 to 1.0)
        this.volumes = {
            master: 0.7,
            music: 0.6,
            sfx: 0.8,
            voice: 0.7
        };
        
        // Current playing audio
        this.currentMusic = null;
        this.currentMusicElement = null;
        this.pendingMusic = null; // Music waiting for user interaction
        this.musicFadeTime = 1000; // 1 second fade
        
        // Audio element cache
        this.audioElements = {};
        
        // Failed file cache - prevents repeated attempts to load missing files
        this.failedFiles = new Set();
        
        // Sound throttling - prevents excessive sound playback at high fire rates
        this.soundThrottle = {
            shoot: { lastPlayed: 0, minInterval: 50 }, // Max 20 shots/sec
            hit: { lastPlayed: 0, minInterval: 30 },   // Max ~33 hits/sec
            equip: { lastPlayed: 0, minInterval: 100 } // Max 10 equips/sec
        };
        
        // Initialized flag
        this.audioInitialized = false; // Will be set to true when init() is called
        
        
        // Background music tracks
        // If files don't exist, procedural music will be generated automatically
        // To use real music: Download from Incompetech.com or other free sources, convert to OGG, place in music/ folder
        this.musicTracks = {
            main: 'music/main_theme.ogg',           // Main gameplay track (Twisting)
            boss1: 'music/galactic_rap.ogg',        // All bosses use Galactic Rap
            boss2: 'music/galactic_rap.ogg',        // All bosses use Galactic Rap
            boss3: 'music/galactic_rap.ogg',        // All bosses use Galactic Rap
            boss4: 'music/galactic_rap.ogg',        // All bosses use Galactic Rap
            bossAdvanced: 'music/galactic_rap.ogg', // All bosses use Galactic Rap
            menu: 'music/menu_theme.ogg'            // Menu/cutscene music
        };
        
        // Sound effects mapping
        this.sfxFiles = {
            // Combat
            shoot: 'sfx/shoot.ogg',
            laser: 'sfx/laser.ogg',
            hit: 'sfx/hit.ogg',
            explosion: 'sfx/explosion.ogg',
            enemyHit: 'sfx/enemy_hit.ogg',
            enemyDestroy: 'sfx/enemy_destroy.ogg',
            bossHit: 'sfx/boss_hit.ogg',
            bossDestroy: 'sfx/boss_destroy.ogg',
            
            // Player
            playerHit: 'sfx/player_hit.ogg',
            playerDeath: 'sfx/player_death.ogg',
            shieldHit: 'sfx/shield_hit.ogg',
            shieldBreak: 'sfx/shield_break.ogg',
            healthPickup: 'sfx/health_pickup.ogg',
            shieldPickup: 'sfx/shield_pickup.ogg',
            
            // UI
            levelUp: 'sfx/level_up.ogg',
            craft: 'sfx/craft.ogg',
            equip: 'sfx/equip.ogg',
            unequip: 'sfx/unequip.ogg',
            purchase: 'sfx/purchase.ogg',
            buttonClick: 'sfx/button_click.ogg',
            menuOpen: 'sfx/menu_open.ogg',
            menuClose: 'sfx/menu_close.ogg',
            
            // Special
            bellPair: 'sfx/bell_pair.ogg',
            quantum: 'sfx/quantum.ogg',
            repair: 'sfx/repair.ogg',
            hammer: 'sfx/hammer.ogg'
        };
        
        // Voice clips mapping
        this.voiceFiles = {
            bell: [
                'voice/bell/bell_thought_1.ogg',
                'voice/bell/bell_thought_2.ogg',
                'voice/bell/bell_thought_3.ogg',
                'voice/bell/bell_quantum_1.ogg',
                'voice/bell/bell_quantum_2.ogg',
                'voice/bell/bell_einstein_1.ogg',
                'voice/bell/bell_einstein_2.ogg'
            ],
            einstein: [
                'voice/einstein/einstein_reply_1.ogg',
                'voice/einstein/einstein_reply_2.ogg',
                'voice/einstein/einstein_quantum_1.ogg',
                'voice/einstein/einstein_quantum_2.ogg',
                'voice/einstein/einstein_complete_1.ogg',
                'voice/einstein/einstein_complete_2.ogg'
            ]
        };
        
    }
    
    // Initialize audio (HTML5 Audio doesn't need special setup, but we'll use this for user interaction)
    init() {
        // HTML5 Audio works immediately, but browsers require user interaction to play
        this.audioInitialized = true;
        console.log('Audio system initialized (HTML5 Audio)');
    }
    
    // Update all volume levels
    updateVolumes() {
        // Update current music volume if playing
        if (this.currentMusicElement) {
            this.currentMusicElement.volume = this.volumes.master * this.volumes.music;
        }
        
        // Note: Individual SFX/Voice elements are created fresh each time,
        // so they'll use the updated volumes automatically
    }
    
    // Set volume for a specific channel
    setVolume(channel, value) {
        this.volumes[channel] = Math.max(0, Math.min(1, value));
        this.updateVolumes();
    }
    
    // Get or create audio element (HTML5 Audio works with file://)
    getAudioElement(url, channel = 'sfx') {
        try {
            // Check if this file has previously failed to load
            if (this.failedFiles.has(url)) {
                return null; // Don't try again
            }
            
            // Always create a new Audio element for playback (allows simultaneous sounds)
            const audio = new Audio(url);
            audio.preload = 'auto';
            audio.dataset.channel = channel;
            
            // Cache a reference for volume updates (but create new instances for playback)
            if (!this.audioElements[url]) {
                this.audioElements[url] = { url, channel };
            }
            
            // Set volume based on channel
            audio.volume = this.volumes.master * this.volumes[channel];
            
            // Track loading errors to prevent repeated attempts
            audio.addEventListener('error', () => {
                this.failedFiles.add(url);
            }, { once: true });
            
            return audio;
        } catch (e) {
            // Mark as failed and don't try again
            this.failedFiles.add(url);
            return null;
        }
    }
    
    // Play sound effect (HTML5 Audio - works with file://)
    playSFX(sfxName, volume = 1.0, pitch = 1.0) {
        try {
            // Check if file is known to be missing
            const url = this.sfxFiles[sfxName];
            if (!url) {
                // Silently fail - file not configured
                return;
            }
            
            // Check if this file has previously failed
            if (this.failedFiles.has(url)) {
                return; // Don't try to play missing files
            }
            
            // Throttle frequently played sounds to prevent performance issues
            const throttle = this.soundThrottle[sfxName];
            if (throttle) {
                const now = Date.now();
                if (now - throttle.lastPlayed < throttle.minInterval) {
                    return; // Skip this sound - too soon since last play
                }
                throttle.lastPlayed = now;
            }
            
            const audio = this.getAudioElement(url, 'sfx');
            if (!audio) {
                // Silently fail - file not found (already cached in failedFiles)
                return;
            }
            
            // Clone for simultaneous playback
            const audioClone = audio.cloneNode();
            audioClone.volume = this.volumes.master * this.volumes.sfx * volume;
            audioClone.playbackRate = pitch;
            
            // Play and clean up
            audioClone.play().catch(e => {
                // Mark as failed if play fails
                this.failedFiles.add(url);
            });
            
            audioClone.onended = () => {
                audioClone.remove();
            };
        } catch (e) {
            // Silently fail - don't break gameplay
        }
    }
    
    // Play background music with seamless crossfade between tracks
    playMusic(trackName, loop = true, fadeIn = true) {
        const url = this.musicTracks[trackName];
        if (!url) {
            console.warn(`Music track not found: ${trackName}`);
            return;
        }
        
        // If same track is already playing, don't restart
        if (this.currentMusic === trackName && this.currentMusicElement) {
            return;
        }
        
        console.log(`[Audio] Playing music: ${trackName} from ${url}`);
        
        // Seamless crossfade: fade out current music while fading in new music
        if (this.currentMusicElement) {
            this.crossfadeToNewTrack(url, loop, fadeIn);
        } else {
            this.startMusic(url, loop, fadeIn);
        }
        
        this.currentMusic = trackName;
    }
    
    // Crossfade from current track to new track (seamless transition)
    crossfadeToNewTrack(newUrl, loop, fadeIn) {
        const oldAudio = this.currentMusicElement;
        const crossfadeDuration = 3.0; // 3 seconds crossfade
        const targetVolume = this.volumes.master * this.volumes.music;
        
        // Create new audio element
        const newAudio = new Audio(newUrl);
        newAudio.preload = 'auto';
        newAudio.volume = 0; // Start at 0
        newAudio.loop = loop;
        newAudio.dataset.isMusic = 'true';
        
        // Start loading new track
        newAudio.load();
        
        // Wait for new track to be ready
        const startCrossfade = () => {
            // Start playing new track at volume 0
            newAudio.play().catch(e => {
                console.warn('[Audio] Autoplay blocked during crossfade:', e);
            });
            
            // Crossfade: fade out old, fade in new simultaneously
            const startTime = Date.now();
            const fadeInterval = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000;
                const progress = Math.min(1.0, elapsed / crossfadeDuration);
                
                if (oldAudio && oldAudio.parentNode !== null) {
                    // Fade out old track
                    oldAudio.volume = targetVolume * (1 - progress);
                }
                
                // Fade in new track
                newAudio.volume = targetVolume * progress;
                
                // When crossfade complete
                if (progress >= 1.0) {
                    clearInterval(fadeInterval);
                    // Stop and remove old track
                    if (oldAudio) {
                        oldAudio.pause();
                        oldAudio.currentTime = 0;
                    }
                    // Set new track as current
                    this.currentMusicElement = newAudio;
                    // Set up seamless looping for new track
                    this.setupSeamlessLoopForAudio(newAudio, loop);
                    console.log('[Audio] Crossfade complete');
                }
            }, 50); // Update every 50ms for smooth fade
        };
        
        // Wait for new track to be ready
        if (newAudio.readyState >= 3) {
            startCrossfade();
        } else {
            newAudio.addEventListener('canplaythrough', startCrossfade, { once: true });
        }
    }
    
    // Start playing music with seamless looping
    startMusic(url, loop, fadeIn) {
        try {
            console.log(`[Audio] Creating audio element for: ${url}`);
            const audio = new Audio(url);
            audio.preload = 'auto';
            // Set initial volume - if looping with fadeIn, seamless loop will handle it
            // Otherwise, set volume based on fadeIn parameter
            audio.volume = (fadeIn && loop) ? 0 : (fadeIn ? 0 : (this.volumes.master * this.volumes.music));
            audio.dataset.isMusic = 'true';
            
            // Add error handlers
            audio.onerror = (e) => {
                console.error(`[Audio] Error loading music file: ${url}`, e);
                if (audio.error) {
                    switch(audio.error.code) {
                        case 1: console.error('[Audio] MEDIA_ERR_ABORTED - User aborted'); break;
                        case 2: console.error('[Audio] MEDIA_ERR_NETWORK - Network error'); break;
                        case 3: console.error('[Audio] MEDIA_ERR_DECODE - Decode error'); break;
                        case 4: console.error('[Audio] MEDIA_ERR_SRC_NOT_SUPPORTED - Format not supported'); break;
                    }
                }
            };
            
            // Set up seamless looping
            if (loop) {
                this.setupSeamlessLoopForAudio(audio, loop, fadeIn);
            } else {
                // Handle end of track (if not looping)
                audio.onended = () => {
                    console.log(`[Audio] Music ended: ${url}`);
                    this.currentMusicElement = null;
                };
            }
            
            // Wait for audio to be ready before playing
            const startPlaying = () => {
                // For initial fade-in, the seamless loop system handles it if looping
                // For non-looping tracks, use quick fade-in
                if (fadeIn && !loop) {
                    // Quick fade-in for non-looping tracks
                    const targetVolume = this.volumes.master * this.volumes.music;
                    const fadeStep = targetVolume / (this.musicFadeTime / 50); // 50ms steps
                    let currentVolume = 0;
                    
                    const fadeInterval = setInterval(() => {
                        if (!this.currentMusicElement || this.currentMusicElement !== audio) {
                            clearInterval(fadeInterval);
                            return;
                        }
                        currentVolume += fadeStep;
                        if (currentVolume >= targetVolume) {
                            audio.volume = targetVolume;
                            clearInterval(fadeInterval);
                        } else {
                            audio.volume = currentVolume;
                        }
                    }, 50);
                }
                
                // Try to play the music
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log(`[Audio] Music playing successfully: ${url}`);
                            console.log(`[Audio] Duration: ${audio.duration}s, Volume: ${audio.volume}, Loop: ${loop}`);
                            if (loop) {
                                console.log(`[Audio] Seamless crossfade looping enabled (10s fade in/out)`);
                            }
                        })
                        .catch(e => {
                            console.warn(`[Audio] Music autoplay blocked: ${url}`, e);
                            // Store reference so we can play it after user interaction
                            this.pendingMusic = audio;
                        });
                }
            };
            
            // Wait for audio to be fully loaded before playing
            audio.addEventListener('canplaythrough', () => {
                console.log(`[Audio] Music fully loaded and ready: ${url}`);
                if (this.currentMusicElement === audio) {
                    startPlaying();
                }
            }, { once: true });
            
            // Also handle if it's already loaded
            if (audio.readyState >= 3) { // HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA
                startPlaying();
            }
            
            // Start loading immediately
            audio.load();
            
            this.currentMusicElement = audio;
            console.log(`[Audio] Music element created, loop: ${loop}, fadeIn: ${fadeIn}`);
        } catch (e) {
            console.error(`[Audio] Failed to create/play music: ${url}`, e);
        }
    }
    
    // Set up seamless looping for an audio element
    setupSeamlessLoopForAudio(audio, loop, fadeIn = false) {
        if (!loop) return;
        
        // Seamless loop with crossfade - fade out last 10 seconds, fade in first 10 seconds
        const fadeDuration = 10.0; // 10 seconds fade in/out for ultra-smooth seamless looping
        let isFadingOut = false;
        let isFadingIn = fadeIn; // Start with fade-in if requested
        let fadeOutStartTime = 0;
        let fadeInStartTime = 0;
        const targetVolume = this.volumes.master * this.volumes.music;
        
        const seamlessLoop = () => {
            if (!loop || !this.currentMusicElement || this.currentMusicElement !== audio) {
                return;
            }
            
            if (!audio.duration) return;
            
            const currentTime = audio.currentTime;
            const timeRemaining = audio.duration - currentTime;
            
            // Fade out during last 10 seconds
            if (timeRemaining <= fadeDuration && timeRemaining > 0) {
                if (!isFadingOut) {
                    isFadingOut = true;
                    fadeOutStartTime = currentTime;
                }
                
                // Calculate fade out volume (1.0 at start of fade, 0.0 at end)
                const fadeProgress = timeRemaining / fadeDuration;
                const fadeOutVolume = Math.max(0, fadeProgress) * targetVolume;
                audio.volume = fadeOutVolume;
            } else if (timeRemaining > fadeDuration) {
                // Not in fade zone, ensure full volume
                if (isFadingOut) {
                    isFadingOut = false;
                }
                if (!isFadingIn) {
                    audio.volume = targetVolume;
                }
            }
            
            // When we reach the end (or very close), restart with fade in
            if (timeRemaining <= 0.05 && !isFadingIn) {
                isFadingIn = true;
                fadeInStartTime = 0;
                audio.currentTime = 0;
                audio.volume = 0; // Start at 0 for fade in
                
                // Ensure it keeps playing
                if (audio.paused) {
                    audio.play().catch(() => {
                        // Ignore autoplay errors
                    });
                }
            }
            
            // Fade in during first 10 seconds after restart
            if (isFadingIn && currentTime < fadeDuration) {
                const fadeProgress = currentTime / fadeDuration;
                const fadeInVolume = Math.min(1.0, fadeProgress) * targetVolume;
                audio.volume = fadeInVolume;
            } else if (isFadingIn && currentTime >= fadeDuration) {
                // Fade in complete
                isFadingIn = false;
                audio.volume = targetVolume;
            }
        };
        
        // Attach the seamless loop to the audio element's timeupdate event
        audio.addEventListener('timeupdate', seamlessLoop);
        
        // Store reference to cleanup later if needed
        audio.dataset.seamlessLoop = 'true';
    }
    
    // Fade out current music
    fadeOutMusic(callback) {
        if (!this.currentMusicElement) {
            if (callback) callback();
            return;
        }
        
        const audio = this.currentMusicElement;
        const startVolume = audio.volume;
        const fadeStep = startVolume / (this.musicFadeTime / 50); // 50ms steps
        let currentVolume = startVolume;
        
        const fadeInterval = setInterval(() => {
            currentVolume -= fadeStep;
            if (currentVolume <= 0) {
                audio.volume = 0;
                audio.pause();
                audio.currentTime = 0;
                this.currentMusicElement = null;
                clearInterval(fadeInterval);
                if (callback) callback();
            } else {
                audio.volume = currentVolume;
            }
        }, 50);
    }
    
    // Stop all music
    stopMusic() {
        if (this.currentMusicElement) {
            this.fadeOutMusic();
        }
    }
    
    
    // Stop all audio
    stopAll() {
        this.stopMusic();
    }
}

class SpaceShooterGame {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        
        // OPTIMIZATION: Cache frequently accessed DOM elements to avoid repeated queries
        this._cachedElements = {
            // Game canvas and context
            gameCanvas: this.canvas,
            cutsceneCanvas: document.getElementById('cutsceneCanvas'),
            cutsceneOverlay: document.getElementById('cutsceneOverlay'),
            cutsceneText: document.getElementById('cutsceneText'),
            
            // UI Panels
            craftingUI: document.getElementById('craftingUI'),
            shopUI: document.getElementById('shopUI'),
            inventoryUI: document.getElementById('inventoryUI'),
            leaderboardUI: document.getElementById('leaderboardUI'),
            settingsUI: document.getElementById('settingsUI'),
            tutorialUI: document.getElementById('tutorialUI'),
            levelUpContinueUI: document.getElementById('levelUpContinueUI'),
            
            // Stats Display
            scoreValue: document.getElementById('scoreValue'),
            hitsValue: document.getElementById('hitsValue'),
            missesValue: document.getElementById('missesValue'),
            accuracyDisplay: document.getElementById('accuracyDisplay'),
            targetCount: document.getElementById('targetCount'),
            
            // Inventory Display
            invQuantum: document.getElementById('invQuantum'),
            invEnergy: document.getElementById('invEnergy'),
            invMetal: document.getElementById('invMetal'),
            invCrystals: document.getElementById('invCrystals'),
            invTokens: document.getElementById('invTokens'),
            
            // Save Feature
            loadSaveBtn: document.getElementById('loadSaveBtn'),
            saveHint: document.getElementById('saveHint'),
            
            // Top Scores
            topScoreDisplay: document.getElementById('topScoreDisplay'),
            topLevelDisplay: document.getElementById('topLevelDisplay'),
            
            // Mode Buttons
            ensembleBtn: document.getElementById('ensembleBtn'),
            individualBtn: document.getElementById('individualBtn'),
            bellBtn: document.getElementById('bellBtn'),
            modeDisplay: document.getElementById('modeDisplay'),
            
            // Other UI Elements
            ui: document.getElementById('ui'),
            theoryPanel: document.getElementById('theoryPanel'),
            instructions: document.getElementById('instructions'),
            currentTheory: document.getElementById('currentTheory'),
            score: document.getElementById('score'),
            
            // Settings UI Elements
            sensitivitySlider: document.getElementById('sensitivitySlider'),
            sensitivityValue: document.getElementById('sensitivityValue'),
            fullscreenToggle: document.getElementById('fullscreenToggle'),
            particlesToggle: document.getElementById('particlesToggle'),
            explosionsToggle: document.getElementById('explosionsToggle'),
            screenShakeToggle: document.getElementById('screenShakeToggle'),
            
            // Inventory List Elements
            inventoryWeaponsList: document.getElementById('inventoryWeaponsList'),
            inventoryShipsList: document.getElementById('inventoryShipsList'),
            inventoryShieldsList: document.getElementById('inventoryShieldsList'),
            inventoryUpgradesList: document.getElementById('inventoryUpgradesList'),
            inventoryConsumablesList: document.getElementById('inventoryConsumablesList')
        };
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Track if we want to stay in fullscreen (prevents ESC from exiting)
        this.forceFullscreen = false;
        
        // Fullscreen change listeners (update checkbox when fullscreen changes and handle resize)
        const handleFullscreenChange = () => {
            this.updateSettingsUI();
            // Preserve player position when entering/exiting fullscreen
            this.resize();
            
            // WORKAROUND: If ESC exits fullscreen and we want to stay in fullscreen, re-enter immediately
            if (this.forceFullscreen && !this.isFullscreen()) {
                // ESC was pressed and exited fullscreen - re-enter it immediately
                setTimeout(() => {
                    if (this.forceFullscreen && !this.isFullscreen()) {
                        this.toggleFullscreen();
                    }
                }, 10); // Small delay to ensure browser has processed the exit
            }
        };
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        // Dev Mode - MUST be set before event listeners
        this.devMode = window.DEV_MODE || false;
        this.devGodMode = false;
        this.devInfiniteAmmo = false;
        this.devShowDebug = false;
        this.devSpeedMultiplier = 1.0;
        
        if (this.devMode) {
            console.log('[DEV] ========================================');
            console.log('[DEV] Developer mode is ENABLED');
            console.log('[DEV] Press F1 to toggle dev panel');
            console.log('[DEV] F1-F10 shortcuts are active');
            console.log('[DEV] ========================================');
        }
        
        // Prevent ESC from exiting fullscreen - intercept in capture phase
        const self = this; // Store reference for use in event listener
        document.addEventListener('keydown', function(e) {
            // In dev mode, allow ESC to work normally
            if (self.devMode && e.key === 'Escape') {
                return; // Don't block ESC in dev mode
            }
            
            // Check if we're in fullscreen
            const isFullscreen = !!(document.fullscreenElement || 
                                    document.webkitFullscreenElement || 
                                    document.mozFullScreenElement || 
                                    document.msFullscreenElement);
            
            if (e.key === 'Escape' && isFullscreen && self.forceFullscreen) {
                // Prevent default and stop propagation
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                // Still allow our normal ESC handler to run for pause/menus
                // But prevent browser from exiting fullscreen
            }
        }, true); // Capture phase - intercepts before browser handles it
        
        // Audio Manager
        this.audio = new AudioManager();
        
        // Initialize audio on first user interaction
        const initAudioOnInteraction = (e) => {
            // Don't block audio init for F-keys in dev mode - let it initialize
            // Only skip if it's a dev mode F-key that we want to handle separately
            if (this.devMode && e && e.code && (e.code.startsWith('F') && parseInt(e.code.substring(1)) >= 1 && parseInt(e.code.substring(1)) <= 12)) {
                // F-keys in dev mode - still initialize audio but don't prevent the dev shortcut
                this.audio.init();
                return; // Let the dev shortcut handler run
            }
            
            this.audio.init();
            
            // If there's pending music (blocked by autoplay), play it now
            if (this.audio.pendingMusic) {
                console.log('[Audio] Playing pending music after user interaction');
                this.audio.pendingMusic.play().then(() => {
                    console.log('[Audio] Pending music started successfully');
                    this.audio.pendingMusic = null;
                }).catch(e => {
                    console.error('[Audio] Failed to play pending music:', e);
                });
            }
            
            // If game is already playing and music should be playing, try to start it
            if (this.gameState === 'playing' && this.audio.currentMusic === 'main' && !this.audio.currentMusicElement) {
                console.log('[Audio] Restarting main music after user interaction');
                this.audio.playMusic('main', true, true);
            }
            
            document.removeEventListener('click', initAudioOnInteraction);
            document.removeEventListener('keydown', initAudioOnInteraction);
        };
        document.addEventListener('click', initAudioOnInteraction, { once: true });
        document.addEventListener('keydown', initAudioOnInteraction, { once: true });
        
        // Game state
        this.mode = 'individual';
        this.level = 1;
        this.gameState = 'cutscene'; // 'cutscene', 'playing', 'paused', 'crafting', 'shop', 'inventory', 'gameover', 'tutorial'
        this.isPaused = false;
        this.bossMode = false; // Track if we're in a boss battle
        this.currentBoss = null; // Current boss entity
        this.bossPuzzleState = {}; // Track puzzle state for boss (e.g., which parts need to be hit)
        
        // Resume smoothing - prevents lag when unpausing with many effects/bullets
        this.resumeSmoothing = {
            active: false,
            framesRemaining: 0,
            targetDeltaTime: 0.016 // Target 60fps
        };
        
        // Hidden sequence tracking for save feature unlock
        // Sequence: Bell mode for 5 levels (1-5), Ensemble mode for 3 levels (6-8), Individual mode for 2 levels (9-10)
        this.hiddenSequence = {
            bellLevels: new Set(),      // Track which levels (1-5) were completed in Bell mode
            ensembleLevels: new Set(),  // Track which levels (6-8) were completed in Ensemble mode
            individualLevels: new Set(), // Track which levels (9-10) were completed in Individual mode
            lastMode: null,    // Track last mode to detect mode switches
            lastLevel: 1,      // Track last level to detect level progression
            levelStartTime: {}, // Track when each level started (for grace period)
            gracePeriod: 10,   // 10 seconds grace period after leveling up to switch modes
            sequenceComplete: false, // Whether the sequence has been completed
            saveUnlocked: false, // Whether save feature is unlocked
            notificationShown: false, // Whether unlock notification has been shown
            lastAutoSaveLevel: 0 // Track last level we auto-saved at
        };
        this.savedGameState = null; // Store saved game state (allows reverting to 2 levels back)
        
        // Cutscene state
        this.cutsceneTime = 0;
        this.cutscenePhase = 0; // Phase within current cutscene
        this.cutsceneId = 'opening'; // ID of current cutscene ('opening', 'level5', 'level10', etc.)
        this.cutscenesShown = JSON.parse(localStorage.getItem('cutscenesShown') || '[]'); // Track which cutscenes have been shown
        this.cutsceneIsManual = false; // Track if cutscene was triggered manually (dev mode) vs automatically (level progression)
        // OPTIMIZATION: Use cached DOM element
        this.cutsceneCanvas = this._cachedElements.cutsceneCanvas;
        this.cutsceneCtx = null;
        if (this.cutsceneCanvas) {
            this.cutsceneCtx = this.cutsceneCanvas.getContext('2d');
            this.cutsceneCanvas.width = window.innerWidth;
            this.cutsceneCanvas.height = window.innerHeight;
        }
        // OPTIMIZATION: Use cached DOM elements
        this.cutsceneOverlay = this._cachedElements.cutsceneOverlay;
        this.cutsceneText = this._cachedElements.cutsceneText;
        // Always show opening cutscene on game start (removed localStorage check)
        this.showCutscene = true;
        
        // Player stats (RPG)
        this.playerStats = {
            health: 100,
            maxHealth: 100,
            baseMaxHealth: 100,
            shield: 0,
            maxShield: 0,
            speed: 150, // Start slower
            baseSpeed: 150,
            fireRate: 0.5, // shots per second
            lastDamageTime: 0, // Track when player last took damage (for cooldown)
            damageCooldown: 1.5, // Cooldown in seconds before taking damage again (1.5s = 1500ms) - doubled for better escape time
            baseFireRate: 0.5,
            damage: 10,
            baseDamage: 10,
            // New RPG stats
            criticalHitChance: 0, // Percentage (0-100)
            criticalHitDamage: 2.0, // Multiplier (2.0 = 2x damage)
            shieldCapacityBonus: 0, // Percentage bonus to shield capacity
            shieldRegenBonus: 0, // Flat bonus to shield regen per second
            damageReduction: 0, // Percentage damage reduction (0-50% cap)
            evasion: 0, // Percentage dodge chance (0-30% cap)
            materialDropRate: 0, // Percentage bonus to material drop chance
            tokenDropRate: 0, // Percentage bonus to token drop rate
            levelTimeReduction: 0, // Percentage reduction to time needed per level (reduces 30s requirement)
            projectileSpeed: 0, // Percentage bonus to projectile speed
            healthRegen: 0 // Health regenerated per second
        };
        
        // Track upgrade levels for cost calculation
        this.upgradeLevels = {
            speed: 0,
            fireRate: 0,
            damage: 0,
            maxHealth: 0,
            criticalHitChance: 0,
            criticalHitDamage: 0,
            shieldCapacityBonus: 0,
            shieldRegenBonus: 0,
            damageReduction: 0,
            evasion: 0,
            materialDropRate: 0,
            tokenDropRate: 0,
            levelTimeReduction: 0,
            projectileSpeed: 0,
            healthRegen: 0
        };
        
        // Player equipment
        this.currentShip = 'basic';
        this.currentWeapons = ['basic']; // Array to support multiple weapons
        this.currentShield = 'none';
        this.currentUpgrades = []; // Array to support multiple upgrades (targeting computer, auto-collector, etc.)
        
        // Owned items inventory (items persist until destroyed or decay to 0)
        // Structure: { itemName: { count: X, durability: Y } } or { itemName: X } for consumables
        this.ownedItems = {
            weapons: { basic: { count: 1, durability: 100 } }, // Start with basic weapon at full durability
            ships: { basic: { count: 1, durability: 100 } }, // Start with basic ship at full durability
            shields: {}, // No shield at start
            upgrades: {}, // No upgrades at start
            consumables: {}, // Health packs, etc. (no durability - consumables)
            tools: {} // Hammer, etc. (has durability)
        };
        
        // Track weapon upgrade levels (0 = no upgrades, 1-4 = upgrade tiers)
        this.weaponUpgrades = {}; // e.g., { rapid: 2, spread: 1 } means rapid is at tier 2, spread at tier 1
        
        // Level-up state - tracks if we're in level-up menu
        this.levelUpState = false;
        
        // Inventory & Crafting
        this.inventory = {
            quantumParticles: 0,
            energyCores: 0,
            metalScraps: 0,
            crystals: 0,
            tokens: 0,
            // Biological components for survival system
            atp: 0,              // Adenosine Triphosphate - energy currency
            aminoAcids: 0,        // Building blocks of proteins
            simpleSugars: 0,     // Glucose and other simple carbohydrates
            fattyAcids: 0,        // Lipid components
            nucleotides: 0,       // DNA/RNA building blocks
            vitamins: 0,         // Essential micronutrients
            minerals: 0           // Essential minerals (iron, calcium, etc.)
        };
        
        // Crafting recipes - balanced for progression (increased costs to slow down early game power spike)
        this.recipes = {
            weapons: {
                basic: { quantumParticles: 1, crystals: 1, metalScraps: 1 }, // Starter weapon - low cost for repairs
                rapid: { quantumParticles: 8, crystals: 5, energyCores: 2 }, // Increased cost - early tier but more expensive
                spread: { quantumParticles: 12, crystals: 8, energyCores: 3, metalScraps: 2 }, // Increased cost - early-mid tier
                laser: { quantumParticles: 18, crystals: 12, energyCores: 6, metalScraps: 4 }, // Increased cost - mid tier
                automatic: { quantumParticles: 25, crystals: 18, metalScraps: 8, energyCores: 8 }, // Increased cost - late tier
                // High-tier weapons based on Einstein's individual system physics
                transformationPredictor: { quantumParticles: 120, crystals: 100, energyCores: 80, metalScraps: 60, tokens: 50 }, // Predicts exact transformation times - very high tier
                deterministicEngine: { quantumParticles: 180, crystals: 150, energyCores: 120, metalScraps: 100, tokens: 80 }, // Complete individual system description - ultra high tier
                individualSystemCore: { quantumParticles: 250, crystals: 200, energyCores: 180, metalScraps: 150, tokens: 120 } // Individual system bypass technology - highest tier
            },
            weaponUpgrades: {
                // Rapid weapon upgrades (4 tiers - each increases fire rate substantially)
                rapid: {
                    1: { quantumParticles: 8, crystals: 5, energyCores: 3 }, // +0.9 fire rate (more expensive than base weapon)
                    2: { quantumParticles: 15, crystals: 10, energyCores: 6, metalScraps: 3 }, // +0.9 fire rate (more expensive than tier 1)
                    3: { quantumParticles: 25, crystals: 18, energyCores: 12, metalScraps: 8 }, // +0.9 fire rate (substantial cost)
                    4: { quantumParticles: 40, crystals: 30, energyCores: 20, metalScraps: 15 } // +0.9 fire rate (very expensive, late game)
                },
                // Spread weapon upgrades (4 tiers - each increases spread count substantially)
                spread: {
                    1: { quantumParticles: 10, crystals: 7, energyCores: 4 }, // Spread: 3→4 (more expensive than base spread)
                    2: { quantumParticles: 18, crystals: 12, energyCores: 8, metalScraps: 5 }, // Spread: 4→5 (more expensive than tier 1)
                    3: { quantumParticles: 28, crystals: 20, energyCores: 14, metalScraps: 10 }, // Spread: 5→6 (substantial cost)
                    4: { quantumParticles: 42, crystals: 32, energyCores: 22, metalScraps: 18 } // Spread: 6→7 (very expensive, late game)
                },
                // Laser weapon upgrades (4 tiers - increases duration and damage substantially)
                laser: {
                    1: { quantumParticles: 12, crystals: 8, energyCores: 5, metalScraps: 3 }, // +0.8s duration, +8 damage (more expensive than base laser)
                    2: { quantumParticles: 22, crystals: 15, energyCores: 10, metalScraps: 8 }, // +0.8s duration, +8 damage (more expensive than tier 1)
                    3: { quantumParticles: 35, crystals: 25, energyCores: 18, metalScraps: 15 }, // +0.8s duration, +8 damage (substantial cost)
                    4: { quantumParticles: 50, crystals: 38, energyCores: 28, metalScraps: 25 } // +0.8s duration, +8 damage (very expensive, late game)
                },
                // Automatic weapon upgrade (1 tier - omnidirectional, very expensive, late game)
                automatic: {
                    1: { quantumParticles: 50, crystals: 40, energyCores: 25, metalScraps: 30 } // Omnidirectional shooting (8 directions)
                }
            },
            ships: {
                basic: { quantumParticles: 2, crystals: 1, metalScraps: 2 }, // Starter ship - low cost for repairs
                fast: { quantumParticles: 5, crystals: 3, metalScraps: 5 }, // Early tier
                rapid: { quantumParticles: 12, crystals: 8, metalScraps: 6, energyCores: 3 }, // Enhanced rapid ship - mid-late tier
                tank: { quantumParticles: 8, crystals: 5, metalScraps: 8 }, // Mid tier
                agile: { quantumParticles: 10, crystals: 5, metalScraps: 5, energyCores: 2 }, // Late tier
                // High-tier ships based on Einstein's individual system physics
                individualStabilizer: { quantumParticles: 100, crystals: 80, energyCores: 60, metalScraps: 50, tokens: 40 }, // Stabilizes individual systems - high tier
                completeDescriptionVessel: { quantumParticles: 180, crystals: 150, energyCores: 120, metalScraps: 100, tokens: 80 } // Complete individual system vessel - ultra high tier
            },
            shields: {
                basic: { quantumParticles: 3, crystals: 2, metalScraps: 3 }, // Early tier
                reinforced: { quantumParticles: 6, crystals: 4, metalScraps: 5 }, // Mid tier
                quantum: { quantumParticles: 15, crystals: 10, energyCores: 5, metalScraps: 8 }, // Late tier - best shield (more expensive)
                // High-tier shields based on Einstein's individual system physics
                ontologicalReality: { quantumParticles: 120, crystals: 100, energyCores: 80, metalScraps: 60, tokens: 50 }, // Makes wave function ontological - high tier
                individualSystemBarrier: { quantumParticles: 200, crystals: 180, energyCores: 150, metalScraps: 120, tokens: 100 } // Complete individual system protection - ultra high tier
            },
            upgrades: {
                targetingComputer: { quantumParticles: 15, crystals: 10, energyCores: 5, metalScraps: 8 }, // Late game - enables crosshair
                autoCollector: { quantumParticles: 25, crystals: 20, energyCores: 10, metalScraps: 15 }, // Late game - attracts all items
                // High-tier upgrades based on Einstein's individual system physics
                completeDescriptionMatrix: { quantumParticles: 150, crystals: 120, energyCores: 100, metalScraps: 80, tokens: 60 }, // Completes QM description for individual systems - high tier
                ensembleBypass: { quantumParticles: 250, crystals: 200, energyCores: 180, metalScraps: 150, tokens: 120 }, // Sidesteps ensemble limitations - ultra high tier
                transformationTimeScanner: { quantumParticles: 180, crystals: 150, energyCores: 120, metalScraps: 100, tokens: 80 }, // Scans exact transformation times (radioactive atom model) - high tier
                individualSystemAmplifier: { quantumParticles: 300, crystals: 250, energyCores: 220, metalScraps: 200, tokens: 150 } // Amplifies individual system properties - highest tier
            },
            consumables: {
                atomSplit: { quantumParticles: 30, crystals: 25, energyCores: 15, metalScraps: 20 }, // Late game - clears everything on screen
                // Food items for survival system
                basicMeal: { atp: 5, aminoAcids: 3, simpleSugars: 2 }, // Basic nutrition - restores 20 hunger
                proteinBar: { aminoAcids: 8, simpleSugars: 4 }, // High protein - restores 35 hunger
                energyDrink: { atp: 10, simpleSugars: 6 }, // Quick energy - restores 35 hunger (improved from 30), +5 methane
                balancedMeal: { atp: 8, aminoAcids: 6, simpleSugars: 5, fattyAcids: 3, vitamins: 2 }, // Complete nutrition - restores 50 hunger
                superFood: { atp: 15, aminoAcids: 12, simpleSugars: 10, fattyAcids: 5, vitamins: 4, minerals: 3 }, // Ultimate nutrition - restores 100 hunger (improved from 80), +15 methane
                methaneSnack: { simpleSugars: 3, fattyAcids: 2 } // Quick methane boost - restores 10 hunger, +10 methane
            },
            tools: {
                hammer: { quantumParticles: 12, crystals: 8, metalScraps: 10, energyCores: 5 } // In-game repair tool (unlocked at level 10)
            }
        };
        
        // Equipment stats
        this.equipmentStats = {
            ships: {
                basic: { speed: 150, health: 100, size: 27, color: '#4fc3f7', shape: 'triangle' }, // Atomic Fighter
                fast: { speed: 220, health: 75, size: 25, color: '#ff9800', shape: 'sleek', bonus: 'speedBoost' }, // Faster, roughly matching basic ship size
                rapid: { speed: 260, health: 95, size: 26, color: '#9c27b0', shape: 'rapid', bonus: 'rapidFire', description: 'Enhanced rapid ship - extreme speed with rapid-fire capabilities' }, // Enhanced rapid ship - faster than fast, better health, matching basic ship size, purple color scheme
                tank: { speed: 90, health: 250, size: 28, color: '#9e9e9e', shape: 'wide', bonus: 'damageResist' }, // Slower, bigger, more health, takes less damage
                agile: { speed: 190, health: 110, size: 16, color: '#00bcd4', shape: 'diamond', bonus: 'evasion' }, // Balanced, smaller hitbox, better dodging
                // High-tier ships based on Einstein's individual system physics
                individualStabilizer: { speed: 250, health: 200, size: 18, color: '#ff6b00', shape: 'sleek', bonus: 'stabilized', description: 'Stabilizes individual systems - high speed and health' },
                completeDescriptionVessel: { speed: 280, health: 350, size: 22, color: '#8b00ff', shape: 'diamond', bonus: 'complete', description: 'Complete individual system vessel - ultimate balance' }
            },
            weapons: {
                basic: { fireRate: 0.5, damage: 10, color: '#4caf50', automatic: false, isLaser: false },
                rapid: { fireRate: 1.0, damage: 8, color: '#ff9800', automatic: false, isLaser: false },
                spread: { fireRate: 0.4, damage: 12, color: '#9c27b0', spread: 3, automatic: false, isLaser: false },
                laser: { fireRate: 0.3, damage: 20, color: '#f44336', automatic: false, isLaser: true, beamDuration: 2.0, beamCooldown: 3.0 }, // Continuous beam, 2s active, 3s cooldown
                automatic: { fireRate: 2.0, damage: 7, color: '#00bcd4', automatic: true, isLaser: false },
                // High-tier weapons based on Einstein's individual system physics
                transformationPredictor: { fireRate: 0.8, damage: 35, color: '#ff6b00', automatic: false, isLaser: false, description: 'Predicts exact transformation times - high damage, penetrates defenses' },
                deterministicEngine: { fireRate: 1.5, damage: 45, color: '#8b00ff', automatic: false, isLaser: false, description: 'Complete individual system description - devastating damage' },
                individualSystemCore: { fireRate: 3.0, damage: 60, color: '#00ffff', automatic: true, isLaser: false, description: 'Individual system bypass - omnidirectional, massive damage' }
            },
            shields: {
                none: { capacity: 0, regen: 0 },
                basic: { capacity: 50, regen: 0 }, // No regen - breaks when depleted
                reinforced: { capacity: 100, regen: 0 }, // No regen - breaks when depleted
                quantum: { capacity: 150, regen: 15 }, // Only quantum recharges
                // High-tier shields based on Einstein's individual system physics
                ontologicalReality: { capacity: 300, regen: 30, description: 'Makes wave function ontological - massive capacity and fast regen' },
                individualSystemBarrier: { capacity: 500, regen: 50, description: 'Complete individual system protection - ultimate defense' }
            },
            upgrades: {
                none: { enabled: false },
                targetingComputer: { enabled: true, description: 'Enables targeting crosshair and aim assist' },
                autoCollector: { enabled: true, description: 'Automatically attracts all material drops to you from anywhere on screen' },
                // High-tier upgrades based on Einstein's individual system physics
                completeDescriptionMatrix: { enabled: true, description: 'Completes QM description for individual systems - +50% damage, +30% fire rate' },
                ensembleBypass: { enabled: true, description: 'Sidesteps ensemble limitations - +100% resource drops, +50% movement speed' },
                transformationTimeScanner: { enabled: true, description: 'Scans exact transformation times - reveals enemy weak points, +40% critical hit chance' },
                individualSystemAmplifier: { enabled: true, description: 'Amplifies individual system properties - +75% all stats, +200% resource drops' }
            },
            tools: {
                hammer: { description: 'In-game repair tool - Press Q to equip/use. Repairs items during gameplay. Decays with use.' }
            }
        };
        
        // Player
        this.player = {
            x: 0,
            y: 0,
            size: 20, // Will be updated from ship stats below
            lastShot: 0,
            angle: 0, // Ship rotation angle (0 = pointing up)
            lastShotByWeapon: {}, // Track cooldown per weapon for multiple weapons
            laserActive: false, // Is laser currently firing
            laserCharge: 0, // Current laser charge (0-1)
            laserCooldown: 0, // Time until laser can fire again
            bossHitEffect: 0, // Visual effect timer when touching boss (0 = no effect, >0 = effect active)
            bossHitIntensity: 0 // Intensity of boss hit effect (0-1)
        };
        
        // Apply ship size from current ship (must be after player and equipmentStats are initialized)
        const initialShip = this.equipmentStats.ships[this.currentShip];
        if (initialShip) {
            this.player.size = initialShip.size;
        }
        
        // Active laser beam (for continuous beam rendering)
        this.activeLaser = null; // { x1, y1, x2, y2, angle, damage, color, lifetime }
        
        // Game objects
        this.bullets = [];
        // OPTIMIZATION: Object pooling for bullets - reuse objects to reduce garbage collection
        this._bulletPool = [];
        this._bulletPoolSize = 200; // Pre-allocate pool size
        
        // OPTIMIZATION: Object pooling for particles - reuse objects to reduce garbage collection
        this._particlePool = [];
        this._particlePoolSize = 500; // Pre-allocate pool size (particles are created more frequently)
        
        // OPTIMIZATION: Track last UI values to only update DOM when values change
        this._lastUIValues = {
            score: -1,
            hits: -1,
            misses: -1,
            accuracy: '',
            targetCount: -1,
            quantumParticles: -1,
            energyCores: -1,
            metalScraps: -1,
            crystals: -1,
            tokens: -1,
            saveUnlocked: false
        };
        
        this.enemyBullets = []; // Enemy bullets
        this.laserBeams = []; // Active laser beams
        this.targets = [];
        this.pairs = [];
        this.obstacles = [];
        this.enemyShips = []; // Enemy ships for Bell mode
        this.bossEnemies = []; // Boss-specific enemies that shoot at player
        this.items = [];
        this.particles = [];
        this.bossSpawned = false; // Track if level 150 boss has spawned
        
        // Stats
        this.score = 0;
        this.hits = 0;
        this.misses = 0;
        this.time = 0;
        this.lastTargetSpawn = 0;
        this.lastObstacleSpawn = 0;
        this.lastEnemySpawn = Date.now(); // Initialize to current time so first spawn waits 8 seconds
        this.lastEnemyShot = 0;
        this.targetSpawnRate = 2000;
        this.obstacleSpawnRate = 3000;
        this.enemySpawnRate = 8000; // Spawn enemy every 8 seconds in Bell mode (more time between spawns)
        this.enemyShotRate = 1500; // Enemy shoots every 1.5 seconds
        
        // Survival system - Einstein's hunger and nutrition
        this.hunger = 100; // 0-100, starts at full
        this.maxHunger = 100;
        this.hungerDecayRate = 0.5; // Hunger decreases by 0.5 per second
        this.lastHungerDecay = Date.now();
        this.methane = 0; // 0-100, accumulates from eating food
        this.maxMethane = 100;
        this.boostActive = false; // Is boost currently active
        this.boostDuration = 0; // Remaining boost duration in ms
        this.boostCooldown = 0; // Cooldown before boost can be used again
        this.boostSpeedMultiplier = 1.5; // Speed multiplier during boost
        this.boostDamageMultiplier = 1.3; // Damage multiplier during boost
        this.foodInventory = {}; // { foodName: count } - crafted food items
        this.survivalUnlocked = true; // Unlocked immediately at game start
        
        // Death reason tracking
        this.deathReason = null; // Will be set when player dies: 'hunger', 'health', etc.
        
        // Player name
        this.playerName = this.loadPlayerName() || '';
        
        // Leaderboard
        this.leaderboard = [];
        this.apiUrl = window.API_URL || ''; // Empty string means no server - use localStorage only
        
        // Load leaderboard from server (only if API URL is set)
        if (this.apiUrl) {
            this.loadLeaderboardFromServer();
        } else {
            // Use local storage only
            this.leaderboard = this.loadLeaderboardLocal();
        }
        
        // Input
        this.keys = {};
        this.mouse = { x: 0, y: 0 };
        this.mouseDown = false;
        this.panelsVisible = {
            ui: true,
            theory: true,
            instructions: true
        };
        
        // Gamepad support
        this.gamepad = null;
        this.gamepadConnected = false;
        this.lastGamepadButtonState = {}; // Track button states for one-time presses
        this.gamepadAiming = false; // Track if gamepad right stick is being used for aiming
        this.lastMouseMoveTime = 0; // Track when mouse was last moved
        
        // Menu navigation for level-up menu
        this.menuSelectedIndex = { crafting: 0, shop: 0 };
        
        // Weapon wheel system
        this.weaponWheelVisible = false;
        this.weaponWheelSelectedIndex = 0;
        
        // Repair selection system
        this.repairSelectionMode = false;
        this.repairSelectedIndex = 0;
        this.repairableItems = [];
        this.selectedRepairItem = null; // Track selected item for repair
        this.menuNavigationCooldown = 0;
        this.currentMenuPanel = 'crafting'; // Which panel is currently focused (crafting or shop)
        
        // Settings
        this.settings = this.loadSettings();
        
        // Weapon use tracking (for use-based decay)
        // Track cumulative use time per weapon (in seconds)
        // Weapons break after 10 seconds of total use
        this.weaponUseTime = {}; // { weaponName: cumulativeUseTimeInSeconds }
        
        // Track shots fired per weapon for use-based decay
        this.weaponShotsFired = {}; // { weaponName: shotCount }
        
        // Hammer system
        this.hammerEquipped = false; // Is hammer currently equipped
        this.hammerDurability = 100; // Hammer durability (0-100)
        this.repairableItems = []; // Items that can be repaired in-game (visual indicator)
        
        // UI update tracking for real-time durability display
        this.lastUIUpdate = 0; // Track time since last UI update
        this._weaponsCacheInvalid = true; // Flag to invalidate weapon cache
        this._cachedRegularWeapons = []; // Cache for regular weapons
        this._cachedLaserWeapons = []; // Cache for laser weapons
        this._statsNeedsUpdate = false; // Flag to batch updateStats calls
        
        this.setupEventListeners();
        this.updateTheoryPanel();
        this.updateStats();
        this.spawnInitialTargets();
        this.lastTime = performance.now();
        
        // Performance tracking for adaptive optimization
        this.fps = 60;
        this.fpsHistory = [];
        this.frameCount = 0;
        this.lastFpsUpdate = performance.now();
        this.adaptiveQuality = 'ultra'; // ultra, high, medium (only reduce if FPS drops)
        
        // Initialize dev mode
        if (this.devMode) {
            this.initDevMode();
        }
        
        // Initialize cutscene
        // In dev mode, skip the opening cutscene automatically (user can play it manually)
        if (this.devMode) {
            console.log('[DEV] Dev mode detected - skipping opening cutscene');
            this.showCutscene = false;
            this.gameState = 'playing';
            this.cutsceneId = null; // Clear cutscene ID to prevent drawing
            // Start main music when game begins
            this.audio.playMusic('main', true, true);
            this.showNameInputDelayed();
        } else if (this.showCutscene && this.gameState === 'cutscene') {
            this.startCutscene();
        } else {
            // Skip cutscene, go straight to game
            this.gameState = 'playing';
            this.cutsceneId = null; // Clear cutscene ID to prevent drawing
            // Start main music when game begins
            this.audio.playMusic('main', true, true);
            this.showNameInputDelayed();
        }
        
        this.gameLoop();
    }

    resize() {
        // Store relative positions before resize (as percentages)
        let playerXPercent = 0.5; // Default center
        let playerYPercent = 0.8; // Default near bottom
        let mouseXPercent = 0.5;
        let mouseYPercent = 0.5;
        
        if (this.player && this.canvas.width > 0 && this.canvas.height > 0) {
            playerXPercent = this.player.x / this.canvas.width;
            playerYPercent = this.player.y / this.canvas.height;
        }
        
        if (this.mouse && this.canvas.width > 0 && this.canvas.height > 0) {
            mouseXPercent = this.mouse.x / this.canvas.width;
            mouseYPercent = this.mouse.y / this.canvas.height;
        }
        
        // Resize canvas
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        if (this.cutsceneCanvas) {
            this.cutsceneCanvas.width = window.innerWidth;
            this.cutsceneCanvas.height = window.innerHeight;
        }
        
        // Restore relative positions after resize
        if (this.player) {
            this.player.x = this.canvas.width * playerXPercent;
            this.player.y = this.canvas.height * playerYPercent;
            // Keep player within bounds
            this.player.x = Math.max(this.player.size, Math.min(this.canvas.width - this.player.size, this.player.x));
            this.player.y = Math.max(this.player.size, Math.min(this.canvas.height - this.player.size, this.player.y));
        }
        
        if (this.mouse) {
            this.mouse.x = this.canvas.width * mouseXPercent;
            this.mouse.y = this.canvas.height * mouseYPercent;
            // Keep mouse within bounds with margin to prevent edge sticking
            const edgeMargin = 5;
            this.mouse.x = Math.max(edgeMargin, Math.min(this.canvas.width - edgeMargin, this.mouse.x));
            this.mouse.y = Math.max(edgeMargin, Math.min(this.canvas.height - edgeMargin, this.mouse.y));
        }
    }

    setupEventListeners() {
        // Mode buttons
        // OPTIMIZATION: Use cached DOM elements
        this._cachedElements.ensembleBtn?.addEventListener('click', () => this.setMode('ensemble'));
        this._cachedElements.individualBtn?.addEventListener('click', () => this.setMode('individual'));
        this._cachedElements.bellBtn?.addEventListener('click', () => this.setMode('bell'));

        // Keyboard
        document.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
            
            // Ensure audio is initialized on any keydown (if not already done)
            // This ensures audio works even if dev mode shortcuts are used first
            if (this.audio && !this.audio.audioInitialized) {
                console.log('[Audio] Initializing audio from keydown event');
                this.audio.init();
                // If game is playing, start music
                if (this.gameState === 'playing' && !this.audio.currentMusicElement) {
                    console.log('[Audio] Game is playing, starting main music');
                    this.audio.playMusic('main', true, true);
                }
            }
            
            // Dev mode shortcuts - check FIRST before other handlers
            if (this.devMode) {
                // Use e.code for F-keys (more reliable across browsers)
                if (e.code === 'F1') {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    console.log('[DEV] ========== F1 PRESSED ==========');
                    console.log('[DEV] Dev mode active:', this.devMode);
                    console.log('[DEV] Calling devTogglePanel...');
                    this.devTogglePanel();
                    console.log('[DEV] =================================');
                    return;
                } else if (e.code === 'F2') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[DEV] F2 pressed - toggling god mode');
                    this.devToggleGodMode();
                    return;
                } else if (e.code === 'F3') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[DEV] F3 pressed - adding materials');
                    this.devAddMaterials(1000);
                    return;
                } else if (e.code === 'F4') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[DEV] F4 pressed - adding credits');
                    this.devAddCredits(10000);
                    return;
                } else if (e.code === 'F5') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[DEV] F5 pressed - healing player');
                    this.devHealPlayer();
                    return;
                } else if (e.code === 'F6') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[DEV] F6 pressed - next level');
                    this.devNextLevel();
                    return;
                } else if (e.code === 'F7') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[DEV] F7 pressed - spawning boss');
                    this.devSpawnBoss();
                    return;
                } else if (e.code === 'F8') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[DEV] F8 pressed - toggling debug');
                    this.devToggleDebug();
                    return;
                } else if (e.code === 'F9') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[DEV] F9 pressed - maxing resources');
                    this.devMaxResources();
                    return;
                } else if (e.code === 'F10') {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[DEV] F10 pressed - killing all enemies');
                    this.devKillAllEnemies();
                    return;
                }
            }
            
            if (e.code === 'Space') {
                e.preventDefault();
                if (this.gameState === 'playing') this.shoot();
            } else if (e.key === 'r' || e.key === 'R') {
                if (this.gameState === 'gameover') this.reset();
            } else if (e.key === '1') {
                // Prevent mode switching during boss battles
                if (!this.bossMode) {
                    this.setMode('ensemble');
                }
            } else if (e.key === '2') {
                // Prevent mode switching during boss battles
                if (!this.bossMode) {
                    this.setMode('individual');
                }
            } else if (e.key === '3') {
                // Prevent mode switching during boss battles
                if (!this.bossMode) {
                    this.setMode('bell');
                }
            } else if (e.key === 'c' || e.key === 'C') {
                // C key for boost (survival system) - changed from crafting
                if (this.gameState === 'playing' && !this.levelUpState && this.survivalUnlocked) {
                    this.activateBoost();
                }
            } else if (e.key === 'u' || e.key === 'U') {
                this.toggleShop();
            } else if (e.key === 'e' || e.key === 'E') {
                this.toggleInventory();
            } else if (e.key === 'h' || e.key === 'H') {
                // Use health pack during gameplay
                if (this.gameState === 'playing' && !this.levelUpState) {
                    this.useHealthPack();
                }
            } else if (e.key === 'x' || e.key === 'X') {
                // Use atom split during gameplay
                if (this.gameState === 'playing' && !this.levelUpState) {
                    this.useAtomSplit();
                }
            } else if (e.key === 'v' || e.key === 'V') {
                // Revert to saved game state (2 levels back) - only if save feature is unlocked
                if (this.hiddenSequence.saveUnlocked && (this.gameState === 'playing' || this.gameState === 'paused')) {
                    this.revertToSavedState();
                }
            } else if (e.key === 'l' || e.key === 'L') {
                this.toggleLeaderboard();
            } else if (e.key === 'F11' || e.code === 'F11') {
                e.preventDefault(); // Prevent browser's default F11 behavior
                this.toggleFullscreen();
            } else if (e.key === 'Escape') {
                // In dev mode, allow ESC to work normally
                if (this.devMode) {
                    // Don't prevent ESC in dev mode - let it work normally
                } else {
                    // Prevent ESC from exiting fullscreen - F11 is the only way to toggle fullscreen
                    // (This is handled in the capture phase listener above, but we also check here as backup)
                    if (this.isFullscreen()) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
                
                // Check if settings is open first
                // OPTIMIZATION: Use cached DOM element
                const settingsUI = this._cachedElements.settingsUI;
                if (settingsUI && settingsUI.classList.contains('active')) {
                    // Close settings if open
                    this.toggleSettings();
                } else if (this.gameState === 'crafting') {
                    this.toggleCrafting();
                } else if (this.gameState === 'shop') {
                    this.toggleShop();
                } else if (this.gameState === 'inventory') {
                    this.toggleInventory();
                } else if (this.gameState === 'leaderboard') {
                    this.toggleLeaderboard();
                } else {
                    // Check if tutorial is open (it's an overlay, not a game state)
                    // OPTIMIZATION: Use cached DOM element
                    const tutorialUI = this._cachedElements.tutorialUI;
                    if (tutorialUI && tutorialUI.classList.contains('active')) {
                        this.hideTutorial();
                    } else if (this.gameState === 'paused') {
                        this.togglePause();
                    } else if (this.gameState === 'playing') {
                        this.togglePause();
                    }
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });

        // Mouse - track mouse anywhere on screen, not just canvas
        document.addEventListener('mousemove', (e) => {
            // Only update mouse position if gamepad right stick is not being used
            // This allows both to work together - mouse takes precedence when moved
            if (!this.gamepadAiming) {
                const rect = this.canvas.getBoundingClientRect();
                // Calculate mouse position relative to canvas
                let mouseX = e.clientX - rect.left;
                let mouseY = e.clientY - rect.top;
                
                // If mouse is outside canvas, clamp to edges with a small margin to prevent getting stuck
                // This allows smooth movement even when cursor goes off-screen
                const edgeMargin = 5; // Small margin to prevent edge sticking
                if (mouseX < 0) {
                    mouseX = edgeMargin;
                } else if (mouseX > this.canvas.width) {
                    mouseX = this.canvas.width - edgeMargin;
                }
                if (mouseY < 0) {
                    mouseY = edgeMargin;
                } else if (mouseY > this.canvas.height) {
                    mouseY = this.canvas.height - edgeMargin;
                }
                
                this.mouse.x = mouseX;
                this.mouse.y = mouseY;
                this.lastMouseMoveTime = Date.now();
            }
        });

        // Mouse events on document to work through panels
        document.addEventListener('mousedown', (e) => {
            if (this.gameState === 'playing' && e.target === this.canvas) {
                e.preventDefault();
                this.mouseDown = true;
                
                // Check if automatic weapon is equipped - if not, only shoot on click (not continuous)
                const hasAutomatic = this.currentWeapons.some(weaponName => {
                    const weapon = this.equipmentStats.weapons[weaponName];
                    return weapon && weapon.automatic && !weapon.isLaser;
                });
                
                // Only shoot immediately on click if NOT automatic (automatic will shoot continuously in update loop)
                // Regular weapons (rapid, spread, etc.) only shoot on click
                if (!hasAutomatic) {
                    this.shoot();
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.target === this.canvas) {
                this.mouseDown = false;
            }
        });

        document.addEventListener('mouseleave', () => {
            this.mouseDown = false;
        });

        // Mouse wheel for weapon wheel and repair selection
        document.addEventListener('wheel', (e) => {
            // Check if instructions panel is visible and mouse is over it - allow normal scrolling
            // OPTIMIZATION: Use cached DOM element
            const instructionsPanel = this._cachedElements.instructions;
            if (instructionsPanel && instructionsPanel.classList.contains('paused')) {
                const rect = instructionsPanel.getBoundingClientRect();
                if (e.clientX >= rect.left && e.clientX <= rect.right &&
                    e.clientY >= rect.top && e.clientY <= rect.bottom) {
                    // Mouse is over instructions panel - allow normal scrolling
                    return; // Don't prevent default, allow normal scroll
                }
            }
            
            // Check if settings panel is visible and mouse is over it - allow normal scrolling
            // OPTIMIZATION: Use cached DOM element
            const settingsPanel = this._cachedElements.settingsUI;
            if (settingsPanel && settingsPanel.classList.contains('active')) {
                const rect = settingsPanel.getBoundingClientRect();
                if (e.clientX >= rect.left && e.clientX <= rect.right &&
                    e.clientY >= rect.top && e.clientY <= rect.bottom) {
                    // Mouse is over settings panel - allow normal scrolling
                    return; // Don't prevent default, allow normal scroll
                }
            }
            
            if (this.gameState === 'playing' && !this.levelUpState) {
                e.preventDefault();
                
                // Repair selection mode (Q held down)
                if (this.repairSelectionMode) {
                    this.updateRepairSelection(e.deltaY > 0 ? 1 : -1);
                    return;
                }
                
                // Weapon wheel mode (Tab held down)
                if (this.weaponWheelVisible) {
                    this.updateWeaponWheelSelection(e.deltaY > 0 ? 1 : -1);
                    return;
                }
            }
        }, { passive: false });
        
        // Tab key for weapon wheel (toggle on press, not hold)
        let tabKeyPressed = false;
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && this.gameState === 'playing' && !this.levelUpState && !tabKeyPressed) {
                e.preventDefault();
                tabKeyPressed = true;
                this.toggleWeaponWheel();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'Tab') {
                tabKeyPressed = false;
            }
        });
        
        // Q key for repair selection mode - only equips hammer if not equipped, then shows repair UI
        let qKeyPressed = false;
        document.addEventListener('keydown', (e) => {
            if ((e.key === 'q' || e.key === 'Q') && this.gameState === 'playing' && !this.levelUpState && !qKeyPressed) {
                qKeyPressed = true;
                
                // First, equip hammer if not equipped (but don't unequip if already equipped)
                if (!this.hammerEquipped) {
                    const hammerCount = this.getItemCount('tools', 'hammer');
                    if (hammerCount > 0) {
                        const hammerDurability = this.getItemDurability('tools', 'hammer');
                        if (hammerDurability > 0) {
                            this.hammerEquipped = true;
                            this.updateRepairableItems();
                        }
                    }
                }
                
                // Then show repair selection UI if hammer is equipped
                if (this.hammerEquipped && !this.repairSelectionMode) {
                    this.startRepairSelection();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'q' || e.key === 'Q') {
                qKeyPressed = false;
                // Don't auto-repair on release - user clicks to repair
                // Just close the UI (but keep hammer equipped)
                this.endRepairSelection();
            }
        });
        
        // E key for eating food (survival system)
        let eKeyPressed = false;
        document.addEventListener('keydown', (e) => {
            if ((e.key === 'e' || e.key === 'E') && this.gameState === 'playing' && !this.levelUpState && !eKeyPressed && this.survivalUnlocked) {
                e.preventDefault();
                eKeyPressed = true;
                
                // Find best available food (prioritize by hunger restoration)
                const foodPriority = ['superFood', 'balancedMeal', 'proteinBar', 'energyDrink', 'basicMeal', 'methaneSnack'];
                let foodEaten = false;
                
                for (let foodName of foodPriority) {
                    if (this.foodInventory[foodName] && this.foodInventory[foodName] > 0) {
                        if (this.eatFood(foodName)) {
                            foodEaten = true;
                            break;
                        }
                    }
                }
                
                if (!foodEaten) {
                    // No food available - show message
                    console.log('[Survival] No food available to eat!');
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'e' || e.key === 'E') {
                eKeyPressed = false;
            }
        });
        
        // Shift key removed - boost now uses C key (no longer conflicts with other buttons)

        // Gamepad support
        window.addEventListener('gamepadconnected', (e) => {
            this.gamepad = e.gamepad;
            this.gamepadConnected = true;
            console.log('Gamepad connected:', e.gamepad.id);
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            if (this.gamepad && this.gamepad.index === e.gamepad.index) {
                this.gamepad = null;
                this.gamepadConnected = false;
                console.log('Gamepad disconnected');
            }
        });

        // Panel toggles - removed individual toggles, now only ESC shows all panels
        
        this.mouse.x = this.canvas.width / 2;
        this.mouse.y = this.canvas.height / 2;
    }
    
    updateGamepad(deltaTime = 0.016) {
        // Poll gamepad state (required for some browsers)
        const gamepads = navigator.getGamepads();
        let activeGamepad = null;
        
        if (gamepads && gamepads.length > 0) {
            // Use first connected gamepad
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i] && gamepads[i].connected) {
                    activeGamepad = gamepads[i];
                    this.gamepad = gamepads[i];
                    this.gamepadConnected = true;
                    break;
                }
            }
        }
        
        if (!activeGamepad || !this.gamepadConnected) {
            this.gamepadAiming = false;
            return;
        }
        
        const gp = activeGamepad; // Use the fresh gamepad object from getGamepads()
        
        // Dead zone for analog sticks (prevent drift)
        const deadZone = 0.15;
        
        // Left stick or D-pad for movement
        let moveX = 0;
        let moveY = 0;
        
        // Left stick (axes 0 = X, 1 = Y)
        if (Math.abs(gp.axes[0]) > deadZone) {
            moveX = gp.axes[0];
        }
        if (Math.abs(gp.axes[1]) > deadZone) {
            moveY = gp.axes[1];
        }
        
        // D-pad (buttons 12-15: up, down, left, right)
        if (gp.buttons[12] && gp.buttons[12].pressed) moveY = -1; // Up
        if (gp.buttons[13] && gp.buttons[13].pressed) moveY = 1;  // Down
        if (gp.buttons[14] && gp.buttons[14].pressed) moveX = -1; // Left
        if (gp.buttons[15] && gp.buttons[15].pressed) moveX = 1;  // Right
        
        // Apply movement (will be handled in update function)
        if (moveX !== 0 || moveY !== 0) {
            // Simulate keyboard input for movement
            this.keys['ArrowLeft'] = moveX < 0;
            this.keys['ArrowRight'] = moveX > 0;
            this.keys['ArrowUp'] = moveY < 0;
            this.keys['ArrowDown'] = moveY > 0;
        } else {
            // Clear movement keys if not moving
            this.keys['ArrowLeft'] = false;
            this.keys['ArrowRight'] = false;
            this.keys['ArrowUp'] = false;
            this.keys['ArrowDown'] = false;
        }
        
        // Right stick for aiming
        // PlayStation controllers: axes 0,1 = left stick, axes 2,3 = right stick
        // Xbox controllers: axes 0,1 = left stick, axes 2,3 = right stick
        // But some controllers might have triggers as axes too, so we need to check
        if (!gp.axes || !this.player) {
            this.gamepadAiming = false;
        } else {
            // Get right stick values (axes 2 and 3 for PlayStation/Xbox controllers)
            let rightStickX = 0;
            let rightStickY = 0;
            
            if (gp.axes.length >= 4) {
                rightStickX = typeof gp.axes[2] !== 'undefined' ? gp.axes[2] : 0;
                rightStickY = typeof gp.axes[3] !== 'undefined' ? gp.axes[3] : 0;
            }
            
            const rightStickLength = Math.sqrt(rightStickX * rightStickX + rightStickY * rightStickY);
            
            // Check if right stick is being used (above dead zone)
            if (rightStickLength > deadZone) {
                // Mark that gamepad is being used for aiming - this prevents mouse from overriding
                this.gamepadAiming = true;
                
                // Move cursor incrementally based on stick input (like mouse movement)
                // Use settings sensitivity (default 600, range 100-2000)
                const sensitivity = this.settings.gamepadSensitivity || 600;
                
                // Normalize stick direction
                const normalizedX = rightStickX / rightStickLength;
                const normalizedY = rightStickY / rightStickLength;
                
                // Calculate movement based on stick push amount (more push = faster movement)
                // Use actual deltaTime for smooth movement
                const moveSpeed = sensitivity * rightStickLength; // Scale speed by how far stick is pushed
                const moveX = normalizedX * moveSpeed * deltaTime;
                const moveY = normalizedY * moveSpeed * deltaTime;
                
                // Update mouse position incrementally (allows cursor to move anywhere on screen)
                this.mouse.x += moveX;
                this.mouse.y += moveY;
                
                // Keep cursor within canvas bounds with margin to prevent edge sticking
                const edgeMargin = 5;
                this.mouse.x = Math.max(edgeMargin, Math.min(this.canvas.width - edgeMargin, this.mouse.x));
                this.mouse.y = Math.max(edgeMargin, Math.min(this.canvas.height - edgeMargin, this.mouse.y));
            } else {
                // Right stick not being used - disable gamepad aiming
                // Mouse can take over immediately when moved
                this.gamepadAiming = false;
            }
        }
        
        // Shooting - Right trigger (button 7) or Right shoulder (button 5) or A/X button (button 0)
        // BUT: During level-up, A/X button is used for menu navigation, not shooting
        const shootButton = (gp.buttons[7] && gp.buttons[7].pressed) || // Right trigger
                           (gp.buttons[5] && gp.buttons[5].pressed) || // Right shoulder
                           (gp.buttons[0] && gp.buttons[0].pressed && this.gameState !== 'levelup');  // A/X button (only for shooting, not during level-up)
        
        if (shootButton) {
            if (!this.mouseDown) {
                this.mouseDown = true;
                // Check if automatic weapon is equipped
                const hasAutomatic = this.currentWeapons.some(weaponName => {
                    const weapon = this.equipmentStats.weapons[weaponName];
                    return weapon && weapon.automatic && !weapon.isLaser;
                });
                // Only shoot immediately if NOT automatic (automatic will shoot continuously)
                if (!hasAutomatic && this.gameState === 'playing') {
                    this.shoot();
                }
            }
        } else {
            this.mouseDown = false;
        }
        
        // Button mappings (one-time presses)
        // A/X button (0) - already used for shooting
        // B/Circle button (1) - Cancel/Back
        if (gp.buttons[1] && gp.buttons[1].pressed && !this.lastGamepadButtonState[1]) {
            if (this.gameState === 'crafting' || this.gameState === 'shop' || 
                this.gameState === 'inventory' || this.gameState === 'leaderboard') {
                if (this.gameState === 'crafting') this.toggleCrafting();
                else if (this.gameState === 'shop') this.toggleShop();
                else if (this.gameState === 'inventory') this.toggleInventory();
                else if (this.gameState === 'leaderboard') this.toggleLeaderboard();
            } else if (this.gameState === 'playing') {
                this.togglePause();
            }
        }
        this.lastGamepadButtonState[1] = gp.buttons[1] && gp.buttons[1].pressed;
        
        // X/Square button (2) - Use health pack
        if (gp.buttons[2] && gp.buttons[2].pressed && !this.lastGamepadButtonState[2]) {
            if (this.gameState === 'playing' && !this.levelUpState) {
                this.useHealthPack();
            }
        }
        this.lastGamepadButtonState[2] = gp.buttons[2] && gp.buttons[2].pressed;
        
        // Y/Triangle button (3) - Use atom split
        if (gp.buttons[3] && gp.buttons[3].pressed && !this.lastGamepadButtonState[3]) {
            if (this.gameState === 'playing' && !this.levelUpState) {
                this.useAtomSplit();
            }
        }
        this.lastGamepadButtonState[3] = gp.buttons[3] && gp.buttons[3].pressed;
        
        // Left shoulder (4) - Inventory
        if (gp.buttons[4] && gp.buttons[4].pressed && !this.lastGamepadButtonState[4]) {
            this.toggleInventory();
        }
        this.lastGamepadButtonState[4] = gp.buttons[4] && gp.buttons[4].pressed;
        
        // Start button (9) - Pause/Menu
        if (gp.buttons[9] && gp.buttons[9].pressed && !this.lastGamepadButtonState[9]) {
            if (this.gameState === 'playing') {
                this.togglePause();
            } else if (this.gameState === 'crafting' || this.gameState === 'shop' || 
                      this.gameState === 'inventory' || this.gameState === 'leaderboard') {
                if (this.gameState === 'crafting') this.toggleCrafting();
                else if (this.gameState === 'shop') this.toggleShop();
                else if (this.gameState === 'inventory') this.toggleInventory();
                else if (this.gameState === 'leaderboard') this.toggleLeaderboard();
            }
        }
        this.lastGamepadButtonState[9] = gp.buttons[9] && gp.buttons[9].pressed;
        
        // Select/Back button (8) - Leaderboard
        if (gp.buttons[8] && gp.buttons[8].pressed && !this.lastGamepadButtonState[8]) {
            this.toggleLeaderboard();
        }
        this.lastGamepadButtonState[8] = gp.buttons[8] && gp.buttons[8].pressed;
        
        // Handle menu navigation during level-up
        if (this.gameState === 'levelup') {
            this.handleMenuNavigation(gp, deltaTime);
        }
    }
    
    handleMenuNavigation(gp, deltaTime) {
        // Navigation cooldown to prevent rapid scrolling
        if (this.menuNavigationCooldown > 0) {
            this.menuNavigationCooldown -= deltaTime;
        }
        
        // Get all clickable buttons in both panels
        const getAllButtons = () => {
            const buttons = [];
            // Crafting panel buttons
            const craftingButtons = document.querySelectorAll('#craftingUI .craft-btn:not([disabled])');
            craftingButtons.forEach(btn => buttons.push({ btn, panel: 'crafting' }));
            // Shop panel buttons
            const shopButtons = document.querySelectorAll('#shopUI .shop-btn:not([disabled])');
            shopButtons.forEach(btn => buttons.push({ btn, panel: 'shop' }));
            // Continue button (bottom UI)
            const continueButton = document.querySelector('#levelUpContinueUI button[onclick*="continueFromLevelUp"]');
            if (continueButton) {
                buttons.push({ btn: continueButton, panel: 'continue' });
            }
            return buttons;
        };
        
        const allButtons = getAllButtons();
        if (allButtons.length === 0) return;
        
        // D-pad or left stick for navigation
        let navUp = false;
        let navDown = false;
        let navLeft = false;
        let navRight = false;
        
        // D-pad
        if (gp.buttons[12] && gp.buttons[12].pressed && !this.lastGamepadButtonState[12]) navUp = true;
        if (gp.buttons[13] && gp.buttons[13].pressed && !this.lastGamepadButtonState[13]) navDown = true;
        if (gp.buttons[14] && gp.buttons[14].pressed && !this.lastGamepadButtonState[14]) navLeft = true;
        if (gp.buttons[15] && gp.buttons[15].pressed && !this.lastGamepadButtonState[15]) navRight = true;
        
        // Left stick (for navigation, not movement during level-up)
        if (Math.abs(gp.axes[1]) > 0.5) {
            if (gp.axes[1] < -0.5 && this.menuNavigationCooldown <= 0) navUp = true;
            if (gp.axes[1] > 0.5 && this.menuNavigationCooldown <= 0) navDown = true;
        }
        if (Math.abs(gp.axes[0]) > 0.5) {
            if (gp.axes[0] < -0.5 && this.menuNavigationCooldown <= 0) navLeft = true;
            if (gp.axes[0] > 0.5 && this.menuNavigationCooldown <= 0) navRight = true;
        }
        
        // Find currently selected button
        let currentIndex = -1;
        let currentPanel = this.currentMenuPanel;
        allButtons.forEach((item, index) => {
            if (item.btn.classList.contains('gamepad-selected')) {
                currentIndex = index;
                currentPanel = item.panel;
            }
        });
        
        // If no button is selected, select the first one
        if (currentIndex === -1) {
            currentIndex = 0;
            currentPanel = allButtons[0].panel;
            allButtons[0].btn.classList.add('gamepad-selected');
            allButtons[0].btn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        // Handle navigation
        if (navUp && this.menuNavigationCooldown <= 0) {
            // Move up in current panel, or switch to previous panel
            const currentPanelButtons = allButtons.filter(item => item.panel === currentPanel);
            const currentPanelIndex = currentPanelButtons.findIndex(item => item.btn.classList.contains('gamepad-selected'));
            
            if (currentPanelIndex > 0) {
                // Move up within panel
                currentPanelButtons[currentPanelIndex].btn.classList.remove('gamepad-selected');
                currentPanelButtons[currentPanelIndex - 1].btn.classList.add('gamepad-selected');
                currentPanelButtons[currentPanelIndex - 1].btn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } else if (currentPanel === 'shop') {
                // Switch to crafting panel (at top of shop, go to bottom of crafting)
                allButtons.forEach(item => item.btn.classList.remove('gamepad-selected'));
                const craftingButtons = allButtons.filter(item => item.panel === 'crafting');
                if (craftingButtons.length > 0) {
                    const lastIndex = craftingButtons.length - 1;
                    craftingButtons[lastIndex].btn.classList.add('gamepad-selected');
                    craftingButtons[lastIndex].btn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    this.currentMenuPanel = 'crafting';
                    this.menuSelectedIndex.crafting = lastIndex;
                }
            }
            this.menuNavigationCooldown = 0.2; // 200ms cooldown
        } else if (navDown && this.menuNavigationCooldown <= 0) {
            // Move down in current panel, or switch to next panel
            const currentPanelButtons = allButtons.filter(item => item.panel === currentPanel);
            const currentPanelIndex = currentPanelButtons.findIndex(item => item.btn.classList.contains('gamepad-selected'));
            
            if (currentPanelIndex < currentPanelButtons.length - 1) {
                // Move down within panel
                currentPanelButtons[currentPanelIndex].btn.classList.remove('gamepad-selected');
                currentPanelButtons[currentPanelIndex + 1].btn.classList.add('gamepad-selected');
                currentPanelButtons[currentPanelIndex + 1].btn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            } else if (currentPanel === 'crafting') {
                // Switch to shop panel (at bottom of crafting, go to top of shop)
                allButtons.forEach(item => item.btn.classList.remove('gamepad-selected'));
                const shopButtons = allButtons.filter(item => item.panel === 'shop');
                if (shopButtons.length > 0) {
                    shopButtons[0].btn.classList.add('gamepad-selected');
                    shopButtons[0].btn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    this.currentMenuPanel = 'shop';
                    this.menuSelectedIndex.shop = 0;
                }
            }
            this.menuNavigationCooldown = 0.2; // 200ms cooldown
        } else if (navLeft && this.menuNavigationCooldown <= 0) {
            // Switch to crafting panel
            if (currentPanel === 'shop') {
                allButtons.forEach(item => item.btn.classList.remove('gamepad-selected'));
                const craftingButtons = allButtons.filter(item => item.panel === 'crafting');
                if (craftingButtons.length > 0) {
                    const index = Math.min(this.menuSelectedIndex.crafting, craftingButtons.length - 1);
                    craftingButtons[index].btn.classList.add('gamepad-selected');
                    craftingButtons[index].btn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    this.currentMenuPanel = 'crafting';
                }
            }
            this.menuNavigationCooldown = 0.2;
        } else if (navRight && this.menuNavigationCooldown <= 0) {
            // Switch to shop panel
            if (currentPanel === 'crafting') {
                allButtons.forEach(item => item.btn.classList.remove('gamepad-selected'));
                const shopButtons = allButtons.filter(item => item.panel === 'shop');
                if (shopButtons.length > 0) {
                    const index = Math.min(this.menuSelectedIndex.shop, shopButtons.length - 1);
                    shopButtons[index].btn.classList.add('gamepad-selected');
                    shopButtons[index].btn.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    this.currentMenuPanel = 'shop';
                }
            }
            this.menuNavigationCooldown = 0.2;
        }
        
        // Update selected index for current panel
        const currentPanelButtons = allButtons.filter(item => item.panel === this.currentMenuPanel);
        const selectedIndex = currentPanelButtons.findIndex(item => item.btn.classList.contains('gamepad-selected'));
        if (selectedIndex >= 0) {
            this.menuSelectedIndex[this.currentMenuPanel] = selectedIndex;
        }
        
        // A/X button (0) - Select/Activate button
        if (gp.buttons[0] && gp.buttons[0].pressed && !this.lastGamepadButtonState[0]) {
            const selectedButton = allButtons.find(item => item.btn.classList.contains('gamepad-selected'));
            if (selectedButton && !selectedButton.btn.disabled) {
                // Click the button
                selectedButton.btn.click();
                // Re-highlight after a short delay (UI updates)
                setTimeout(() => {
                    this.clearGamepadSelection();
                }, 100);
            }
        }
        this.lastGamepadButtonState[0] = gp.buttons[0] && gp.buttons[0].pressed;
        
        // Update button states for D-pad
        this.lastGamepadButtonState[12] = gp.buttons[12] && gp.buttons[12].pressed;
        this.lastGamepadButtonState[13] = gp.buttons[13] && gp.buttons[13].pressed;
        this.lastGamepadButtonState[14] = gp.buttons[14] && gp.buttons[14].pressed;
        this.lastGamepadButtonState[15] = gp.buttons[15] && gp.buttons[15].pressed;
    }

    setMode(mode) {
        // Don't allow mode switching during boss battles
        if (this.bossMode) {
            return;
        }
        
        // Track hidden sequence for save feature unlock
        // Sequence must be: Bell (levels 1-5), Ensemble (levels 6-8), Individual (levels 9-10)
        // Don't reset on mode switch - allow time to switch modes after leveling up
        this.hiddenSequence.lastMode = mode;
        
        this.mode = mode;
        document.querySelectorAll('.mode-btn')?.forEach(btn => btn.classList.remove('active'));
        
        if (mode === 'ensemble') {
            // OPTIMIZATION: Use cached DOM elements
            this._cachedElements.ensembleBtn?.classList.add('active');
            const modeDisplay = this._cachedElements.modeDisplay;
            if (modeDisplay) modeDisplay.textContent = 'Ensemble QM';
            // Don't clear enemy ships - they persist across mode switches
            // Just clear bullets when leaving Bell mode
            this.enemyBullets = [];
        } else if (mode === 'individual') {
            // OPTIMIZATION: Use cached DOM elements
            this._cachedElements.individualBtn?.classList.add('active');
            const modeDisplay = this._cachedElements.modeDisplay;
            if (modeDisplay) modeDisplay.textContent = 'Individual';
            // Don't clear enemy ships - they persist across mode switches
            // Just clear bullets when leaving Bell mode
            this.enemyBullets = [];
        } else if (mode === 'bell') {
            // OPTIMIZATION: Use cached DOM elements
            this._cachedElements.bellBtn?.classList.add('active');
            const modeDisplay = this._cachedElements.modeDisplay;
            if (modeDisplay) modeDisplay.textContent = 'Bell Pairs';
            // Enemy ships persist - they keep their health and position when you switch modes
            // Only clear bullets when entering Bell mode (they'll respawn from ships)
            this.enemyBullets = [];
            // Do NOT reset lastEnemySpawn - timer persists across mode switches
            // Do NOT clear enemyShips - they persist with their state
        }

        this.updateTheoryPanel();
    }
    
    enterBossMode(forcedBossNumber = null) {
        // Enter boss mode - combines all three game modes
        this.bossMode = true;
        this.bossSpawned = false;
        this.currentBoss = null;
        this.bossPuzzleState = {};
        
        // Disable mode switching buttons during boss battle
        document.querySelectorAll('.mode-btn')?.forEach(btn => {
            btn.style.pointerEvents = 'none';
            btn.style.opacity = '0.5';
        });
        
        // Determine boss number (use forced if provided, otherwise calculate from level)
        const bossNumber = forcedBossNumber !== null ? forcedBossNumber : Math.floor(this.level / 15);
        
        // Update level to match boss if forced
        if (forcedBossNumber !== null) {
            this.level = Math.max(15, forcedBossNumber * 15);
        }
        
        // Update mode display
        // OPTIMIZATION: Use cached DOM element
        const modeDisplay = this._cachedElements.modeDisplay;
        if (modeDisplay) {
            modeDisplay.textContent = `BOSS BATTLE ${bossNumber}`;
        }
        
        // Change music based on boss type
        if (bossNumber === 1) {
            this.audio.playMusic('boss1', true, true);
        } else if (bossNumber === 2) {
            this.audio.playMusic('boss2', true, true);
        } else if (bossNumber === 3) {
            this.audio.playMusic('boss3', true, true);
        } else if (bossNumber === 4) {
            this.audio.playMusic('boss4', true, true);
        } else {
            this.audio.playMusic('bossAdvanced', true, true);
        }
        
        // Clear any existing obstacles/enemies BEFORE spawning boss
        this.obstacles = [];
        this.enemyShips = [];
        this.bossEnemies = [];
        this.enemyBullets = []; // Clear enemy bullets when entering boss mode
        this.targets = [];
        this.pairs = [];
        
        // Ensure canvas is ready
        this.resize();
        
        // Spawn the boss based on boss number
        this.spawnBossByNumber(bossNumber);
        
        // Spawn boss-specific enemies
        this.spawnBossEnemies(bossNumber);
        
        // Spawn elements from all three modes
        this.spawnBossModeElements();
        
        // Mark boss as spawned
        this.bossSpawned = true;
    }
    
    exitBossMode() {
        // Exit boss mode - return to normal mode
        this.bossMode = false;
        this.bossEnemies = []; // Clear boss enemies when exiting boss mode
        this.currentBoss = null;
        this.bossPuzzleState = {};
        // OPTIMIZATION: Clear boss cache when exiting boss mode
        this._cachedBossCore = null;
        
        // Re-enable mode switching buttons
        document.querySelectorAll('.mode-btn')?.forEach(btn => {
            btn.style.pointerEvents = 'auto';
            btn.style.opacity = '1';
        });
        
        // Return to individual mode (or last selected mode)
        this.setMode('individual');
        
        // Clear boss-specific entities
        this.obstacles = this.obstacles.filter(o => !o.isBoss);
        
        // Return to main music with seamless crossfade
        this.audio.playMusic('main', true, true);
        
        // After boss is defeated, trigger level-up menu
        // The level was frozen during boss battle, so now we can show the level-up menu
        this.levelUpState = true;
        this.gameState = 'levelup';
        this.showLevelUpMenu();
    }
    
    spawnBossForLevel(level) {
        const bossNumber = Math.floor(level / 15);
        this.spawnBossByNumber(bossNumber);
    }
    
    spawnBossByNumber(bossNumber) {
        // Ensure canvas is ready
        if (this.canvas.width === 0 || this.canvas.height === 0) {
            console.warn('[Boss] Canvas not ready, resizing...');
            this.resize();
        }
        
        if (bossNumber === 1) {
            // Level 15: Neurotransmitter and Neuron
            // Puzzle: Destroy vesicles first, then neuron core
            this.spawnNeurotransmitterBoss();
        } else if (bossNumber === 2) {
            // Level 30: DNA Helix
            // Puzzle: Destroy both strands simultaneously (within 3 seconds of each other)
            this.spawnDNAHelixBoss();
        } else if (bossNumber === 3) {
            // Level 45: Protein Complex
            // Puzzle: Destroy subunits in specific order (1, 2, 3, 4, then core)
            this.spawnProteinComplexBoss();
        } else if (bossNumber === 4) {
            // Level 60: Cell Membrane
            // Puzzle: Destroy outer membrane, then inner membrane, then nucleus
            this.spawnCellMembraneBoss();
        } else {
            // Level 75+: Advanced bosses with more complex puzzles
            this.spawnAdvancedBoss(bossNumber);
        }
        
        // Verify boss was spawned
        const bossObstacles = this.obstacles.filter(o => o.isBoss);
        if (bossObstacles.length === 0) {
            console.error(`[Boss] Failed to spawn boss ${bossNumber}! Canvas size: ${this.canvas.width}x${this.canvas.height}`);
        } else {
            console.log(`[Boss] Successfully spawned boss ${bossNumber} with ${bossObstacles.length} parts`);
        }
    }
    
    spawnNeurotransmitterBoss() {
        // First boss: Neurotransmitter and Neuron structure
        // Puzzle: Must destroy neurotransmitter vesicles first, then the neuron core
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        
        console.log('[Boss] Spawning Neurotransmitter Boss at:', centerX, centerY, 'Canvas:', this.canvas.width, 'x', this.canvas.height);
        
        // Generate neuron structure first
        const neuronNodes = this.generateNeuronStructure(80);
        console.log('[Boss] Generated neuron nodes:', neuronNodes.length);
        
        // Main neuron (core)
        const neuron = {
            x: centerX,
            y: centerY,
            size: 80,
            originalSize: 80,
            maxHealth: 2000 + this.level * 50,
            health: 2000 + this.level * 50,
            vx: 0,
            vy: 0,
            color: '#8b00ff',
            damage: 30,
            lastHitTime: 0,
            regenDelay: 999999, // Neuron should NOT regenerate (very long delay effectively prevents it)
            moleculeType: 'boss',
            isBoss: true,
            bossType: 'neurotransmitter',
            bossPart: 'neuron', // Core part
            rewardMultiplier: 15.0,
            canTakeDamage: false, // Can't damage until vesicles are destroyed
            nodes: neuronNodes
        };
        
        // Neurotransmitter vesicles (must be destroyed first)
        const vesicleCount = 4;
        const vesicles = [];
        for (let i = 0; i < vesicleCount; i++) {
            const angle = (Math.PI * 2 * i) / vesicleCount;
            const distance = 120;
            vesicles.push({
                x: centerX + Math.cos(angle) * distance,
                y: centerY + Math.sin(angle) * distance,
                size: 30,
                originalSize: 30,
                maxHealth: 300 + this.level * 10,
                health: 300 + this.level * 10,
                vx: 0,
                vy: 0,
                color: '#ff6b6b',
                damage: 15,
                lastHitTime: 0,
                regenDelay: 5.0, // Longer delay before regeneration starts (5 seconds)
                moleculeType: 'boss',
                isBoss: true,
                bossType: 'neurotransmitter',
                bossPart: 'vesicle', // Must destroy these first
                rewardMultiplier: 5.0,
                canTakeDamage: true,
                angle: angle,
                distance: distance,
                parentX: centerX,
                parentY: centerY
            });
        }
        
        this.currentBoss = neuron;
        this.obstacles.push(neuron);
        vesicles.forEach(v => this.obstacles.push(v));
        
        console.log('[Boss] Added boss to obstacles. Total obstacles:', this.obstacles.length, 'Boss obstacles:', this.obstacles.filter(o => o.isBoss).length);
        
        // Initialize puzzle state
        this.bossPuzzleState = {
            vesiclesDestroyed: 0,
            totalVesicles: vesicleCount,
            neuronVulnerable: false
        };
    }
    
    generateNeuronStructure(size) {
        // Neuron structure with dendrites and axon
        const nodes = [];
        
        // Cell body (soma)
        nodes.push({
            x: 0,
            y: 0,
            radius: size * 0.4,
            color: '#8b00ff',
            isCore: true
        });
        
        // Dendrites (input branches)
        const dendriteCount = 6;
        for (let i = 0; i < dendriteCount; i++) {
            const angle = (Math.PI * 2 * i) / dendriteCount - Math.PI / 2;
            const length = size * 0.6;
            nodes.push({
                x: Math.cos(angle) * length,
                y: Math.sin(angle) * length,
                radius: size * 0.15,
                color: '#aa44ff',
                isCore: false,
                isDendrite: true
            });
        }
        
        // Axon (output branch)
        nodes.push({
            x: 0,
            y: size * 0.8,
            radius: size * 0.2,
            color: '#9b55ff',
            isCore: false,
            isAxon: true
        });
        
        return nodes;
    }
    
    spawnDNAHelixBoss() {
        // Level 30: DNA Helix
        // Puzzle: Destroy strand1 first, then strand2, then core becomes vulnerable
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        
        // Two DNA strands (must be destroyed in order: strand1 first, then strand2)
        // Made larger and more visible with distinct colors
        const strand1 = {
            x: centerX - 80,
            y: centerY,
            size: 60, // Larger size for visibility
            originalSize: 60,
            maxHealth: 1000 + this.level * 20, // Reduced health to make it easier
            health: 1000 + this.level * 20,
            vx: 0,
            vy: 0,
            color: '#00ff88', // Bright green - distinct from core
            damage: 25,
            lastHitTime: 0,
            regenDelay: 999999, // No regeneration
            moleculeType: 'boss',
            isBoss: true,
            bossType: 'dnaHelix',
            bossPart: 'strand1',
            rewardMultiplier: 8.0,
            canTakeDamage: true
        };
        
        const strand2 = {
            x: centerX + 80,
            y: centerY,
            size: 60, // Larger size for visibility
            originalSize: 60,
            maxHealth: 1000 + this.level * 20, // Reduced health to make it easier
            health: 1000 + this.level * 20,
            vx: 0,
            vy: 0,
            color: '#00ccff', // Cyan - distinct from strand1
            damage: 25,
            lastHitTime: 0,
            regenDelay: 999999,
            moleculeType: 'boss',
            isBoss: true,
            bossType: 'dnaHelix',
            bossPart: 'strand2',
            rewardMultiplier: 8.0,
            canTakeDamage: false // Cannot take damage until strand1 is destroyed
        };
        
        // Core (only vulnerable when both strands are destroyed in order)
        const core = {
            x: centerX,
            y: centerY,
            size: 70,
            originalSize: 70,
            maxHealth: 2500 + this.level * 50,
            health: 2500 + this.level * 50,
            vx: 0,
            vy: 0,
            color: '#8b00ff',
            damage: 35,
            lastHitTime: 0,
            regenDelay: 999999,
            moleculeType: 'boss',
            isBoss: true,
            bossType: 'dnaHelix',
            bossPart: 'core',
            rewardMultiplier: 15.0,
            canTakeDamage: false,
            nodes: this.generateDNAHelixStructure(70)
        };
        
        this.currentBoss = core;
        this.obstacles.push(strand1, strand2, core);
        
        // Initialize puzzle state - order-based: destroy strand1 first, then strand2, then core
        this.bossPuzzleState = {
            strand1Destroyed: false,
            strand2Destroyed: false
        };
    }
    
    spawnProteinComplexBoss() {
        // Level 45: Protein Complex
        // Puzzle: Destroy subunits in specific order (1, 2, 3, 4, then core)
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        
        const subunits = [];
        const subunitCount = 4;
        const radius = 100;
        
        // Create 4 subunits that must be destroyed in order
        // Use distinct colors for each subunit to make them more visible
        const subunitColors = ['#ff6b6b', '#ff8c42', '#ffb347', '#ffd700']; // Red, Orange, Light Orange, Gold
        for (let i = 0; i < subunitCount; i++) {
            const angle = (Math.PI * 2 * i) / subunitCount;
            const subunit = {
                x: centerX + Math.cos(angle) * radius,
                y: centerY + Math.sin(angle) * radius,
                size: 45, // Slightly larger for better visibility
                originalSize: 45,
                maxHealth: 800 + this.level * 20,
                health: 800 + this.level * 20,
                vx: 0,
                vy: 0,
                color: subunitColors[i], // Distinct color for each subunit
                damage: 20,
                lastHitTime: 0,
                regenDelay: 999999,
                moleculeType: 'boss',
                isBoss: true,
                bossType: 'proteinComplex',
                bossPart: 'subunit',
                subunitOrder: i + 1, // Order: 1, 2, 3, 4
                rewardMultiplier: 6.0,
                canTakeDamage: i === 0, // Only first subunit can take damage initially
                angle: angle,
                distance: radius,
                parentX: centerX,
                parentY: centerY
            };
            subunits.push(subunit);
        }
        
        // Core (only vulnerable when all subunits destroyed in order)
        const core = {
            x: centerX,
            y: centerY,
            size: 80,
            originalSize: 80,
            maxHealth: 3000 + this.level * 60,
            health: 3000 + this.level * 60,
            vx: 0,
            vy: 0,
            color: '#8b00ff',
            damage: 40,
            lastHitTime: 0,
            regenDelay: 999999,
            moleculeType: 'boss',
            isBoss: true,
            bossType: 'proteinComplex',
            bossPart: 'core',
            rewardMultiplier: 18.0,
            canTakeDamage: false,
            nodes: this.generateProteinComplexStructure(80)
        };
        
        this.currentBoss = core;
        this.obstacles.push(core);
        subunits.forEach(s => this.obstacles.push(s));
        
        // Initialize puzzle state
        this.bossPuzzleState = {
            nextSubunitOrder: 1, // Must destroy in order: 1, 2, 3, 4
            subunitsDestroyed: 0,
            totalSubunits: subunitCount
        };
    }
    
    spawnCellMembraneBoss() {
        // Level 60: Cell Membrane
        // Puzzle: Destroy outer membrane, then inner membrane, then nucleus
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        
        // Outer membrane (must be destroyed first)
        const outerMembrane = {
            x: centerX,
            y: centerY,
            size: 120,
            originalSize: 120,
            maxHealth: 2000 + this.level * 40,
            health: 2000 + this.level * 40,
            vx: 0,
            vy: 0,
            color: '#ffaa00',
            damage: 30,
            lastHitTime: 0,
            regenDelay: 999999,
            moleculeType: 'boss',
            isBoss: true,
            bossType: 'cellMembrane',
            bossPart: 'outerMembrane',
            rewardMultiplier: 7.0,
            canTakeDamage: true
        };
        
        // Inner membrane (only vulnerable when outer membrane is destroyed)
        const innerMembrane = {
            x: centerX,
            y: centerY,
            size: 90,
            originalSize: 90,
            maxHealth: 1800 + this.level * 35,
            health: 1800 + this.level * 35,
            vx: 0,
            vy: 0,
            color: '#ff8800',
            damage: 35,
            lastHitTime: 0,
            regenDelay: 999999,
            moleculeType: 'boss',
            isBoss: true,
            bossType: 'cellMembrane',
            bossPart: 'innerMembrane',
            rewardMultiplier: 10.0,
            canTakeDamage: false
        };
        
        // Nucleus (only vulnerable when both membranes are destroyed)
        const nucleus = {
            x: centerX,
            y: centerY,
            size: 60,
            originalSize: 60,
            maxHealth: 3500 + this.level * 70,
            health: 3500 + this.level * 70,
            vx: 0,
            vy: 0,
            color: '#8b00ff',
            damage: 45,
            lastHitTime: 0,
            regenDelay: 999999,
            moleculeType: 'boss',
            isBoss: true,
            bossType: 'cellMembrane',
            bossPart: 'nucleus',
            rewardMultiplier: 20.0,
            canTakeDamage: false,
            nodes: this.generateCellMembraneStructure(60)
        };
        
        this.currentBoss = nucleus;
        this.obstacles.push(outerMembrane, innerMembrane, nucleus);
        
        // Initialize puzzle state
        this.bossPuzzleState = {
            outerMembraneDestroyed: false,
            innerMembraneDestroyed: false,
            nucleusVulnerable: false
        };
    }
    
    spawnAdvancedBoss(bossNumber) {
        // Level 75+: Advanced bosses with more complex puzzles
        // For now, use a generic structure but mark as boss
        const boss = {
            x: this.canvas.width / 2,
            y: this.canvas.height / 2,
            size: 100 + bossNumber * 10,
            originalSize: 100 + bossNumber * 10,
            maxHealth: 4000 + bossNumber * 600,
            health: 4000 + bossNumber * 600,
            vx: 0,
            vy: 0,
            color: '#8b00ff',
            damage: 50 + bossNumber * 5,
            lastHitTime: 0,
            regenDelay: 999999, // No regeneration
            moleculeType: 'boss',
            isBoss: true,
            bossType: 'advanced',
            rewardMultiplier: 15.0 + bossNumber * 2,
            canTakeDamage: true,
            nodes: this.generateBossStructure(100 + bossNumber * 10)
        };
        
        this.currentBoss = boss;
        this.obstacles.push(boss);
        
        // Initialize puzzle state (simple for advanced bosses)
        this.bossPuzzleState = {
            canTakeDamage: true
        };
    }
    
    generateDNAHelixStructure(size) {
        // DNA double helix structure
        const nodes = [];
        const helixTurns = 3;
        const nodesPerTurn = 8;
        
        // Create nodes in a double helix pattern
        for (let turn = 0; turn < helixTurns; turn++) {
            for (let i = 0; i < nodesPerTurn; i++) {
                const angle = (Math.PI * 2 * i) / nodesPerTurn + turn * Math.PI;
                const radius = size * 0.4;
                const y = (turn - helixTurns / 2) * size * 0.3;
                nodes.push({
                    x: Math.cos(angle) * radius,
                    y: y,
                    radius: size * 0.1,
                    color: '#00ff88',
                    isCore: false
                });
            }
        }
        
        // Central core
        nodes.push({
            x: 0,
            y: 0,
            radius: size * 0.3,
            color: '#8b00ff',
            isCore: true
        });
        
        return nodes;
    }
    
    generateProteinComplexStructure(size) {
        // Protein complex with multiple subunits
        const nodes = [];
        
        // Central core
        nodes.push({
            x: 0,
            y: 0,
            radius: size * 0.4,
            color: '#8b00ff',
            isCore: true
        });
        
        // Subunit nodes
        const subunitCount = 4;
        for (let i = 0; i < subunitCount; i++) {
            const angle = (Math.PI * 2 * i) / subunitCount;
            const radius = size * 0.7;
            nodes.push({
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                radius: size * 0.2,
                color: '#ff6b6b',
                isCore: false
            });
        }
        
        return nodes;
    }
    
    generateCellMembraneStructure(size) {
        // Cell structure with nucleus
        const nodes = [];
        
        // Nucleus core
        nodes.push({
            x: 0,
            y: 0,
            radius: size * 0.5,
            color: '#8b00ff',
            isCore: true
        });
        
        // Organelles around nucleus
        const organelleCount = 6;
        for (let i = 0; i < organelleCount; i++) {
            const angle = (Math.PI * 2 * i) / organelleCount;
            const radius = size * 0.8;
            nodes.push({
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                radius: size * 0.15,
                color: '#ffaa00',
                isCore: false
            });
        }
        
        return nodes;
    }
    
    spawnBossModeElements() {
        // Spawn elements from all three modes combined
        // Individual mode: targets
        for (let i = 0; i < 3; i++) {
            this.spawnTarget();
        }
        
        // Ensemble mode: more targets (represented as individual targets with randomness)
        for (let i = 0; i < 2; i++) {
            this.spawnTarget();
        }
        
        // Bell mode: pairs (but no enemy ships in boss mode)
        for (let i = 0; i < 2; i++) {
            const x1 = Math.random() * Math.max(100, this.canvas.width - 200) + 100;
            const y1 = Math.random() * Math.max(100, this.canvas.height - 200) + 100;
            const x2 = x1 + (Math.random() - 0.5) * 150;
            const y2 = y1 + (Math.random() - 0.5) * 150;
            
            this.pairs.push({
                a: { x: x1, y: y1, size: 15, health: 1, color: '#4fc3f7', vx: (Math.random() - 0.5) * 50, vy: (Math.random() - 0.5) * 50 },
                b: { x: x2, y: y2, size: 15, health: 1, color: '#4fc3f7', vx: (Math.random() - 0.5) * 50, vy: (Math.random() - 0.5) * 50 }
            });
        }
        
        // Spawn some obstacles (molecules)
        for (let i = 0; i < 2; i++) {
            this.spawnObstacle();
        }
    }
    
    spawnBossEnemies(bossNumber) {
        // Spawn boss-specific enemies that shoot at the player
        // Different enemy types for each boss to make them visually distinct
        
        if (bossNumber === 1) {
            // Boss 1: Neural Drones (hexagonal, purple/blue)
            for (let i = 0; i < 3; i++) {
                this.spawnNeuralDrone();
            }
        } else if (bossNumber === 2) {
            // Boss 2: Genetic Sentinels (double-helix shape, green/cyan)
            for (let i = 0; i < 3; i++) {
                this.spawnGeneticSentinel();
            }
        } else if (bossNumber === 3) {
            // Boss 3: Molecular Defenders (complex geometric, orange/red)
            for (let i = 0; i < 4; i++) {
                this.spawnMolecularDefender();
            }
        } else if (bossNumber === 4) {
            // Boss 4: Cellular Guardians (circular with spikes, yellow/orange)
            for (let i = 0; i < 4; i++) {
                this.spawnCellularGuardian();
            }
        } else {
            // Advanced bosses: Quantum Disruptors (energy-based, purple/cyan)
            for (let i = 0; i < 5; i++) {
                this.spawnQuantumDisruptor();
            }
        }
    }
    
    spawnNeuralDrone() {
        // Neural Drone - hexagonal shape, purple/blue, for Boss 1
        // Spawn within visible frame to ensure players can see them immediately
        const margin = 50; // Keep enemies away from exact edges
        const x = margin + Math.random() * (this.canvas.width - margin * 2);
        const y = margin + Math.random() * (this.canvas.height - margin * 2);
        
        this.bossEnemies.push({
            x, y,
            size: 22,
            speed: 60 + this.level * 3,
            health: 100 + this.level * 20,
            maxHealth: 100 + this.level * 20,
            color: '#9c27b0', // Purple
            secondaryColor: '#2196f3', // Blue
            type: 'neuralDrone',
            lastShot: 0,
            shotCooldown: 2500 + Math.random() * 1000 // 2.5-3.5 seconds (slower shooting)
        });
    }
    
    spawnGeneticSentinel() {
        // Genetic Sentinel - double-helix shape, green/cyan, for Boss 2
        // Spawn within visible frame to ensure players can see them immediately
        const margin = 50; // Keep enemies away from exact edges
        const x = margin + Math.random() * (this.canvas.width - margin * 2);
        const y = margin + Math.random() * (this.canvas.height - margin * 2);
        
        this.bossEnemies.push({
            x, y,
            size: 24,
            speed: 70 + this.level * 3.5,
            health: 120 + this.level * 25,
            maxHealth: 120 + this.level * 25,
            color: '#00ff88', // Green
            secondaryColor: '#00ccff', // Cyan
            type: 'geneticSentinel',
            lastShot: 0,
            shotCooldown: 2800 + Math.random() * 800 // 2.8-3.6 seconds (slower shooting)
        });
    }
    
    spawnMolecularDefender() {
        // Molecular Defender - complex geometric shape, orange/red, for Boss 3
        // Spawn within visible frame to ensure players can see them immediately
        const margin = 50; // Keep enemies away from exact edges
        const x = margin + Math.random() * (this.canvas.width - margin * 2);
        const y = margin + Math.random() * (this.canvas.height - margin * 2);
        
        this.bossEnemies.push({
            x, y,
            size: 26,
            speed: 65 + this.level * 4,
            health: 150 + this.level * 30,
            maxHealth: 150 + this.level * 30,
            color: '#ff9800', // Orange
            secondaryColor: '#f44336', // Red
            type: 'molecularDefender',
            lastShot: 0,
            shotCooldown: 2600 + Math.random() * 900 // 2.6-3.5 seconds (slower shooting)
        });
    }
    
    spawnCellularGuardian() {
        // Cellular Guardian - circular with spikes, yellow/orange, for Boss 4
        // Spawn within visible frame to ensure players can see them immediately
        const margin = 50; // Keep enemies away from exact edges
        const x = margin + Math.random() * (this.canvas.width - margin * 2);
        const y = margin + Math.random() * (this.canvas.height - margin * 2);
        
        this.bossEnemies.push({
            x, y,
            size: 28,
            speed: 55 + this.level * 3,
            health: 180 + this.level * 35,
            maxHealth: 180 + this.level * 35,
            color: '#ffc107', // Yellow
            secondaryColor: '#ff9800', // Orange
            type: 'cellularGuardian',
            lastShot: 0,
            shotCooldown: 3000 + Math.random() * 1000 // 3-4 seconds (slower shooting)
        });
    }
    
    spawnQuantumDisruptor() {
        // Quantum Disruptor - energy-based shape, purple/cyan, for Advanced bosses
        // Spawn within visible frame to ensure players can see them immediately
        const margin = 50; // Keep enemies away from exact edges
        const x = margin + Math.random() * (this.canvas.width - margin * 2);
        const y = margin + Math.random() * (this.canvas.height - margin * 2);
        
        this.bossEnemies.push({
            x, y,
            size: 30,
            speed: 80 + this.level * 5,
            health: 200 + this.level * 40,
            maxHealth: 200 + this.level * 40,
            color: '#8b00ff', // Purple
            secondaryColor: '#00ffff', // Cyan
            type: 'quantumDisruptor',
            lastShot: 0,
            shotCooldown: 2400 + Math.random() * 800 // 2.4-3.2 seconds (slower shooting)
        });
    }

    updateTheoryPanel() {
        const theoryTexts = {
            ensemble: `<span class="warning">Ensemble QM:</span> Probabilistic shooting with uncertainty.`,
            individual: `<span class="success">Individual System:</span> Precise, deterministic shooting.`,
            bell: `<span class="warning">Bell Pairs:</span> Correlated pairs behavior.`
        };

        // OPTIMIZATION: Use cached DOM element
        const panel = this._cachedElements.currentTheory;
        if (panel) panel.innerHTML = theoryTexts[this.mode] || '';
    }

    spawnInitialTargets() {
        setTimeout(() => {
            for (let i = 0; i < 3 + this.level; i++) {
                this.spawnTarget();
            }
        }, 100);
    }

    spawnTarget() {
        if (!this.canvas || this.canvas.width === 0 || this.canvas.height === 0) return;
        
        if (this.mode === 'bell') {
            const x1 = Math.random() * Math.max(100, this.canvas.width - 200) + 100;
            const y1 = Math.random() * Math.max(100, this.canvas.height - 200) + 100;
            const x2 = x1 + (Math.random() - 0.5) * 150;
            const y2 = y1 + (Math.random() - 0.5) * 150;
            
            this.pairs.push({
                a: { x: x1, y: y1, size: 15, health: 1, color: '#4fc3f7', vx: (Math.random() - 0.5) * 50, vy: (Math.random() - 0.5) * 50 },
                b: { x: x2, y: y2, size: 15, health: 1, color: '#4fc3f7', vx: (Math.random() - 0.5) * 50, vy: (Math.random() - 0.5) * 50 }
            });
        } else {
            this.targets.push({
                x: Math.random() * Math.max(50, this.canvas.width - 100) + 50,
                y: Math.random() * Math.max(50, this.canvas.height - 200) + 50,
                size: 15,
                health: 1,
                color: '#4fc3f7',
                vx: (Math.random() - 0.5) * 50,
                vy: (Math.random() - 0.5) * 50
            });
        }
    }

    spawnEnemyShip() {
        // Spawn enemy ship at random edge (Bell mode only)
        if (this.mode !== 'bell') return;
        
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { // Top
            x = Math.random() * this.canvas.width;
            y = -30;
        } else if (side === 1) { // Right
            x = this.canvas.width + 30;
            y = Math.random() * this.canvas.height;
        } else if (side === 2) { // Bottom
            x = Math.random() * this.canvas.width;
            y = this.canvas.height + 30;
        } else { // Left
            x = -30;
            y = Math.random() * this.canvas.height;
        }
        
        // Enemy ship stats scale with player power (stats and weapons)
        // Start easier, scale up as player gets stronger
        const difficulty = this.calculateEnemyDifficulty();
        
        // Base speed starts at 50 (slower at first), scales with difficulty
        const baseSpeed = 50;
        const speed = baseSpeed * difficulty;
        
        // Health also scales with difficulty and level
        const baseHealth = 60 + this.level * 10;
        const health = Math.floor(baseHealth * difficulty);
        
        this.enemyShips.push({
            x, y,
            size: 18, // Reduced from 25 to make it smaller
            speed: speed,
            health: health,
            maxHealth: health,
            color: '#f44336'
        });
    }
    
    // Helper function to calculate enemy difficulty based on player power
    // Returns a multiplier (0.5 to 3.0) based on player stats, weapons, and level
    // Starts low and scales up as player gets stronger
    // Improved scaling: higher cap and level-based minimum to keep challenge at high levels
    calculateEnemyDifficulty() {
        // Base difficulty starts at 0.5 (50% - easier at start)
        let difficulty = 0.5;
        
        // Scale with level (gradual increase)
        difficulty += (this.level - 1) * 0.02; // +2% per level
        
        // Scale with player damage (stronger weapons = harder enemies)
        const baseDamage = this.playerStats.damage || 10;
        const damageMultiplier = (baseDamage - 10) / 50; // Normalize: 10 damage = 0, 60 damage = 1.0
        difficulty += damageMultiplier * 0.3; // Up to +30% from damage
        
        // Scale with number of weapons equipped (more weapons = harder enemies)
        const weaponCount = this.currentWeapons.filter(w => w !== 'basic').length;
        difficulty += weaponCount * 0.05; // +5% per additional weapon
        
        // Scale with player speed (faster player = harder enemies)
        const speedBonus = this.playerStats.speed - this.playerStats.baseSpeed;
        const speedMultiplier = speedBonus / 200; // Normalize: 0 speed = 0, 200 speed = 1.0
        difficulty += speedMultiplier * 0.2; // Up to +20% from speed
        
        // Level-based minimum difficulty to ensure challenge at high levels
        // At level 100+, minimum difficulty is 2.0, scaling up to 3.0 at level 200+
        const levelBasedMinimum = Math.min(3.0, 0.5 + this.level * 0.025); // +2.5% per level, caps at 3.0
        
        // Cap difficulty between level-based minimum and 3.0 (increased from 2.0)
        // This ensures enemies remain challenging even when player has maxed stats
        difficulty = Math.max(levelBasedMinimum, Math.min(3.0, difficulty));
        
        return difficulty;
    }
    
    // Helper function to calculate combined damage from all equipped weapons and stats
    // This matches the damage calculation used when shooting bullets
    calculateCombinedDamage() {
        // Get regular weapons (non-laser, non-automatic)
        const regularWeapons = this.currentWeapons.filter(w => 
            w !== 'laser' && w !== 'automatic' && w !== 'individualSystemCore'
        );
        
        if (regularWeapons.length === 0) {
            // Fallback if no weapons
            return (this.playerStats.damage || 10);
        }
        
        // Calculate combined damage from all weapons (weapons stack)
        let combinedDamage = 0;
        let spreadCount = 0;
        const hasSpread = regularWeapons.includes('spread');
        
        regularWeapons.forEach(weaponName => {
            const weapon = this.equipmentStats.weapons[weaponName];
            if (!weapon) return;
            
            // Apply weapon-specific upgrades
            const upgradeLevel = this.weaponUpgrades[weaponName] || 0;
            let weaponSpread = weapon.spread || 0;
            
            if (weaponName === 'spread') {
                // Spread upgrades: each tier increases spread count (3→4→5→6→7)
                weaponSpread = (weapon.spread || 3) + upgradeLevel;
                if (weaponSpread > spreadCount) {
                    spreadCount = weaponSpread;
                }
            }
            
            // Combine weapon damage - weapons work together to increase damage
            combinedDamage += weapon.damage;
        });
        
        // Safety check: If no weapons processed, use default damage
        if (combinedDamage === 0 && regularWeapons.length > 0) {
            combinedDamage = 10;
        }
        
        // Apply upgrade bonuses (matches shoot() function - applied before base damage)
        if (this.currentUpgrades.includes('completeDescriptionMatrix')) {
            combinedDamage *= 1.5; // +50% damage
        }
        if (this.currentUpgrades.includes('individualSystemAmplifier')) {
            combinedDamage *= 1.75; // +75% damage
        }
        
        // Add base damage from upgrades (matches createBullet() function)
        // This is what each bullet actually does when it hits
        const baseDamage = this.playerStats.damage - this.playerStats.baseDamage;
        const damagePerBullet = combinedDamage + baseDamage;
        
        // Calculate damage per "shot" (accounting for spread - each bullet in spread does full damage)
        // If spread is equipped, you get multiple bullets, each doing full damage
        // So total damage per shot = damage per bullet * spread count (or 1 if no spread)
        const damagePerShot = damagePerBullet * (spreadCount > 0 ? spreadCount : 1);
        
        return damagePerShot;
    }
    
    spawnObstacle() {
        if (!this.canvas || this.canvas.width === 0) return;
        
        // Don't spawn regular obstacles during boss battles
        if (this.bossMode) {
            return;
        }
        
        // Level 150 is a boss - special handling (old system, kept for compatibility)
        if (this.level === 150 && !this.bossSpawned && !this.bossMode) {
            this.spawnBoss();
            this.bossSpawned = true;
            return;
        }
        
        const side = Math.floor(Math.random() * 4);
        let x, y, vx, vy;
        
        // OPTIMIZED: Progressive speed scaling for late game (starts earlier at level 70)
        // Early game (1-50): Linear scaling (80 + level * 15)
        // Mid game (50-70): Slower scaling (cap at level 50 speed, then +8 per level)
        // Late game (70-150): Very slow scaling (cap at level 70 speed, then +3 per level)
        // Very late game (150+): Minimal scaling (cap at level 150 speed, then +1 per level)
        // This prevents excessive speeds that cause lag, starting optimization earlier
        let baseSpeed;
        if (this.level <= 50) {
            baseSpeed = 80 + this.level * 15; // Original scaling
        } else if (this.level <= 70) {
            // Cap at level 50 speed (830), then add slower scaling
            const level50Speed = 80 + 50 * 15; // 830
            baseSpeed = level50Speed + (this.level - 50) * 8; // +8 per level after 50
        } else if (this.level <= 150) {
            // Cap at level 70 speed (990), then add very slow scaling
            const level70Speed = 80 + 50 * 15 + 20 * 8; // 990
            baseSpeed = level70Speed + (this.level - 70) * 3; // +3 per level after 70
        } else {
            // Cap at level 150 speed (1110), then add minimal scaling
            const level150Speed = 80 + 50 * 15 + 20 * 8 + 80 * 3; // 1110
            baseSpeed = level150Speed + (this.level - 150) * 1; // +1 per level after 150
        }
        
        // Cap maximum speed to prevent lag (absolute maximum of 1200)
        baseSpeed = Math.min(baseSpeed, 1200);
        
        switch(side) {
            case 0: // Top
                x = Math.random() * this.canvas.width;
                y = -20;
                vx = (Math.random() - 0.5) * 80;
                vy = baseSpeed;
                break;
            case 1: // Right
                x = this.canvas.width + 20;
                y = Math.random() * this.canvas.height;
                vx = -baseSpeed;
                vy = (Math.random() - 0.5) * 80;
                break;
            case 2: // Bottom
                x = Math.random() * this.canvas.width;
                y = this.canvas.height + 20;
                vx = (Math.random() - 0.5) * 80;
                vy = -baseSpeed;
                break;
            case 3: // Left
                x = -20;
                y = Math.random() * this.canvas.height;
                vx = baseSpeed;
                vy = (Math.random() - 0.5) * 80;
                break;
        }
        
        // Determine molecule complexity based on level
        let moleculeType = 'simple'; // H2O, CO2, NH3
        let atomCount = 3;
        let baseSize;
        let healthMultiplier = 1.0;
        let rewardMultiplier = 1.0;
        
        // OPTIMIZED: Size scaling for late game performance (starts earlier at level 70)
        // Early game (1-50): Linear scaling
        // Mid game (50-70): Slower scaling
        // Late game (70-150): Very slow scaling with cap
        // Very late game (150+): Minimal growth
        if (this.level < 50) {
            // Simple molecules: start at 45 (3x blue particles), grow by 1.5 per level
            // Level 1: 45, Level 20: 45 + 19*1.5 = 73.5, Level 49: 45 + 48*1.5 = 117
            baseSize = 45 + (this.level - 1) * 1.5;
        } else if (this.level < 70) {
            // Medium molecules: continue growing but slower
            // Level 50: ~120, Level 69: ~139
            baseSize = 45 + 49 * 1.5 + (this.level - 50) * 1.0; // Continue from level 49, slower growth
        } else if (this.level < 150) {
            // Late game: very slow growth, approaching cap
            // Level 70: ~139, Level 149: ~149
            const level70Size = 45 + 49 * 1.5 + 20 * 1.0; // ~139
            baseSize = level70Size + (this.level - 70) * 0.15; // Very slow growth (+0.15 per level)
        } else {
            // Very late game: cap at level 150 size (~152)
            const level150Size = 45 + 49 * 1.5 + 20 * 1.0 + 80 * 0.15; // ~152
            baseSize = Math.min(level150Size + (this.level - 150) * 0.05, 160); // Minimal growth, hard cap at 160
        }
        
        if (this.level >= 50) {
            moleculeType = 'medium'; // C6H6, CH4, etc.
            atomCount = 4 + Math.floor((this.level - 50) / 10);
            healthMultiplier = 1.5;
            rewardMultiplier = 2.0;
        }
        if (this.level >= 100) {
            moleculeType = 'complex'; // Large organic molecules
            atomCount = 6 + Math.floor((this.level - 100) / 5);
            healthMultiplier = 2.0;
            rewardMultiplier = 3.0;
        }
        
        // Health scaling: Start easy (3-5 hits), then scale with player damage/stats/weapons
        // Calculate combined damage from all equipped weapons and stats
        const damagePerShot = this.calculateCombinedDamage();
        
        // Start with 3-5 hits worth of health (randomized for variety)
        const hitsToKill = 3 + Math.floor(Math.random() * 3); // 3, 4, or 5 hits
        const baseHealth = damagePerShot * hitsToKill;
        
        // Scale with level and molecule complexity
        const maxHealth = Math.floor(baseHealth * healthMultiplier);
        const obstacle = {
            x, y,
            size: baseSize,
            originalSize: baseSize,
            maxHealth: maxHealth,
            health: maxHealth,
            vx, vy,
            color: '#ff4444',
            damage: 10 + this.level,
            lastHitTime: 0,
            regenDelay: 3.0,
            moleculeType: moleculeType,
            atomCount: atomCount,
            rewardMultiplier: rewardMultiplier,
            atoms: this.generateMoleculeStructure(moleculeType, atomCount, baseSize)
        };
        
        this.obstacles.push(obstacle);
    }
    
    generateMoleculeStructure(type, atomCount, baseSize) {
        const atoms = [];
        const centerRadius = baseSize * 0.3;
        
        // Central atom
        atoms.push({
            x: 0,
            y: 0,
            radius: baseSize * 0.4,
            color: '#ff6666'
        });
        
        // Surrounding atoms based on molecule type
        if (type === 'simple') {
            // Simple molecules: H2O (3 atoms), CO2 (3 atoms), NH3 (4 atoms)
            const bondLength = baseSize * 0.6;
            for (let i = 0; i < atomCount - 1; i++) {
                const angle = (Math.PI * 2 * i) / (atomCount - 1);
                atoms.push({
                    x: Math.cos(angle) * bondLength,
                    y: Math.sin(angle) * bondLength,
                    radius: baseSize * 0.25,
                    color: '#ff9999'
                });
            }
        } else if (type === 'medium') {
            // Medium molecules: ring structures or branched
            const bondLength = baseSize * 0.7;
            for (let i = 0; i < atomCount - 1; i++) {
                const angle = (Math.PI * 2 * i) / (atomCount - 1);
                atoms.push({
                    x: Math.cos(angle) * bondLength,
                    y: Math.sin(angle) * bondLength,
                    radius: baseSize * 0.3,
                    color: '#ff8888'
                });
            }
        } else if (type === 'complex') {
            // Complex molecules: multiple rings or chains
            const layers = Math.ceil(Math.sqrt(atomCount - 1));
            let atomIndex = 0;
            for (let layer = 1; layer <= layers && atomIndex < atomCount - 1; layer++) {
                const layerAtoms = Math.min(atomCount - 1 - atomIndex, layer * 2);
                const bondLength = baseSize * (0.4 + layer * 0.3);
                for (let i = 0; i < layerAtoms && atomIndex < atomCount - 1; i++) {
                    const angle = (Math.PI * 2 * i) / layerAtoms;
                    atoms.push({
                        x: Math.cos(angle) * bondLength,
                        y: Math.sin(angle) * bondLength,
                        radius: baseSize * 0.25,
                        color: '#ff7777'
                    });
                    atomIndex++;
                }
            }
        }
        
        return atoms;
    }
    
    spawnBoss() {
        // Level 150 boss: Neural network structure (scientist's brain)
        const boss = {
            x: this.canvas.width / 2,
            y: this.canvas.height / 2,
            size: 100,
            originalSize: 100,
            maxHealth: 5000,
            health: 5000,
            vx: 0,
            vy: 0,
            color: '#8b00ff',
            damage: 50,
            lastHitTime: 0,
            regenDelay: 0,
            moleculeType: 'boss',
            atomCount: 20,
            rewardMultiplier: 10.0,
            isBoss: true,
            nodes: this.generateBossStructure(100)
        };
        
        this.obstacles.push(boss);
    }
    
    generateBossStructure(size) {
        // Neural network structure with nodes and connections
        const nodes = [];
        const nodeCount = 20;
        const centerRadius = size * 0.4;
        
        // Central core
        nodes.push({
            x: 0,
            y: 0,
            radius: size * 0.3,
            color: '#8b00ff',
            isCore: true
        });
        
        // Surrounding nodes
        for (let i = 0; i < nodeCount - 1; i++) {
            const angle = (Math.PI * 2 * i) / (nodeCount - 1);
            const radius = centerRadius + (Math.random() * size * 0.3);
            nodes.push({
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                radius: size * 0.15,
                color: '#aa44ff',
                isCore: false
            });
        }
        
        return nodes;
    }

    reset() {
        // Complete reset - start over from scratch
        this.deathReason = null; // Clear death reason on reset
        this.level = 1;
        this.gameState = 'playing';
        this.bullets = [];
        this.enemyBullets = [];
        this.targets = [];
        this.pairs = [];
        this.obstacles = [];
        this.enemyShips = [];
        this.items = [];
        this.particles = [];
        this.score = 0;
        this.hits = 0;
        this.misses = 0;
        this.time = 0;
        this.lastTargetSpawn = 0;
        this.lastObstacleSpawn = 0;
        this.lastEnemySpawn = Date.now(); // Initialize to current time so first spawn waits
        this.lastEnemyShot = 0;
        this.targetSpawnRate = 2000;
        this.obstacleSpawnRate = 3000;
        this.enemySpawnRate = 8000; // Spawn enemy every 8 seconds in Bell mode (more time between spawns)
        this.enemyShotRate = 1500; // Enemy shoots every 1.5 seconds
        
        // Reset inventory completely (including biological components)
        this.inventory = {
            quantumParticles: 0,
            energyCores: 0,
            metalScraps: 0,
            crystals: 0,
            tokens: 0,
            // Biological components for survival system
            atp: 0,
            aminoAcids: 0,
            simpleSugars: 0,
            fattyAcids: 0,
            nucleotides: 0,
            vitamins: 0,
            minerals: 0
        };
        
        // Reset equipment to starting values
        this.currentShip = 'basic';
        this.currentWeapons = ['basic'];
        this.currentShield = 'none';
        this.currentUpgrades = [];
        
        // Reset owned items to starting values
        this.ownedItems = {
            weapons: { basic: { count: 1, durability: 100 } },
            ships: { basic: { count: 1, durability: 100 } },
            shields: {},
            upgrades: {},
            consumables: {},
            tools: {} // Hammer, etc.
        };
        
        // Reset level-up state
        this.levelUpState = false;
        
        // Reset player stats to base values - MUST include all properties to prevent freeze
        this.playerStats = {
            health: 100,
            maxHealth: 100,
            baseMaxHealth: 100,
            shield: 0,
            maxShield: 0,
            speed: 150,
            baseSpeed: 150,
            fireRate: 0.5,
            baseFireRate: 0.5,
            damage: 10,
            baseDamage: 10,
            // New RPG stats - all must be reset
            criticalHitChance: 0,
            criticalHitDamage: 2.0,
            shieldCapacityBonus: 0,
            shieldRegenBonus: 0,
            damageReduction: 0,
            evasion: 0,
            materialDropRate: 0,
            tokenDropRate: 0,
            levelTimeReduction: 0,
            projectileSpeed: 0,
            healthRegen: 0,
            lastDamageTime: 0, // Reset damage cooldown timer
            damageCooldown: 1.5 // Cooldown in seconds before taking damage again (1.5s = 1500ms) - doubled for better escape time
        };
        
        // Reset player size - use current ship's size
        const currentShip = this.equipmentStats.ships[this.currentShip];
        this.player.size = currentShip ? currentShip.size : 20;
        
        // Reset player position
        this.player.x = this.canvas.width / 2;
        this.player.y = this.canvas.height - 100;
        this.player.lastShotByWeapon = {}; // Reset weapon cooldowns
        this.player.laserActive = false;
        this.player.laserCharge = 0;
        this.player.laserCooldown = 0;
        this.player.bossHitEffect = 0; // Reset boss hit visual effect
        this.player.bossHitIntensity = 0; // Reset boss hit intensity
        this.activeLaser = null;
        
        // Reset weapon upgrades (all back to level 0)
        this.weaponUpgrades = {};
        
        // Reset upgrade levels for cost calculation
        this.upgradeLevels = {
            speed: 0,
            fireRate: 0,
            damage: 0,
            maxHealth: 0,
            criticalHitChance: 0,
            criticalHitDamage: 0,
            shieldCapacityBonus: 0,
            shieldRegenBonus: 0,
            damageReduction: 0,
            evasion: 0,
            materialDropRate: 0,
            tokenDropRate: 0,
            levelTimeReduction: 0,
            projectileSpeed: 0,
            healthRegen: 0
        };
        
        // Reset weapon use time tracking
        this.weaponUseTime = {};
        
        // Reset weapon shots fired tracking
        this.weaponShotsFired = {};
        
        // Reset hammer state
        this.hammerEquipped = false;
        this.repairableItems = [];
        this.repairSelectionMode = false;
        this.repairSelectedIndex = 0;
        this.selectedRepairItem = null;
        
        // Reset UI state
        this.menuSelectedIndex = { crafting: 0, shop: 0 };
        this.currentMenuPanel = 'crafting';
        this.weaponWheelVisible = false;
        this.weaponWheelSelectedIndex = 0;
        this.individualSystemCoreOmniState = undefined;
        
        // Reset boss spawn flag and boss mode
        this.bossSpawned = false;
        this.bossMode = false;
        this.currentBoss = null;
        this.bossPuzzleState = {};
        
        // Reset hidden sequence tracking
        this.hiddenSequence = {
            bellLevels: new Set(),
            ensembleLevels: new Set(),
            individualLevels: new Set(),
            lastMode: null,
            lastLevel: 1,
            levelStartTime: {},
            gracePeriod: 10,
            sequenceComplete: false,
            saveUnlocked: false,
            notificationShown: false,
            lastAutoSaveLevel: 0
        };
        this.savedGameState = null;
        
        // Reset weapon cache
        this._weaponsCacheInvalid = true;
        this._cachedRegularWeapons = [];
        this._cachedLaserWeapons = [];
        this._statsNeedsUpdate = false;
        
        // Reset cutscene state - CRITICAL: prevents freeze on restart
        this.cutsceneTime = 0;
        this.cutscenePhase = 0;
        this.cutsceneId = null; // Clear cutscene ID to prevent drawing
        this.cutsceneIsManual = false;
        
        // Reset survival system
        this.hunger = 100; // Reset to full hunger
        this.maxHunger = 100;
        this.hungerDecayRate = 0.5;
        this.lastHungerDecay = Date.now();
        this.methane = 0; // Reset methane
        this.maxMethane = 100;
        this.boostActive = false; // Reset boost state
        this.boostDuration = 0;
        this.boostCooldown = 0;
        this.boostSpeedMultiplier = 1.5;
        this.boostDamageMultiplier = 1.3;
        this.foodInventory = {}; // Clear food inventory
        
        // Unlock survival system immediately (starts from level 1, not after level up)
        this.survivalUnlocked = true;
        console.log('[Survival] Survival system unlocked at game start! You can now collect biological components and craft food.');
        this.showCutscene = false; // Don't show cutscene on restart
        this._cutsceneWasSkipped = false;
        this._cutsceneDrawLogged = false;
        
        // Hide cutscene overlay if it's showing
        if (this.cutsceneOverlay) {
            this.cutsceneOverlay.classList.remove('active');
        }
        if (this.cutsceneText) {
            this.cutsceneText.textContent = '';
            this.cutsceneText.classList.remove('visible');
        }
        
        // Reset pause state
        this.isPaused = false;
        
        // CRITICAL FIX: Ensure boss mode is fully exited and boss obstacles are cleared
        // This prevents random death from boss obstacles colliding after level up
        this.bossMode = false;
        this.bossEnemies = [];
        this.currentBoss = null;
        this.bossPuzzleState = {};
        // Ensure all boss obstacles are removed (double-check to prevent collision issues)
        this.obstacles = this.obstacles.filter(o => !o.isBoss);
        // Also clear enemy bullets from boss enemies to prevent damage after level up
        this.enemyBullets = [];
        
        // Reset game loop timing - CRITICAL: prevents deltaTime calculation issues
        this.lastTime = performance.now();
        
        // Activate resume smoothing to gradually resume effects/bullets after level-up
        // This prevents lag spikes when many objects resume at once
        this.resumeSmoothing.active = true;
        this.resumeSmoothing.framesRemaining = 5; // More frames for level-up resume
        
        // Remove level-up class from body if present
        document.body.classList.remove('level-up');
        
        // Hide level-up continue button
        // OPTIMIZATION: Use cached DOM element
        const continueUI = this._cachedElements.levelUpContinueUI;
        if (continueUI) {
            continueUI.style.display = 'none';
        }
        
        // Restart music if it was playing (in dev mode, music should continue)
        if (this.audio && this.gameState === 'playing') {
            // Only restart if music isn't already playing
            if (!this.audio.currentMusicElement || this.audio.currentMusicElement.paused) {
                this.audio.playMusic('main', true, true);
            }
        }
        
        // Reset mode to default (ensemble mode)
        this.mode = 'ensemble';
        
        // Clear any remaining state
        this.bossSpawned = false;
        this.levelUpState = false;
        
        // Ensure game state is set to playing
        this.gameState = 'playing';
        
        // Update UI
        this.updateStats();
        this.spawnInitialTargets();
        
        // Close any open UIs
        // OPTIMIZATION: Use cached DOM elements
        this._cachedElements.craftingUI?.classList.remove('active');
        this._cachedElements.shopUI?.classList.remove('active');
        this._cachedElements.inventoryUI?.classList.remove('active');
        this._cachedElements.leaderboardUI?.classList.remove('active');
        this._cachedElements.settingsUI?.classList.remove('active');
        
        // Force update to ensure game starts
        this.updateStats();
    }
    
    deepCopyOwnedItems(ownedItems) {
        // Optimized: Manual deep copy for ownedItems structure (faster than JSON.parse/stringify)
        const copy = {};
        for (let type in ownedItems) {
            copy[type] = {};
            for (let name in ownedItems[type]) {
                const item = ownedItems[type][name];
                if (typeof item === 'object' && item !== null) {
                    copy[type][name] = { ...item }; // Shallow copy of item object
                } else {
                    copy[type][name] = item;
                }
            }
        }
        return copy;
    }
    
    saveGameState() {
        // Save current game state at the CURRENT level (not level - 2)
        // When reverting, we'll always go back 2 levels from the current level
        // Only save if we're at least 2 levels
        if (this.level < 2) return;
        
        // Optimized: Use manual deep copy instead of JSON.parse(JSON.stringify)
        // Manual copy is faster for simple objects
        this.savedGameState = {
            level: this.level, // Save at current level (not level - 2)
            mode: this.mode, // Save current game mode
            inventory: { ...this.inventory }, // Shallow copy is sufficient for simple objects
            ownedItems: this.deepCopyOwnedItems(this.ownedItems), // Custom deep copy for nested structure
            currentShip: this.currentShip,
            currentWeapons: [...this.currentWeapons],
            currentShield: this.currentShield,
            currentUpgrades: [...this.currentUpgrades],
            playerStats: { ...this.playerStats }, // Shallow copy is sufficient
            weaponUpgrades: { ...this.weaponUpgrades }, // Shallow copy is sufficient
            upgradeLevels: { ...this.upgradeLevels }, // Save upgrade levels
            score: this.score,
            time: this.time // Save current time
        };
        
        // Save to localStorage for persistence
        try {
            localStorage.setItem('bellGameSavedState', JSON.stringify(this.savedGameState));
        } catch (e) {
            console.warn('Failed to save game state:', e);
        }
    }
    
    revertToSavedState() {
        // Alias for loadGameState - reverts to saved state (2 levels back)
        return this.loadGameState();
    }
    
    loadGameState() {
        // Load saved game state (revert to 2 levels back from CURRENT level)
        if (!this.hiddenSequence.saveUnlocked) {
            console.log('Save feature not unlocked yet!');
            return false;
        }
        
        // Store the level we died at (before reverting)
        const deathLevel = this.level;
        
        // Calculate target level (always 2 levels back from where we died)
        const targetLevel = Math.max(1, deathLevel - 2);
        
        // Try to load from memory first, then localStorage
        let savedState = this.savedGameState;
        if (!savedState) {
            try {
                const stored = localStorage.getItem('bellGameSavedState');
                if (stored) {
                    savedState = JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load saved game state:', e);
                return false;
            }
        }
        
        if (!savedState) {
            console.log('No saved game state found!');
            return false;
        }
        
        // Check if saved state is valid (should be from a level <= targetLevel)
        // If saved state is from a level higher than target, we can't use it properly
        const savedLevel = savedState.level || targetLevel;
        if (savedLevel > targetLevel) {
            console.warn(`Saved state is from level ${savedLevel}, but target is ${targetLevel}. Using target level.`);
        }
        
        // Use the saved level if it's <= targetLevel, otherwise use targetLevel
        // This ensures we don't restore to a level higher than intended
        const restoreLevel = Math.min(savedLevel, targetLevel);
        
        // Restore game state from saved state
        this.inventory = savedState.inventory || this.inventory;
        this.ownedItems = savedState.ownedItems || this.ownedItems;
        this.currentShip = savedState.currentShip || this.currentShip;
        this.currentWeapons = savedState.currentWeapons || this.currentWeapons;
        this.currentShield = savedState.currentShield || this.currentShield;
        this.currentUpgrades = savedState.currentUpgrades || this.currentUpgrades;
        this.weaponUpgrades = savedState.weaponUpgrades || this.weaponUpgrades;
        this.upgradeLevels = savedState.upgradeLevels || this.upgradeLevels;
        this.score = savedState.score !== undefined ? savedState.score : this.score;
        this.mode = savedState.mode || this.mode; // Restore game mode
        
        // Restore playerStats - need to preserve the saved health properly
        if (savedState.playerStats) {
            // Deep copy playerStats to avoid reference issues
            this.playerStats = { ...savedState.playerStats };
        }
        
        // Set level to restore level (use saved level if valid, otherwise target level)
        this.level = restoreLevel;
        
        // Calculate time based on level and levelTimeReduction
        // Level formula: level = Math.floor(time / adjustedTimePerLevel) + 1
        // So: time = (level - 1) * adjustedTimePerLevel
        const baseTimePerLevel = 30;
        const timeReduction = Math.min(40, Math.max(0, this.playerStats.levelTimeReduction)) / 100; // Clamp between 0-40% to prevent negative values
        const adjustedTimePerLevel = Math.max(10, baseTimePerLevel * (1 - timeReduction)); // Minimum 10 seconds per level to prevent negative/zero values
        
        // Use saved time if available and valid, otherwise calculate from level
        // Time should be (level - 1) * adjustedTimePerLevel to match the level calculation
        if (savedState.time !== undefined && savedState.level !== undefined && savedState.level === restoreLevel) {
            // Use saved time, but ensure it matches the level calculation
            const expectedTime = (restoreLevel - 1) * adjustedTimePerLevel;
            // If saved time is close to expected (within 5 seconds), use it, otherwise recalculate
            if (Math.abs(savedState.time - expectedTime) < 5) {
                this.time = savedState.time;
            } else {
                this.time = expectedTime;
            }
        } else {
            this.time = (restoreLevel - 1) * adjustedTimePerLevel; // Correct formula: (level - 1) * adjustedTimePerLevel
        }
        
        // Update equipment stats based on restored items
        // This must happen AFTER restoring playerStats to ensure health is set correctly
        const ship = this.equipmentStats.ships[this.currentShip];
        if (ship) {
            // Update maxHealth from ship, but preserve saved health if it's valid
            const savedHealth = this.playerStats.health;
            this.playerStats.maxHealth = ship.health;
            // Restore health: use saved health if valid, otherwise use ship's max health
            // Cap at maxHealth to ensure health doesn't exceed ship's capacity
            // Ensure health is at least 1 (shouldn't be 0 in a saved state, but safety check)
            this.playerStats.health = Math.max(1, Math.min(Math.max(savedHealth, 0), ship.health));
            
            // Preserve speed upgrades when updating base speed
            const speedUpgrades = this.playerStats.speed - this.playerStats.baseSpeed;
            this.playerStats.baseSpeed = ship.speed;
            this.playerStats.speed = ship.speed + speedUpgrades;
            this.player.size = ship.size;
        }
        
        const shield = this.equipmentStats.shields[this.currentShield];
        if (shield) {
            this.updateShieldStats(); // Use helper function to apply shield bonuses
        } else {
            this.playerStats.maxShield = 0;
            this.playerStats.shield = 0;
        }
        
        // Clear all game entities
        this.targets = [];
        this.pairs = [];
        this.obstacles = [];
        this.enemyShips = [];
        this.enemyBullets = [];
        this.bullets = [];
        this.items = [];
        this.particles = [];
        
        // Reset spawn timers
        // Adjusted spawn rates for better balance, especially levels 1-5
        if (this.level <= 5) {
            // Slower target spawning: 3-3.5 seconds (was 1.5-2 seconds)
            // Faster obstacle spawning: 2-2.5 seconds (was 2.25-3 seconds)
            this.targetSpawnRate = 3500 - (this.level - 1) * 100; // Level 1: 3500ms, Level 5: 3100ms
            this.obstacleSpawnRate = 2500 - (this.level - 1) * 100; // Level 1: 2500ms, Level 5: 2100ms
        } else {
            // Normal scaling for levels 6+
            this.targetSpawnRate = Math.max(500, 2000 - this.level * 100);
            this.obstacleSpawnRate = Math.max(1000, 3000 - this.level * 150);
        }
        this.lastTargetSpawn = 0;
        this.lastObstacleSpawn = 0;
        this.lastEnemySpawn = Date.now();
        
        // Spawn initial targets
        this.spawnInitialTargets();
        
        // Update UI
        this.updateStats();
        this.updateInventoryUI();
        
        // DO NOT save a new state after reverting - keep the old save point
        // The save point only updates when you progress forward (auto-save every 2 levels)
        
        // Resume gameplay
        this.gameState = 'playing';
        this.levelUpState = false;
        this.isPaused = false;
        
        console.log(`Game state loaded! Reverted to level ${this.level} (from level ${deathLevel}). Save feature remains active.`);
        return true;
    }

    shoot() {
        const now = Date.now();
        
        // Dev mode: Infinite ammo bypasses cooldown
        const infiniteAmmo = this.devMode && this.devInfiniteAmmo;
        
        // Separate laser weapons from regular weapons (laser has special behavior)
        // Optimized: Cache weapon separation to avoid repeated filtering
        if (this._weaponsCacheInvalid || !this._cachedRegularWeapons || !this._cachedLaserWeapons) {
            this._cachedRegularWeapons = [];
            this._cachedLaserWeapons = [];
            // If currentWeapons is empty, add basic weapon
            if (this.currentWeapons.length === 0) {
                this.currentWeapons = ['basic'];
            }
            for (let i = 0; i < this.currentWeapons.length; i++) {
                const name = this.currentWeapons[i];
                const weapon = this.equipmentStats.weapons[name];
                if (weapon && weapon.isLaser) {
                    this._cachedLaserWeapons.push(name);
                } else if (weapon) {
                    this._cachedRegularWeapons.push(name);
                }
            }
            this._weaponsCacheInvalid = false;
        }
        const laserWeapons = this._cachedLaserWeapons;
        let regularWeapons = this._cachedRegularWeapons;
        
        // Laser weapons are handled in update() function with deltaTime
        // This function only handles regular weapons
        
        // Handle regular weapons with combined effects
        // If no weapons equipped, use basic weapon (default)
        if (regularWeapons.length === 0) {
            // Use basic weapon as fallback - create a new array to avoid modifying cache
            const basicWeapon = this.equipmentStats.weapons['basic'];
            if (!basicWeapon) {
                console.error('Basic weapon not found in equipmentStats - cannot shoot!');
                return;
            }
            regularWeapons = ['basic'];
        }
        
        // Combine all weapon effects
        const hasRapid = regularWeapons.includes('rapid');
        const hasSpread = regularWeapons.includes('spread');
        const hasAutomatic = regularWeapons.includes('automatic');
        const hasLaser = laserWeapons.length > 0; // Check if laser weapons are equipped
        
        // Calculate combined fire rate (use highest fire rate from equipped weapons)
        let combinedFireRate = 0;
        let combinedDamage = 0; // Start at 0, will be set by first weapon
        let combinedColor = '#4caf50';
        let spreadCount = 0; // Only > 0 if spread weapon is equipped
        
        // Priority order for weapon colors (crafted weapons take priority over basic)
        // This ensures crafted weapons like rapid keep their distinctive colors
        const weaponColorPriority = ['rapid', 'spread', 'laser', 'automatic', 'basic'];
        let priorityColor = null;
        let priorityIndex = Infinity;
        
        regularWeapons.forEach(weaponName => {
            const weapon = this.equipmentStats.weapons[weaponName];
            if (!weapon) return;
            
            let weaponFireRate = weapon.fireRate;
            let weaponSpread = weapon.spread || 0; // Only spread weapon has this property
            
            // Apply weapon-specific upgrades
            const upgradeLevel = this.weaponUpgrades[weaponName] || 0;
            
            if (weaponName === 'rapid') {
                // Rapid upgrades: each tier offers MORE than the previous tier
                // Tier 1: +0.9, Tier 2: +1.2, Tier 3: +1.5, Tier 4: +1.8
                const rapidBonuses = [0, 0.9, 1.2, 1.5, 1.8]; // Index 0 unused, tiers 1-4
                let totalBonus = 0;
                for (let i = 1; i <= upgradeLevel && i <= 4; i++) {
                    totalBonus += rapidBonuses[i];
                }
                weaponFireRate += totalBonus;
            } else if (weaponName === 'spread') {
                // Spread upgrades: each tier increases spread count (3→4→5→6→7)
                weaponSpread = (weapon.spread || 3) + upgradeLevel;
            }
            // Auto upgrades handled separately (omnidirectional only)
            
            if (weaponFireRate > combinedFireRate) {
                combinedFireRate = weaponFireRate;
            }
            // Combine weapon damage - weapons work together to increase damage
            // This allows players to combine weapons for more powerful shots
            combinedDamage += weapon.damage;
            // Only set spreadCount if this weapon actually has spread property AND is the spread weapon
            // This prevents accidental spread from other weapons
            if (weaponName === 'spread' && weaponSpread > spreadCount) {
                spreadCount = weaponSpread;
            }
            
            // Prioritize weapon colors: crafted weapons (rapid, spread, etc.) take priority over basic
            const colorIndex = weaponColorPriority.indexOf(weaponName);
            if (colorIndex >= 0 && colorIndex < priorityIndex && weapon.color) {
                priorityColor = weapon.color;
                priorityIndex = colorIndex;
            }
        });
        
        // Use priority color if found, otherwise use last weapon's color as fallback
        if (priorityColor) {
            combinedColor = priorityColor;
        }
        
        // Safety check: If no weapons processed, use default damage
        if (combinedDamage === 0 && regularWeapons.length > 0) {
            // Fallback to basic weapon damage if something went wrong
            combinedDamage = 10;
        }
        
        // Final safety: Ensure spreadCount is 0 if spread weapon is not equipped
        if (!hasSpread || !regularWeapons.includes('spread')) {
            spreadCount = 0;
        }
        
        // Apply global fire rate upgrades from shop
        combinedFireRate += (this.playerStats.fireRate - this.playerStats.baseFireRate);
        
        // Apply upgrade bonuses
        if (this.currentUpgrades.includes('completeDescriptionMatrix')) {
            combinedFireRate *= 1.3; // +30% fire rate
            combinedDamage *= 1.5; // +50% damage
        }
        if (this.currentUpgrades.includes('individualSystemAmplifier')) {
            combinedFireRate *= 1.75; // +75% fire rate
            combinedDamage *= 1.75; // +75% damage
        }
        
        // Apply rapid ship bonus - rapidFire increases fire rate by 20%
        const ship = this.equipmentStats.ships[this.currentShip];
        if (ship && ship.bonus === 'rapidFire') {
            combinedFireRate *= 1.2; // +20% fire rate bonus
        }
        
        const cooldown = 1000 / combinedFireRate;
        
        // Check for Individual System Core (needed for automatic firing check and special behavior)
        const hasIndividualSystemCore = regularWeapons.includes('individualSystemCore');
        const isIndividualSystemCoreAlone = hasIndividualSystemCore && regularWeapons.length === 1;
        
        // Track last shot for combined weapons
        if (!this.player.lastShotByWeapon) {
            this.player.lastShotByWeapon = {};
        }
        const lastShot = this.player.lastShotByWeapon['combined'] || 0;
        
        // For automatic weapons (automatic weapon or individual system core), check if mouse is held down
        // Individual System Core is automatic (fires continuously when mouse is held)
        if ((hasAutomatic || hasIndividualSystemCore) && !this.mouseDown) {
            return;
        }
        
        // Individual System Core special behavior: Check omnidirectional state
        // (State is tracked in update() function where deltaTime is available)
        let individualSystemCoreOmnidirectionalActive = false;
        
        if (hasIndividualSystemCore) {
            // Initialize state if needed
            if (this.individualSystemCoreOmniState === undefined) {
                this.individualSystemCoreOmniState = 'ready'; // 'ready', 'active', 'cooldown'
            }
            
            // Check if currently in omnidirectional burst mode
            if (this.individualSystemCoreOmniState === 'active') {
                individualSystemCoreOmnidirectionalActive = true;
            }
        }
        
        // Dev mode: Infinite ammo bypasses cooldown
        if (!infiniteAmmo && now - lastShot < cooldown) return;
        this.player.lastShotByWeapon['combined'] = now;

        // Determine shooting directions
        let angles = [];
        
        // Check for omnidirectional weapons:
        // 1. Automatic weapon with tier 1 upgrade (omnidirectional upgrade)
        // 2. Individual System Core: omnidirectional only during active burst state (whether alone or stacked)
        const autoUpgradeLevel = this.weaponUpgrades['automatic'] || 0;
        const hasAutomaticOmnidirectional = hasAutomatic && autoUpgradeLevel >= 1;
        
        // Individual System Core behavior:
        // - Always respects cooldown system (whether alone or stacked)
        // - Regular shots when not in active burst mode
        // - Omnidirectional only during active burst state
        let hasOmnidirectional = false;
        if (hasAutomaticOmnidirectional) {
            hasOmnidirectional = true;
        } else if (hasIndividualSystemCore && individualSystemCoreOmnidirectionalActive) {
            // Individual System Core: omnidirectional only during active burst (applies to both alone and stacked)
            hasOmnidirectional = true;
        }
        
        if (hasOmnidirectional) {
            // Omnidirectional: shoot in 8 directions
            for (let i = 0; i < 8; i++) {
                angles.push((Math.PI * 2 * i) / 8);
            }
        } else {
            // Normal: shoot toward mouse (Individual System Core alone fires regular shots when not in burst)
            const dx = this.mouse.x - this.player.x;
            const dy = this.mouse.y - this.player.y;
            const angle = Math.atan2(dy, dx);
            angles = [angle];
        }
        
        // Fire in all directions
        // CRITICAL: Only use spread if spread weapon is actually equipped AND spreadCount > 0
        // This prevents accidental spread shots when only basic weapon is equipped
        const shouldUseSpread = hasSpread && spreadCount > 0 && regularWeapons.includes('spread');
        
        // OPTIMIZATION: Reduce spread count when omnidirectional is active to prevent bullet spam
        // Omnidirectional (8 directions) + full spread (7 bullets) = 56 bullets per shot = too many!
        // Reduce spread to 3-4 bullets when omnidirectional is active
        let effectiveSpreadCount = spreadCount;
        if (hasOmnidirectional && shouldUseSpread) {
            // When omnidirectional, reduce spread to prevent performance issues
            // Max 4 bullets per direction = 32 bullets total (still powerful but manageable)
            effectiveSpreadCount = Math.min(4, spreadCount);
        }
        
        // OPTIMIZATION: Adaptive bullet limit - lower for late game to prevent crashes
        // Level 75+ with stacked weapons: 100 bullets max
        // Level 50+: 120 bullets max
        // Otherwise: 150 bullets max
        const level = this.level || 1;
        const weaponCount = (this.currentWeapons && this.currentWeapons.length) || 0;
        const hasHighTierWeapons = this.currentWeapons && this.currentWeapons.some(w => 
            ['transformationPredictor', 'deterministicEngine', 'individualSystemCore'].includes(w)
        );
        
        // More aggressive limits for level 75+ to prevent freezes
        let MAX_BULLETS = 150; // Default
        if (level >= 75 && weaponCount >= 3 && hasHighTierWeapons) {
            MAX_BULLETS = 80; // Very aggressive for end-game stacked high-tier (was 100)
        } else if (level >= 75 && weaponCount >= 3) {
            MAX_BULLETS = 90; // Aggressive for end-game stacked (was 110)
        } else if (level >= 75) {
            MAX_BULLETS = 100; // Aggressive for level 75+ (was 130)
        } else if (level >= 50 && weaponCount >= 3) {
            MAX_BULLETS = 110; // Moderate for late game stacked (was 120)
        } else if (level >= 50) {
            MAX_BULLETS = 120; // Moderate for late game (was 130)
        }
        const currentBulletCount = this.bullets.length;
        const bulletsToCreate = hasOmnidirectional 
            ? (shouldUseSpread ? angles.length * effectiveSpreadCount : angles.length)
            : (shouldUseSpread ? effectiveSpreadCount : 1);
        
        // If adding these bullets would exceed limit, skip creating them
        // Also add safety margin: don't create if we're within 10 bullets of the limit
        const safetyMargin = 10;
        if (currentBulletCount + bulletsToCreate > MAX_BULLETS - safetyMargin) {
            // Don't create bullets if we're at or near the limit
            return;
        }
        
        // Additional safety: If current bullet count is already way over limit, don't create more
        if (currentBulletCount > MAX_BULLETS * 1.2) {
            return; // Emergency: too many bullets already
        }
        
        // Play shoot sound effect
        if (hasLaser) {
            this.audio.playSFX('laser', 0.8);
        } else {
            this.audio.playSFX('shoot', 0.6 + Math.random() * 0.2); // Slight pitch variation
        }
        
        // Determine weapon combination for bullet visuals
        // If multiple weapons, create combo identifier
        let weaponCombo = 'single';
        let primaryWeaponName = regularWeapons.length > 0 ? regularWeapons[0] : 'basic';
        
        if (regularWeapons.length >= 2) {
            // Multiple weapons equipped - create combo
            const sortedWeapons = [...regularWeapons].sort(); // Sort for consistent combo names
            weaponCombo = sortedWeapons.join('+'); // e.g., "rapid+spread", "basic+rapid"
            primaryWeaponName = weaponCombo; // Use combo name for visuals
        } else {
            primaryWeaponName = regularWeapons.length > 0 ? regularWeapons[0] : 'basic';
        }
        
        angles.forEach(baseAngle => {
            if (shouldUseSpread) {
                // Spread shot in this direction (using reduced count if omnidirectional)
                for (let i = 0; i < effectiveSpreadCount; i++) {
                    const spreadAngle = baseAngle + (i - effectiveSpreadCount / 2) * 0.2;
                    this.createBullet(spreadAngle, { damage: combinedDamage, color: combinedColor, weaponName: primaryWeaponName });
                }
            } else {
                // Single shot in this direction
                this.createBullet(baseAngle, { damage: combinedDamage, color: combinedColor, weaponName: primaryWeaponName });
            }
        });
        
        // Track shots fired for use-based decay (balanced decay based on shots, not time like auto)
        regularWeapons.forEach(weaponName => {
            if (!this.weaponShotsFired[weaponName]) {
                this.weaponShotsFired[weaponName] = 0;
            }
            // Increment shot count (balanced: each shot reduces durability slightly)
            this.weaponShotsFired[weaponName]++;
            
            // Apply use-based decay: every X shots = 1% durability loss (balanced)
            // Different weapons have different decay rates
            // Spread decays faster to make it more challenging (fires multiple shots per trigger)
            const shotsPerPercent = weaponName === 'rapid' ? 60 : // Rapid: 60 shots = 1% decay
                                   weaponName === 'spread' ? 35 : // Spread: 35 shots = 1% decay (faster decay - more challenging)
                                   weaponName === 'laser' ? 40 : // Laser: 40 shots = 1% decay (more powerful = more decay)
                                   weaponName === 'automatic' ? 70 : // Automatic: 70 shots = 1% decay (fast firing)
                                   50; // Default: 50 shots = 1% decay
            
            if (this.weaponShotsFired[weaponName] >= shotsPerPercent) {
                // Apply 1% durability decay
                const item = this.ownedItems.weapons[weaponName];
                if (item && typeof item === 'object' && item.durability !== undefined) {
                    if (this.currentWeapons.includes(weaponName)) {
                        item.durability = Math.max(0, item.durability - 1);
                        
                        // If durability reaches 0, item breaks
                        if (item.durability <= 0 && item.count > 0) {
                            item.count--;
                            if (item.count > 0) {
                                item.durability = 100;
                            } else {
                                delete this.ownedItems.weapons[weaponName];
                                if (this.currentWeapons.includes(weaponName)) {
                                    this.unequip('weapons', weaponName);
                                }
                            }
                        }
                    }
                }
                // Reset shot counter
                this.weaponShotsFired[weaponName] = 0;
            }
        });
    }

    createBullet(angle, weapon) {
        // OPTIMIZATION: Adaptive bullet limit - same logic as in shoot()
        const level = this.level || 1;
        const weaponCount = (this.currentWeapons && this.currentWeapons.length) || 0;
        const hasHighTierWeapons = this.currentWeapons && this.currentWeapons.some(w => 
            ['transformationPredictor', 'deterministicEngine', 'individualSystemCore'].includes(w)
        );
        // More aggressive limits for level 75+ to prevent freezes
        let MAX_BULLETS = 150;
        if (level >= 75 && weaponCount >= 3 && hasHighTierWeapons) {
            MAX_BULLETS = 80; // Very aggressive for end-game stacked high-tier
        } else if (level >= 75 && weaponCount >= 3) {
            MAX_BULLETS = 90; // Aggressive for end-game stacked
        } else if (level >= 75) {
            MAX_BULLETS = 100; // Aggressive for level 75+
        } else if (level >= 50 && weaponCount >= 3) {
            MAX_BULLETS = 110; // Moderate for late game stacked
        } else if (level >= 50) {
            MAX_BULLETS = 120; // Moderate for late game
        }
        if (this.bullets.length >= MAX_BULLETS) {
            return; // Skip creating this bullet
        }
        
        if (this.mode === 'ensemble') {
            // Much more random uncertainty - can go in almost any direction, sometimes opposite
            const uncertainty = 2.0; // Large uncertainty (about 115 degrees)
            angle += (Math.random() - 0.5) * uncertainty;
            
            // 15% chance to shoot in completely opposite direction (quantum weirdness!)
            if (Math.random() < 0.15) {
                angle += Math.PI; // Add 180 degrees (opposite direction)
            }
        }
        
        // Bullet colors must be distinct from game entities (blue/cyan targets, pairs, player ship)
        // Use bright, contrasting colors: yellow, white, magenta, orange
        let photonColor = '#ffff00'; // Default: bright yellow (highly visible)
        
        // CRITICAL: If weapon has a color property, use it (crafted weapons have specific colors)
        // Only fall back to damage-based coloring if no color is specified
        if (weapon.color) {
            photonColor = weapon.color;
        } else {
            // Fallback: Color based on damage/energy, but avoid blue/cyan to contrast with game entities
            // Add base damage from upgrades to weapon damage
            const baseDamage = this.playerStats.damage - this.playerStats.baseDamage;
            let damage = (weapon.damage || 10) + baseDamage;
            
            // Apply boost damage multiplier (if boost is active)
            if (this.boostActive) {
                damage *= this.boostDamageMultiplier; // 1.3x damage during boost
            }
            
            if (damage >= 20) {
                photonColor = '#ff00ff'; // High energy - bright magenta/pink (very visible)
            } else if (damage >= 15) {
                photonColor = '#ffff00'; // Medium-high energy - bright yellow (highly visible)
            } else if (damage >= 10) {
                photonColor = '#ffffff'; // Medium energy - white (stands out against dark background)
            } else {
                photonColor = '#ff6600'; // Lower energy - bright orange (distinct from blue)
            }
        }
        
        // Add base damage from upgrades to weapon damage (still needed for damage calculation)
        const baseDamage = this.playerStats.damage - this.playerStats.baseDamage;
        let damage = (weapon.damage || 10) + baseDamage;
        
        // Apply boost damage multiplier if boost is active (applies to all enemy types)
        if (this.boostActive) {
            damage *= this.boostDamageMultiplier; // 1.3x damage during boost
        }
        
        // Apply projectile speed bonus from upgrades
        const baseSpeed = 500;
        const speedMultiplier = 1 + (this.playerStats.projectileSpeed / 100);
        const bulletSpeed = baseSpeed * speedMultiplier;
        
        // Get weapon name from weapon object or default to 'basic'
        const weaponName = weapon.weaponName || 'basic';
        
        // Individual System Core bullets should be smaller (reduce size by 25%)
        let bulletSize = 4 + Math.floor(damage / 5); // Larger photons for higher energy
        if (weaponName === 'individualSystemCore') {
            bulletSize = Math.floor(bulletSize * 0.75); // Reduce Individual System Core bullet size by 25%
        }
        
        // OPTIMIZATION: Object pooling - reuse bullet objects instead of creating new ones
        let bullet = this._bulletPool.pop();
        if (!bullet) {
            // Pool empty - create new bullet object
            bullet = {};
        }
        
        // Set bullet properties (reuse existing object)
        bullet.x = this.player.x;
        bullet.y = this.player.y;
        bullet.vx = Math.cos(angle) * bulletSpeed;
        bullet.vy = Math.sin(angle) * bulletSpeed;
        bullet.color = photonColor;
        bullet.size = bulletSize;
        bullet.damage = damage;
        bullet.lifetime = 2;
        bullet.energy = damage; // Store energy level for visual effects
        bullet.weaponName = weaponName; // Store weapon name for enhanced visuals
        
        this.bullets.push(bullet);
    }

    // Helper functions to get item count and durability from the new structure
    getItemCount(type, name) {
        const item = this.ownedItems[type] && this.ownedItems[type][name];
        if (!item) return 0;
        // Handle both old format (number) and new format (object with count)
        if (typeof item === 'number') return item;
        if (typeof item === 'object' && item.count !== undefined) return item.count;
        return 0;
    }
    
    getItemDurability(type, name) {
        const item = this.ownedItems[type] && this.ownedItems[type][name];
        if (!item) return 0;
        // Handle both old format (number) and new format (object with durability)
        if (typeof item === 'number') return 100; // Old format assumed full durability
        if (typeof item === 'object' && item.durability !== undefined) return item.durability;
        return 0;
    }
    
    setItemCount(type, name, count) {
        if (!this.ownedItems[type]) this.ownedItems[type] = {};
        const item = this.ownedItems[type][name];
        if (typeof item === 'object' && item.durability !== undefined) {
            // New format: update count
            item.count = count;
            if (count <= 0) {
                delete this.ownedItems[type][name];
            }
        } else {
            // Old format or new item: create new structure
            if (count > 0) {
                this.ownedItems[type][name] = { count: count, durability: 100 };
            } else {
                delete this.ownedItems[type][name];
            }
        }
    }
    
    setItemDurability(type, name, durability) {
        if (!this.ownedItems[type]) this.ownedItems[type] = {};
        const item = this.ownedItems[type][name];
        if (typeof item === 'object' && item.durability !== undefined) {
            // New format: update durability
            item.durability = Math.max(0, Math.min(100, durability));
        } else if (typeof item === 'number') {
            // Old format: convert to new format
            this.ownedItems[type][name] = { count: item, durability: Math.max(0, Math.min(100, durability)) };
        } else {
            // New item: create with full durability
            this.ownedItems[type][name] = { count: 1, durability: Math.max(0, Math.min(100, durability)) };
        }
    }
    
    applyRealTimeDecay(deltaTime) {
        // Real-time decay based on time and use (continuous during gameplay)
        // Base time-based decay rate (very slow - most decay comes from use and damage)
        const timeDecayRate = (0.01 + (this.level * 0.0001)) * deltaTime; // 1% per 100 seconds at level 1, scales with level
        
        // Decay weapons (only if equipped) - use-based decay from shooting is handled in shoot()
        // Time-based decay is minimal since use-based decay handles most of it
        for (let weapon in this.ownedItems.weapons) {
            const item = this.ownedItems.weapons[weapon];
            if (typeof item === 'object' && item.durability !== undefined) {
                if (this.currentWeapons.includes(weapon)) {
                    // Very slow time-based decay (use-based decay from shooting is the main source)
                    const weaponTimeDecay = timeDecayRate * 0.1; // 10% of normal time decay
                    item.durability = Math.max(0, item.durability - (100 * weaponTimeDecay));
                    
                    // Check if item broke
                    if (item.durability <= 0 && item.count > 0) {
                        item.count--;
                        if (item.count > 0) {
                            item.durability = 100;
                        } else {
                            delete this.ownedItems.weapons[weapon];
                            if (this.currentWeapons.includes(weapon)) {
                                this.unequip('weapons', weapon);
                            }
                        }
                    }
                }
            }
        }
        
        // Decay hammer (only if equipped) - use-based decay from repairing is handled in useHammer()
        if (this.ownedItems.tools && this.ownedItems.tools.hammer) {
            const hammer = this.ownedItems.tools.hammer;
            if (typeof hammer === 'object' && hammer.durability !== undefined) {
                if (this.hammerEquipped) {
                    // Slow time-based decay (use-based decay from repairing is the main source)
                    const hammerTimeDecay = timeDecayRate * 0.2; // 20% of normal time decay
                    hammer.durability = Math.max(0, hammer.durability - (100 * hammerTimeDecay));
                    
                    if (hammer.durability <= 0 && hammer.count > 0) {
                        hammer.count--;
                        if (hammer.count > 0) {
                            hammer.durability = 100;
                        } else {
                            delete this.ownedItems.tools.hammer;
                            this.hammerEquipped = false;
                        }
                    }
                }
            }
        }
        
        // Decay ships (only if equipped) - damage-based decay is handled in applyDamageDecay()
        // Time-based decay is minimal since damage-based decay handles most of it
        for (let ship in this.ownedItems.ships) {
            const item = this.ownedItems.ships[ship];
            if (typeof item === 'object' && item.durability !== undefined) {
                if (this.currentShip === ship) {
                    // Very slow time-based decay (damage-based decay is the main source)
                    const shipTimeDecay = timeDecayRate * 0.15; // 15% of normal time decay
                    item.durability = Math.max(0, item.durability - (100 * shipTimeDecay));
                    
                    if (item.durability <= 0 && item.count > 0) {
                        item.count--;
                        if (item.count > 0) {
                            item.durability = 100;
                        } else {
                            // Prevent deleting basic ship - player must always have a ship
                            if (ship === 'basic') {
                                // Keep basic ship but reset durability to 1% (critical condition)
                                item.count = 1;
                                item.durability = 1;
                                console.warn('[Ship] Basic ship reached 0 durability - kept at 1% (cannot delete basic ship)');
                            } else {
                                delete this.ownedItems.ships[ship];
                                if (this.currentShip === ship) {
                                    this.unequip('ships');
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Decay shields (only if equipped) - damage-based decay is handled in applyDamageDecay()
        // Time-based decay is minimal since damage-based decay handles most of it
        for (let shield in this.ownedItems.shields) {
            const item = this.ownedItems.shields[shield];
            if (typeof item === 'object' && item.durability !== undefined) {
                if (this.currentShield === shield) {
                    // Very slow time-based decay (damage-based decay is the main source)
                    const shieldTimeDecay = timeDecayRate * 0.15; // 15% of normal time decay
                    item.durability = Math.max(0, item.durability - (100 * shieldTimeDecay));
                    
                    if (item.durability <= 0 && item.count > 0) {
                        item.count--;
                        if (item.count > 0) {
                            item.durability = 100;
                        } else {
                            delete this.ownedItems.shields[shield];
                            if (this.currentShield === shield) {
                                this.unequip('shields');
                            }
                        }
                    }
                }
            }
        }
        
        // Decay upgrades (only if equipped, slower decay for upgrades)
        for (let upgrade in this.ownedItems.upgrades) {
            const item = this.ownedItems.upgrades[upgrade];
            if (typeof item === 'object' && item.durability !== undefined) {
                if (this.currentUpgrades.includes(upgrade)) {
                    // Upgrades decay slower (50% of normal rate)
                    const upgradeTimeDecay = timeDecayRate * 0.5;
                    item.durability = Math.max(0, item.durability - (100 * upgradeTimeDecay));
                    
                    if (item.durability <= 0 && item.count > 0) {
                        item.count--;
                        if (item.count > 0) {
                            item.durability = 100;
                        } else {
                            delete this.ownedItems.upgrades[upgrade];
                            if (this.currentUpgrades.includes(upgrade)) {
                                this.unequip('upgrades', upgrade);
                            }
                        }
                    }
                }
            }
        }
        
        // Update UI periodically to show real-time durability changes
        // Optimized: Update every 1 second instead of 0.5 to reduce DOM operations
        if (!this.lastUIUpdate) this.lastUIUpdate = 0;
        this.lastUIUpdate += deltaTime;
        if (this.lastUIUpdate >= 1.0) {
            this.updateInventoryUI();
            this.lastUIUpdate = 0;
        }
    }
    
    applyDamageDecay(type, name, damageAmount) {
        // Apply durability decay based on damage taken (real-time)
        // Ships and shields lose durability when they take damage
        if (!this.ownedItems[type] || !this.ownedItems[type][name]) {
            return;
        }
        
        const item = this.ownedItems[type][name];
        if (typeof item !== 'object' || !item.durability) {
            return;
        }
        
        // Calculate durability loss based on damage
        // Formula: 1% durability loss per 10 damage (balanced)
        // Higher level = more damage = more decay
        const durabilityLoss = (damageAmount / 10) * (1 + this.level * 0.01); // Scales with level
        
        // Apply decay
        item.durability = Math.max(0, item.durability - durabilityLoss);
        
        // Check if item broke
        if (item.durability <= 0 && item.count > 0) {
            item.count--;
            if (item.count > 0) {
                item.durability = 100;
            } else {
                delete this.ownedItems[type][name];
                
                // Unequip if currently equipped
                if (type === 'ships' && this.currentShip === name) {
                    this.unequip('ships');
                } else if (type === 'shields' && this.currentShield === name) {
                    this.unequip('shields');
                }
            }
        }
        
        // Update UI immediately to show real-time durability changes from damage
        this.updateInventoryUI();
    }
    
    dropItem(x, y, type) {
        // ALWAYS drop a visible material item (no random chance)
        // Mode-specific material drops - encourages switching modes
        let itemType;
        const rand = Math.random();
        
        if (this.mode === 'ensemble') {
            // Ensemble mode: quantum particles and crystals
            if (rand < 0.5) {
                itemType = 'quantumParticles';
            } else {
                itemType = 'crystals';
            }
        } else if (this.mode === 'individual') {
            // Individual mode: energy cores and metal scraps
            if (rand < 0.5) {
                itemType = 'energyCores';
            } else {
                itemType = 'metalScraps';
            }
        } else if (this.mode === 'bell') {
            // Bell mode: primarily quantum particles and crystals (less energy cores and metal scraps)
            // This encourages switching to other modes for those materials
            if (rand < 0.5) {
                itemType = 'quantumParticles';
            } else if (rand < 0.85) {
                itemType = 'crystals';
            } else if (rand < 0.95) {
                itemType = 'metalScraps';
            } else {
                itemType = 'energyCores';
            }
        }
        
        // Always create a visible item that must be collected
        // Calculate distance from player at creation time to prevent immediate collection
        // OPTIMIZATION: Use squared distance comparison to avoid sqrt
        const dxFromPlayer = x - this.player.x;
        const dyFromPlayer = y - this.player.y;
        const distFromPlayerSquared = dxFromPlayer * dxFromPlayer + dyFromPlayer * dyFromPlayer;
        const playerRadius = this.player.size || 20;
        const itemRadius = 8;
        const minCollectionDistance = playerRadius + itemRadius + 5; // Must be at least 5 pixels away from touching
        const minCollectionDistanceSquared = minCollectionDistance * minCollectionDistance;
        
        this.items.push({
            x, y,
            type: itemType,
            vx: (Math.random() - 0.5) * 50,
            vy: (Math.random() - 0.5) * 50,
            lifetime: 5,
            collected: false,
            createdTime: this.time, // Track when item was created
            size: 8, // Size for collision detection
            framesSinceCreation: 0, // Track frames since creation - prevents same-frame collection
            createdTooClose: distFromPlayerSquared < minCollectionDistanceSquared // Flag if created too close to player
        });
        
        // Token drops - double in Bell mode, plus token drop rate bonus from upgrades
        const tokenMultiplier = this.mode === 'bell' ? 2 : 1;
        const tokenDropBonus = 1 + (this.playerStats.tokenDropRate / 100);
        const baseTokens = (1 + Math.floor(this.level / 2)) * tokenMultiplier;
        this.inventory.tokens += Math.floor(baseTokens * tokenDropBonus);
    }

    togglePause() {
        this.isPaused = !this.isPaused;
        
        // OPTIMIZATION: Use cached DOM elements
        const ui = this._cachedElements.ui;
        const theoryPanel = this._cachedElements.theoryPanel;
        const instructions = this._cachedElements.instructions;
        // Don't manipulate settingsUI here - it's independent
        
        if (this.isPaused) {
            // Show all panels (except settings - it's independent)
            if (ui) ui.classList.add('paused');
            if (theoryPanel) theoryPanel.classList.add('paused');
            if (instructions) instructions.classList.add('paused');
        } else {
            // Hide all panels (except settings - it's independent)
            if (ui) ui.classList.remove('paused');
            if (theoryPanel) theoryPanel.classList.remove('paused');
            if (instructions) instructions.classList.remove('paused');
            
            // CRITICAL: Reset game loop timing when unpausing to prevent lag
            // This ensures deltaTime doesn't become huge after a long pause
            this.lastTime = performance.now();
            
            // Activate resume smoothing to gradually resume effects/bullets
            // This prevents lag spikes when many objects resume at once
            this.resumeSmoothing.active = true;
            this.resumeSmoothing.framesRemaining = 3;
        }
    }
    
    toggleSettings() {
        // OPTIMIZATION: Use cached DOM element
        const ui = this._cachedElements.settingsUI;
        if (!ui) return;
        
        // Settings is independent of game state - just show/hide the UI
        // Game continues running in the background
        if (ui.classList.contains('active')) {
            // Close settings
            ui.classList.remove('active');
        } else {
            // Open settings
            ui.classList.add('active');
            this.updateSettingsUI();
        }
    }
    
    loadSettings() {
        try {
            const saved = localStorage.getItem('bellGameSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                return {
                    gamepadSensitivity: settings.gamepadSensitivity || 600,
                    showParticles: settings.showParticles !== undefined ? settings.showParticles : true,
                    showExplosions: settings.showExplosions !== undefined ? settings.showExplosions : true,
                    screenShake: settings.screenShake !== undefined ? settings.screenShake : true
                };
            }
        } catch (e) {
            console.error('Error loading settings:', e);
        }
        // Default settings
        return {
            gamepadSensitivity: 600,
            showParticles: true,
            showExplosions: true,
            screenShake: true
        };
    }
    
    saveSettings() {
        try {
            localStorage.setItem('bellGameSettings', JSON.stringify(this.settings));
        } catch (e) {
            console.error('Error saving settings:', e);
        }
    }
    
    updateSettingsUI() {
        // OPTIMIZATION: Use cached DOM elements
        const sensitivitySlider = this._cachedElements.sensitivitySlider;
        const sensitivityValue = this._cachedElements.sensitivityValue;
        const fullscreenToggle = this._cachedElements.fullscreenToggle;
        const particlesToggle = this._cachedElements.particlesToggle;
        const explosionsToggle = this._cachedElements.explosionsToggle;
        const screenShakeToggle = this._cachedElements.screenShakeToggle;
        
        if (sensitivitySlider && sensitivityValue) {
            sensitivitySlider.value = this.settings.gamepadSensitivity;
            sensitivityValue.textContent = this.settings.gamepadSensitivity;
        }
        
        if (fullscreenToggle) {
            fullscreenToggle.checked = this.isFullscreen();
        }
        
        if (particlesToggle) {
            particlesToggle.checked = this.settings.showParticles;
        }
        
        if (explosionsToggle) {
            explosionsToggle.checked = this.settings.showExplosions;
        }
        
        if (screenShakeToggle) {
            screenShakeToggle.checked = this.settings.screenShake;
        }
    }
    
    isFullscreen() {
        return !!(document.fullscreenElement || 
                  document.webkitFullscreenElement || 
                  document.mozFullScreenElement || 
                  document.msFullscreenElement);
    }
    
    toggleFullscreen() {
        if (this.isFullscreen()) {
            // Exit fullscreen
            this.forceFullscreen = false; // Allow exit
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        } else {
            // Enter fullscreen
            this.forceFullscreen = true; // Set flag to prevent ESC from exiting
            const element = document.documentElement;
            if (element.requestFullscreen) {
                element.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                    this.forceFullscreen = false;
                });
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        }
    }
    
    updateSetting(setting, value) {
        this.settings[setting] = value;
        this.saveSettings();
        this.updateSettingsUI();
    }
    
    togglePanel(panelName) {
        this.panelsVisible[panelName] = !this.panelsVisible[panelName];
        let panelId;
        if (panelName === 'ui') {
            panelId = 'ui';
        } else if (panelName === 'theory') {
            panelId = 'theoryPanel';
        } else if (panelName === 'instructions') {
            panelId = 'instructions';
        }
        
        const panel = document.getElementById(panelId);
        if (panel) {
            if (this.panelsVisible[panelName]) {
                panel.style.display = 'block';
                panel.classList.remove('hidden');
            } else {
                panel.classList.add('hidden');
            }
        }
    }

    update(deltaTime) {
        // Update cutscene if active - DON'T update time or level during cutscenes
        if (this.gameState === 'cutscene') {
            this.updateCutscene(deltaTime);
            return; // Early return prevents time/level updates
        }
        
        // Update gamepad input (always check, even when paused)
        // Pass deltaTime so gamepad can use it for smooth cursor movement
        this.updateGamepad(deltaTime);
        
        // Update menu navigation cooldown
        if (this.menuNavigationCooldown > 0) {
            this.menuNavigationCooldown -= deltaTime;
        }
        
        // Don't update game if paused
        if (this.isPaused && this.gameState === 'playing') {
            return;
        }
        // Don't update during level-up or if not playing
        if (this.gameState === 'levelup' || this.levelUpState) {
            return;
        }
        if (this.gameState !== 'playing') return;
        
        // Update survival system (hunger decay, boost duration, etc.)
        if (this.survivalUnlocked) {
            this.updateSurvivalSystem(deltaTime);
        }
        
        
        // Optimized: Batch updateStats calls - only update once per frame at the end
        this._statsNeedsUpdate = false;
        
        // Handle laser weapons (continuous beam, not affected by other weapons)
        // Optimized: Cache laser weapons check instead of filtering every frame
        if (this._weaponsCacheInvalid || !this._cachedLaserWeapons || !this._cachedRegularWeapons) {
            this._cachedRegularWeapons = [];
            this._cachedLaserWeapons = [];
            for (let i = 0; i < this.currentWeapons.length; i++) {
                const name = this.currentWeapons[i];
                const weapon = this.equipmentStats.weapons[name];
                if (weapon && weapon.isLaser) {
                    this._cachedLaserWeapons.push(name);
                } else if (weapon) {
                    this._cachedRegularWeapons.push(name);
                }
            }
            this._weaponsCacheInvalid = false;
        }
        const laserWeapons = this._cachedLaserWeapons;
        
        if (laserWeapons.length > 0) {
            const weapon = this.equipmentStats.weapons[laserWeapons[0]]; // Use first laser weapon
            if (weapon) {
                // Apply laser weapon upgrades (each tier offers MORE than the previous tier)
                const laserUpgradeLevel = this.weaponUpgrades['laser'] || 0;
                // Tier 1: +0.8s/+8, Tier 2: +1.0s/+10, Tier 3: +1.3s/+13, Tier 4: +1.6s/+16
                const laserDurationBonuses = [0, 0.8, 1.0, 1.3, 1.6];
                const laserDamageBonuses = [0, 8, 10, 13, 16];
                let durationBonus = 0;
                let damageBonus = 0;
                for (let i = 1; i <= laserUpgradeLevel && i <= 4; i++) {
                    durationBonus += laserDurationBonuses[i];
                    damageBonus += laserDamageBonuses[i];
                }
                const adjustedDuration = weapon.beamDuration + durationBonus;
                // Add base damage from upgrades to laser damage
                const baseDamage = this.playerStats.damage - this.playerStats.baseDamage;
                const adjustedDamage = weapon.damage + damageBonus + baseDamage;
                
                // Apply global fire rate upgrades to laser (reduces cooldown)
                const fireRateBonus = this.playerStats.fireRate - this.playerStats.baseFireRate;
                const cooldownReduction = fireRateBonus * 0.1; // Each 0.1 fire rate = 0.1s less cooldown
                const adjustedCooldown = Math.max(0.5, weapon.beamCooldown - cooldownReduction); // Min 0.5s cooldown
                
                // Update laser cooldown
                if (this.player.laserCooldown > 0) {
                    this.player.laserCooldown = Math.max(0, this.player.laserCooldown - deltaTime);
                }
                
                // Start laser if mouse is down and not on cooldown
                if (this.mouseDown && !this.player.laserActive && this.player.laserCooldown <= 0) {
                    this.player.laserActive = true;
                    this.player.laserCharge = adjustedDuration; // Start with full charge (upgraded duration)
                }
                
                // Update laser if active
                if (this.player.laserActive) {
                    this.player.laserCharge -= deltaTime;
                    
                    if (this.player.laserCharge <= 0 || !this.mouseDown) {
                        // Laser depleted or mouse released - start cooldown (upgraded cooldown)
                        this.player.laserActive = false;
                        this.player.laserCharge = 0;
                        this.player.laserCooldown = adjustedCooldown;
                        this.activeLaser = null;
                    } else {
                        // Create/update laser beam
                        const dx = this.mouse.x - this.player.x;
                        const dy = this.mouse.y - this.player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx);
                        
                        // Calculate beam end point (extend to edge of screen or max distance)
                        const maxBeamLength = Math.max(this.canvas.width, this.canvas.height);
                        const beamLength = Math.min(distance, maxBeamLength);
                        
                        this.activeLaser = {
                            x1: this.player.x,
                            y1: this.player.y,
                            x2: this.player.x + Math.cos(angle) * beamLength,
                            y2: this.player.y + Math.sin(angle) * beamLength,
                            angle: angle,
                            damage: adjustedDamage, // Use upgraded damage
                            color: weapon.color,
                            width: 8,
                            charge: this.player.laserCharge / adjustedDuration
                        };
                        
                        // Laser beam deals continuous damage to entities it touches
                        this.updateLaserBeam(deltaTime);
                    }
                }
            }
        }
        
        // Track use time for omnidirectional upgrade (ONLY the upgrade, not the weapon)
        // Omnidirectional upgrade (automatic weapon tier 1) breaks after 10 seconds of total cumulative use
        // When it breaks, the automatic weapon remains but loses omnidirectional shooting
        // All other weapons decay normally on level-up only
        if (this.gameState === 'playing' && this.mouseDown) {
            // Check if automatic weapon has omnidirectional upgrade (tier 1)
            const autoUpgradeLevel = this.weaponUpgrades['automatic'] || 0;
            const hasOmnidirectional = this.currentWeapons.includes('automatic') && autoUpgradeLevel >= 1;
            
            // Only track use time for omnidirectional upgrade
            if (hasOmnidirectional) {
                if (!this.weaponUseTime['omnidirectional']) {
                    this.weaponUseTime['omnidirectional'] = 0;
                }
                // Increment use time (cumulative across all uses)
                this.weaponUseTime['omnidirectional'] += deltaTime;
                
                // Check if omnidirectional has been used for 10 seconds total
                if (this.weaponUseTime['omnidirectional'] >= 10.0) {
                    // Omnidirectional upgrade breaks - remove the upgrade tier (set back to 0)
                    // The automatic weapon itself remains intact
                    this.weaponUpgrades['automatic'] = 0;
                    this.weaponUseTime['omnidirectional'] = 0; // Reset use time
                    
                    // Update UI to reflect the loss of omnidirectional upgrade
                    this.updateInventoryUI();
                    this.updateCraftingUI();
                }
            }
        }
        
        // Track Individual System Core omnidirectional burst state
        // Individual System Core has periodic omnidirectional bursts with cooldown (whether alone or stacked)
        const hasIndividualSystemCore = this.currentWeapons.includes('individualSystemCore');
        
        if (hasIndividualSystemCore && this.gameState === 'playing') {
            // Initialize tracking if needed
            if (!this.weaponUseTime['individualSystemCoreOmni']) {
                this.weaponUseTime['individualSystemCoreOmni'] = 0; // Time spent in omnidirectional mode
            }
            if (!this.weaponUseTime['individualSystemCoreOmniCooldown']) {
                this.weaponUseTime['individualSystemCoreOmniCooldown'] = 0; // Cooldown timer
            }
            if (this.individualSystemCoreOmniState === undefined) {
                this.individualSystemCoreOmniState = 'ready'; // 'ready', 'active', 'cooldown'
            }
            
            // State machine for Individual System Core omnidirectional bursts
            if (this.individualSystemCoreOmniState === 'ready' && this.mouseDown) {
                // Start omnidirectional burst (5 seconds duration)
                this.individualSystemCoreOmniState = 'active';
                this.weaponUseTime['individualSystemCoreOmni'] = 0;
            } else if (this.individualSystemCoreOmniState === 'active') {
                // Track time in omnidirectional mode
                this.weaponUseTime['individualSystemCoreOmni'] += deltaTime;
                if (this.weaponUseTime['individualSystemCoreOmni'] >= 5.0) {
                    // End omnidirectional burst, enter cooldown (15 seconds)
                    this.individualSystemCoreOmniState = 'cooldown';
                    this.weaponUseTime['individualSystemCoreOmniCooldown'] = 0;
                }
            } else if (this.individualSystemCoreOmniState === 'cooldown') {
                // Track cooldown time
                this.weaponUseTime['individualSystemCoreOmniCooldown'] += deltaTime;
                if (this.weaponUseTime['individualSystemCoreOmniCooldown'] >= 15.0) {
                    // Cooldown complete, ready for next burst
                    this.individualSystemCoreOmniState = 'ready';
                }
            }
        }
        
        // Continuous shooting ONLY for automatic weapons
        // Regular weapons (rapid, spread, etc.) only shoot on click, not continuously
        if (this.mouseDown && this.gameState === 'playing') {
            // Check if any equipped weapon is automatic (and not laser)
            const hasAutomatic = this.currentWeapons.some(weaponName => {
                const weapon = this.equipmentStats.weapons[weaponName];
                return weapon && weapon.automatic && !weapon.isLaser;
            });
            
            // Individual System Core is also automatic (fires continuously)
            const hasIndividualSystemCore = this.currentWeapons.includes('individualSystemCore');
            
            // Only shoot continuously if automatic weapon or Individual System Core is equipped
            // Regular weapons will shoot via click events, not continuous
            if (hasAutomatic || hasIndividualSystemCore) {
                this.shoot();
            }
        } else if (!this.mouseDown && this.player.laserActive) {
            // Stop laser when mouse is released
            this.player.laserActive = false;
            this.activeLaser = null;
        }
        
        this.time += deltaTime;
        
        // Apply real-time decay based on use and time (continuous, not just on level-up)
        this.applyRealTimeDecay(deltaTime);
        
        // Track hidden sequence for save feature unlock (CONTINUOUSLY, not just on level change)
        // Sequence: Bell mode for levels 1-5, Ensemble for 6-8, Individual for 9-10
        if (!this.hiddenSequence.sequenceComplete && !this.hiddenSequence.saveUnlocked) {
            // Record when this level started (for grace period)
            if (!this.hiddenSequence.levelStartTime[this.level]) {
                this.hiddenSequence.levelStartTime[this.level] = this.time;
            }
            
            // Check if we're in the correct mode for the current level
            // Continuously check during gameplay - allows time to switch modes after leveling up
            if (this.level >= 1 && this.level <= 5) {
                // Levels 1-5: Must be in Bell mode
                if (this.mode === 'bell') {
                    this.hiddenSequence.bellLevels.add(this.level);
                }
            } else if (this.level >= 6 && this.level <= 8) {
                // Levels 6-8: Must be in Ensemble mode (and have completed Bell sequence)
                if (this.mode === 'ensemble' && this.hiddenSequence.bellLevels.size >= 5) {
                    this.hiddenSequence.ensembleLevels.add(this.level);
                }
            } else if (this.level >= 9 && this.level <= 10) {
                // Levels 9-10: Must be in Individual mode (and have completed previous sequences)
                if (this.mode === 'individual' && 
                    this.hiddenSequence.bellLevels.size >= 5 && 
                    this.hiddenSequence.ensembleLevels.size >= 3) {
                    this.hiddenSequence.individualLevels.add(this.level);
                }
            }
            
            // Check if sequence is complete (all requirements met)
            if (this.hiddenSequence.bellLevels.size >= 5 && 
                this.hiddenSequence.ensembleLevels.size >= 3 && 
                this.hiddenSequence.individualLevels.size >= 2) {
                this.hiddenSequence.sequenceComplete = true;
                this.hiddenSequence.saveUnlocked = true;
                // Save current game state (for reverting to 2 levels back)
                this.saveGameState();
                
                // Show notification if not already shown
                if (!this.hiddenSequence.notificationShown) {
                    this.showSaveUnlockNotification();
                    this.hiddenSequence.notificationShown = true;
                }
                
                console.log('Save feature unlocked! Press V to revert to 2 levels back.');
            }
        }
        
        // Auto-save game state every 2 levels (if save is unlocked)
        // Only save once per level, when we first reach that level
        if (this.hiddenSequence.saveUnlocked && this.level % 2 === 0) {
            if (!this.hiddenSequence.lastAutoSaveLevel || this.hiddenSequence.lastAutoSaveLevel < this.level) {
                this.saveGameState();
                this.hiddenSequence.lastAutoSaveLevel = this.level;
            }
        }
        
        // Level progression (prevent level progression during boss battles and cutscenes)
        // Note: Cutscenes already return early, but double-check here for safety
        if (!this.bossMode && this.gameState === 'playing') {
            // Apply level time reduction from upgrades (reduces the 30 seconds needed per level)
            const baseTimePerLevel = 30;
            const timeReduction = Math.min(40, Math.max(0, this.playerStats.levelTimeReduction)) / 100; // Clamp between 0-40% to prevent negative values
            const adjustedTimePerLevel = Math.max(10, baseTimePerLevel * (1 - timeReduction)); // Minimum 10 seconds per level to prevent negative/zero values
            const newLevel = Math.floor(this.time / adjustedTimePerLevel) + 1;
            if (newLevel > this.level) {
                const oldLevel = this.level;
                this.level = newLevel;
                
                // Adjusted spawn rates for better balance, especially levels 1-5
                // Levels 1-5: Slower target spawn (more time between particles), faster obstacle spawn (more molecules)
                // This ensures players can reach molecules for food crafting
                if (this.level <= 5) {
                    // Slower target spawning: 3-3.5 seconds (was 1.5-2 seconds)
                    // Faster obstacle spawning: 2-2.5 seconds (was 2.25-3 seconds)
                    this.targetSpawnRate = 3500 - (this.level - 1) * 100; // Level 1: 3500ms, Level 5: 3100ms
                    this.obstacleSpawnRate = 2500 - (this.level - 1) * 100; // Level 1: 2500ms, Level 5: 2100ms
                } else {
                    // Normal scaling for levels 6+
                    this.targetSpawnRate = Math.max(500, 2000 - this.level * 100);
                    this.obstacleSpawnRate = Math.max(1000, 3000 - this.level * 150);
                }
                
                // Check if this is a boss level (every 15 levels: 15, 30, 45, 60, etc.)
                const isBossLevel = this.level % 15 === 0;
                
                if (isBossLevel && !this.bossMode) {
                    // Enter boss mode - combines all three modes
                    this.enterBossMode();
                    // Don't show level-up menu during boss battle - boss must be defeated first
                    return; // Stop updating to prevent level progression
                }
                
                // Reset boss spawn flag when level changes (for old level 150 boss)
                if (this.level !== 150) {
                    this.bossSpawned = false;
                }
                
                // Level up! Use triggerLevelUp to handle cutscenes and level-up menu
                this.triggerLevelUp();
                return; // Stop updating after level-up
            }
        } else {
            // In boss mode - prevent level progression, but still update time for other mechanics
            // Time continues so other game mechanics work, but level is frozen
        }

        // Player movement - use playerStats.speed (includes upgrades)
        const ship = this.equipmentStats.ships[this.currentShip];
        // Safety check: ensure ship exists, fallback to basic if not
        if (!ship) {
            console.warn(`[Ship] Ship '${this.currentShip}' not found, falling back to basic`);
            this.currentShip = 'basic';
            // Ensure basic ship exists in inventory
            if (!this.ownedItems.ships.basic) {
                this.ownedItems.ships.basic = { count: 1, durability: 100 };
            }
            return; // Skip movement this frame, will work next frame
        }
        const shipBaseSpeed = ship.speed;
        let totalSpeed = shipBaseSpeed + (this.playerStats.speed - this.playerStats.baseSpeed);
        
        // Apply ship-specific speed bonuses
        if (ship.bonus === 'speedBoost') {
            totalSpeed *= 1.15; // Fast ship gets 15% speed boost
        }
        
        // Apply upgrade speed bonuses
        if (this.currentUpgrades.includes('ensembleBypass')) {
            totalSpeed *= 1.5; // +50% movement speed
        }
        
        // Apply boost speed multiplier (if boost is active)
        if (this.boostActive) {
            totalSpeed *= this.boostSpeedMultiplier; // 1.5x speed during boost
        }
        if (this.currentUpgrades.includes('individualSystemAmplifier')) {
            totalSpeed *= 1.75; // +75% movement speed (stacks)
        }
        
        // Track movement direction for rotation (normalized direction vector)
        let moveX = 0;
        let moveY = 0;
        let isMoving = false;
        
        // Check for standard movement keys first
        const hasUp = this.keys['KeyW'] || this.keys['ArrowUp'];
        const hasDown = this.keys['KeyS'] || this.keys['ArrowDown'];
        const hasLeft = this.keys['KeyA'] || this.keys['ArrowLeft'];
        const hasRight = this.keys['KeyD'] || this.keys['ArrowRight'];
        
        // Standard movement (WASD or Arrow Keys)
        if (hasUp) {
            moveY -= 1;
            this.player.y -= totalSpeed * deltaTime;
            isMoving = true;
        }
        if (hasDown) {
            moveY += 1;
            this.player.y += totalSpeed * deltaTime;
            isMoving = true;
        }
        if (hasLeft) {
            moveX -= 1;
            this.player.x -= totalSpeed * deltaTime;
            isMoving = true;
        }
        if (hasRight) {
            moveX += 1;
            this.player.x += totalSpeed * deltaTime;
            isMoving = true;
        }
        
        // S key backward movement (only if S is pressed WITHOUT other movement keys and not in shop)
        // This allows backward movement as a separate feature
        if (this.keys['KeyS'] && !hasDown && !hasUp && !hasLeft && !hasRight && this.gameState === 'playing') {
            // Calculate backward direction based on mouse position
            const dx = this.player.x - this.mouse.x;
            const dy = this.player.y - this.mouse.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0) {
                // Normalize direction
                const normX = dx / dist;
                const normY = dy / dist;
                moveX = normX;
                moveY = normY;
                this.player.x += normX * totalSpeed * deltaTime * 0.5;
                this.player.y += normY * totalSpeed * deltaTime * 0.5;
                isMoving = true;
            }
        }
        
        // Normalize movement vector for consistent rotation (handles diagonal movement)
        if (isMoving && (moveX !== 0 || moveY !== 0)) {
            const moveLength = Math.sqrt(moveX * moveX + moveY * moveY);
            if (moveLength > 0) {
                // Normalize to unit vector for consistent angle calculation
                moveX = moveX / moveLength;
                moveY = moveY / moveLength;
                
                // Calculate angle from movement direction (0 = up, PI/2 = right, PI = down, -PI/2 = left)
                // atan2(y, x) gives angle from positive x-axis, we add PI/2 to make 0 = up
                this.player.angle = Math.atan2(moveY, moveX) + Math.PI / 2;
            }
        }
        // If not moving, keep the current angle (ship maintains last direction)

        // Constrain player to canvas bounds with smooth edge handling
        // Use a small margin to prevent getting stuck at exact edges
        const edgeMargin = 2;
        const minX = this.player.size + edgeMargin;
        const maxX = this.canvas.width - this.player.size - edgeMargin;
        const minY = this.player.size + edgeMargin;
        const maxY = this.canvas.height - this.player.size - edgeMargin;
        
        // Smoothly constrain player position - if stuck at edge, allow slight movement away
        if (this.player.x < minX) {
            this.player.x = minX;
        } else if (this.player.x > maxX) {
            this.player.x = maxX;
        }
        if (this.player.y < minY) {
            this.player.y = minY;
        } else if (this.player.y > maxY) {
            this.player.y = maxY;
        }
        
        // If player is at edge and trying to move further, apply slight push-back to prevent sticking
        // This allows the player to easily move away from edges when stuck
        const atLeftEdge = this.player.x <= minX + 1;
        const atRightEdge = this.player.x >= maxX - 1;
        const atTopEdge = this.player.y <= minY + 1;
        const atBottomEdge = this.player.y >= maxY - 1;
        
        // When at an edge and trying to move into it, allow movement in opposite direction
        // This prevents getting stuck when WASD keys are held while at edge
        if (atLeftEdge && hasLeft) {
            // At left edge trying to go left - allow movement right (away from edge)
            this.player.x = Math.min(maxX, this.player.x + totalSpeed * deltaTime * 0.5);
        }
        if (atRightEdge && hasRight) {
            // At right edge trying to go right - allow movement left (away from edge)
            this.player.x = Math.max(minX, this.player.x - totalSpeed * deltaTime * 0.5);
        }
        if (atTopEdge && hasUp) {
            // At top edge trying to go up - allow movement down (away from edge)
            this.player.y = Math.min(maxY, this.player.y + totalSpeed * deltaTime * 0.5);
        }
        if (atBottomEdge && hasDown) {
            // At bottom edge trying to go down - allow movement up (away from edge)
            this.player.y = Math.max(minY, this.player.y - totalSpeed * deltaTime * 0.5);
        }

        // Shield regeneration - for quantum shields and high-tier shields, plus regen bonus
        const shield = this.equipmentStats.shields[this.currentShield];
        if (this.currentShield !== 'none' && shield.regen > 0 && this.playerStats.shield > 0) {
            if (this.playerStats.shield < this.playerStats.maxShield) {
                // Apply shield regen bonus from upgrades
                const totalRegen = shield.regen + this.playerStats.shieldRegenBonus;
                this.playerStats.shield = Math.min(
                    this.playerStats.maxShield,
                    this.playerStats.shield + totalRegen * deltaTime
                );
            }
        }
        
        // Update boss hit visual effect timer
        if (this.player.bossHitEffect > 0) {
            this.player.bossHitEffect = Math.max(0, this.player.bossHitEffect - deltaTime);
            // Fade out intensity over time
            this.player.bossHitIntensity = this.player.bossHitEffect / 0.3; // Fade from 1.0 to 0.0 over 0.3 seconds
        }
        
        // Health regeneration (passive)
        if (this.playerStats.healthRegen > 0 && this.playerStats.health < this.playerStats.maxHealth) {
            this.playerStats.health = Math.min(
                this.playerStats.maxHealth,
                this.playerStats.health + this.playerStats.healthRegen * deltaTime
            );
        }
        
        // All shields break when depleted (including quantum)
        // Only break shield if it was actually taking damage (shield was > 0 before, now <= 0)
        // Don't break if shield was never initialized (maxShield is 0)
        if (this.currentShield !== 'none' && this.playerStats.shield <= 0 && this.playerStats.maxShield > 0) {
            // Shield was depleted - remove from inventory
            const currentCount = this.getItemCount('shields', this.currentShield);
            if (currentCount > 0) {
                this.setItemCount('shields', this.currentShield, currentCount - 1);
            }
            this.currentShield = 'none';
            this.playerStats.maxShield = 0;
            this.playerStats.shield = 0;
        } else if (this.currentShield !== 'none' && this.playerStats.maxShield === 0) {
            // Shield is equipped but maxShield is 0 - this shouldn't happen, but reset to prevent issues
            console.warn(`[Shield] Shield '${this.currentShield}' is equipped but maxShield is 0. Resetting.`);
            this.currentShield = 'none';
            this.playerStats.shield = 0;
        }

        // Update bullets
        // OPTIMIZATION: Use manual loop with object pooling - return removed bullets to pool
        // OPTIMIZATION: Adaptive bullet limit - cull oldest bullets if we exceed the limit
        // SAFETY: Wrap in try-catch to prevent crashes from causing state loss
        const level = this.level || 1;
        
        try {
        const weaponCount = (this.currentWeapons && this.currentWeapons.length) || 0;
        const hasHighTierWeapons = this.currentWeapons && this.currentWeapons.some(w => 
            ['transformationPredictor', 'deterministicEngine', 'individualSystemCore'].includes(w)
        );
        // More aggressive limits for level 75+ to prevent freezes
        let MAX_BULLETS = 150;
        if (level >= 75 && weaponCount >= 3 && hasHighTierWeapons) {
            MAX_BULLETS = 80; // Very aggressive for end-game stacked high-tier
        } else if (level >= 75 && weaponCount >= 3) {
            MAX_BULLETS = 90; // Aggressive for end-game stacked
        } else if (level >= 75) {
            MAX_BULLETS = 100; // Aggressive for level 75+
        } else if (level >= 50 && weaponCount >= 3) {
            MAX_BULLETS = 110; // Moderate for late game stacked
        } else if (level >= 50) {
            MAX_BULLETS = 120; // Moderate for late game
        }
        
        // Safety check: If bullets exceed limit by too much, aggressively cull to prevent freeze
        if (this.bullets.length > MAX_BULLETS * 1.5) {
            // Emergency cull: Remove 50% of bullets if we're way over limit
            const targetCount = Math.floor(MAX_BULLETS * 0.8);
            const bulletsToRemove = this.bullets.length - targetCount;
            for (let i = 0; i < bulletsToRemove; i++) {
                const bullet = this.bullets.shift();
                if (bullet && this._bulletPool.length < this._bulletPoolSize) {
                    this._bulletPool.push(bullet);
                }
            }
        } else if (this.bullets.length > MAX_BULLETS) {
            // Normal cull: Remove oldest bullets to get back under limit
            const bulletsToRemove = this.bullets.length - MAX_BULLETS;
            for (let i = 0; i < bulletsToRemove; i++) {
                const bullet = this.bullets.shift();
                // Return to pool
                if (bullet && this._bulletPool.length < this._bulletPoolSize) {
                    this._bulletPool.push(bullet);
                }
            }
        }
        
        const aliveBullets = [];
        const bulletCount = this.bullets.length;
        
        // OPTIMIZATION: Aggressive culling for off-screen bullets in update loop
        // This prevents bullets from accumulating off-screen and causing performance issues
        // More aggressive culling for level 75+ to prevent freezes
        const cullMarginX = (level >= 75) ? this.canvas.width * 0.1 : this.canvas.width * 0.2; // 10% margin for level 75+, 20% otherwise
        const cullMarginY = (level >= 75) ? this.canvas.height * 0.1 : this.canvas.height * 0.2; // 10% margin for level 75+, 20% otherwise
        
        for (let i = 0; i < bulletCount; i++) {
            const bullet = this.bullets[i];
            
            // Early cull: Remove bullets that are far off-screen (before updating)
            // Skip collision detection for off-screen bullets to save performance
            const isOffScreen = bullet.x < -cullMarginX || bullet.x > this.canvas.width + cullMarginX ||
                                bullet.y < -cullMarginY || bullet.y > this.canvas.height + cullMarginY;
            
            if (isOffScreen) {
                // Bullet is far off-screen, mark for removal
                bullet.lifetime = -1; // Force removal
                // Still update position but skip collision checks
                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;
                bullet.lifetime -= deltaTime;
                continue; // Skip collision detection for off-screen bullets
            }
            
            bullet.x += bullet.vx * deltaTime;
            bullet.y += bullet.vy * deltaTime;
            bullet.lifetime -= deltaTime;

            // CRITICAL FIX: Track if bullet has hit something to prevent multiple hits
            let bulletHit = false;
            
            // OPTIMIZATION: Skip collision detection if bullet is about to expire
            // This reduces collision checks for bullets that won't hit anything
            if (bullet.lifetime < 0.1) {
                continue; // Skip collision checks for bullets about to expire
            }

            // Check hits on boss enemies FIRST (works in boss mode regardless of current mode)
            // Boss enemies must be destroyed before puzzle parts can be damaged
            if (!bulletHit && this.bossMode && this.bossEnemies.length > 0) {
                for (let enemy of this.bossEnemies) {
                    if (this.checkCollision(bullet, enemy)) {
                        let damage = bullet.damage || 10;
                        
                        // Apply critical hit chance from upgrades
                        let critChance = this.playerStats.criticalHitChance / 100;
                        if (this.currentUpgrades.includes('transformationTimeScanner')) {
                            critChance += 0.4;
                        }
                        critChance = Math.min(1.0, critChance);
                        
                        let isCritical = false;
                        if (Math.random() < critChance) {
                            isCritical = true;
                            damage *= this.playerStats.criticalHitDamage;
                        }
                        
                        enemy.health -= damage;
                        bulletHit = true;
                        this.audio.playSFX('enemyHit', 0.7);
                        this.createExplosion(bullet.x, bullet.y);
                        
                        if (enemy.health <= 0) {
                            this.audio.playSFX('enemyDestroy', 0.8);
                            this.audio.playSFX('explosion', 0.6);
                            // Boss enemies drop more resources
                            const dropCount = 4 + Math.floor(this.level / 3);
                            for (let i = 0; i < dropCount; i++) {
                                const rand = Math.random();
                                let itemType;
                                if (rand < 0.25) itemType = 'quantumParticles';
                                else if (rand < 0.5) itemType = 'crystals';
                                else if (rand < 0.75) itemType = 'energyCores';
                                else itemType = 'metalScraps';
                                this.dropItem(enemy.x + (Math.random() - 0.5) * 30, enemy.y + (Math.random() - 0.5) * 30, itemType);
                            }
                            // Drop tokens
                            const tokenCount = 2 + Math.floor(this.level / 5);
                            for (let i = 0; i < tokenCount; i++) {
                                this.dropItem(enemy.x + (Math.random() - 0.5) * 30, enemy.y + (Math.random() - 0.5) * 30, 'tokens');
                            }
                            this.createExplosion(enemy.x, enemy.y);
                            
                            // Remove enemy from array immediately so puzzle parts can be damaged
                            const enemyIndex = this.bossEnemies.indexOf(enemy);
                            if (enemyIndex !== -1) {
                                this.bossEnemies.splice(enemyIndex, 1);
                            }
                            
                            // Mark that a boss enemy was destroyed (for tracking)
                            this.bossPuzzleState.bossEnemiesDestroyed = (this.bossPuzzleState.bossEnemiesDestroyed || 0) + 1;
                        }
                        break;
                    }
                }
            }
            
            // Helper function to check if all boss enemies are destroyed
            const allBossEnemiesDestroyed = this.bossMode && this.bossEnemies.length === 0;

            if (this.mode === 'bell' || this.bossMode) {
                // Check hits on Bell pairs - instant destroy, no critical hits
                // Note: Bell pairs are destroyed instantly and are NOT affected by RPG stats
                for (let pair of this.pairs) {
                    if (bulletHit) break; // Bullet already hit something, skip remaining checks
                    const hitA = this.checkCollision(bullet, pair.a);
                    const hitB = this.checkCollision(bullet, pair.b);
                    
                    if (hitA || hitB) {
                        if (hitA) {
                            pair.a.health = 0;
                            pair.b.health = 0;
                            this.dropItem(pair.a.x, pair.a.y, 'quantumParticles');
                        } else {
                            pair.b.health = 0;
                            pair.a.health = 0;
                            this.dropItem(pair.b.x, pair.b.y, 'quantumParticles');
                        }
                        this.createExplosion(bullet.x, bullet.y);
                        this.score += 10;
                        this.hits++;
                        this._statsNeedsUpdate = true; // Batch update at end of frame
                        bulletHit = true; // Mark bullet as hit
                        break; // Exit pairs loop immediately
                    }
                }
                
                // Check hits on enemy ships (only if bullet hasn't hit anything yet, and not in boss mode)
                if (!bulletHit && !this.bossMode) {
                    for (let enemy of this.enemyShips) {
                        if (this.checkCollision(bullet, enemy)) {
                            let damage = bullet.damage || 10;
                            
                            // Apply critical hit chance from upgrades (base + transformationTimeScanner)
                            let critChance = this.playerStats.criticalHitChance / 100;
                            if (this.currentUpgrades.includes('transformationTimeScanner')) {
                                critChance += 0.4; // +40% from upgrade item
                            }
                            critChance = Math.min(1.0, critChance); // Cap at 100%
                            
                            let isCritical = false;
                            if (Math.random() < critChance) {
                                isCritical = true;
                                damage *= this.playerStats.criticalHitDamage; // Use crit damage multiplier from upgrades
                            }
                            
                            enemy.health -= damage;
                            this.audio.playSFX('enemyHit', 0.7);
                            this.createExplosion(bullet.x, bullet.y);
                            if (enemy.health <= 0) {
                                this.audio.playSFX('enemyDestroy', 0.8);
                                this.audio.playSFX('explosion', 0.6);
                                // Enemy ships drop resources (reduced drop count for balance)
                                let dropCount = 2 + Math.floor(this.level / 3); // 2-4+ items based on level (reduced from 3-5+)
                                
                                // Apply upgrade bonuses to resource drops
                                let dropMultiplier = 1.0;
                                if (this.currentUpgrades.includes('ensembleBypass')) {
                                    dropMultiplier *= 2.0; // +100% resource drops
                                }
                                if (this.currentUpgrades.includes('individualSystemAmplifier')) {
                                    dropMultiplier *= 3.0; // +200% resource drops (total)
                                }
                                // Apply material drop rate bonus from upgrades
                                dropMultiplier *= (1 + (this.playerStats.materialDropRate / 100));
                                dropCount = Math.floor(dropCount * dropMultiplier);
                                for (let i = 0; i < dropCount; i++) {
                                    // Drop various materials
                                    const rand = Math.random();
                                    let itemType;
                                    if (rand < 0.3) {
                                        itemType = 'quantumParticles';
                                    } else if (rand < 0.55) {
                                        itemType = 'crystals';
                                    } else if (rand < 0.75) {
                                        itemType = 'energyCores';
                                    } else {
                                        itemType = 'metalScraps';
                                    }
                                    
                                    // Spread items around the enemy position
                                    const angle = (Math.PI * 2 * i) / dropCount;
                                    const offset = 30;
                                    const itemX = enemy.x + Math.cos(angle) * offset;
                                    const itemY = enemy.y + Math.sin(angle) * offset;
                                    // Check if item is created too close to player
                                    // OPTIMIZATION: Use squared distance comparison to avoid sqrt
                                    const dxFromPlayer = itemX - this.player.x;
                                    const dyFromPlayer = itemY - this.player.y;
                                    const distFromPlayerSquared = dxFromPlayer * dxFromPlayer + dyFromPlayer * dyFromPlayer;
                                    const playerRadius = this.player.size || 20;
                                    const itemRadius = 8;
                                    const minCollectionDistance = playerRadius + itemRadius + 5;
                                    const minCollectionDistanceSquared = minCollectionDistance * minCollectionDistance;
                                    
                                    this.items.push({
                                        x: itemX,
                                        y: itemY,
                                        type: itemType,
                                        vx: Math.cos(angle) * 100,
                                        vy: Math.sin(angle) * 100,
                                        lifetime: 5,
                                        collected: false,
                                        createdTime: this.time, // Track when item was created
                                        size: 8, // Size for collision detection
                                        framesSinceCreation: 0, // Track frames since creation - prevents same-frame collection
                                        createdTooClose: distFromPlayerSquared < minCollectionDistanceSquared // Flag if created too close to player
                                    });
                                }
                                
                                // Bonus tokens for enemy ships
                                this.inventory.tokens += 5 + this.level * 2;
                                
                                this.score += 20; // More points for enemy ships
                                this.hits++;
                                
                                // Reset spawn timer when ship is destroyed - next spawn waits 8 seconds
                                this.lastEnemySpawn = Date.now();
                            }
                            this._statsNeedsUpdate = true; // Batch update at end of frame
                            bulletHit = true; // Mark bullet as hit
                            break; // Exit enemy loop immediately
                        }
                    }
                }
            } else {
                // Check hits on particles (blue targets) - instant destroy, no critical hits
                // Note: Particles are destroyed instantly and are NOT affected by RPG stats
                if (!bulletHit) {
                    for (let target of this.targets) {
                        if (this.checkCollision(bullet, target)) {
                            target.health = 0; // Instant destroy - no damage calculation needed
                            this.audio.playSFX('hit', 0.6);
                            this.dropItem(target.x, target.y, 'quantumParticles');
                            this.createExplosion(target.x, target.y);
                            this.score += 10;
                            this.hits++;
                            this._statsNeedsUpdate = true; // Batch update at end of frame
                            bulletHit = true; // Mark bullet as hit
                            break; // Exit targets loop immediately
                        }
                    }
                }
            }
            
            // Check hits on red molecules (obstacles) and bosses - only if bullet hasn't hit anything yet
            // Note: Red molecules ARE affected by critical hits and RPG stats (unlike particles)
            if (!bulletHit) {
                for (let obstacle of this.obstacles) {
                    if (this.checkCollision(bullet, obstacle)) {
                        // Boss puzzle mechanics: check if boss part can take damage
                        // ORDER: 1) Boss enemies (ships) must be destroyed first
                        //        2) Then outer features can be damaged
                        //        3) Finally core can be damaged after outer features
                        // EXCEPTION: Individual System Core bypasses all order restrictions
                        if (obstacle.isBoss) {
                            let canDamage = false;
                            
                            // Check if Individual System Core is equipped (bypasses all order restrictions)
                            const hasIndividualSystemCore = this.currentWeapons.includes('individualSystemCore');
                            
                            // STEP 1: All boss enemies (ships) must be destroyed before ANY puzzle part can take damage
                            // UNLESS Individual System Core is equipped (bypasses ALL order restrictions)
                            if (!allBossEnemiesDestroyed && !hasIndividualSystemCore) {
                                // Boss enemies still exist - cannot damage puzzle parts yet (unless using Individual System Core)
                                canDamage = false;
                            } else if (hasIndividualSystemCore) {
                                // Individual System Core bypasses ALL order restrictions - can damage any boss part immediately
                                // This weapon represents complete individual system knowledge, bypassing all puzzle mechanics
                                canDamage = true;
                            } else {
                                // Boss enemies destroyed - check puzzle part order (normal weapons must follow order)
                                if (obstacle.bossType === 'neurotransmitter') {
                                    // Level 15: Neurotransmitter boss
                                    // Outer features: vesicles, Core: neuron
                                    if (obstacle.bossPart === 'vesicle') {
                                        // Vesicles (outer features) can take damage after boss enemies are destroyed
                                        canDamage = true;
                                    } else if (obstacle.bossPart === 'neuron') {
                                        // Neuron (core) can only take damage if all vesicles (outer features) are destroyed
                                        canDamage = this.bossPuzzleState && 
                                                  this.bossPuzzleState.vesiclesDestroyed >= this.bossPuzzleState.totalVesicles;
                                    }
                                } else if (obstacle.bossType === 'dnaHelix') {
                                    // Level 30: DNA Helix boss
                                    // Outer features: strand1, strand2, Core: core
                                    if (obstacle.bossPart === 'strand1') {
                                        // Strand1 (outer feature) can take damage after boss enemies are destroyed
                                        canDamage = true;
                                    } else if (obstacle.bossPart === 'strand2') {
                                        // Strand2 (outer feature) can only take damage after strand1 is destroyed
                                        canDamage = this.bossPuzzleState && this.bossPuzzleState.strand1Destroyed;
                                    } else if (obstacle.bossPart === 'core') {
                                        // Core can only take damage if both strands (outer features) destroyed in order
                                        canDamage = this.bossPuzzleState && 
                                                  this.bossPuzzleState.strand1Destroyed && 
                                                  this.bossPuzzleState.strand2Destroyed &&
                                                  obstacle.canTakeDamage === true;
                                    }
                                } else if (obstacle.bossType === 'proteinComplex') {
                                    // Level 45: Protein Complex boss
                                    // Outer features: subunits, Core: core
                                    if (obstacle.bossPart === 'subunit') {
                                        // Subunits (outer features) can only take damage in order (1, 2, 3, 4) after boss enemies destroyed
                                        canDamage = this.bossPuzzleState && 
                                                  obstacle.subunitOrder === this.bossPuzzleState.nextSubunitOrder;
                                    } else if (obstacle.bossPart === 'core') {
                                        // Core can only take damage if all subunits (outer features) destroyed in order
                                        canDamage = this.bossPuzzleState && 
                                                  this.bossPuzzleState.subunitsDestroyed >= this.bossPuzzleState.totalSubunits;
                                    }
                                } else if (obstacle.bossType === 'cellMembrane') {
                                    // Level 60: Cell Membrane boss
                                    // Outer features: outerMembrane, innerMembrane, Core: nucleus
                                    if (obstacle.bossPart === 'outerMembrane') {
                                        // Outer membrane (outer feature) can take damage after boss enemies are destroyed
                                        canDamage = true;
                                    } else if (obstacle.bossPart === 'innerMembrane') {
                                        // Inner membrane (outer feature) only vulnerable when outer is destroyed
                                        canDamage = this.bossPuzzleState && 
                                                  this.bossPuzzleState.outerMembraneDestroyed;
                                    } else if (obstacle.bossPart === 'nucleus') {
                                        // Nucleus (core) only vulnerable when both membranes (outer features) are destroyed
                                        canDamage = this.bossPuzzleState && 
                                                  this.bossPuzzleState.outerMembraneDestroyed && 
                                                  this.bossPuzzleState.innerMembraneDestroyed;
                                    }
                                } else if (obstacle.bossType === 'advanced') {
                                    // Level 75+: Advanced bosses - no puzzle, but still need boss enemies destroyed first
                                    canDamage = true;
                                } else {
                                    // Unknown boss type - allow damage only after boss enemies destroyed
                                    canDamage = true;
                                }
                            }
                            
                            if (canDamage) {
                                let damage = bullet.damage || 10;
                                
                                // Apply critical hit chance from upgrades (base + transformationTimeScanner)
                                let critChance = this.playerStats.criticalHitChance / 100;
                                if (this.currentUpgrades.includes('transformationTimeScanner')) {
                                    critChance += 0.4; // +40% from upgrade item
                                }
                                critChance = Math.min(1.0, critChance); // Cap at 100%
                                
                                if (Math.random() < critChance) {
                                    damage *= this.playerStats.criticalHitDamage; // Use crit damage multiplier from upgrades
                                }
                                
                                obstacle.health -= damage;
                                obstacle.lastHitTime = this.time;
                                this.audio.playSFX('bossHit', 0.7);
                            } else {
                                // Can't damage this boss part yet - bullet bounces off
                                this.createExplosion(bullet.x, bullet.y);
                                bulletHit = true; // Mark bullet as hit
                                break; // Exit obstacle loop immediately
                            }
                        } else {
                            // Red molecules (regular obstacles) take damage normally
                            // These ARE affected by critical hits and RPG stats
                            let damage = bullet.damage || 10;
                            
                            // Apply critical hit chance from upgrades (base + transformationTimeScanner)
                            let critChance = this.playerStats.criticalHitChance / 100;
                            if (this.currentUpgrades.includes('transformationTimeScanner')) {
                                critChance += 0.4; // +40% from upgrade item
                            }
                            critChance = Math.min(1.0, critChance); // Cap at 100%
                            
                            if (Math.random() < critChance) {
                                damage *= this.playerStats.criticalHitDamage; // Use crit damage multiplier from upgrades
                            }
                            
                            obstacle.health -= damage;
                            obstacle.lastHitTime = this.time;
                        }
                        
                        // Shrink obstacle based on health percentage (for non-boss obstacles)
                        if (!obstacle.isBoss) {
                            const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
                            obstacle.size = obstacle.originalSize * healthPercent;
                        }
                        
                        this.createExplosion(bullet.x, bullet.y);
                        
                        if (obstacle.health <= 0) {
                            // Play destroy sound
                            if (obstacle.isBoss) {
                                this.audio.playSFX('bossDestroy', 1.0);
                                this.audio.playSFX('explosion', 0.8);
                            } else {
                                this.audio.playSFX('explosion', 0.6);
                            }
                            
                            // Handle boss puzzle state updates for all boss types
                            if (obstacle.isBoss) {
                                if (obstacle.bossType === 'neurotransmitter') {
                                    // Level 15: Neurotransmitter boss
                                    if (obstacle.bossPart === 'vesicle') {
                                        if (this.bossPuzzleState) {
                                            this.bossPuzzleState.vesiclesDestroyed++;
                                            if (this.bossPuzzleState.vesiclesDestroyed >= this.bossPuzzleState.totalVesicles) {
                                                this.bossPuzzleState.neuronVulnerable = true;
                                                const neuron = this.obstacles.find(o => o.isBoss && o.bossPart === 'neuron');
                                                if (neuron) neuron.canTakeDamage = true;
                                            }
                                        }
                                    }
                                } else if (obstacle.bossType === 'dnaHelix') {
                                    // Level 30: DNA Helix boss - order-based destruction
                                    if (obstacle.bossPart === 'strand1') {
                                        if (this.bossPuzzleState) {
                                            this.bossPuzzleState.strand1Destroyed = true;
                                            // Make strand2 vulnerable now
                                            const strand2 = this.obstacles.find(o => o.isBoss && o.bossPart === 'strand2' && o.bossType === 'dnaHelix');
                                            if (strand2) {
                                                strand2.canTakeDamage = true;
                                            }
                                            this.checkDNAHelixPuzzle();
                                        }
                                    } else if (obstacle.bossPart === 'strand2') {
                                        if (this.bossPuzzleState) {
                                            this.bossPuzzleState.strand2Destroyed = true;
                                            this.checkDNAHelixPuzzle();
                                        }
                                    }
                                } else if (obstacle.bossType === 'proteinComplex') {
                                    // Level 45: Protein Complex boss
                                    if (obstacle.bossPart === 'subunit') {
                                        if (this.bossPuzzleState && 
                                            obstacle.subunitOrder === this.bossPuzzleState.nextSubunitOrder) {
                                            this.bossPuzzleState.subunitsDestroyed++;
                                            this.bossPuzzleState.nextSubunitOrder++;
                                            // Make next subunit vulnerable
                                            const nextSubunit = this.obstacles.find(o => 
                                                o.isBoss && o.bossPart === 'subunit' && 
                                                o.subunitOrder === this.bossPuzzleState.nextSubunitOrder);
                                            if (nextSubunit) {
                                                nextSubunit.canTakeDamage = true;
                                            } else if (this.bossPuzzleState.subunitsDestroyed >= this.bossPuzzleState.totalSubunits) {
                                                // All subunits destroyed - make core vulnerable
                                                const core = this.obstacles.find(o => o.isBoss && o.bossPart === 'core');
                                                if (core) core.canTakeDamage = true;
                                            }
                                        }
                                    }
                                } else if (obstacle.bossType === 'cellMembrane') {
                                    // Level 60: Cell Membrane boss
                                    if (obstacle.bossPart === 'outerMembrane') {
                                        if (this.bossPuzzleState) {
                                            this.bossPuzzleState.outerMembraneDestroyed = true;
                                            const innerMembrane = this.obstacles.find(o => o.isBoss && o.bossPart === 'innerMembrane');
                                            if (innerMembrane) innerMembrane.canTakeDamage = true;
                                        }
                                    } else if (obstacle.bossPart === 'innerMembrane') {
                                        if (this.bossPuzzleState) {
                                            this.bossPuzzleState.innerMembraneDestroyed = true;
                                            this.bossPuzzleState.nucleusVulnerable = true;
                                            const nucleus = this.obstacles.find(o => o.isBoss && o.bossPart === 'nucleus');
                                            if (nucleus) nucleus.canTakeDamage = true;
                                        }
                                    }
                                }
                            }
                            
                            // Obstacle destroyed - drop resources based on molecule size/complexity
                            // Increased drop count for biological materials to make food crafting viable
                            let baseDropCount = 8; // Increased from 5 to make food crafting more accessible
                            
                            // Apply upgrade bonuses to resource drops
                            if (this.currentUpgrades.includes('ensembleBypass')) {
                                baseDropCount *= 2.0; // +100% resource drops
                            }
                            if (this.currentUpgrades.includes('individualSystemAmplifier')) {
                                baseDropCount *= 3.0; // +200% resource drops (total)
                            }
                            
                            const dropCount = Math.floor(baseDropCount * (obstacle.rewardMultiplier || 1.0));
                            
                            // If survival is unlocked, molecules ONLY drop food materials (no regular materials)
                            if (this.survivalUnlocked) {
                                // All drops are biological components
                                for (let i = 0; i < dropCount; i++) {
                                    const bioRand = Math.random();
                                    let bioType;
                                    // Distribute biological components with different rarities
                                    // Balanced: More sugars, minerals, and vitamins for better food crafting balance
                                    if (bioRand < 0.25) {
                                        bioType = 'atp'; // Most common - energy currency (25%)
                                    } else if (bioRand < 0.55) {
                                        bioType = 'simpleSugars'; // Common - carbohydrates (30%)
                                    } else if (bioRand < 0.70) {
                                        bioType = 'aminoAcids'; // Common - protein building blocks (15%)
                                    } else if (bioRand < 0.80) {
                                        bioType = 'fattyAcids'; // Uncommon - lipids (10%)
                                    } else if (bioRand < 0.86) {
                                        bioType = 'nucleotides'; // Uncommon - DNA/RNA (6%, reduced from 8%)
                                    } else if (bioRand < 0.92) {
                                        bioType = 'vitamins'; // Rare - micronutrients (6%, increased from 4%)
                                    } else {
                                        bioType = 'minerals'; // Rare - essential minerals (10%, increased from 8%)
                                    }
                                    
                                    // Spread biological components around obstacle
                                    const angle = (Math.PI * 2 * i) / dropCount;
                                    const offset = 40;
                                    const bioItemX = obstacle.x + Math.cos(angle) * offset;
                                    const bioItemY = obstacle.y + Math.sin(angle) * offset;
                                    
                                    // Check if item is created too close to player
                                    // OPTIMIZATION: Use squared distance comparison to avoid sqrt
                                    const dxFromPlayer = bioItemX - this.player.x;
                                    const dyFromPlayer = bioItemY - this.player.y;
                                    const distFromPlayerSquared = dxFromPlayer * dxFromPlayer + dyFromPlayer * dyFromPlayer;
                                    const playerRadius = this.player.size || 20;
                                    const itemRadius = 8;
                                    const minCollectionDistance = playerRadius + itemRadius + 5;
                                    const minCollectionDistanceSquared = minCollectionDistance * minCollectionDistance;
                                    
                                    this.items.push({
                                        x: bioItemX,
                                        y: bioItemY,
                                        type: bioType,
                                        vx: Math.cos(angle) * 150,
                                        vy: Math.sin(angle) * 150,
                                        lifetime: 5,
                                        collected: false,
                                        createdTime: this.time,
                                        size: 8,
                                        framesSinceCreation: 0,
                                        createdTooClose: distFromPlayerSquared < minCollectionDistanceSquared,
                                        isBiological: true // Flag for enhanced graphics
                                    });
                                }
                            } else {
                                // Survival not unlocked - drop regular materials (old system)
                                for (let i = 0; i < dropCount; i++) {
                                    const rand = Math.random();
                                    let itemType;
                                    if (this.mode === 'ensemble') {
                                        if (rand < 0.5) {
                                            itemType = 'quantumParticles';
                                        } else {
                                            itemType = 'crystals';
                                        }
                                    } else if (this.mode === 'individual') {
                                        if (rand < 0.5) {
                                            itemType = 'energyCores';
                                        } else {
                                            itemType = 'metalScraps';
                                        }
                                    } else if (this.mode === 'bell') {
                                        if (rand < 0.4) {
                                            itemType = 'quantumParticles';
                                        } else if (rand < 0.65) {
                                            itemType = 'crystals';
                                        } else if (rand < 0.85) {
                                            itemType = 'metalScraps';
                                        } else {
                                            itemType = 'energyCores';
                                        }
                                    }
                                    
                                    // Spread items around the obstacle position
                                    const angle = (Math.PI * 2 * i) / dropCount;
                                    const offset = 40;
                                    const itemX = obstacle.x + Math.cos(angle) * offset;
                                    const itemY = obstacle.y + Math.sin(angle) * offset;
                                    // Check if item is created too close to player
                                    // OPTIMIZATION: Use squared distance comparison to avoid sqrt
                                    const dxFromPlayer = itemX - this.player.x;
                                    const dyFromPlayer = itemY - this.player.y;
                                    const distFromPlayerSquared = dxFromPlayer * dxFromPlayer + dyFromPlayer * dyFromPlayer;
                                    const playerRadius = this.player.size || 20;
                                    const itemRadius = 8;
                                    const minCollectionDistance = playerRadius + itemRadius + 5;
                                    const minCollectionDistanceSquared = minCollectionDistance * minCollectionDistance;
                                    
                                    this.items.push({
                                        x: itemX,
                                        y: itemY,
                                        type: itemType,
                                        vx: Math.cos(angle) * 150,
                                        vy: Math.sin(angle) * 150,
                                        lifetime: 5,
                                        collected: false,
                                        createdTime: this.time, // Track when item was created
                                        size: 8, // Size for collision detection
                                        framesSinceCreation: 0, // Track frames since creation - prevents same-frame collection
                                        createdTooClose: distFromPlayerSquared < minCollectionDistanceSquared // Flag if created too close to player
                                    });
                                }
                            }
                            
                            // OLD CODE REMOVED - biological drops are now the only drops when survival is unlocked
                            if (false && this.survivalUnlocked && biologicalDropCount > 0) {
                                for (let bioIndex = 0; bioIndex < biologicalDropCount; bioIndex++) {
                                    const bioRand = Math.random();
                                    let bioType;
                                    // Distribute biological components with different rarities
                                    if (bioRand < 0.25) {
                                        bioType = 'atp'; // Most common - energy currency
                                    } else if (bioRand < 0.55) {
                                        bioType = 'simpleSugars'; // Common - carbohydrates (increased from 20% to 30%)
                                    } else if (bioRand < 0.70) {
                                        bioType = 'aminoAcids'; // Common - protein building blocks
                                    } else if (bioRand < 0.80) {
                                        bioType = 'fattyAcids'; // Uncommon - lipids
                                    } else if (bioRand < 0.88) {
                                        bioType = 'nucleotides'; // Uncommon - DNA/RNA
                                    } else if (bioRand < 0.92) {
                                        bioType = 'vitamins'; // Rare - micronutrients
                                    } else {
                                        bioType = 'minerals'; // Rare - essential minerals (increased from 5% to 8%)
                                    }
                                    
                                    // Spread biological components around obstacle (offset from regular drops)
                                    const bioAngle = (Math.PI * 2 * bioIndex) / biologicalDropCount + Math.PI / biologicalDropCount; // Offset by half step
                                    const offset = 40;
                                    const bioItemX = obstacle.x + Math.cos(bioAngle) * offset;
                                    const bioItemY = obstacle.y + Math.sin(bioAngle) * offset;
                                    
                                    // Check if item is created too close to player
                                    // OPTIMIZATION: Use squared distance comparison to avoid sqrt
                                    const dxFromPlayer = bioItemX - this.player.x;
                                    const dyFromPlayer = bioItemY - this.player.y;
                                    const distFromPlayerSquared = dxFromPlayer * dxFromPlayer + dyFromPlayer * dyFromPlayer;
                                    const playerRadius = this.player.size || 20;
                                    const itemRadius = 8;
                                    const minCollectionDistance = playerRadius + itemRadius + 5;
                                    const minCollectionDistanceSquared = minCollectionDistance * minCollectionDistance;
                                    
                                    this.items.push({
                                        x: bioItemX,
                                        y: bioItemY,
                                        type: bioType,
                                        vx: Math.cos(bioAngle) * 150,
                                        vy: Math.sin(bioAngle) * 150,
                                        lifetime: 5,
                                        collected: false,
                                        createdTime: this.time,
                                        size: 8,
                                        framesSinceCreation: 0,
                                        createdTooClose: distFromPlayerSquared < minCollectionDistanceSquared,
                                        isBiological: true // Flag for enhanced graphics
                                    });
                                }
                            }
                        }
                        
                        // Tokens based on molecule complexity
                        const baseTokens = (1 + Math.floor(this.level / 2)) * 3;
                        this.inventory.tokens += Math.floor(baseTokens * (obstacle.rewardMultiplier || 1.0));
                        
                        // Score based on molecule complexity
                        const baseScore = obstacle.isBoss ? 500 : 30;
                        this.score += Math.floor(baseScore * (obstacle.rewardMultiplier || 1.0));
                        this.hits++;
                        obstacle.size = 0; // Mark for removal
                        
                        // Special boss defeat message
                        if (obstacle.isBoss) {
                            // Create massive explosion
                            for (let i = 0; i < 50; i++) {
                                this.createExplosion(obstacle.x + (Math.random() - 0.5) * 200, 
                                                    obstacle.y + (Math.random() - 0.5) * 200);
                            }
                        }
                        
                        this._statsNeedsUpdate = true; // Batch update at end of frame
                        bulletHit = true; // Mark bullet as hit
                        break; // Exit obstacle loop immediately
                }
            }
        }

            // If bullet hit something, don't add it to aliveBullets
            if (bulletHit) {
                // OPTIMIZATION: Return bullet to pool when removed (hit something)
                if (this._bulletPool.length < this._bulletPoolSize) {
                    this._bulletPool.push(bullet);
                }
                continue; // Skip this bullet (don't add to aliveBullets)
            }

            if (bullet.x < 0 || bullet.x > this.canvas.width ||
                bullet.y < 0 || bullet.y > this.canvas.height ||
                bullet.lifetime <= 0) {
                if (bullet.lifetime > 0) {
                    this.misses++;
                    this._statsNeedsUpdate = true; // Batch update at end of frame
                }
                // OPTIMIZATION: Return bullet to pool when removed (off screen or expired)
                if (this._bulletPool.length < this._bulletPoolSize) {
                    this._bulletPool.push(bullet);
                }
                continue; // Skip this bullet (don't add to aliveBullets)
            }
            aliveBullets.push(bullet); // Bullet is still alive
        }
        this.bullets = aliveBullets; // Replace array with filtered results
        
        } catch (error) {
            // Safety: If bullet update crashes, log error and clear bullets to prevent freeze
            console.error('[Bullet Update Error]', error);
            // Clear all bullets to prevent further issues
            this.bullets = [];
            // Don't throw - allow game to continue
        }

        // Update targets
        this.targets = this.targets.filter(target => {
            target.x += target.vx * deltaTime;
            target.y += target.vy * deltaTime;
            if (target.x < target.size || target.x > this.canvas.width - target.size) target.vx *= -1;
            if (target.y < target.size || target.y > this.canvas.height - target.size) target.vy *= -1;
            
            // Boost mode: Destroy targets on contact
            if (this.boostActive && this.checkCollision(target, this.player)) {
                const boostResourceMultiplier = 0.75; // Reduced to half (was 1.5, now 0.75)
                // Drop materials with boost bonus
                const dropCount = Math.floor((2 + Math.floor(this.level / 3)) * boostResourceMultiplier);
                for (let i = 0; i < dropCount; i++) {
                    const rand = Math.random();
                    let itemType;
                    if (this.mode === 'ensemble') {
                        itemType = rand < 0.5 ? 'quantumParticles' : 'crystals';
                    } else if (this.mode === 'individual') {
                        itemType = rand < 0.5 ? 'energyCores' : 'metalScraps';
                    } else {
                        itemType = rand < 0.33 ? 'quantumParticles' : (rand < 0.66 ? 'crystals' : 'energyCores');
                    }
                    const angle = (Math.PI * 2 * i) / dropCount;
                    this.items.push({
                        x: target.x + Math.cos(angle) * 30,
                        y: target.y + Math.sin(angle) * 30,
                        type: itemType,
                        vx: Math.cos(angle) * 150,
                        vy: Math.sin(angle) * 150,
                        lifetime: 5,
                        collected: false,
                        createdTime: this.time,
                        size: 8,
                        framesSinceCreation: 0
                    });
                }
                this.score += 10 * boostResourceMultiplier;
                this.inventory.tokens += Math.floor((1 + Math.floor(this.level / 2)) * boostResourceMultiplier);
                this.audio.playSFX('explosion', 0.4);
                this.createExplosion(target.x, target.y);
                return false; // Remove target
            }
            
            return target.health > 0;
        });

        // Update pairs
        this.pairs = this.pairs.filter(pair => {
            pair.a.x += pair.a.vx * deltaTime;
            pair.a.y += pair.a.vy * deltaTime;
            pair.b.x += pair.b.vx * deltaTime;
            pair.b.y += pair.b.vy * deltaTime;
            
            // OPTIMIZATION: Use squared distance for comparison (avoid sqrt)
            const dx = pair.b.x - pair.a.x;
            const dy = pair.b.y - pair.a.y;
            const distanceSquared = dx * dx + dy * dy;
            const maxDistanceSquared = 200 * 200; // 200^2 = 40000
            if (distanceSquared > maxDistanceSquared) {
                // Need actual distance for angle calculation
                const distance = Math.sqrt(distanceSquared);
                const angle = Math.atan2(dy, dx);
                pair.b.x = pair.a.x + Math.cos(angle) * 200;
                pair.b.y = pair.a.y + Math.sin(angle) * 200;
            }
            
            [pair.a, pair.b].forEach(p => {
                if (p.x < p.size || p.x > this.canvas.width - p.size) p.vx *= -1;
                if (p.y < p.size || p.y > this.canvas.height - p.size) p.vy *= -1;
            });
            
            // Boost mode: Destroy pairs on contact
            if (this.boostActive) {
                const hitA = this.checkCollision(pair.a, this.player);
                const hitB = this.checkCollision(pair.b, this.player);
                if (hitA || hitB) {
                    const boostResourceMultiplier = 0.75; // Reduced to half (was 1.5, now 0.75)
                    // Destroy both parts of the pair
                    const dropCount = Math.floor((4 + Math.floor(this.level / 3)) * boostResourceMultiplier);
                    for (let i = 0; i < dropCount; i++) {
                        const rand = Math.random();
                        let itemType;
                        if (this.mode === 'ensemble') {
                            itemType = rand < 0.5 ? 'quantumParticles' : 'crystals';
                        } else if (this.mode === 'individual') {
                            itemType = rand < 0.5 ? 'energyCores' : 'metalScraps';
                        } else {
                            itemType = rand < 0.33 ? 'quantumParticles' : (rand < 0.66 ? 'crystals' : 'energyCores');
                        }
                        const angle = (Math.PI * 2 * i) / dropCount;
                        const centerX = (pair.a.x + pair.b.x) / 2;
                        const centerY = (pair.a.y + pair.b.y) / 2;
                        this.items.push({
                            x: centerX + Math.cos(angle) * 30,
                            y: centerY + Math.sin(angle) * 30,
                            type: itemType,
                            vx: Math.cos(angle) * 150,
                            vy: Math.sin(angle) * 150,
                            lifetime: 5,
                            collected: false,
                            createdTime: this.time,
                            size: 8,
                            framesSinceCreation: 0
                        });
                    }
                    this.score += 20 * boostResourceMultiplier;
                    this.inventory.tokens += Math.floor((2 + Math.floor(this.level / 2)) * boostResourceMultiplier);
                    this.audio.playSFX('bellPair', 0.6);
                    this.createExplosion((pair.a.x + pair.b.x) / 2, (pair.a.y + pair.b.y) / 2);
                    return false; // Remove pair
                }
            }
            
            return pair.a.health > 0 || pair.b.health > 0;
        });

        // Update obstacles
        this.obstacles.forEach(obstacle => {
            // CRITICAL FIX: Skip boss obstacles if not in boss mode (prevents random death after level up)
            // This is a safety check in case boss obstacles weren't properly cleared
            if (obstacle.isBoss && !this.bossMode) {
                return; // Skip updating and collision checking for boss obstacles when not in boss mode
            }
            
            obstacle.x += obstacle.vx * deltaTime;
            obstacle.y += obstacle.vy * deltaTime;
            
            // Regenerate obstacle if not being shot (grow back to original size)
            if (obstacle.health < obstacle.maxHealth && obstacle.health > 0) {
                const timeSinceLastHit = this.time - obstacle.lastHitTime;
                if (timeSinceLastHit >= obstacle.regenDelay) {
                    // Regenerate health and size
                    // Boss vesicles regenerate at 20% per second (slightly more challenging but not too hard)
                    // Regular obstacles regenerate at 30% per second
                    // Neuron should NOT regenerate (regenDelay is set very high)
                    let regenRateMultiplier = 0.3; // Default: 30% per second for regular obstacles
                    if (obstacle.isBoss && obstacle.bossType === 'neurotransmitter' && obstacle.bossPart === 'vesicle') {
                        regenRateMultiplier = 0.20; // Boss vesicles: 20% per second (slightly more challenging)
                    } else if (obstacle.isBoss && obstacle.bossType === 'neurotransmitter' && obstacle.bossPart === 'neuron') {
                        regenRateMultiplier = 0; // Neuron does NOT regenerate
                    }
                    const regenRate = obstacle.maxHealth * deltaTime * regenRateMultiplier;
                    obstacle.health = Math.min(obstacle.maxHealth, obstacle.health + regenRate);
                    const healthPercent = obstacle.health / obstacle.maxHealth;
                    // OPTIMIZATION: Only update size if it changed significantly (reduces unnecessary updates)
                    const newSize = obstacle.originalSize * healthPercent;
                    if (Math.abs(obstacle.size - newSize) > 0.1) {
                        obstacle.size = newSize;
                    }
                }
            }
            
            // OPTIMIZATION: Update size based on health for non-boss obstacles (only if not regenerating)
            // This ensures size stays in sync with health when taking damage
            if (!obstacle.isBoss && obstacle.health > 0 && obstacle.health < obstacle.maxHealth) {
                const timeSinceLastHit = this.time - (obstacle.lastHitTime || 0);
                // Only update size if we just took damage (within last 0.1 seconds) or if size is out of sync
                if (timeSinceLastHit < 0.1 || Math.abs(obstacle.size - (obstacle.originalSize * (obstacle.health / obstacle.maxHealth))) > 0.5) {
                    const healthPercent = obstacle.health / obstacle.maxHealth;
                    obstacle.size = obstacle.originalSize * healthPercent;
                }
            }
            
            // Check collision with player - use strict collision for precise contact detection
            if (this.checkObstacleCollision(obstacle, this.player)) {
                // Boost mode: Destroy obstacles on contact (invincibility + destruction)
                if (this.boostActive) {
                    // Destroy obstacle and give bonus resources
                    const boostResourceMultiplier = 0.75; // Reduced to half (was 1.5, now 0.75)
                    
                    // Drop resources with boost bonus
                    let baseDropCount = 8; // Base drops for molecules
                    if (this.currentUpgrades.includes('ensembleBypass')) {
                        baseDropCount *= 2.0;
                    }
                    if (this.currentUpgrades.includes('individualSystemAmplifier')) {
                        baseDropCount *= 3.0;
                    }
                    const dropCount = Math.floor(baseDropCount * (obstacle.rewardMultiplier || 1.0) * boostResourceMultiplier);
                    
                    // Drop biological components (survival system)
                    if (this.survivalUnlocked) {
                        for (let i = 0; i < dropCount; i++) {
                            const bioRand = Math.random();
                            let bioType;
                            // Balanced: More sugars, minerals, and vitamins for better food crafting balance
                            if (bioRand < 0.25) bioType = 'atp'; // 25%
                            else if (bioRand < 0.55) bioType = 'simpleSugars'; // 30%
                            else if (bioRand < 0.70) bioType = 'aminoAcids'; // 15%
                            else if (bioRand < 0.80) bioType = 'fattyAcids'; // 10%
                            else if (bioRand < 0.86) bioType = 'nucleotides'; // 6% (reduced from 8%)
                            else if (bioRand < 0.92) bioType = 'vitamins'; // 6% (increased from 4%)
                            else bioType = 'minerals'; // 10% (increased from 8%)
                            
                            const angle = (Math.PI * 2 * i) / dropCount;
                            const offset = 40;
                            this.items.push({
                                x: obstacle.x + Math.cos(angle) * offset,
                                y: obstacle.y + Math.sin(angle) * offset,
                                type: bioType,
                                vx: Math.cos(angle) * 150,
                                vy: Math.sin(angle) * 150,
                                lifetime: 5,
                                collected: false,
                                createdTime: this.time,
                                size: 8,
                                framesSinceCreation: 0,
                                isBiological: true
                            });
                        }
                    }
                    
                    // Play explosion sound
                    this.audio.playSFX('explosion', 0.6);
                    this.createExplosion(obstacle.x, obstacle.y);
                    
                    // Add score and tokens
                    this.score += 50 * (obstacle.rewardMultiplier || 1.0);
                    const tokens = Math.floor((1 + Math.floor(this.level / 2)) * (obstacle.rewardMultiplier || 1.0) * boostResourceMultiplier);
                    this.inventory.tokens += tokens;
                    
                    // Mark obstacle for removal
                    obstacle.health = 0;
                    return; // Skip normal collision handling
                }
                
                // For bosses, add visual effect immediately when touching
                if (obstacle.isBoss) {
                    this.player.bossHitEffect = 0.3; // 0.3 seconds of visual effect
                    this.player.bossHitIntensity = 1.0; // Start at full intensity
                }
                
                // Boost mode: Invincibility - skip damage when boosting
                if (!this.boostActive && !(this.devMode && this.devGodMode)) {
                    // Check damage cooldown - prevent continuous damage from boss collisions
                    // IMPORTANT: Cooldown applies globally to prevent multiple boss parts from damaging simultaneously
                    let canTakeDamage = true; // Default: allow damage
                    
                    if (obstacle.isBoss) {
                        // For bosses, check cooldown
                        const lastDamage = this.playerStats.lastDamageTime || 0;
                        const currentTime = this.time || 0;
                        const timeSinceLastDamage = currentTime - lastDamage;
                        
                        // First hit always applies (if never been hit before, lastDamageTime is 0)
                        // After first hit, must wait for cooldown (1.5 seconds)
                        if (lastDamage > 0 && timeSinceLastDamage < this.playerStats.damageCooldown) {
                            canTakeDamage = false; // Still in cooldown period
                        }
                    }
                    
                    // For bosses, ONLY apply damage if cooldown has passed (prevents instant death from multiple parts)
                    // For regular obstacles, always apply damage (they get destroyed on collision anyway)
                    // Also ensure we're not processing damage if already dead
                    if (((obstacle.isBoss && canTakeDamage) || !obstacle.isBoss) && this.playerStats.health > 0) {
                        let damage = obstacle.damage;
                        
                        // Bosses deal significantly more damage (but not instant kill)
                        if (obstacle.isBoss) {
                            // Increase boss damage - make it threatening but survivable
                            // Reduced from 2.5x to 1.8x to prevent instant kills on low health players
                            damage = damage * 1.8;
                            
                            // Cap boss damage to prevent instant kills - never more than 60% of max health
                            const maxBossDamage = this.playerStats.maxHealth * 0.6;
                            if (damage > maxBossDamage) {
                                damage = maxBossDamage;
                            }
                            
                            // Play boss hit sound (only once per damage instance)
                            if (this.audio && canTakeDamage) {
                                this.audio.playSFX('bossHit', 0.8);
                            }
                        }
                        
                        const ship = this.equipmentStats.ships[this.currentShip];
                        // Safety check: ensure ship exists
                        if (!ship) {
                            console.warn(`[Ship] Ship '${this.currentShip}' not found during damage calculation`);
                            // Fallback to basic ship
                            this.currentShip = 'basic';
                            if (!this.ownedItems.ships.basic) {
                                this.ownedItems.ships.basic = { count: 1, durability: 100 };
                            }
                            return; // Skip damage this frame
                        }
                        
                        // Apply ship-specific damage reduction
                        if (ship.bonus === 'damageResist') {
                            damage = damage * 0.7; // Tank takes 30% less damage
                        } else if (ship.bonus === 'evasion') {
                            // Agile ship has 20% chance to dodge
                            if (Math.random() < 0.2) {
                                damage = 0;
                            }
                        }
                        
                        // Apply damage to shield first, then health
                        if (this.playerStats.shield > 0) {
                            const shieldDamage = damage;
                            const remainingDamage = Math.max(0, damage - this.playerStats.shield);
                            this.playerStats.shield = Math.max(0, this.playerStats.shield - damage);
                            
                            // Apply damage-based decay to shield (real-time)
                            if (this.currentShield !== 'none' && shieldDamage > 0) {
                                this.applyDamageDecay('shields', this.currentShield, shieldDamage);
                            }
                            
                            if (remainingDamage > 0) {
                                this.playerStats.health = Math.max(0, this.playerStats.health - remainingDamage);
                                
                                // Apply damage-based decay to ship (real-time)
                                if (remainingDamage > 0) {
                                    this.applyDamageDecay('ships', this.currentShip, remainingDamage);
                                }
                            }
                            // Check if shield broke (all shields break when depleted)
                            if (this.playerStats.shield <= 0 && this.currentShield !== 'none') {
                                // Remove destroyed shield from inventory
                                const currentCount = this.getItemCount('shields', this.currentShield);
                                if (currentCount > 0) {
                                    this.setItemCount('shields', this.currentShield, currentCount - 1);
                                }
                                this.currentShield = 'none';
                                this.playerStats.maxShield = 0;
                            }
                        } else {
                            this.playerStats.health = Math.max(0, this.playerStats.health - damage);
                            
                            // Apply damage-based decay to ship (real-time)
                            if (damage > 0) {
                                this.applyDamageDecay('ships', this.currentShip, damage);
                            }
                        }
                        
                        // Update last damage time for cooldown
                        if (damage > 0) {
                            this.playerStats.lastDamageTime = this.time;
                        }
                        
                        // Play player hit sound for non-boss obstacles
                        if (!obstacle.isBoss && this.audio) {
                            this.audio.playSFX('playerHit', 0.6);
                        }
                        
                        this.createExplosion(obstacle.x, obstacle.y);
                    }
                }
                
                // Boss and boss parts (vesicles) can only be destroyed by shooting, not by collision
                // Regular obstacles are destroyed on collision
                if (!obstacle.isBoss) {
                    obstacle.vx = 0;
                    obstacle.vy = 0;
                    obstacle.size = 0;
                }
                // If it's a boss, just damage the player but don't destroy the obstacle
                
                // Safety check: Only die if health is actually 0 or less AND we're not in boost mode
                // Also ensure we have a valid ship (can't die from no ship)
                if (this.playerStats.health <= 0 && !this.boostActive) {
                    // Double-check: ensure we actually have health (prevent false deaths)
                    if (this.playerStats.health <= 0 && this.playerStats.maxHealth > 0) {
                        // Check if save feature is unlocked - if so, automatically revert to saved state
                        if (this.hiddenSequence.saveUnlocked) {
                            // Automatically revert to saved state (2 levels back) on death
                            if (this.revertToSavedState()) {
                                console.log('Automatically reverted to saved state on death!');
                                return; // Don't go to game over screen
                            }
                        }
                        
                        // If save feature not unlocked or revert failed, go to game over
                        this.deathReason = 'health'; // Died from health reaching 0
                        // Clear movement keys when game over to prevent ship from moving
                        this.clearMovementKeys();
                        this.gameState = 'gameover';
                        // Submit score on game over
                        setTimeout(async () => {
                            if (!this.playerName) {
                                this.showNameInput();
                            } else {
                                await this.submitScore();
                            }
                        }, 500);
                    }
                }
            }
        });
        // Filter obstacles but keep bosses (they might be off-screen temporarily or have special positioning)
        this.obstacles = this.obstacles.filter(o => {
            if (o.isBoss) {
                // Keep bosses regardless of position/size (they're managed separately)
                return o.health > 0;
            }
            return o.size > 0 && 
                   o.x > -50 && o.x < this.canvas.width + 50 &&
                   o.y > -50 && o.y < this.canvas.height + 50;
        });

        // Update items
        // Optimized: Cache auto-collector check outside loop
        const hasAutoCollector = this.currentUpgrades.includes('autoCollector');
        this.items.forEach(item => {
            // Increment frame counter - items must exist for at least 1 frame before collection
            item.framesSinceCreation = (item.framesSinceCreation || 0) + 1;
            
            // Attract to player (much stronger if auto-collector is equipped)
            const dx = this.player.x - item.x;
            const dy = this.player.y - item.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (hasAutoCollector) {
                // Auto-collector: attract from anywhere on screen at very high speed
                if (dist > 0) {
                    const attractSpeed = 2500; // Very fast attraction to collect before they disappear
                    item.vx += (dx / dist) * attractSpeed * deltaTime;
                    item.vy += (dy / dist) * attractSpeed * deltaTime;
                }
                // Reduce friction significantly when auto-collector is active
                item.vx *= 0.98;
                item.vy *= 0.98;
            } else {
                // Normal friction
                item.vx *= 0.95;
                item.vy *= 0.95;
                // Normal attraction only when close
                if (dist < 100) {
                    item.vx += (dx / dist) * 200 * deltaTime;
                    item.vy += (dy / dist) * 200 * deltaTime;
                }
            }
            
            item.x += item.vx * deltaTime;
            item.y += item.vy * deltaTime;
            item.lifetime -= deltaTime;
            
            // MATERIAL COLLECTION SYSTEM:
            // Materials drop as VISUAL ITEMS when objects are destroyed - these are the colored balls you see on screen
            // Tokens are separate - awarded IMMEDIATELY on destruction (not visual items, go straight to inventory)
            // 
            // Collection requirements for MATERIAL ITEMS (the visual balls):
            // 1. Item must have existed for at least 3 frames (prevents immediate collection when spawned near player)
            // 2. If item was created too close to player, require 5 frames (prevents collection of items spawned inside player)
            // 3. Ship must physically TOUCH the item (strict collision check in checkMaterialCollection)
            // 
            // The attraction system (lines above) only MOVES items closer - it does NOT collect them
            // Items are only collected when they actually touch the player ship (collision detection)
            // Auto-collector makes items move faster toward you, but you still must touch them to collect
            
            // Require more frames if item was created too close to player (prevents instant collection)
            const minFrames = (item.createdTooClose) ? 5 : 3;
            const canCollect = (item.framesSinceCreation || 0) >= minFrames;
            
            // Only collect if item has existed long enough AND ship is touching it
            // CRITICAL SAFEGUARD: Items must have existed for at least the minimum frames
            // AND must not be collected on the frame they're created (framesSinceCreation check handles this)
            if (canCollect && this.checkMaterialCollection(item, this.player)) {
                // Double-check: ensure item has existed for at least 2 frames as final safeguard
                if (item.framesSinceCreation >= 2) {
                    // Bell mode: double all material resources (same as tokens)
                    const materialMultiplier = this.mode === 'bell' ? 2 : 1;
                    // Ensure material exists in inventory before adding (safety check)
                    if (!this.inventory[item.type]) {
                        this.inventory[item.type] = 0;
                    }
                    this.inventory[item.type] += materialMultiplier;
                    item.collected = true;
                    // Mark that stats need updating so UI reflects the new material count
                    this._statsNeedsUpdate = true;
                }
            }
        });
        this.items = this.items.filter(item => !item.collected && item.lifetime > 0);

        // Update particles
        // OPTIMIZATION: Use for loop instead of filter for better performance
        // OPTIMIZATION: Limit particle count during boss battles
        const maxParticles = this.bossMode ? 100 : 300;
        
        // Update particles and remove dead ones
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.lifetime -= deltaTime;
            // Calculate alpha safely (handle missing maxLifetime)
            if (p.maxLifetime && p.maxLifetime > 0) {
            p.alpha = p.lifetime / p.maxLifetime;
            } else {
                p.alpha = Math.max(0, p.lifetime / (p.lifetime + deltaTime));
            }
            
            // Boost mode: Destroy particles on contact
            if (this.boostActive && this.checkCollision(p, this.player)) {
                const boostResourceMultiplier = 0.75; // Reduced to half (was 1.5, now 0.75)
                // Drop materials with boost bonus
                const dropCount = Math.floor((1 + Math.floor(this.level / 5)) * boostResourceMultiplier);
                for (let j = 0; j < dropCount; j++) {
                    const rand = Math.random();
                    let itemType;
                    if (this.mode === 'ensemble') {
                        itemType = rand < 0.5 ? 'quantumParticles' : 'crystals';
                    } else if (this.mode === 'individual') {
                        itemType = rand < 0.5 ? 'energyCores' : 'metalScraps';
                    } else {
                        itemType = rand < 0.33 ? 'quantumParticles' : (rand < 0.66 ? 'crystals' : 'energyCores');
                    }
                    const angle = (Math.PI * 2 * j) / dropCount;
                    this.items.push({
                        x: p.x + Math.cos(angle) * 20,
                        y: p.y + Math.sin(angle) * 20,
                        type: itemType,
                        vx: Math.cos(angle) * 150,
                        vy: Math.sin(angle) * 150,
                        lifetime: 5,
                        collected: false,
                        createdTime: this.time,
                        size: 8,
                        framesSinceCreation: 0
                    });
                }
                this.score += 5 * boostResourceMultiplier;
                this.inventory.tokens += Math.floor((1 + Math.floor(this.level / 3)) * boostResourceMultiplier);
                this.particles.splice(i, 1);
                // OPTIMIZATION: Return particle to pool
                if (this._particlePool.length < this._particlePoolSize) {
                    this._particlePool.push(p);
                }
                continue; // Skip to next particle
            }
            
            // Remove dead particles or if we exceed max count (remove oldest first)
            // OPTIMIZATION: Return particles to pool instead of deleting
            if (p.lifetime <= 0) {
                this.particles.splice(i, 1);
                // Return to pool if pool isn't full
                if (this._particlePool.length < this._particlePoolSize) {
                    this._particlePool.push(p);
                }
            } else if (this.particles.length > maxParticles && i < this.particles.length - maxParticles) {
                // Remove oldest particles when exceeding max count
                this.particles.splice(i, 1);
                // Return to pool if pool isn't full
                if (this._particlePool.length < this._particlePoolSize) {
                    this._particlePool.push(p);
                }
            }
        }

        // Update enemy ships (only when in Bell mode, but they persist in memory)
        if (this.mode === 'bell') {
            this.enemyShips = this.enemyShips.filter(enemy => {
                // Move enemy toward player
                const dx = this.player.x - enemy.x;
                const dy = this.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    enemy.x += (dx / dist) * enemy.speed * deltaTime;
                    enemy.y += (dy / dist) * enemy.speed * deltaTime;
                }
                
                // Keep enemy on screen
                enemy.x = Math.max(enemy.size, Math.min(this.canvas.width - enemy.size, enemy.x));
                enemy.y = Math.max(enemy.size, Math.min(this.canvas.height - enemy.size, enemy.y));
                
                // Boost mode: Destroy enemy ships on contact
                if (this.boostActive && this.checkCollision(enemy, this.player)) {
                    const boostResourceMultiplier = 0.75; // Reduced to half (was 1.5, now 0.75)
                    // Drop resources with boost bonus
                    const dropCount = Math.floor((2 + Math.floor(this.level / 3)) * boostResourceMultiplier);
                    for (let i = 0; i < dropCount; i++) {
                        const rand = Math.random();
                        let itemType;
                        if (rand < 0.5) {
                            itemType = 'quantumParticles';
                        } else {
                            itemType = 'crystals';
                        }
                        const angle = (Math.PI * 2 * i) / dropCount;
                        this.items.push({
                            x: enemy.x + Math.cos(angle) * 30,
                            y: enemy.y + Math.sin(angle) * 30,
                            type: itemType,
                            vx: Math.cos(angle) * 150,
                            vy: Math.sin(angle) * 150,
                            lifetime: 5,
                            collected: false,
                            createdTime: this.time,
                            size: 8,
                            framesSinceCreation: 0
                        });
                    }
                    this.score += 20 * boostResourceMultiplier;
                    // Double tokens for enemy ships (Bell mode bonus) + boost bonus
                    const tokenMultiplier = 2 * boostResourceMultiplier;
                    this.inventory.tokens += Math.floor((5 + this.level * 2) * tokenMultiplier);
                    this.audio.playSFX('enemyDestroy', 0.8);
                    this.createExplosion(enemy.x, enemy.y);
                    return false; // Remove enemy
                }
                
                return enemy.health > 0;
            });
            
            // Enemy shooting and spawning
            const now = Date.now();
            
            // Spawn enemy ships - max ships based on level (1 at start, +1 every 10 levels)
            const maxEnemyShips = Math.floor(this.level / 10) + 1; // Level 1-9: 1 ship, 10-19: 2 ships, 20-29: 3 ships, etc.
            
            if (now - this.lastEnemySpawn > this.enemySpawnRate && this.enemyShips.length < maxEnemyShips) {
                this.spawnEnemyShip();
                this.lastEnemySpawn = now;
            }
            
            // Enemy shooting - fire rate scales with player power
            // Base fire rate starts at 2500ms (2.5 seconds - slower at first)
            // As player gets stronger, enemies fire more frequently
            const difficulty = this.calculateEnemyDifficulty();
            const baseFireRate = 2500; // Start slower (2.5 seconds between shots)
            // Lower difficulty = slower fire rate, higher difficulty = faster fire rate
            // Inverse relationship: difficulty 0.5 = 5000ms, difficulty 2.0 = 1250ms
            const dynamicFireRate = baseFireRate / difficulty;
            
            if (now - this.lastEnemyShot > dynamicFireRate) {
                this.enemyShips.forEach(enemy => {
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        const angle = Math.atan2(dy, dx);
                        // Shoot from front tip of ship (front is at -enemySize * 1.2 in ship's local coordinates)
                        // After rotation, front tip is at angle from center
                        const frontOffset = enemy.size * 1.2; // Distance from center to front tip
                        const bulletX = enemy.x + Math.cos(angle) * frontOffset;
                        const bulletY = enemy.y + Math.sin(angle) * frontOffset;
                        this.enemyBullets.push({
                            x: bulletX,
                            y: bulletY,
                            vx: Math.cos(angle) * 400,
                            vy: Math.sin(angle) * 400,
                            color: '#f44336',
                            size: 4,
                            damage: 15,
                            lifetime: 3
                        });
                    }
                });
                this.lastEnemyShot = now;
            }
        }
        // When not in Bell mode, enemy ships persist in memory but don't update
        // They'll resume exactly where they were when you switch back to Bell mode
        
        // Update boss enemies (only in boss mode)
        if (this.bossMode) {
            this.updateBossEnemies(deltaTime);
        }
        
        // Update enemy bullets
        this.enemyBullets = this.enemyBullets.filter(bullet => {
            bullet.x += bullet.vx * deltaTime;
            bullet.y += bullet.vy * deltaTime;
            bullet.lifetime -= deltaTime;
            
            // Check collision with player
            if (this.checkCollision(bullet, this.player)) {
                // Boost mode: Invincibility - remove bullet but don't apply damage
                if (this.boostActive) {
                    return true; // Remove bullet but don't apply damage
                }
                // Dev mode: God mode protection
                if (this.devMode && this.devGodMode) {
                    return true; // Remove bullet but don't apply damage
                }
                
                let damage = bullet.damage;
                const ship = this.equipmentStats.ships[this.currentShip];
                // Safety check: ensure ship exists
                if (!ship) {
                    console.warn(`[Ship] Ship '${this.currentShip}' not found during bullet damage`);
                    // Fallback to basic ship
                    this.currentShip = 'basic';
                    if (!this.ownedItems.ships.basic) {
                        this.ownedItems.ships.basic = { count: 1, durability: 100 };
                    }
                    return true; // Remove bullet but don't apply damage
                }
                
                // Apply evasion chance (from upgrades + ship bonus)
                let evasionChance = this.playerStats.evasion / 100;
                if (ship.bonus === 'evasion') {
                    evasionChance += 0.2; // +20% from ship bonus
                }
                evasionChance = Math.min(0.3, evasionChance); // Cap at 30%
                
                if (Math.random() < evasionChance) {
                    damage = 0; // Dodged!
                } else {
                    // Apply damage reduction (from upgrades + ship bonus)
                    let damageReduction = this.playerStats.damageReduction / 100;
                    if (ship.bonus === 'damageResist') {
                        damageReduction += 0.3; // +30% from ship bonus
                    }
                    damageReduction = Math.min(0.5, damageReduction); // Cap at 50%
                    damage = damage * (1 - damageReduction);
                }
                
                // Apply damage to shield first, then health
                if (this.playerStats.shield > 0) {
                    const shieldDamage = damage;
                    const remainingDamage = Math.max(0, damage - this.playerStats.shield);
                    this.playerStats.shield = Math.max(0, this.playerStats.shield - damage);
                    
                    // Apply damage-based decay to shield (real-time)
                    if (this.currentShield !== 'none' && shieldDamage > 0) {
                        this.applyDamageDecay('shields', this.currentShield, shieldDamage);
                    }
                    
                    if (remainingDamage > 0) {
                        this.playerStats.health = Math.max(0, this.playerStats.health - remainingDamage);
                        
                        // Apply damage-based decay to ship (real-time)
                        if (remainingDamage > 0) {
                            this.applyDamageDecay('ships', this.currentShip, remainingDamage);
                        }
                    }
                    if (this.playerStats.shield <= 0 && this.currentShield !== 'none') {
                        // Remove destroyed shield from inventory
                        const currentCount = this.getItemCount('shields', this.currentShield);
                        if (currentCount > 0) {
                            this.setItemCount('shields', this.currentShield, currentCount - 1);
                        }
                        this.currentShield = 'none';
                        this.playerStats.maxShield = 0;
                    }
                } else {
                    this.playerStats.health = Math.max(0, this.playerStats.health - damage);
                    
                    // Apply damage-based decay to ship (real-time)
                    if (damage > 0) {
                        this.applyDamageDecay('ships', this.currentShip, damage);
                    }
                }
                
                this.createExplosion(bullet.x, bullet.y);
                
                // Safety check: Only die if health is actually 0 or less AND we're not in boost mode
                // Also ensure we have a valid ship (can't die from no ship)
                if (this.playerStats.health <= 0 && !this.boostActive) {
                    // Double-check: ensure we actually have health (prevent false deaths)
                    if (this.playerStats.health <= 0 && this.playerStats.maxHealth > 0) {
                        // Check if save feature is unlocked - if so, automatically revert to saved state
                        if (this.hiddenSequence.saveUnlocked) {
                            // Automatically revert to saved state (2 levels back) on death
                            if (this.revertToSavedState()) {
                                console.log('Automatically reverted to saved state on death!');
                                return; // Don't go to game over screen
                            }
                        }
                        
                        // If save feature not unlocked or revert failed, go to game over
                        this.deathReason = 'health'; // Died from health reaching 0
                        // Clear movement keys when game over to prevent ship from moving
                        this.clearMovementKeys();
                        this.gameState = 'gameover';
                        setTimeout(async () => {
                            if (!this.playerName) {
                                this.showNameInput();
                            } else {
                                await this.submitScore();
                            }
                        }, 500);
                    }
                }
                
                return false; // Remove enemy bullet (hit player)
            }
            
            if (bullet.x < 0 || bullet.x > this.canvas.width ||
                bullet.y < 0 || bullet.y > this.canvas.height ||
                bullet.lifetime <= 0) {
                return false; // Remove enemy bullet (off screen or expired)
            }
            
            return true; // Keep enemy bullet alive
        });
        
        // Spawn new targets and obstacles (not during boss battles)
        if (!this.bossMode) {
            const now = Date.now();
            if (now - this.lastTargetSpawn > this.targetSpawnRate) {
                this.spawnTarget();
                this.lastTargetSpawn = now;
            }
            if (now - this.lastObstacleSpawn > this.obstacleSpawnRate) {
                this.spawnObstacle();
                this.lastObstacleSpawn = now;
            }
        }
        
        // Update boss entities (handle rotations and check defeat)
        if (this.bossMode && this.currentBoss) {
            this.obstacles.forEach(obstacle => {
                if (!obstacle.isBoss || obstacle.health <= 0) return;
                
                // Neurotransmitter boss: vesicles orbit around neuron
                if (obstacle.bossType === 'neurotransmitter' && obstacle.bossPart === 'vesicle') {
                    obstacle.angle += deltaTime * 0.5; // Rotate slowly
                    obstacle.x = obstacle.parentX + Math.cos(obstacle.angle) * obstacle.distance;
                    obstacle.y = obstacle.parentY + Math.sin(obstacle.angle) * obstacle.distance;
                }
                
                // Protein Complex boss: subunits orbit around core
                if (obstacle.bossType === 'proteinComplex' && obstacle.bossPart === 'subunit') {
                    obstacle.angle += deltaTime * 0.3; // Rotate slowly
                    obstacle.x = obstacle.parentX + Math.cos(obstacle.angle) * obstacle.distance;
                    obstacle.y = obstacle.parentY + Math.sin(obstacle.angle) * obstacle.distance;
                }
            });
            
            // Check if boss is defeated (core destroyed)
            // OPTIMIZATION: Cache boss core references to avoid find() every frame
            let bossDefeated = false;
            if (!this._cachedBossCore || this._cachedBossCore.health <= 0) {
                // Cache is invalid or boss core destroyed - refresh cache
                if (this.currentBoss.bossType === 'neurotransmitter') {
                    this._cachedBossCore = this.obstacles.find(o => o.isBoss && o.bossPart === 'neuron');
                } else if (this.currentBoss.bossType === 'dnaHelix') {
                    this._cachedBossCore = this.obstacles.find(o => o.isBoss && o.bossPart === 'core' && o.bossType === 'dnaHelix');
                } else if (this.currentBoss.bossType === 'proteinComplex') {
                    this._cachedBossCore = this.obstacles.find(o => o.isBoss && o.bossPart === 'core' && o.bossType === 'proteinComplex');
                } else if (this.currentBoss.bossType === 'cellMembrane') {
                    this._cachedBossCore = this.obstacles.find(o => o.isBoss && o.bossPart === 'nucleus');
                } else if (this.currentBoss.bossType === 'advanced') {
                    this._cachedBossCore = this.currentBoss;
                }
            }
            
            // Check if boss is defeated using cached reference
            if (this.currentBoss.bossType === 'advanced') {
                bossDefeated = !this.currentBoss || this.currentBoss.health <= 0;
            } else {
                bossDefeated = !this._cachedBossCore || this._cachedBossCore.health <= 0;
            }
            
            if (bossDefeated) {
                // Boss defeated! Exit boss mode
                this.exitBossMode();
            }
        }
        
        // Optimized: Batch updateStats - only update once per frame if needed
        if (this._statsNeedsUpdate) {
            this.updateStats();
            this._statsNeedsUpdate = false;
        }
    }

    checkCollision(obj1, obj2) {
        // Optimized: Avoid sqrt by comparing squared distances
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const minDist = (obj1.size || 10) + (obj2.size || 10);
        const minDistSquared = minDist * minDist;
        return (dx * dx + dy * dy) < minDistSquared;
    }
    
    // Strict collision check for material collection - requires actual contact
    // OPTIMIZATION: Removed sqrt - using squared distance comparison
    checkMaterialCollection(item, player) {
        // Ensure both objects have valid positions and sizes
        if (!item || !player || item.x === undefined || item.y === undefined || 
            player.x === undefined || player.y === undefined) {
            return false;
        }
        
        // Get sizes (items have size: 8 = radius, player size = radius)
        // Items are drawn with radius 8 (see drawItems: ctx.arc(..., 8, ...))
        // Player size is the radius (see drawPlayer: shipSize is used as radius)
        const itemRadius = item.size || 8;
        const playerRadius = this.getPlayerCollisionRadius(player);
        
        // Calculate squared distance between centers (avoid sqrt for performance)
        const dx = item.x - player.x;
        const dy = item.y - player.y;
        const distanceSquared = dx * dx + dy * dy;
        
        // Only collect if item is actually touching the player (distance <= sum of radii)
        // Add a small buffer (0.5 pixels) to ensure items must be very close to touch
        // This prevents collection when items are just barely overlapping visually
        const collisionDistance = itemRadius + playerRadius - 0.5;
        const collisionDistanceSquared = collisionDistance * collisionDistance;
        return distanceSquared <= collisionDistanceSquared;
    }
    
    // Strict collision check for obstacles - requires actual contact/overlap (precise for skilled players)
    // OPTIMIZATION: Removed sqrt - using squared distance comparison
    checkObstacleCollision(obstacle, player) {
        // Ensure both objects have valid positions and sizes
        if (!obstacle || !player || obstacle.x === undefined || obstacle.y === undefined || 
            player.x === undefined || player.y === undefined) {
            return false;
        }
        
        // Calculate player's actual collision radius based on ship shape
        // The player.size is the base radius, but different ship shapes extend differently
        const playerRadius = this.getPlayerCollisionRadius(player);
        
        // Check collision with each individual atom, not the molecule center
        // This ensures damage only occurs when the player actually touches a visible atom
        if (obstacle.atoms && obstacle.atoms.length > 0) {
            // Calculate health scaling factor
            const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
            
            // OPTIMIZATION: Use for loop instead of for...of for better performance
            const atomCount = obstacle.atoms.length;
            for (let i = 0; i < atomCount; i++) {
                const atom = obstacle.atoms[i];
                // Calculate world position of atom (atoms are relative to obstacle center)
                const atomWorldX = obstacle.x + atom.x;
                const atomWorldY = obstacle.y + atom.y;
                
                // Atom radius scaled by health
                const atomRadius = (atom.radius || 0) * healthPercent;
                
                // Skip if atom has no size (destroyed)
                if (atomRadius <= 0) continue;
                
                // Calculate squared distance from player center to atom center (avoid sqrt for performance)
                const dx = atomWorldX - player.x;
                const dy = atomWorldY - player.y;
                const distanceSquared = dx * dx + dy * dy;
                
                // Check if this atom is touching the player
                // Use a small buffer (1 pixel) to ensure collision only happens on actual visual contact
                const collisionDistance = atomRadius + playerRadius - 1.0;
                const collisionDistanceSquared = collisionDistance * collisionDistance;
                if (distanceSquared <= collisionDistanceSquared) {
                    return true; // Collision detected with this atom
                }
            }
            return false; // No collision with any atom
        } else {
            // Fallback for obstacles without atoms (shouldn't happen for regular molecules)
            // Use a conservative percentage of size to match visual appearance
            const obstacleRadius = (obstacle.size || 10) * 0.85;
        
            // Calculate squared distance between centers (avoid sqrt for performance)
            const dx = obstacle.x - player.x;
            const dy = obstacle.y - player.y;
            const distanceSquared = dx * dx + dy * dy;
        
            // Check for actual contact
            const collisionDistance = obstacleRadius + playerRadius - 1.0;
            const collisionDistanceSquared = collisionDistance * collisionDistance;
            return distanceSquared <= collisionDistanceSquared;
        }
    }
    
    // Calculate player's actual collision radius based on ship shape
    // This ensures collision matches the visual appearance of the ship
    getPlayerCollisionRadius(player) {
        const ship = this.equipmentStats.ships[this.currentShip];
        const shipSize = player.size || 20;
        
        if (!ship) return shipSize;
        
        // Calculate maximum extent from center to edge for each ship shape
        // This matches the visual drawing code above
        if (this.currentShip === 'basic') {
            // Atomic Fighter (compact fighter jet style): extends 1.0 forward (nose), 0.8 backward (tail), 1.15 sideways (rocket pods)
            // Maximum extent is rocket pods: shipSize * 1.15 (widest point)
            return shipSize * 1.15; // Rocket pods on wings make it widest
        } else if (this.currentShip === 'individualStabilizer') {
            // Individual Stabilizer: extends 1.4 forward, 0.7 backward, 0.65 sideways
            // Maximum extent is forward: shipSize * 1.4
            return shipSize * 1.4;
        } else if (ship.shape === 'triangle' || !ship.shape) {
            // Legacy triangle shape: extends 1.1 * shipSize forward, 0.8 backward, 0.7 sideways
            return shipSize * 1.1;
        } else if (ship.shape === 'sleek') {
            // Atomic Fighter (basic): extends 1.4 forward (sharp nose), 1.0 backward (tail), 1.05 sideways (rocket pods)
            if (this.currentShip === 'basic') {
                return Math.max(ship.size * 1.4, ship.size * 1.0, ship.size * 1.05);
            }
            // Enhanced sleek ship: extends 1.3 forward (sharp nose), 0.6 backward (tail), 0.4 sideways
            // Maximum extent is forward: shipSize * 1.3
            return shipSize * 1.3;
        } else if (ship.shape === 'rapid') {
            // Enhanced rapid ship: extends 1.5 forward (ultra-sharp nose), 0.7 backward (tail), 0.5 sideways (wing tips)
            // Maximum extent is forward: shipSize * 1.5
            return shipSize * 1.5;
        } else if (ship.shape === 'wide') {
            // Enhanced tank ship: extends 0.9 backward, 1.05 sideways (widest point)
            // Maximum extent is sideways: shipSize * 1.05
            return shipSize * 1.05;
        } else if (this.currentShip === 'completeDescriptionVessel') {
            // Complete Description Vessel: extends 1.2 forward, 0.95 backward, 0.8 sideways
            // Maximum extent is forward: shipSize * 1.2
            return shipSize * 1.2;
        } else if (ship.shape === 'diamond') {
            // Enhanced agile ship: extends 1.1 forward, 0.9 backward, 0.85 sideways
            // Maximum extent is forward: shipSize * 1.1
            return shipSize * 1.1;
        }
        
        // Default fallback
        return shipSize;
    }

    // OPTIMIZATION: Helper function to create particles using object pooling
    createParticle(x, y, vx, vy, color, size, lifetime, maxLifetime) {
        // Get particle from pool or create new one
        let particle = this._particlePool.pop();
        if (!particle) {
            particle = {};
        }
        
        // Set particle properties
        particle.x = x;
        particle.y = y;
        particle.vx = vx;
        particle.vy = vy;
        particle.color = color;
        particle.size = size;
        particle.lifetime = lifetime;
        particle.maxLifetime = maxLifetime;
        particle.alpha = 1;
        
        return particle;
    }

    createExplosion(x, y) {
        // Check if explosions are enabled
        if (!this.settings.showExplosions) return;
        
        // Enhanced explosion with more particles and variety
        const particleCount = 15;
        for (let i = 0; i < particleCount; i++) {
            const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
            const speed = 150 + Math.random() * 150;
            
            // Color variation - orange to red to yellow
            const hue = 15 + Math.random() * 45; // Orange to red range
            const saturation = 80 + Math.random() * 20;
            const lightness = 40 + Math.random() * 20;
            
            // OPTIMIZATION: Use object pooling for particles
            const particle = this.createParticle(
                x, y,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed,
                `hsl(${hue}, ${saturation}%, ${lightness}%)`,
                Math.random() * 6 + 3,
                0.6 + Math.random() * 0.4,
                0.6 + Math.random() * 0.4
            );
            this.particles.push(particle);
        }
        
        // Add some bright core particles
        for (let i = 0; i < 5; i++) {
            // OPTIMIZATION: Use object pooling for particles
            const particle = this.createParticle(
                x, y,
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100,
                '#ffeb3b', // Bright yellow
                Math.random() * 4 + 2,
                0.3 + Math.random() * 0.2,
                0.3 + Math.random() * 0.2
            );
            this.particles.push(particle);
        }
    }

    toggleCrafting() {
        // Only allow crafting during level-up
        if (!this.levelUpState) {
            return; // Can't craft during gameplay
        }
        
        if (this.gameState === 'crafting') {
            // Don't allow closing during level-up, must use "Continue" button
            return;
        } else {
            // Clear movement keys when opening crafting menu to prevent ship from moving
            this.clearMovementKeys();
            this.gameState = 'crafting';
            this.showCraftingUI();
        }
    }

    toggleShop() {
        // Only allow shop during level-up
        if (!this.levelUpState) {
            return; // Can't shop during gameplay
        }
        
        if (this.gameState === 'shop') {
            // Don't allow closing during level-up, must use "Continue" button
            return;
        } else {
            // Clear movement keys when opening shop menu to prevent ship from moving
            this.clearMovementKeys();
            this.gameState = 'shop';
            this.showShopUI();
        }
    }
    
    // Survival System Functions
    updateSurvivalSystem(deltaTime) {
        // Update hunger decay
        const now = Date.now();
        const timeSinceLastDecay = (now - this.lastHungerDecay) / 1000; // Convert to seconds
        if (timeSinceLastDecay >= 1.0) {
            this.hunger = Math.max(0, this.hunger - this.hungerDecayRate);
            this.lastHungerDecay = now;
            
            // If hunger reaches 0, player dies immediately
            if (this.hunger <= 0) {
                // Instant death when hunger reaches 0
                // Prevent false deaths during boost or invalid states
                if (!this.boostActive && this.gameState === 'playing') {
                    this.deathReason = 'hunger'; // Died from starvation
                    this.gameState = 'gameover';
                }
            }
        }
        
        // Update boost - deplete methane over time
        if (this.boostActive) {
            // Deplete methane at a rate of 20 per second (100 methane = 5 seconds of boost)
            // deltaTime is already in seconds, so multiply directly
            const depletionRate = 20; // methane per second
            const methaneDepleted = depletionRate * deltaTime;
            this.methane = Math.max(0, this.methane - methaneDepleted);
            
            // Boost ends when methane is depleted
            if (this.methane <= 0) {
                this.boostActive = false;
                this.boostCooldown = 5000; // 5 second cooldown after boost ends (in milliseconds)
                this.methane = 0; // Ensure it's exactly 0
            }
        }
        
        // Update boost cooldown (cooldown is in milliseconds, deltaTime is in seconds)
        if (this.boostCooldown > 0) {
            this.boostCooldown -= deltaTime * 1000; // Convert deltaTime to milliseconds
            if (this.boostCooldown < 0) {
                this.boostCooldown = 0;
            }
        }
    }
    
    // Activate boost (uses methane)
    // Works with ANY amount of methane - duration scales with amount
    // Methane depletes over time while boosting
    activateBoost() {
        if (this.methane > 0 && !this.boostActive && this.boostCooldown <= 0) {
            // Activate boost - methane will deplete over time
            this.boostActive = true;
            this.audio.playSFX('quantum'); // Play boost sound
        }
    }
    
    // Eat food item
    eatFood(foodName) {
        if (!this.foodInventory[foodName] || this.foodInventory[foodName] <= 0) {
            return false; // No food available
        }
        
        const foodData = {
            basicMeal: { hunger: 20, methane: 0 },
            proteinBar: { hunger: 35, methane: 0 },
            energyDrink: { hunger: 35, methane: 5 }, // Improved from 30 to 35 for better efficiency
            balancedMeal: { hunger: 50, methane: 0 },
            superFood: { hunger: 100, methane: 15 }, // Improved from 80 to 100 for better efficiency
            methaneSnack: { hunger: 10, methane: 10 }
        };
        
        const food = foodData[foodName];
        if (!food) return false;
        
        // Restore hunger
        this.hunger = Math.min(this.maxHunger, this.hunger + food.hunger);
        
        // Add methane
        if (food.methane > 0) {
            this.methane = Math.min(this.maxMethane, this.methane + food.methane);
        }
        
        // Consume food item
        this.foodInventory[foodName]--;
        if (this.foodInventory[foodName] <= 0) {
            delete this.foodInventory[foodName];
        }
        
        this.audio.playSFX('healthPickup'); // Play eating sound
        this.updateInventoryUI(); // Update inventory to reflect consumed food
        return true;
    }
    
    // Craft food item
    craftFood(foodName) {
        if (!this.survivalUnlocked) {
            return false;
        }
        
        const recipe = this.recipes.consumables[foodName];
        if (!recipe) return false;
        
        // Check if we have all required materials (handle undefined as 0)
        for (let material in recipe) {
            const currentAmount = this.inventory[material] || 0;
            if (currentAmount < recipe[material]) {
                return false;
            }
        }
        
        // Consume materials (ensure material exists in inventory first)
        for (let material in recipe) {
            if (!this.inventory[material]) {
                this.inventory[material] = 0;
            }
            this.inventory[material] -= recipe[material];
            // Ensure it doesn't go negative
            if (this.inventory[material] < 0) {
                this.inventory[material] = 0;
            }
        }
        
        // Add food to inventory
        if (!this.foodInventory[foodName]) {
            this.foodInventory[foodName] = 0;
        }
        this.foodInventory[foodName]++;
        
        this.audio.playSFX('craft');
        this.updateCraftingUI();
        return true;
    }
    
    showLevelUpMenu() {
        // Show level-up menu with crafting and shop options
        // OPTIMIZATION: Use cached DOM elements
        const craftingUI = this._cachedElements.craftingUI;
        const shopUI = this._cachedElements.shopUI;
        
        // Check if UI elements exist
        if (!craftingUI) {
            console.error('[LevelUp] craftingUI element not found! Make sure it exists in the HTML.');
        }
        if (!shopUI) {
            console.error('[LevelUp] shopUI element not found! Make sure it exists in the HTML.');
        }
        
        if (!craftingUI || !shopUI) {
            console.error('[LevelUp] Cannot show level-up menu - UI elements missing!');
            // Don't set level-up state if UI elements don't exist
            this.levelUpState = false;
            this.gameState = 'playing';
            return;
        }
        
        // Add level-up class to body for side-by-side layout
        document.body.classList.add('level-up');
        
        // Show crafting UI by default
        craftingUI.classList.add('active');
        shopUI.classList.add('active');
        
        // Show score display during level up
        // OPTIMIZATION: Use cached DOM element
        const scoreEl = this._cachedElements.score;
        if (scoreEl) {
            scoreEl.style.display = 'block';
        }
        
        // Show bottom continue button UI
        // OPTIMIZATION: Use cached DOM element
        const continueUI = this._cachedElements.levelUpContinueUI;
        if (continueUI) {
            continueUI.style.display = 'block';
        }
        
        this.gameState = 'levelup';
        
        // Clear movement keys when opening level-up menu to prevent ship from moving
        this.clearMovementKeys();
        
        // Survival system is now unlocked at game start, no need to unlock here
        
        this.updateCraftingUI();
        this.updateShopUI();
        
        // Reset menu navigation and highlight first item
        this.menuSelectedIndex = { crafting: 0, shop: 0 };
        // OPTIMIZATION: Don't auto-scroll on level-up menu start - preserve user's scroll position
        // Removed scrollIntoView to prevent auto-scrolling when menu opens
        setTimeout(() => {
            // Highlight first available button after UI updates (without scrolling)
            const firstButton = document.querySelector('#craftingUI .craft-btn:not([disabled]), #shopUI .craft-btn:not([disabled])');
            if (firstButton) {
                firstButton.classList.add('gamepad-selected');
                // Don't scroll - let user stay where they are
                // firstButton.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }, 100);
        
        console.log('[LevelUp] Level-up menu shown successfully');
    }
    
    continueFromLevelUp() {
        // Close level-up menu and resume gameplay
        this.levelUpState = false;
        this.gameState = 'playing';
        
        // Remove level-up class from body
        document.body.classList.remove('level-up');
        
        // OPTIMIZATION: Use cached DOM elements
        const craftingUI = this._cachedElements.craftingUI;
        const shopUI = this._cachedElements.shopUI;
        // OPTIMIZATION: Use cached DOM element
        const continueUI = this._cachedElements.levelUpContinueUI;
        const scoreEl = this._cachedElements.score;
        
        if (craftingUI) {
            craftingUI.classList.remove('active');
        }
        if (shopUI) {
            shopUI.classList.remove('active');
        }
        if (continueUI) {
            continueUI.style.display = 'none';
        }
        // Hide score display when leaving level up menu
        if (scoreEl) {
            scoreEl.style.display = 'none';
        }
        
        // Clear gamepad selection highlights
        this.clearGamepadSelection();
    }
    
    clearGamepadSelection() {
        // Clear all gamepad selection highlights
        document.querySelectorAll('.gamepad-selected').forEach(item => {
            item.classList.remove('gamepad-selected');
        });
        
        // Re-highlight first available button after UI updates
        if (this.gameState === 'levelup') {
            setTimeout(() => {
                const firstButton = document.querySelector('#craftingUI .craft-btn:not([disabled]), #shopUI .craft-btn:not([disabled]), #levelUpContinueUI button[onclick*="continueFromLevelUp"]');
                if (firstButton) {
                    firstButton.classList.add('gamepad-selected');
                    // OPTIMIZATION: Don't auto-scroll - preserve user's scroll position
                    // firstButton.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 50);
        }
    }
    
    clearMovementKeys() {
        // Clear all movement keys to prevent ship from continuing to move when menus open
        this.keys['KeyW'] = false;
        this.keys['KeyS'] = false;
        this.keys['KeyA'] = false;
        this.keys['KeyD'] = false;
        this.keys['ArrowUp'] = false;
        this.keys['ArrowDown'] = false;
        this.keys['ArrowLeft'] = false;
        this.keys['ArrowRight'] = false;
    }
    
    toggleInventory() {
        // OPTIMIZATION: Use cached DOM element
        const ui = this._cachedElements.inventoryUI;
        if (!ui) return;
        
        if (this.gameState === 'inventory') {
            this.gameState = 'playing';
            ui.classList.remove('active');
            
            // CRITICAL: Reset game loop timing when closing inventory to prevent lag
            // This ensures deltaTime doesn't become huge after being in inventory
            this.lastTime = performance.now();
            
            // Activate resume smoothing to gradually resume effects/bullets
            this.resumeSmoothing.active = true;
            this.resumeSmoothing.framesRemaining = 3;
        } else {
            // Clear movement keys when opening inventory to prevent ship from moving
            this.clearMovementKeys();
            this.gameState = 'inventory';
            ui.classList.add('active');
            this.updateInventoryUI();
        }
    }
    
    showInventoryUI() {
        this.toggleInventory();
    }
    
    showTutorial() {
        // OPTIMIZATION: Use cached DOM element
        const ui = this._cachedElements.tutorialUI;
        if (!ui) return;
        
        // Close other UIs (but keep game state unchanged - tutorial is just an overlay)
        // OPTIMIZATION: Use cached DOM elements
        this._cachedElements.craftingUI?.classList.remove('active');
        this._cachedElements.shopUI?.classList.remove('active');
        this._cachedElements.inventoryUI?.classList.remove('active');
        this._cachedElements.leaderboardUI?.classList.remove('active');
        this._cachedElements.settingsUI?.classList.remove('active');
        
        // Show tutorial - this is just a UI overlay, doesn't change game state
        // The game continues to render in the background (paused or playing)
        ui.classList.add('active');
        
        // Reset to first tab
        this.switchTutorialTab('basics');
    }
    
    hideTutorial() {
        // OPTIMIZATION: Use cached DOM element
        const ui = this._cachedElements.tutorialUI;
        if (!ui) return;
        
        // Just hide the tutorial UI - don't change game state
        // The game state remains whatever it was before (paused or playing)
        ui.classList.remove('active');
    }
    
    switchTutorialTab(tabName) {
        // Hide all tabs
        const tabs = document.querySelectorAll('.tutorial-tab');
        const contents = document.querySelectorAll('.tutorial-content');
        
        tabs.forEach(tab => tab.classList.remove('active'));
        contents.forEach(content => content.classList.remove('active'));
        
        // Show selected tab
        const selectedTab = Array.from(tabs).find(tab => tab.onclick?.toString().includes(tabName));
        const selectedContent = document.getElementById(`tutorial-${tabName}`);
        
        if (selectedTab) selectedTab.classList.add('active');
        if (selectedContent) selectedContent.classList.add('active');
    }
    
    updateInventoryUI() {
        // Update player stats display
        this.updatePlayerStatsDisplay();
        
        // OPTIMIZATION: Use cached DOM elements
        const weaponsList = this._cachedElements.inventoryWeaponsList;
        const shipsList = this._cachedElements.inventoryShipsList;
        const shieldsList = this._cachedElements.inventoryShieldsList;
        
        if (weaponsList) {
            weaponsList.innerHTML = '';
            for (let weapon in this.ownedItems.weapons) {
                const count = this.getItemCount('weapons', weapon);
                const durability = this.getItemDurability('weapons', weapon);
                if (count <= 0) continue;
                
                const weaponStats = this.equipmentStats.weapons[weapon];
                const isEquipped = this.currentWeapons.includes(weapon);
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: ${isEquipped ? '#4fc3f7' : '#fff'};">
                            ${weapon.toUpperCase()} ${isEquipped ? '(EQUIPPED)' : ''}
                        </strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Fire Rate: ${weaponStats.fireRate}/s | Damage: ${weaponStats.damage}
                            ${weaponStats.automatic ? '| Automatic' : ''}
                            ${weaponStats.spread ? '| Spread: ' + weaponStats.spread : ''}
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Owned: ${count} | Durability: ${Math.round(durability)}%
                        </div>
                    </div>
                    <div>
                        <button class="craft-btn" ${isEquipped ? 'disabled' : ''} onclick="game.equip('weapons', '${weapon}'); game.updateInventoryUI();" style="margin-right: 5px;">
                            ${isEquipped ? 'Equipped' : 'Equip'}
                        </button>
                        ${isEquipped ? `<button class="craft-btn" onclick="game.unequip('weapons', '${weapon}'); game.updateInventoryUI();" style="background: #f44336;">Unequip</button>` : ''}
                    </div>
                `;
                weaponsList.appendChild(item);
            }
        }
        
        if (shipsList) {
            shipsList.innerHTML = '';
            for (let ship in this.ownedItems.ships) {
                const count = this.getItemCount('ships', ship);
                const durability = this.getItemDurability('ships', ship);
                if (count <= 0) continue;
                
                const shipStats = this.equipmentStats.ships[ship];
                const isEquipped = this.currentShip === ship;
                const bonusText = shipStats.bonus === 'speedBoost' ? '⚡ Speed Boost' : 
                                 shipStats.bonus === 'rapidFire' ? '🔥 Rapid Fire' :
                                 shipStats.bonus === 'damageResist' ? '🛡️ Damage Resist' :
                                 shipStats.bonus === 'evasion' ? '✨ Evasion' : '';
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: ${isEquipped ? '#4fc3f7' : '#fff'};">
                            ${ship.toUpperCase()} ${isEquipped ? '(EQUIPPED)' : ''}
                        </strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Speed: ${shipStats.speed} | Health: ${shipStats.health} ${bonusText ? '| ' + bonusText : ''}
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Owned: ${count} | Durability: ${Math.round(durability)}%
                        </div>
                    </div>
                    <div>
                        <button class="craft-btn" ${isEquipped ? 'disabled' : ''} onclick="game.equip('ships', '${ship}'); game.updateInventoryUI();" style="margin-right: 5px;">
                            ${isEquipped ? 'Equipped' : 'Equip'}
                        </button>
                        ${isEquipped ? `<button class="craft-btn" onclick="game.unequip('ships'); game.updateInventoryUI();" style="background: #f44336;">Unequip</button>` : ''}
                    </div>
                `;
                shipsList.appendChild(item);
            }
        }
        
        if (shieldsList) {
            shieldsList.innerHTML = '';
            for (let shield in this.ownedItems.shields) {
                const count = this.getItemCount('shields', shield);
                const durability = this.getItemDurability('shields', shield);
                if (count <= 0) continue;
                
                const shieldStats = this.equipmentStats.shields[shield];
                const isEquipped = this.currentShield === shield;
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: ${isEquipped ? '#4fc3f7' : '#fff'};">
                            ${shield.toUpperCase()} ${isEquipped ? '(EQUIPPED)' : ''}
                        </strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Capacity: ${shieldStats.capacity} ${shieldStats.regen > 0 ? '| Regen: ' + shieldStats.regen + '/s' : '| No Regen'}
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Owned: ${count} | Durability: ${Math.round(durability)}%
                        </div>
                    </div>
                    <div>
                        <button class="craft-btn" ${isEquipped ? 'disabled' : ''} onclick="game.equip('shields', '${shield}'); game.updateInventoryUI();" style="margin-right: 5px;">
                            ${isEquipped ? 'Equipped' : 'Equip'}
                        </button>
                        ${isEquipped ? `<button class="craft-btn" onclick="game.unequip('shields'); game.updateInventoryUI();" style="background: #f44336;">Unequip</button>` : ''}
                    </div>
                `;
                shieldsList.appendChild(item);
            }
            
            // Show "None" option for shields
            const noneItem = document.createElement('div');
            noneItem.className = 'craft-item';
            const isNoneEquipped = this.currentShield === 'none';
            noneItem.innerHTML = `
                <div>
                    <strong style="color: ${isNoneEquipped ? '#4fc3f7' : '#fff'};">
                        NONE ${isNoneEquipped ? '(EQUIPPED)' : ''}
                    </strong>
                    <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                        No shield protection
                    </div>
                </div>
                <button class="craft-btn" ${isNoneEquipped ? 'disabled' : ''} onclick="game.unequip('shields'); game.updateInventoryUI();">
                    ${isNoneEquipped ? 'Equipped' : 'Equip None'}
                </button>
            `;
            shieldsList.appendChild(noneItem);
        }
        
        // Add upgrades section to inventory UI
        // OPTIMIZATION: Use cached DOM element
        const upgradesList = this._cachedElements.inventoryUpgradesList;
        if (upgradesList) {
            upgradesList.innerHTML = '';
            for (let upgrade in this.ownedItems.upgrades) {
                const count = this.getItemCount('upgrades', upgrade);
                const durability = this.getItemDurability('upgrades', upgrade);
                if (count <= 0) continue;
                
                const upgradeStats = this.equipmentStats.upgrades[upgrade];
                const isEquipped = this.currentUpgrades.includes(upgrade);
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: ${isEquipped ? '#4fc3f7' : '#fff'};">
                            ${upgrade.toUpperCase()} ${isEquipped ? '(EQUIPPED)' : ''}
                        </strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            ${upgradeStats.description || 'Upgrade'}
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Owned: ${count} | Durability: ${Math.round(durability)}%
                        </div>
                    </div>
                    <div>
                        <button class="craft-btn" ${isEquipped ? 'disabled' : ''} onclick="game.equip('upgrades', '${upgrade}'); game.updateInventoryUI();" style="margin-right: 5px;">
                            ${isEquipped ? 'Equipped' : 'Equip'}
                        </button>
                        ${isEquipped ? `<button class="craft-btn" onclick="game.unequip('upgrades', '${upgrade}'); game.updateInventoryUI();" style="background: #f44336;">Unequip</button>` : ''}
                    </div>
                `;
                upgradesList.appendChild(item);
            }
            
        }
        
        // Add consumables section to inventory UI
        // OPTIMIZATION: Use cached DOM element
        const consumablesList = this._cachedElements.inventoryConsumablesList;
        if (consumablesList) {
            consumablesList.innerHTML = '';
            let hasConsumables = false;
            
            // Health packs
            if (this.ownedItems.consumables && this.ownedItems.consumables.healthPack && this.ownedItems.consumables.healthPack > 0) {
                hasConsumables = true;
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #fff;">
                            HEALTH PACK
                        </strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Restores 50 HP
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Owned: ${this.ownedItems.consumables.healthPack}
                        </div>
                    </div>
                    <button class="craft-btn" onclick="game.useHealthPack(); game.updateInventoryUI();" style="background: #4caf50;">
                        Use (H)
                    </button>
                `;
                consumablesList.appendChild(item);
            }
            
            // Atom Split
            if (this.ownedItems.consumables && this.ownedItems.consumables.atomSplit && this.ownedItems.consumables.atomSplit > 0) {
                hasConsumables = true;
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #fff;">
                            ATOM SPLIT
                        </strong>
                        <div style="font-size: 0.85em; color: #f44336; margin-top: 3px;">
                            Clears all enemies and obstacles on screen
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Owned: ${this.ownedItems.consumables.atomSplit}
                        </div>
                    </div>
                    <button class="craft-btn" onclick="game.useAtomSplit(); game.updateInventoryUI();" style="background: #f44336;">
                        Use (X)
                    </button>
                `;
                consumablesList.appendChild(item);
            }
            
            // Food items (survival system)
            if (this.survivalUnlocked && this.foodInventory) {
                const foodData = {
                    basicMeal: { name: 'Basic Meal', hunger: 20, color: '#ff9800' },
                    proteinBar: { name: 'Protein Bar', hunger: 35, color: '#ff9800' },
                    energyDrink: { name: 'Energy Drink', hunger: 35, color: '#ff9800' }, // Improved from 30
                    balancedMeal: { name: 'Balanced Meal', hunger: 50, color: '#ff9800' },
                    superFood: { name: 'Super Food', hunger: 100, color: '#ff9800' }, // Improved from 80
                    methaneSnack: { name: 'Methane Snack', hunger: 10, color: '#ff9800' }
                };
                
                for (let foodName in this.foodInventory) {
                    const count = this.foodInventory[foodName];
                    if (count > 0 && foodData[foodName]) {
                        hasConsumables = true;
                        const food = foodData[foodName];
                        const item = document.createElement('div');
                        item.className = 'craft-item';
                        item.innerHTML = `
                            <div>
                                <strong style="color: ${food.color};">
                                    ${food.name.toUpperCase()}
                                </strong>
                                <div style="font-size: 0.85em; color: ${food.color}; margin-top: 3px;">
                                    Restores ${food.hunger} hunger
                                </div>
                                <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                                    Owned: ${count}
                                </div>
                            </div>
                            <button class="craft-btn" onclick="game.eatFood('${foodName}'); game.updateInventoryUI();" style="background: ${food.color};">
                                Eat (E)
                            </button>
                        `;
                        consumablesList.appendChild(item);
                    }
                }
            }
            
            if (!hasConsumables) {
                const noItems = document.createElement('div');
                noItems.style.color = '#aaa';
                noItems.style.textAlign = 'center';
                noItems.style.padding = '20px';
                noItems.textContent = 'No consumables available';
                consumablesList.appendChild(noItems);
            }
        }
        
        // Add tools section to inventory UI (for hammer)
        const toolsList = document.getElementById('inventoryToolsList');
        if (toolsList) {
            toolsList.innerHTML = '';
            
            // Hammer
            if (this.ownedItems.tools && this.ownedItems.tools.hammer) {
                const hammerItem = this.ownedItems.tools.hammer;
                const count = typeof hammerItem === 'object' ? hammerItem.count : hammerItem;
                const durability = this.getItemDurability('tools', 'hammer');
                
                if (count > 0) {
                    const item = document.createElement('div');
                    item.className = 'craft-item';
                    item.innerHTML = `
                        <div>
                            <strong style="color: ${this.hammerEquipped ? '#4fc3f7' : '#fff'};">
                                HAMMER ${this.hammerEquipped ? '(EQUIPPED)' : ''}
                            </strong>
                            <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                                Repairs equipped items (10% per use)
                            </div>
                            <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                                Owned: ${count} | Durability: ${Math.round(durability)}%
                            </div>
                        </div>
                        <div>
                            <button class="craft-btn" ${this.hammerEquipped ? 'disabled' : ''} onclick="game.equipHammer(); game.updateInventoryUI();" style="margin-right: 5px;">
                                ${this.hammerEquipped ? 'Equipped' : 'Equip'}
                            </button>
                            ${this.hammerEquipped ? `<button class="craft-btn" onclick="game.unequipHammer(); game.updateInventoryUI();" style="background: #f44336;">Unequip</button>` : ''}
                        </div>
                    `;
                    toolsList.appendChild(item);
                }
            }
            
            // Show "None" if no tools
            if (!toolsList.hasChildNodes() || toolsList.children.length === 0) {
                const noItems = document.createElement('div');
                noItems.style.color = '#aaa';
                noItems.style.textAlign = 'center';
                noItems.style.padding = '20px';
                noItems.textContent = 'No tools available';
                toolsList.appendChild(noItems);
            }
        }
    }
    
    updatePlayerStatsDisplay() {
        const statsDisplay = document.getElementById('playerStatsDisplay');
        if (!statsDisplay) return;
        
        const stats = this.playerStats;
        const healthBonus = stats.maxHealth - (stats.baseMaxHealth || stats.maxHealth);
        const shieldBonus = stats.maxShield - (stats.baseMaxShield || 0);
        const speedBonus = stats.speed - stats.baseSpeed;
        const fireRateBonus = stats.fireRate - stats.baseFireRate;
        const damageBonus = stats.damage - stats.baseDamage;
        
        statsDisplay.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 15px;">
                <!-- Core Stats -->
                <div style="background: linear-gradient(135deg, rgba(79, 195, 247, 0.15) 0%, rgba(79, 195, 247, 0.05) 100%); padding: 12px; border-radius: 8px; border-left: 3px solid #4fc3f7;">
                    <div style="color: #4fc3f7; font-weight: bold; margin-bottom: 8px; font-size: 0.9em;">Core Stats</div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #f44336;">Health:</span> 
                        <span style="color: #fff; font-weight: bold;">${Math.ceil(stats.health)}/${Math.ceil(stats.maxHealth)}</span>
                        ${healthBonus > 0 ? `<span style="color: #4caf50; font-size: 0.9em;"> (+${Math.ceil(healthBonus)})</span>` : ''}
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #4fc3f7;">Shield:</span> 
                        <span style="color: #fff; font-weight: bold;">${Math.ceil(stats.shield)}/${Math.ceil(stats.maxShield)}</span>
                        ${shieldBonus > 0 ? `<span style="color: #4caf50; font-size: 0.9em;"> (+${Math.ceil(shieldBonus)})</span>` : ''}
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #ffc107;">Speed:</span> 
                        <span style="color: #fff; font-weight: bold;">${Math.ceil(stats.speed)}</span>
                        ${speedBonus > 0 ? `<span style="color: #4caf50; font-size: 0.9em;"> (+${Math.ceil(speedBonus)})</span>` : ''}
                    </div>
                </div>
                
                <!-- Combat Stats -->
                <div style="background: linear-gradient(135deg, rgba(79, 195, 247, 0.15) 0%, rgba(79, 195, 247, 0.05) 100%); padding: 12px; border-radius: 8px; border-left: 3px solid #4fc3f7;">
                    <div style="color: #4fc3f7; font-weight: bold; margin-bottom: 8px; font-size: 0.9em;">Combat Stats</div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #ff9800;">Fire Rate:</span> 
                        <span style="color: #fff; font-weight: bold;">${stats.fireRate.toFixed(2)}/s</span>
                        ${fireRateBonus > 0 ? `<span style="color: #4caf50; font-size: 0.9em;"> (+${fireRateBonus.toFixed(2)})</span>` : ''}
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #f44336;">Damage:</span> 
                        <span style="color: #fff; font-weight: bold;">${Math.ceil(stats.damage)}</span>
                        ${damageBonus > 0 ? `<span style="color: #4caf50; font-size: 0.9em;"> (+${Math.ceil(damageBonus)})</span>` : ''}
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #9c27b0;">Crit Chance:</span> 
                        <span style="color: #fff; font-weight: bold;">${stats.criticalHitChance.toFixed(1)}%</span>
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #9c27b0;">Crit Damage:</span> 
                        <span style="color: #fff; font-weight: bold;">${(stats.criticalHitDamage * 100).toFixed(0)}%</span>
                    </div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                <!-- Defense Stats -->
                <div style="background: linear-gradient(135deg, rgba(79, 195, 247, 0.15) 0%, rgba(79, 195, 247, 0.05) 100%); padding: 12px; border-radius: 8px; border-left: 3px solid #4fc3f7;">
                    <div style="color: #4fc3f7; font-weight: bold; margin-bottom: 8px; font-size: 0.9em;">Defense Stats</div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #4fc3f7;">Shield Capacity:</span> 
                        <span style="color: #fff; font-weight: bold;">+${stats.shieldCapacityBonus.toFixed(1)}%</span>
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #4fc3f7;">Shield Regen:</span> 
                        <span style="color: #fff; font-weight: bold;">+${stats.shieldRegenBonus.toFixed(2)}/s</span>
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #4caf50;">Damage Reduction:</span> 
                        <span style="color: #fff; font-weight: bold;">${stats.damageReduction.toFixed(1)}%</span>
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #ff9800;">Evasion:</span> 
                        <span style="color: #fff; font-weight: bold;">${stats.evasion.toFixed(1)}%</span>
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #4caf50;">Health Regen:</span> 
                        <span style="color: #fff; font-weight: bold;">+${stats.healthRegen.toFixed(2)}/s</span>
                    </div>
                </div>
                
                <!-- Utility Stats -->
                <div style="background: linear-gradient(135deg, rgba(79, 195, 247, 0.15) 0%, rgba(79, 195, 247, 0.05) 100%); padding: 12px; border-radius: 8px; border-left: 3px solid #4fc3f7;">
                    <div style="color: #4fc3f7; font-weight: bold; margin-bottom: 8px; font-size: 0.9em;">Utility Stats</div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #ffc107;">Material Drop:</span> 
                        <span style="color: #fff; font-weight: bold;">+${stats.materialDropRate.toFixed(1)}%</span>
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #ffc107;">Token Drop:</span> 
                        <span style="color: #fff; font-weight: bold;">+${stats.tokenDropRate.toFixed(1)}%</span>
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #9c27b0;">Level Time:</span> 
                        <span style="color: #fff; font-weight: bold;">-${stats.levelTimeReduction.toFixed(1)}%</span>
                    </div>
                    <div style="font-size: 0.85em; color: #ccc; margin: 4px 0;">
                        <span style="color: #4fc3f7;">Projectile Speed:</span> 
                        <span style="color: #fff; font-weight: bold;">+${stats.projectileSpeed.toFixed(1)}%</span>
                    </div>
                </div>
            </div>
        `;
    }
    
    equipHammer() {
        const hammerCount = this.getItemCount('tools', 'hammer');
        if (hammerCount <= 0) {
            return; // No hammer owned
        }
        
        const hammerDurability = this.getItemDurability('tools', 'hammer');
        if (hammerDurability <= 0) {
            return; // Hammer is broken
        }
        
        // Equip hammer (don't toggle, just equip)
        this.hammerEquipped = true;
        this.updateRepairableItems();
    }
    
    unequipHammer() {
        // Unequip hammer
        this.hammerEquipped = false;
        this.repairableItems = [];
        this.endRepairSelection();
    }
    
    toggleLeaderboard() {
        // OPTIMIZATION: Use cached DOM element
        const ui = this._cachedElements.leaderboardUI;
        if (!ui) return;
        
        if (this.gameState === 'leaderboard') {
            this.gameState = this.gameState === 'gameover' ? 'gameover' : 'playing';
            ui.classList.remove('active');
        } else {
            // Clear movement keys when opening leaderboard to prevent ship from moving
            this.clearMovementKeys();
            this.gameState = 'leaderboard';
            ui.classList.add('active');
            this.updateLeaderboardUI();
        }
    }
    
    async updateLeaderboardUI() {
        // Reload leaderboard from server
        await this.loadLeaderboardFromServer();
        
        const leaderboardList = document.getElementById('leaderboardList');
        const playerNameInput = document.getElementById('playerNameInput');
        
        if (playerNameInput) {
            playerNameInput.value = this.playerName || '';
            // Remove old listeners and add new one
            const newInput = playerNameInput.cloneNode(true);
            playerNameInput.parentNode.replaceChild(newInput, playerNameInput);
            newInput.addEventListener('change', (e) => {
                this.playerName = e.target.value.trim();
                this.savePlayerName();
            });
        }
        
        if (leaderboardList) {
            leaderboardList.innerHTML = '';
            
            if (this.leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div style="text-align: center; color: #aaa; padding: 20px;">No scores yet. Be the first!</div>';
                return;
            }
            
            this.leaderboard.forEach((entry, index) => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                const date = new Date(entry.date);
                const dateStr = date.toLocaleDateString();
                const isCurrentPlayer = entry.name === this.playerName;
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                        <div>
                            <strong style="color: ${isCurrentPlayer ? '#4fc3f7' : '#4fc3f7'}; font-size: 1.1em;">
                                #${index + 1} ${entry.name} ${isCurrentPlayer ? ' (You)' : ''}
                            </strong>
                            <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                                Score: ${entry.score} | Level: ${entry.level} | ${dateStr}
                            </div>
                        </div>
                    </div>
                `;
                leaderboardList.appendChild(item);
            });
        }
    }

    upgradeWeapon(weaponName, tier) {
        // Only allow upgrading during level-up
        if (!this.levelUpState) {
            return false;
        }
        
        // Check if player owns the weapon
        if (this.getItemCount('weapons', weaponName) <= 0) {
            return false;
        }
        
        // Check level requirement for omnidirectional upgrade
        if (weaponName === 'automatic' && tier === 1 && this.level < 50) {
            return false; // Omnidirectional requires level 50
        }
        
        // Get current upgrade level (0 = no upgrades)
        const currentLevel = this.weaponUpgrades[weaponName] || 0;
        const requestedTier = tier || (currentLevel + 1);
        
        // ENFORCE SEQUENTIAL UPGRADES: Can only upgrade to the next tier (currentLevel + 1)
        // Cannot skip tiers even if you have materials for later tiers
        if (requestedTier !== currentLevel + 1) {
            return false; // Must upgrade sequentially, cannot skip tiers
        }
        
        // Check if this upgrade tier exists
        const weaponUpgrades = this.recipes.weaponUpgrades[weaponName];
        if (!weaponUpgrades || !weaponUpgrades[requestedTier]) {
            return false; // No more upgrades available
        }
        
        // Check if already at max level
        const maxTier = weaponName === 'automatic' ? 1 : 4; // Auto only has 1 tier, others have 4
        if (currentLevel >= maxTier) {
            return false; // Already at max upgrade
        }
        
        // Get recipe for this tier
        const recipe = weaponUpgrades[requestedTier];
        
        // Check if player has enough materials
        for (let material in recipe) {
            if (this.inventory[material] < recipe[material]) {
                return false;
            }
        }
        
        // Deduct materials
        for (let material in recipe) {
            this.inventory[material] -= recipe[material];
        }
        
        // Upgrade weapon to next tier
        this.weaponUpgrades[weaponName] = requestedTier;
        
        this.updateStats();
        this.updateCraftingUI();
        this.clearGamepadSelection();
        return true;
    }
    
    craft(type, name) {
        // Only allow crafting during level-up
        if (!this.levelUpState) {
            return false;
        }
        
        // Handle consumables separately
        if (type === 'consumables') {
            const recipe = this.recipes.consumables[name];
            if (!recipe) return false;
            
            for (let material in recipe) {
                if (this.inventory[material] < recipe[material]) {
                    return false;
                }
            }
            
            for (let material in recipe) {
                this.inventory[material] -= recipe[material];
            }
            
            // Add to consumables inventory
            if (!this.ownedItems.consumables) {
                this.ownedItems.consumables = {};
            }
            if (!this.ownedItems.consumables[name]) {
                this.ownedItems.consumables[name] = 0;
            }
            this.ownedItems.consumables[name]++;
            
            this.updateStats();
            this.updateCraftingUI();
            return true;
        }
        
        // Handle tools separately (hammer)
        if (type === 'tools') {
            const recipe = this.recipes.tools[name];
            if (!recipe) return false;
            
            // Check level requirements
            if (name === 'hammer' && this.level < 10) {
                return false; // Hammer requires level 10
            }
            
            for (let material in recipe) {
                if (this.inventory[material] < recipe[material]) {
                    return false;
                }
            }
            
            for (let material in recipe) {
                this.inventory[material] -= recipe[material];
            }
            
            // Add to tools inventory (with durability)
            if (!this.ownedItems.tools) {
                this.ownedItems.tools = {};
            }
            if (!this.ownedItems.tools[name]) {
                this.ownedItems.tools[name] = { count: 0, durability: 100 };
            }
            this.ownedItems.tools[name].count++;
            
            this.updateStats();
            this.updateCraftingUI();
            return true;
        }
        
        const recipe = this.recipes[type][name];
        if (!recipe) return false;
        
        // Level requirements for weapons (gate powerful weapons behind level progression)
        if (type === 'weapons') {
            if (name === 'rapid' && this.level < 3) {
                return false; // Rapid requires level 3
            } else if (name === 'spread' && this.level < 5) {
                return false; // Spread requires level 5
            } else if (name === 'laser' && this.level < 10) {
                return false; // Laser requires level 10
            } else if (name === 'automatic' && this.level < 15) {
                return false; // Automatic requires level 15
            } else if (name === 'transformationPredictor' && this.level < 30) {
                return false; // Transformation Predictor requires level 30
            } else if (name === 'deterministicEngine' && this.level < 50) {
                return false; // Deterministic Engine requires level 50
            } else if (name === 'individualSystemCore' && this.level < 75) {
                return false; // Individual System Core requires level 75
            }
        }
        
        // Level requirements for ships
        if (type === 'ships') {
            if (name === 'individualStabilizer' && this.level < 35) {
                return false; // Individual Stabilizer requires level 35
            } else if (name === 'completeDescriptionVessel' && this.level < 60) {
                return false; // Complete Description Vessel requires level 60
            }
        }
        
        // Level requirements for shields
        if (type === 'shields') {
            if (name === 'ontologicalReality' && this.level < 40) {
                return false; // Ontological Reality requires level 40
            } else if (name === 'individualSystemBarrier' && this.level < 70) {
                return false; // Individual System Barrier requires level 70
            }
        }
        
        // Level requirements for upgrades
        if (type === 'upgrades') {
            if (name === 'completeDescriptionMatrix' && this.level < 35) {
                return false; // Complete Description Matrix requires level 35
            } else if (name === 'transformationTimeScanner' && this.level < 40) {
                return false; // Transformation Time Scanner requires level 40
            } else if (name === 'ensembleBypass' && this.level < 65) {
                return false; // Ensemble Bypass requires level 65
            } else if (name === 'individualSystemAmplifier' && this.level < 80) {
                return false; // Individual System Amplifier requires level 80
            }
        }
        
        for (let material in recipe) {
            if (this.inventory[material] < recipe[material]) {
                return false;
            }
        }
        
        for (let material in recipe) {
            this.inventory[material] -= recipe[material];
        }
        
        // Add item to owned items inventory (don't auto-equip)
        if (!this.ownedItems[type]) {
            this.ownedItems[type] = {};
        }
        const currentCount = this.getItemCount(type, name);
        this.setItemCount(type, name, currentCount + 1);
        // Set durability to 100 for newly crafted items
        this.setItemDurability(type, name, 100);
        
        this.updateStats();
        this.updateCraftingUI();
        this.clearGamepadSelection(); // Re-highlight after weapon upgrade
        return true;
    }
    
    equip(type, name) {
        if (this.getItemCount(type, name) <= 0) {
            return false; // Don't own this item
        }
        
        if (type === 'weapons') {
            // Prevent basic weapon from being equipped if other weapons are owned
            if (name === 'basic') {
                const hasOtherWeapons = Object.keys(this.ownedItems.weapons || {}).some(w => w !== 'basic' && this.getItemCount('weapons', w) > 0);
                if (hasOtherWeapons) {
                    return false; // Can't equip basic if you have other weapons
                }
            }
            
            // Laser weapon is exclusive - cannot be equipped with other weapons
            const weapon = this.equipmentStats.weapons[name];
            const isLaser = weapon && weapon.isLaser;
            
            if (isLaser) {
                // Equipping laser - remove all other weapons
                this.currentWeapons = [name];
                // Invalidate weapon cache when weapons change
                this._weaponsCacheInvalid = true;
            } else {
                // Equipping non-laser weapon - remove laser if equipped
                const hasLaser = this.currentWeapons.some(w => {
                    const wWeapon = this.equipmentStats.weapons[w];
                    return wWeapon && wWeapon.isLaser;
                });
                if (hasLaser) {
                    // Remove all laser weapons
                    this.currentWeapons = this.currentWeapons.filter(w => {
                        const wWeapon = this.equipmentStats.weapons[w];
                        return !wWeapon || !wWeapon.isLaser;
                    });
                }
                // Add weapon to equipped weapons array if not already equipped
                if (!this.currentWeapons.includes(name)) {
                    this.currentWeapons.push(name);
                }
                // Remove basic from equipped if equipping a non-basic weapon
                if (name !== 'basic' && this.currentWeapons.includes('basic')) {
                    const basicIndex = this.currentWeapons.indexOf('basic');
                    this.currentWeapons.splice(basicIndex, 1);
                }
            }
            // Invalidate weapon cache when weapons change
            this._weaponsCacheInvalid = true;
            this.audio.playSFX('equip', 0.7);
        } else if (type === 'ships') {
            this.currentShip = name;
            this.audio.playSFX('equip', 0.7);
            const ship = this.equipmentStats.ships[name];
            this.playerStats.maxHealth = ship.health;
            this.playerStats.health = Math.min(this.playerStats.health, ship.health);
            // Update base speed when changing ships
            this.playerStats.baseSpeed = ship.speed;
            // Keep speed upgrades by adjusting playerStats.speed
            const speedUpgrades = this.playerStats.speed - this.playerStats.baseSpeed;
            this.playerStats.speed = ship.speed + speedUpgrades;
            this.playerStats.baseSpeed = ship.speed; // Update base speed
            // Update player size based on ship
            this.player.size = ship.size;
        } else if (type === 'shields') {
            // Verify shield exists in equipmentStats before equipping
            const shield = this.equipmentStats.shields[name];
            if (!shield) {
                console.error(`[Equip] Shield '${name}' not found in equipmentStats!`);
                return false;
            }
            // Verify shield exists in inventory
            if (this.getItemCount('shields', name) <= 0) {
                console.error(`[Equip] Shield '${name}' not in inventory!`);
                return false;
            }
            this.currentShield = name;
            this.updateShieldStats();
        } else if (type === 'upgrades') {
            // Add upgrade to equipped upgrades array if not already equipped
            if (!this.currentUpgrades.includes(name)) {
                this.currentUpgrades.push(name);
            }
        }
        
        this.updateStats();
        this.updateInventoryUI();
        return true;
    }
    
    switchWeapon(direction) {
        // Switch between owned weapons using mouse wheel
        // direction: 1 = next, -1 = previous
        if (this.gameState !== 'playing' || this.levelUpState) {
            return; // Only switch during gameplay
        }
        
        // Get all owned weapons (excluding basic if other weapons exist)
        const ownedWeapons = Object.keys(this.ownedItems.weapons || {}).filter(w => {
            return this.getItemCount('weapons', w) > 0;
        });
        
        // If no weapons owned, nothing to switch
        if (ownedWeapons.length === 0) {
            return;
        }
        
        // Filter out basic if other weapons exist
        const hasOtherWeapons = ownedWeapons.some(w => w !== 'basic');
        const availableWeapons = hasOtherWeapons ? ownedWeapons.filter(w => w !== 'basic') : ownedWeapons;
        
        // Get current weapon (first in currentWeapons array, or 'basic' if empty)
        const currentWeapon = this.currentWeapons.length > 0 ? this.currentWeapons[0] : 'basic';
        const currentIndex = availableWeapons.indexOf(currentWeapon);
        
        // Calculate next index
        let nextIndex;
        if (direction > 0) {
            // Next weapon
            nextIndex = (currentIndex + 1) % availableWeapons.length;
        } else {
            // Previous weapon
            nextIndex = (currentIndex - 1 + availableWeapons.length) % availableWeapons.length;
        }
        
        const nextWeapon = availableWeapons[nextIndex];
        
        // Equip the next weapon (this will handle laser exclusivity, etc.)
        if (nextWeapon) {
            // Unequip current weapon first (but keep it in inventory)
            if (currentWeapon !== 'basic') {
                this.unequip('weapons', currentWeapon);
            } else {
                this.currentWeapons = [];
            }
            // Invalidate weapon cache when weapons change
            this._weaponsCacheInvalid = true;
            // Equip next weapon
            this.equip('weapons', nextWeapon);
        }
    }
    
    toggleWeaponWheel() {
        if (this.weaponWheelVisible) {
            this.closeWeaponWheel();
        } else {
            this.showWeaponWheel();
        }
    }
    
    showWeaponWheel() {
        this.weaponWheelVisible = true;
        const wheelUI = document.getElementById('weaponWheelUI');
        if (!wheelUI) return;
        
        wheelUI.classList.add('active');
        this.updateWeaponWheel();
    }
    
    closeWeaponWheel() {
        this.weaponWheelVisible = false;
        const wheelUI = document.getElementById('weaponWheelUI');
        if (wheelUI) {
            wheelUI.classList.remove('active');
        }
    }
    
    updateWeaponWheel() {
        const container = document.getElementById('weaponWheelContainer');
        if (!container) return;
        
        // Get all owned weapons
        const ownedWeapons = Object.keys(this.ownedItems.weapons || {}).filter(w => {
            return this.getItemCount('weapons', w) > 0;
        });
        
        // Get all food items (survival system)
        const ownedFood = [];
        if (this.survivalUnlocked && this.foodInventory) {
            const foodData = {
                basicMeal: 'Basic Meal',
                proteinBar: 'Protein Bar',
                energyDrink: 'Energy Drink',
                balancedMeal: 'Balanced Meal',
                superFood: 'Super Food',
                methaneSnack: 'Methane Snack'
            };
            for (let foodName in this.foodInventory) {
                if (this.foodInventory[foodName] > 0 && foodData[foodName]) {
                    ownedFood.push({ name: foodName, displayName: foodData[foodName] });
                }
            }
        }
        
        // Combine weapons and food for the wheel
        const allItems = [
            ...ownedWeapons.map(w => ({ type: 'weapon', name: w })),
            ...ownedFood.map(f => ({ type: 'food', name: f.name, displayName: f.displayName }))
        ];
        
        if (allItems.length === 0) {
            container.innerHTML = '<div class="weapon-wheel-center">NO ITEMS</div>';
            return;
        }
        
        // Clear container (keep center)
        const center = container.querySelector('.weapon-wheel-center');
        container.innerHTML = '';
        if (center) container.appendChild(center);
        
        // Calculate positions in a circle
        const radius = 140;
        const centerX = 200;
        const centerY = 200;
        const angleStep = (Math.PI * 2) / allItems.length;
        
        allItems.forEach((item, index) => {
            const angle = index * angleStep - Math.PI / 2; // Start at top
            const x = centerX + Math.cos(angle) * radius - 40;
            const y = centerY + Math.sin(angle) * radius - 40;
            
            let isEquipped = false;
            let displayName = item.name.toUpperCase();
            if (item.type === 'weapon') {
                isEquipped = this.currentWeapons.includes(item.name);
            } else if (item.type === 'food') {
                displayName = item.displayName.toUpperCase();
            }
            
            const isSelected = index === this.weaponWheelSelectedIndex;
            
            const wheelItem = document.createElement('div');
            wheelItem.className = `weapon-wheel-item ${isEquipped ? 'equipped' : ''} ${isSelected ? 'selected' : ''} ${item.type === 'food' ? 'food-item' : ''}`;
            wheelItem.style.left = x + 'px';
            wheelItem.style.top = y + 'px';
            wheelItem.innerHTML = `<div class="weapon-wheel-item-name">${displayName}</div>`;
            wheelItem.onclick = (e) => {
                e.stopPropagation();
                if (item.type === 'weapon') {
                    this.toggleWeaponEquip(item.name);
                } else if (item.type === 'food') {
                    if (this.eatFood(item.name)) {
                        this.closeWeaponWheel();
                    }
                }
            };
            
            container.appendChild(wheelItem);
        });
        
        // Set initial selection if needed
        if (this.weaponWheelSelectedIndex >= allItems.length) {
            this.weaponWheelSelectedIndex = 0;
        }
        this.updateWeaponWheelSelection(0);
    }
    
    updateWeaponWheelSelection(direction) {
        // Get all items (weapons + food) for selection
        const ownedWeapons = Object.keys(this.ownedItems.weapons || {}).filter(w => {
            return this.getItemCount('weapons', w) > 0;
        });
        
        const ownedFood = [];
        if (this.survivalUnlocked && this.foodInventory) {
            for (let foodName in this.foodInventory) {
                if (this.foodInventory[foodName] > 0) {
                    ownedFood.push(foodName);
                }
            }
        }
        
        const totalItems = ownedWeapons.length + ownedFood.length;
        if (totalItems === 0) return;
        
        if (direction !== 0) {
            this.weaponWheelSelectedIndex = (this.weaponWheelSelectedIndex + direction + totalItems) % totalItems;
        }
        
        // Update visual selection without rebuilding entire wheel
        const container = document.getElementById('weaponWheelContainer');
        if (container) {
            const items = container.querySelectorAll('.weapon-wheel-item');
            items.forEach((item, index) => {
                if (index === this.weaponWheelSelectedIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }
    }
    
    toggleWeaponEquip(weaponName) {
        const isEquipped = this.currentWeapons.includes(weaponName);
        
        if (isEquipped) {
            this.unequip('weapons', weaponName);
        } else {
            this.equip('weapons', weaponName);
        }
        
        this.updateWeaponWheel();
        this.updateInventoryUI();
    }
    
    startRepairSelection() {
        if (!this.hammerEquipped) {
            // Show message that hammer needs to be equipped
            const repairUI = document.getElementById('repairSelectionUI');
            if (repairUI) {
                const list = document.getElementById('repairSelectionList');
                if (list) {
                    list.innerHTML = '<p style="color: #ffc107; text-align: center;">Equip hammer first (from inventory)</p>';
                }
                repairUI.classList.add('active');
            }
            return; // Can't repair without hammer
        }
        
        this.repairSelectionMode = true;
        this.selectedRepairItem = null;
        this.repairSelectedIndex = 0;
        this.updateRepairableItems();
        this.updateRepairSelectionUI();
        
        const repairUI = document.getElementById('repairSelectionUI');
        if (repairUI) {
            repairUI.classList.add('active');
        }
    }
    
    endRepairSelection() {
        this.repairSelectionMode = false;
        this.selectedRepairItem = null;
        
        const repairUI = document.getElementById('repairSelectionUI');
        if (repairUI) {
            repairUI.classList.remove('active');
        }
    }
    
    updateRepairSelection(direction) {
        if (this.repairableItems.length === 0) return;
        
        this.repairSelectedIndex = (this.repairSelectedIndex + direction + this.repairableItems.length) % this.repairableItems.length;
        this.updateRepairSelectionUI();
    }
    
    selectRepairItem(itemIndex) {
        if (itemIndex >= 0 && itemIndex < this.repairableItems.length && this.hammerEquipped) {
            this.selectedRepairItem = this.repairableItems[itemIndex];
            this.repairSelectedIndex = itemIndex;
            // Repair immediately when clicked
            const repaired = this.repairSelectedItem();
            // Update UI after repair
            if (repaired) {
                // Clear selection after successful repair
                this.selectedRepairItem = null;
            }
            this.updateRepairSelectionUI();
        }
    }
    
    repairSelectedItem() {
        if (!this.selectedRepairItem) {
            return false;
        }
        
        // Check if hammer is still equipped and has durability
        if (!this.hammerEquipped) {
            this.endRepairSelection();
            return false;
        }
        
        const hammerDurability = this.getItemDurability('tools', 'hammer');
        if (hammerDurability <= 0) {
            this.hammerEquipped = false;
            this.endRepairSelection();
            return false;
        }
        
        // Repair the selected item (restore 10% durability per use)
        const currentDurability = this.getItemDurability(this.selectedRepairItem.type, this.selectedRepairItem.name);
        const newDurability = Math.min(100, currentDurability + 10);
        this.setItemDurability(this.selectedRepairItem.type, this.selectedRepairItem.name, newDurability);
        
        // Hammer loses 2% durability per use
        const hammerItem = this.ownedItems.tools.hammer;
        if (hammerItem && typeof hammerItem === 'object') {
            hammerItem.durability = Math.max(0, hammerItem.durability - 2);
            
            if (hammerItem.durability <= 0) {
                hammerItem.count--;
                if (hammerItem.count > 0) {
                    hammerItem.durability = 100;
                } else {
                    // Hammer is completely broken - but don't delete it, just mark as unequipped
                    // The player can still see it in inventory and repair it
                    this.hammerEquipped = false;
                }
            }
        }
        
        // Reset use-based decay counters for repaired weapon
        if (this.selectedRepairItem.type === 'weapons') {
            this.weaponShotsFired[this.selectedRepairItem.name] = 0;
        }
        
        // Update repairable items list (item might be at 100% now)
        this.updateRepairableItems();
        
        // If hammer broke, end repair selection
        if (!this.hammerEquipped) {
            this.endRepairSelection();
        } else {
            // Update UI but keep repair selection open if Q is still held
            this.updateRepairSelectionUI();
        }
        
        this.updateInventoryUI();
        
        return true;
    }
    
    updateRepairSelectionUI() {
        const list = document.getElementById('repairSelectionList');
        if (!list) return;
        
        list.innerHTML = '';
        
        // Check if hammer is still equipped
        if (!this.hammerEquipped) {
            list.innerHTML = '<p style="color: #ffc107; text-align: center;">Hammer not equipped or broken</p>';
            return;
        }
        
        if (this.repairableItems.length === 0) {
            list.innerHTML = '<p style="color: #aaa; text-align: center;">No items to repair (all at 100%)</p>';
            return;
        }
        
        this.repairableItems.forEach((item, index) => {
            const div = document.createElement('div');
            const isSelected = index === this.repairSelectedIndex;
            div.className = `repair-item ${isSelected ? 'selected' : ''}`;
            div.style.cursor = 'pointer';
            div.onclick = () => this.selectRepairItem(index);
            
            // Check if item is at 100% (recently repaired)
            const currentDurability = this.getItemDurability(item.type, item.name);
            const isFullyRepaired = currentDurability >= 100;
            
            div.innerHTML = `
                <strong>${item.name.toUpperCase()}</strong> (${item.type})<br>
                <span style="color: #aaa; font-size: 0.9em;">Durability: ${Math.round(currentDurability)}%</span>
                ${isFullyRepaired ? '<br><span style="color: #4caf50; font-size: 0.9em;">✓ Fully Repaired!</span>' : ''}
            `;
            list.appendChild(div);
        });
    }
    
    unequip(type, name) {
        if (type === 'weapons') {
            // Remove weapon from equipped weapons array
            const index = this.currentWeapons.indexOf(name);
            if (index > -1) {
                this.currentWeapons.splice(index, 1);
            }
            // Ensure at least one weapon is equipped
            if (this.currentWeapons.length === 0) {
                this.currentWeapons.push('basic');
            }
            // Invalidate weapon cache when weapons change
            this._weaponsCacheInvalid = true;
        } else if (type === 'ships') {
            // Unequip ship - go back to basic
            this.currentShip = 'basic';
            // Ensure basic ship exists in inventory
            if (!this.ownedItems.ships.basic) {
                this.ownedItems.ships.basic = { count: 1, durability: 100 };
            }
            const ship = this.equipmentStats.ships.basic;
            // Safety check: ensure basic ship exists in equipmentStats
            if (!ship) {
                console.error('[Ship] Basic ship not found in equipmentStats! This should never happen.');
                // Try to recover by using first available ship
                const availableShips = Object.keys(this.equipmentStats.ships);
                if (availableShips.length > 0) {
                    this.currentShip = availableShips[0];
                    const fallbackShip = this.equipmentStats.ships[this.currentShip];
                    this.playerStats.maxHealth = fallbackShip.health;
                    this.playerStats.health = Math.min(this.playerStats.health, fallbackShip.health);
                    const speedUpgrades = this.playerStats.speed - this.playerStats.baseSpeed;
                    this.playerStats.baseSpeed = fallbackShip.speed;
                    this.playerStats.speed = fallbackShip.speed + speedUpgrades;
                    this.player.size = fallbackShip.size;
                } else {
                    console.error('[Ship] No ships available! Game may be broken.');
                }
            } else {
                this.playerStats.maxHealth = ship.health;
                this.playerStats.health = Math.min(this.playerStats.health, ship.health);
                const speedUpgrades = this.playerStats.speed - this.playerStats.baseSpeed;
                this.playerStats.baseSpeed = ship.speed;
                this.playerStats.speed = ship.speed + speedUpgrades;
                this.player.size = ship.size;
            }
        } else if (type === 'shields') {
            // Unequip shield
            this.currentShield = 'none';
            this.playerStats.maxShield = 0;
            this.playerStats.shield = 0;
        } else if (type === 'upgrades') {
            // Remove upgrade from equipped upgrades array
            const index = this.currentUpgrades.indexOf(name);
            if (index > -1) {
                this.currentUpgrades.splice(index, 1);
            }
        }
        
        this.updateStats();
        this.updateInventoryUI();
        return true;
    }
    
    updateShieldStats() {
        // Update shield capacity with bonus from upgrades
        if (this.currentShield !== 'none') {
            const shield = this.equipmentStats.shields[this.currentShield];
            if (!shield) {
                console.error(`[Shield] Shield '${this.currentShield}' not found in equipmentStats! Cannot update stats.`);
                // Don't unequip here - let the equip function handle validation
                // Just set shield stats to 0 to prevent errors
                this.playerStats.maxShield = 0;
                this.playerStats.shield = 0;
                return;
            }
            const baseCapacity = shield.capacity || 0;
            if (baseCapacity <= 0) {
                console.error(`[Shield] Shield '${this.currentShield}' has invalid capacity: ${baseCapacity}`);
                this.playerStats.maxShield = 0;
                this.playerStats.shield = 0;
                return;
            }
            const bonusMultiplier = 1 + (this.playerStats.shieldCapacityBonus / 100);
            this.playerStats.maxShield = Math.floor(baseCapacity * bonusMultiplier);
            // When equipping a new shield, set to full capacity
            // Only preserve current shield value if we're updating an already-equipped shield
            const wasAlreadyEquipped = (this.playerStats.shield > 0 && this.playerStats.maxShield > 0);
            if (!wasAlreadyEquipped || this.playerStats.shield > this.playerStats.maxShield) {
                // New shield or capacity increased - set to full
                this.playerStats.shield = this.playerStats.maxShield;
            } else {
                // Keep current shield value, but cap at new max
                this.playerStats.shield = Math.min(this.playerStats.shield, this.playerStats.maxShield);
            }
        } else {
            this.playerStats.maxShield = 0;
            this.playerStats.shield = 0;
        }
    }

    upgradeStat(stat, cost) {
        // Only allow during level-up
        if (!this.levelUpState) {
            return false;
        }
        
        if (this.inventory.tokens < cost) {
            console.log('Not enough tokens!');
            return false;
        }
        
        this.inventory.tokens -= cost;
        
        switch(stat) {
            case 'speed':
                // Cap speed based on ship type
                // Basic ship: max 650 (150 + 500), all other ships: baseSpeed + 600
                // This allows players to keep up with late-game molecules (830-1200 speed)
                // Basic ship: 650 max, Fast ship: 220 + 600 = 820, etc.
                let maxSpeed;
                if (this.currentShip === 'basic') {
                    maxSpeed = 650; // Special cap for basic ship
                } else {
                    maxSpeed = this.playerStats.baseSpeed + 600; // Standard cap for all other ships
                }
                if (this.playerStats.speed < maxSpeed) {
                    this.playerStats.speed = Math.min(maxSpeed, this.playerStats.speed + 30);
                    this.upgradeLevels.speed++;
                    console.log(`Speed upgraded! New speed: ${this.playerStats.speed}${this.playerStats.speed >= maxSpeed ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Speed is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'fireRate':
                // Cap fire rate at baseFireRate + 8.0 (performance-safe cap)
                // This allows higher fire rates while preventing bullet spam that causes lag
                // Basic weapon: 0.5 + 8.0 = 8.5 shots/sec, Rapid: 1.0 + 8.0 = 9.0 shots/sec
                // Individual System Core: 3.0 + 8.0 = 11.0 shots/sec (with multiple weapons, this is reasonable)
                const maxFireRate = this.playerStats.baseFireRate + 8.0;
                if (this.playerStats.fireRate < maxFireRate) {
                    this.playerStats.fireRate = Math.min(maxFireRate, this.playerStats.fireRate + 0.2);
                    this.upgradeLevels.fireRate++;
                    console.log(`Fire rate upgraded! New rate: ${this.playerStats.fireRate.toFixed(2)}${this.playerStats.fireRate >= maxFireRate ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Fire rate is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'damage':
                // Cap damage at baseDamage + 100 (110 total max)
                const maxDamage = this.playerStats.baseDamage + 100;
                if (this.playerStats.damage < maxDamage) {
                    this.playerStats.damage = Math.min(maxDamage, this.playerStats.damage + 2);
                    this.upgradeLevels.damage++;
                    console.log(`Damage upgraded! New damage: ${this.playerStats.damage}${this.playerStats.damage >= maxDamage ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Damage is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'maxHealth':
                // Cap max health at baseMaxHealth + 500 (600 total max)
                const maxMaxHealth = this.playerStats.baseMaxHealth + 500;
                if (this.playerStats.maxHealth < maxMaxHealth) {
                    const oldMaxHealth = this.playerStats.maxHealth;
                    this.playerStats.maxHealth = Math.min(maxMaxHealth, this.playerStats.maxHealth + 10);
                    const healthIncrease = this.playerStats.maxHealth - oldMaxHealth;
                    this.playerStats.health += healthIncrease; // Also increase current health
                    this.upgradeLevels.maxHealth++;
                    console.log(`Max Health upgraded! New max: ${this.playerStats.maxHealth}${this.playerStats.maxHealth >= maxMaxHealth ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Max Health is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'criticalHitChance':
                this.playerStats.criticalHitChance = Math.min(100, this.playerStats.criticalHitChance + 2); // +2% crit chance, cap at 100%
                this.upgradeLevels.criticalHitChance++;
                console.log(`Critical Hit Chance upgraded! New chance: ${this.playerStats.criticalHitChance}%${this.playerStats.criticalHitChance >= 100 ? ' (MAXED)' : ''}`);
                break;
            case 'criticalHitDamage':
                // Cap critical hit damage at 5.0x
                if (this.playerStats.criticalHitDamage < 5.0) {
                    this.playerStats.criticalHitDamage = Math.min(5.0, this.playerStats.criticalHitDamage + 0.05);
                    this.upgradeLevels.criticalHitDamage++;
                    console.log(`Critical Hit Damage upgraded! New multiplier: ${this.playerStats.criticalHitDamage.toFixed(2)}x${this.playerStats.criticalHitDamage >= 5.0 ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Critical Hit Damage is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'shieldCapacityBonus':
                this.playerStats.shieldCapacityBonus = Math.min(100, this.playerStats.shieldCapacityBonus + 5); // +5% shield capacity, cap at 100%
                this.upgradeLevels.shieldCapacityBonus++;
                console.log(`Shield Capacity Bonus upgraded! New bonus: ${this.playerStats.shieldCapacityBonus}%${this.playerStats.shieldCapacityBonus >= 100 ? ' (MAXED)' : ''}`);
                break;
            case 'shieldRegenBonus':
                // Cap shield regen at 50/s
                if (this.playerStats.shieldRegenBonus < 50) {
                    this.playerStats.shieldRegenBonus = Math.min(50, this.playerStats.shieldRegenBonus + 1);
                    this.upgradeLevels.shieldRegenBonus++;
                    console.log(`Shield Regeneration upgraded! New regen: ${this.playerStats.shieldRegenBonus}/s${this.playerStats.shieldRegenBonus >= 50 ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Shield Regeneration is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'damageReduction':
                this.playerStats.damageReduction = Math.min(50, this.playerStats.damageReduction + 1); // +1% damage reduction, cap at 50%
                this.upgradeLevels.damageReduction++;
                console.log(`Damage Reduction upgraded! New reduction: ${this.playerStats.damageReduction}%${this.playerStats.damageReduction >= 50 ? ' (MAXED)' : ''}`);
                break;
            case 'evasion':
                this.playerStats.evasion = Math.min(30, this.playerStats.evasion + 1); // +1% evasion, cap at 30%
                this.upgradeLevels.evasion++;
                console.log(`Evasion upgraded! New evasion: ${this.playerStats.evasion}%${this.playerStats.evasion >= 30 ? ' (MAXED)' : ''}`);
                break;
            case 'materialDropRate':
                // Cap material drop rate at 300%
                if (this.playerStats.materialDropRate < 300) {
                    this.playerStats.materialDropRate = Math.min(300, this.playerStats.materialDropRate + 5);
                    this.upgradeLevels.materialDropRate++;
                    console.log(`Material Drop Rate upgraded! New bonus: ${this.playerStats.materialDropRate}%${this.playerStats.materialDropRate >= 300 ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Material Drop Rate is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'tokenDropRate':
                // CRITICAL: Cap token drop rate at 200% to prevent infinite feedback loop
                if (this.playerStats.tokenDropRate < 200) {
                    this.playerStats.tokenDropRate = Math.min(200, this.playerStats.tokenDropRate + 5);
                    this.upgradeLevels.tokenDropRate++;
                    console.log(`Token Drop Rate upgraded! New bonus: ${this.playerStats.tokenDropRate}%${this.playerStats.tokenDropRate >= 200 ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Token Drop Rate is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'levelTimeReduction':
                this.playerStats.levelTimeReduction = Math.min(40, this.playerStats.levelTimeReduction + 3); // +3% time reduction, cap at 40% (18s minimum per level)
                this.upgradeLevels.levelTimeReduction++;
                console.log(`Level Time Reduction upgraded! New reduction: ${this.playerStats.levelTimeReduction}%${this.playerStats.levelTimeReduction >= 40 ? ' (MAXED)' : ''}`);
                break;
            case 'projectileSpeed':
                // Cap projectile speed at 200%
                if (this.playerStats.projectileSpeed < 200) {
                    this.playerStats.projectileSpeed = Math.min(200, this.playerStats.projectileSpeed + 10);
                    this.upgradeLevels.projectileSpeed++;
                    console.log(`Projectile Speed upgraded! New bonus: ${this.playerStats.projectileSpeed}%${this.playerStats.projectileSpeed >= 200 ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Projectile Speed is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'healthRegen':
                // Cap health regen at 10 HP/s
                if (this.playerStats.healthRegen < 10) {
                    this.playerStats.healthRegen = Math.min(10, this.playerStats.healthRegen + 0.5);
                    this.upgradeLevels.healthRegen++;
                    console.log(`Health Regeneration upgraded! New regen: ${this.playerStats.healthRegen.toFixed(1)} HP/s${this.playerStats.healthRegen >= 10 ? ' (MAXED)' : ''}`);
                } else {
                    console.log('Health Regeneration is already at maximum!');
                    this.inventory.tokens += cost; // Refund tokens
                }
                break;
            case 'health':
                // Health upgrades are now consumable items stored in inventory
                if (!this.ownedItems.consumables) {
                    this.ownedItems.consumables = {};
                }
                if (!this.ownedItems.consumables.healthPack) {
                    this.ownedItems.consumables.healthPack = 0;
                }
                this.ownedItems.consumables.healthPack += 1; // Add health pack to inventory
                console.log(`Health pack purchased! Total: ${this.ownedItems.consumables.healthPack}`);
                break;
        }
        
        // Update shield capacity if shield is equipped (apply bonus)
        if (this.currentShield !== 'none') {
            this.updateShieldStats();
        }
        
        this.updateStats();
        this.updateShopUI(); // Refresh shop to show updated costs
        this.updateInventoryUI(); // Update inventory to show new health packs
        this.clearGamepadSelection(); // Re-highlight after buying
        return true;
    }
    
    useHealthPack() {
        // Use a health pack from inventory
        if (!this.ownedItems.consumables || !this.ownedItems.consumables.healthPack || this.ownedItems.consumables.healthPack <= 0) {
            return false; // No health packs available
        }
        
        // Restore 50 HP (or to max if less than 50 missing)
        const healAmount = 50;
        const missingHealth = this.playerStats.maxHealth - this.playerStats.health;
        const actualHeal = Math.min(healAmount, missingHealth);
        
        if (actualHeal > 0) {
            this.playerStats.health += actualHeal;
            this.ownedItems.consumables.healthPack--;
            
            if (this.ownedItems.consumables.healthPack <= 0) {
                delete this.ownedItems.consumables.healthPack;
            }
            
            this.updateStats();
            this.updateInventoryUI();
            return true;
        }
        
        return false; // Already at full health
    }
    
    useAtomSplit() {
        // Use atom split consumable - clears everything on screen and collects/doubles all resources
        if (!this.ownedItems.consumables || !this.ownedItems.consumables.atomSplit || this.ownedItems.consumables.atomSplit <= 0) {
            return false; // No atom splits available
        }
        
        // Collect all items on screen and double their value
        let collectedQuantum = 0;
        let collectedEnergy = 0;
        let collectedMetal = 0;
        let collectedCrystals = 0;
        let collectedTokens = 0;
        
        this.items.forEach(item => {
            // Count each item type
            if (item.type === 'quantumParticles') collectedQuantum++;
            else if (item.type === 'energyCores') collectedEnergy++;
            else if (item.type === 'metalScraps') collectedMetal++;
            else if (item.type === 'crystals') collectedCrystals++;
        });
        
        // Double all collected resources
        this.inventory.quantumParticles += collectedQuantum * 2;
        this.inventory.energyCores += collectedEnergy * 2;
        this.inventory.metalScraps += collectedMetal * 2;
        this.inventory.crystals += collectedCrystals * 2;
        
        // Collect and double tokens from all destroyed entities
        // Count tokens that would have been dropped
        const tokensFromTargets = this.targets.length * (1 + Math.floor(this.level / 2));
        const tokensFromPairs = this.pairs.length * 2 * (1 + Math.floor(this.level / 2));
        const tokensFromObstacles = this.obstacles.length * (1 + Math.floor(this.level / 2)) * 3; // Triple for obstacles
        const tokensFromEnemies = this.enemyShips.length * (5 + this.level * 2);
        const tokenMultiplier = this.mode === 'bell' ? 2 : 1;
        collectedTokens = (tokensFromTargets + tokensFromPairs + tokensFromObstacles + tokensFromEnemies) * tokenMultiplier;
        this.inventory.tokens += collectedTokens * 2;
        
        // Create massive explosion at player position
        // OPTIMIZATION: Use object pooling for particles
        for (let i = 0; i < 100; i++) {
            const particle = this.createParticle(
                this.player.x,
                this.player.y,
                (Math.random() - 0.5) * 500,
                (Math.random() - 0.5) * 500,
                `hsl(${Math.random() * 60 + 10}, 100%, 50%)`,
                Math.random() * 10 + 5,
                1.0,
                1.0
            );
            this.particles.push(particle);
        }
        
        // Clear all enemies, obstacles, targets, pairs, enemy ships, enemy bullets, and items
        this.targets = [];
        this.pairs = [];
        this.obstacles = [];
        this.enemyShips = [];
        this.enemyBullets = [];
        this.bullets = []; // Clear player bullets too
        this.items = []; // Clear items (already collected)
        
        // Award score for clearing
        this.score += 100;
        
        // Consume one atom split
        this.ownedItems.consumables.atomSplit--;
        
        if (this.ownedItems.consumables.atomSplit <= 0) {
            delete this.ownedItems.consumables.atomSplit;
        }
        
        this.updateStats();
        this.updateInventoryUI();
        return true;
    }

    showCraftingUI() {
        // OPTIMIZATION: Use cached DOM element
        const ui = this._cachedElements.craftingUI;
        const craftingInstructions = document.getElementById('craftingInstructions');
        if (!ui) return;
        
        if (craftingInstructions) {
            if (this.levelUpState) {
                craftingInstructions.textContent = `Level ${this.level} Complete! Craft items with your materials.`;
            } else {
                craftingInstructions.textContent = 'Available only during level-up';
            }
        }
        
        ui.classList.add('active');
        this.updateCraftingUI();
    }

    showShopUI() {
        // OPTIMIZATION: Use cached DOM element
        const ui = this._cachedElements.shopUI;
        if (!ui) return;
        
        if (this.gameState === 'shop') {
            this.gameState = 'playing';
            ui.classList.remove('active');
        } else {
            this.gameState = 'shop';
            ui.classList.add('active');
            this.updateShopUI();
        }
    }

    getMaterialDisplayName(material) {
        const displayNames = {
            quantumParticles: 'Electrons',
            energyCores: 'Photons',
            metalScraps: 'Nuclei',
            crystals: 'Energy Crystals',
            tokens: 'Energy Tokens',
            // Biological components
            atp: 'ATP (Adenosine Triphosphate)',
            aminoAcids: 'Amino Acids',
            simpleSugars: 'Simple Sugars',
            fattyAcids: 'Fatty Acids',
            nucleotides: 'Nucleotides',
            vitamins: 'Vitamins',
            minerals: 'Minerals'
        };
        return displayNames[material] || material;
    }
    
    updateCraftingUI() {
        // CRITICAL FIX: Save scroll position before updating UI to prevent auto-scrolling
        const craftingUI = document.getElementById('craftingUI');
        let savedScrollTop = 0;
        let scrollableContainer = null;
        
        // Save scroll position from ALL possible scrollable containers
        // We'll restore to the one that actually has scroll
        const allScrollPositions = new Map();
        
        if (craftingUI) {
            // Check craftingUI itself
            allScrollPositions.set(craftingUI, craftingUI.scrollTop || 0);
            
            // Check all parent elements (the actual scrollable container is likely a parent)
            let parent = craftingUI.parentElement;
            while (parent && parent !== document.body && parent !== document.documentElement) {
                allScrollPositions.set(parent, parent.scrollTop || 0);
                parent = parent.parentElement;
            }
            
            // Find the container with the highest scroll position (most likely the active one)
            let maxScrollTop = 0;
            for (const [container, scrollTop] of allScrollPositions) {
                if (scrollTop > maxScrollTop) {
                    maxScrollTop = scrollTop;
                    scrollableContainer = container;
                    savedScrollTop = scrollTop;
                }
            }
            
            // If no scroll found, use craftingUI as fallback
            if (!scrollableContainer) {
                scrollableContainer = craftingUI;
                savedScrollTop = craftingUI.scrollTop || 0;
            }
        }
        
        const weaponsList = document.getElementById('weaponsList');
        const shipsList = document.getElementById('shipsList');
        const shieldsList = document.getElementById('shieldsList');
        
        // Also save scroll position of individual lists if they're scrollable
        const weaponsListScroll = weaponsList ? weaponsList.scrollTop || 0 : 0;
        const shipsListScroll = shipsList ? shipsList.scrollTop || 0 : 0;
        const shieldsListScroll = shieldsList ? shieldsList.scrollTop || 0 : 0;
        
        // CRITICAL: Prevent any automatic scrolling during DOM updates
        // Store original scroll behavior
        const originalScrollRestore = (container, scrollTop) => {
            if (container && scrollTop >= 0) {
                container.scrollTop = scrollTop;
            }
        };
        
        if (weaponsList) {
            weaponsList.innerHTML = '';
            for (let weapon in this.recipes.weapons) {
                // Skip "basic" weapon - it's always available, not craftable
                if (weapon === 'basic') continue;
                
                const recipe = this.recipes.weapons[weapon];
                // Check level requirements
                let levelRequired = 0;
                if (weapon === 'rapid') levelRequired = 3;
                else if (weapon === 'spread') levelRequired = 5;
                else if (weapon === 'laser') levelRequired = 10;
                else if (weapon === 'automatic') levelRequired = 15;
                else if (weapon === 'transformationPredictor') levelRequired = 30;
                else if (weapon === 'deterministicEngine') levelRequired = 50;
                else if (weapon === 'individualSystemCore') levelRequired = 75;
                
                const hasLevel = this.level >= levelRequired;
                const canCraft = hasLevel && Object.keys(recipe).every(mat => this.inventory[mat] >= recipe[mat]);
                const item = document.createElement('div');
                item.className = 'craft-item';
                const buttonId = `craft-btn-${weapon}`;
                item.innerHTML = `
                    <div>
                        <strong style="color: #4fc3f7;">${weapon.toUpperCase()} (Photon Emitter)</strong>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            ${Object.keys(recipe).map(mat => `${this.getMaterialDisplayName(mat)}: ${recipe[mat]}`).join(', ')}
                        </div>
                        ${levelRequired > 0 ? `<div style="font-size: 0.85em; color: ${hasLevel ? '#4caf50' : '#ff9800'}; margin-top: 5px;">${hasLevel ? '✓' : '⚠️'} Requires Level ${levelRequired} ${hasLevel ? '(Unlocked)' : '(Locked)'}</div>` : ''}
                    </div>
                    <button id="${buttonId}" class="craft-btn" ${!canCraft ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.craft('weapons', '${weapon}'); game.updateCraftingUI();">
                        Craft
                    </button>
                `;
                weaponsList.appendChild(item);
            }
        }
        
        if (shipsList) {
            shipsList.innerHTML = '';
            for (let ship in this.recipes.ships) {
                // Skip "basic" ship - it's always available, not craftable
                if (ship === 'basic') continue;
                
                const recipe = this.recipes.ships[ship];
                // Check level requirements
                let levelRequired = 0;
                if (ship === 'rapid') levelRequired = 5; // Enhanced rapid ship requires level 5
                else if (ship === 'individualStabilizer') levelRequired = 35;
                else if (ship === 'completeDescriptionVessel') levelRequired = 60;
                const hasLevel = this.level >= levelRequired;
                const canCraft = hasLevel && Object.keys(recipe).every(mat => this.inventory[mat] >= recipe[mat]);
                const shipStats = this.equipmentStats.ships[ship];
                const bonusText = shipStats.bonus === 'speedBoost' ? '⚡ Speed Boost' : 
                                 shipStats.bonus === 'damageResist' ? '🛡️ Damage Resist' :
                                 shipStats.bonus === 'evasion' ? '✨ Evasion' :
                                 shipStats.bonus === 'stabilized' ? '🔬 Stabilized' :
                                 shipStats.bonus === 'complete' ? '⚛️ Complete' : '';
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #4fc3f7;">${ship.toUpperCase()} (Electron Config)</strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Speed: ${shipStats.speed} | Health: ${shipStats.health} ${bonusText ? '| ' + bonusText : ''}
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            ${Object.keys(recipe).map(mat => `${this.getMaterialDisplayName(mat)}: ${recipe[mat]}`).join(', ')}
                        </div>
                        ${levelRequired > 0 ? `<div style="font-size: 0.85em; color: ${hasLevel ? '#4caf50' : '#ff9800'}; margin-top: 5px;">${hasLevel ? '✓' : '⚠️'} Requires Level ${levelRequired} ${hasLevel ? '(Unlocked)' : '(Locked)'}</div>` : ''}
                    </div>
                    <button class="craft-btn" ${!canCraft ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.craft('ships', '${ship}'); game.updateCraftingUI();">
                        Craft
                    </button>
                `;
                shipsList.appendChild(item);
            }
        }
        
        if (shieldsList) {
            shieldsList.innerHTML = '';
            for (let shield in this.recipes.shields) {
                const recipe = this.recipes.shields[shield];
                // Check level requirements
                let levelRequired = 0;
                if (shield === 'ontologicalReality') levelRequired = 40;
                else if (shield === 'individualSystemBarrier') levelRequired = 70;
                const hasLevel = this.level >= levelRequired;
                const canCraft = hasLevel && Object.keys(recipe).every(mat => this.inventory[mat] >= recipe[mat]);
                const shieldStats = this.equipmentStats.shields[shield];
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #4fc3f7;">${shield.toUpperCase()} (Energy Barrier)</strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Capacity: ${shieldStats.capacity} | Regen: ${shieldStats.regen}/s
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            ${Object.keys(recipe).map(mat => `${this.getMaterialDisplayName(mat)}: ${recipe[mat]}`).join(', ')}
                        </div>
                        ${levelRequired > 0 ? `<div style="font-size: 0.85em; color: ${hasLevel ? '#4caf50' : '#ff9800'}; margin-top: 5px;">${hasLevel ? '✓' : '⚠️'} Requires Level ${levelRequired} ${hasLevel ? '(Unlocked)' : '(Locked)'}</div>` : ''}
                    </div>
                    <button class="craft-btn" ${!canCraft ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.craft('shields', '${shield}'); game.updateCraftingUI();">
                        Craft
                    </button>
                `;
                shieldsList.appendChild(item);
            }
        }
        
        // Add upgrades section to crafting UI
        const craftingUpgradesList = document.getElementById('craftingUpgradesList');
        if (craftingUpgradesList) {
            craftingUpgradesList.innerHTML = '';
            for (let upgrade in this.recipes.upgrades) {
                const recipe = this.recipes.upgrades[upgrade];
                // Check level requirements
                let levelRequired = 0;
                if (upgrade === 'completeDescriptionMatrix') levelRequired = 35;
                else if (upgrade === 'transformationTimeScanner') levelRequired = 40;
                else if (upgrade === 'ensembleBypass') levelRequired = 65;
                else if (upgrade === 'individualSystemAmplifier') levelRequired = 80;
                const hasLevel = this.level >= levelRequired;
                const canCraft = hasLevel && Object.keys(recipe).every(mat => this.inventory[mat] >= recipe[mat]);
                const upgradeStats = this.equipmentStats.upgrades[upgrade];
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #4fc3f7;">${upgrade.toUpperCase()}</strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            ${upgradeStats.description || 'Upgrade'}
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            ${Object.keys(recipe).map(mat => `${this.getMaterialDisplayName(mat)}: ${recipe[mat]}`).join(', ')}
                        </div>
                        ${levelRequired > 0 ? `<div style="font-size: 0.85em; color: ${hasLevel ? '#4caf50' : '#ff9800'}; margin-top: 5px;">${hasLevel ? '✓' : '⚠️'} Requires Level ${levelRequired} ${hasLevel ? '(Unlocked)' : '(Locked)'}</div>` : ''}
                    </div>
                    <button class="craft-btn" ${!canCraft ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.craft('upgrades', '${upgrade}'); game.updateCraftingUI();">
                        Craft
                    </button>
                `;
                craftingUpgradesList.appendChild(item);
            }
        }
        
        // Add weapon upgrades section to crafting UI
        const weaponUpgradesList = document.getElementById('weaponUpgradesList');
        if (weaponUpgradesList) {
            weaponUpgradesList.innerHTML = '';
            
            for (let weapon in this.recipes.weaponUpgrades) {
                const ownsWeapon = this.getItemCount('weapons', weapon) > 0;
                if (!ownsWeapon) continue; // Skip if player doesn't own the weapon
                
                const currentLevel = this.weaponUpgrades[weapon] || 0;
                const weaponUpgrades = this.recipes.weaponUpgrades[weapon];
                const maxTier = weapon === 'automatic' ? 1 : 4;
                
                // SEQUENTIAL UPGRADES: Only show the NEXT tier (currentLevel + 1)
                // Cannot skip tiers - must upgrade in order
                const nextTier = currentLevel + 1;
                if (nextTier > maxTier) continue; // Already at max tier
                
                const recipe = weaponUpgrades[nextTier];
                if (!recipe) continue;
                
                const canUpgrade = Object.keys(recipe).every(mat => this.inventory[mat] >= recipe[mat]);
                
                // Get upgrade description based on weapon and tier
                let upgradeDescription = '';
                if (weapon === 'rapid') {
                    const rapidBonuses = [0, 0.9, 1.2, 1.5, 1.8];
                    const bonus = rapidBonuses[nextTier] || 0;
                    // Calculate total bonus after this upgrade (accumulated)
                    let totalBonus = 0;
                    for (let i = 1; i <= nextTier && i <= 4; i++) {
                        totalBonus += rapidBonuses[i];
                    }
                    upgradeDescription = `Tier ${nextTier}: +${bonus} fire rate (total: +${totalBonus.toFixed(1)} when upgraded)`;
                } else if (weapon === 'spread') {
                    const currentSpread = 3 + currentLevel;
                    const newSpread = 3 + nextTier;
                    upgradeDescription = `Tier ${nextTier}: Spread ${currentSpread} → ${newSpread} shots`;
                } else if (weapon === 'laser') {
                    const laserDurationBonuses = [0, 0.8, 1.0, 1.3, 1.6];
                    const laserDamageBonuses = [0, 8, 10, 13, 16];
                    const durationBonus = laserDurationBonuses[nextTier] || 0;
                    const damageBonus = laserDamageBonuses[nextTier] || 0;
                    // Calculate total bonuses after this upgrade (accumulated)
                    let totalDurationBonus = 0;
                    let totalDamageBonus = 0;
                    for (let i = 1; i <= nextTier && i <= 4; i++) {
                        totalDurationBonus += laserDurationBonuses[i];
                        totalDamageBonus += laserDamageBonuses[i];
                    }
                    upgradeDescription = `Tier ${nextTier}: +${durationBonus}s/+${damageBonus} (total: +${totalDurationBonus.toFixed(1)}s/+${totalDamageBonus} when upgraded)`;
                } else if (weapon === 'automatic') {
                    // Check if player is level 50 or higher
                    const canCraftOmnidirectional = this.level >= 50;
                    if (!canCraftOmnidirectional) {
                        upgradeDescription = `Tier ${nextTier}: Omnidirectional shooting (8 directions) - Requires Level 50`;
                    } else {
                        upgradeDescription = `Tier ${nextTier}: Omnidirectional shooting (8 directions) - Very expensive, late game`;
                    }
                }
                
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #fff;">
                            ${weapon.toUpperCase()} - Tier ${nextTier} Upgrade
                        </strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            ${upgradeDescription}
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            ${Object.keys(recipe).map(mat => `${this.getMaterialDisplayName(mat)}: ${recipe[mat]}`).join(', ')}
                        </div>
                        ${currentLevel > 0 ? `<div style="font-size: 0.85em; color: #4fc3f7; margin-top: 5px;">Current: Tier ${currentLevel}</div>` : ''}
                        ${currentLevel === 0 ? `<div style="font-size: 0.85em; color: #ff9800; margin-top: 5px;">⚠️ Must upgrade tiers in order</div>` : ''}
                    </div>
                    <button class="craft-btn" ${!canUpgrade || (weapon === 'automatic' && this.level < 50) ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.upgradeWeapon('${weapon}', ${nextTier}); game.updateCraftingUI();">
                        Upgrade to Tier ${nextTier}
                    </button>
                    ${weapon === 'automatic' && this.level < 50 ? `<div style="font-size: 0.85em; color: #ff9800; margin-top: 5px;">⚠️ Requires Level 50</div>` : ''}
                `;
                weaponUpgradesList.appendChild(item);
            }
        }
        
        // Add consumables section to crafting UI (only non-food items like atomSplit)
        const craftingConsumablesList = document.getElementById('craftingConsumablesList');
        if (craftingConsumablesList) {
            craftingConsumablesList.innerHTML = '';
            // List of food items to exclude from consumables section (they're in Food Crafting section)
            const foodItems = ['basicMeal', 'proteinBar', 'energyDrink', 'balancedMeal', 'superFood', 'methaneSnack'];
            
            for (let consumable in this.recipes.consumables) {
                // Skip food items - they're shown in the Food Crafting section
                if (foodItems.includes(consumable)) continue;
                
                const recipe = this.recipes.consumables[consumable];
                const canCraft = Object.keys(recipe).every(mat => this.inventory[mat] >= recipe[mat]);
                let description = '';
                if (consumable === 'atomSplit') {
                    description = 'Nuclear fission - Clears all molecules and enemies on screen';
                }
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #f44336;">${consumable.toUpperCase()}</strong>
                        <div style="font-size: 0.85em; color: #f44336; margin-top: 3px;">
                            ${description}
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            ${Object.keys(recipe).map(mat => `${this.getMaterialDisplayName(mat)}: ${recipe[mat]}`).join(', ')}
                        </div>
                    </div>
                    <button class="craft-btn" ${!canCraft ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.craft('consumables', '${consumable}'); game.updateCraftingUI();">
                        Craft
                    </button>
                `;
                craftingConsumablesList.appendChild(item);
            }
        }
        
        // Add tools section to crafting UI (hammer)
        const craftingToolsList = document.getElementById('craftingToolsList');
        if (craftingToolsList) {
            craftingToolsList.innerHTML = '';
            for (let tool in this.recipes.tools) {
                const recipe = this.recipes.tools[tool];
                // Hammer requires level 10
                const levelRequired = tool === 'hammer' ? 10 : 0;
                const hasLevel = this.level >= levelRequired;
                const canCraft = hasLevel && Object.keys(recipe).every(mat => this.inventory[mat] >= recipe[mat]);
                const toolStats = this.equipmentStats.tools[tool];
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #ff9800;">${tool.toUpperCase()}</strong>
                        <div style="font-size: 0.85em; color: #ff9800; margin-top: 3px;">
                            ${toolStats.description || 'Tool'}
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            ${Object.keys(recipe).map(mat => `${this.getMaterialDisplayName(mat)}: ${recipe[mat]}`).join(', ')}
                        </div>
                        ${levelRequired > 0 ? `<div style="font-size: 0.85em; color: ${hasLevel ? '#4caf50' : '#ff9800'}; margin-top: 5px;">${hasLevel ? '✓' : '⚠️'} Requires Level ${levelRequired} ${hasLevel ? '(Unlocked)' : '(Locked)'}</div>` : ''}
                    </div>
                    <button class="craft-btn" ${!canCraft ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.craft('tools', '${tool}'); game.updateCraftingUI();">
                        Craft
                    </button>
                `;
                craftingToolsList.appendChild(item);
            }
        }
        
        // Add repair section to crafting UI (after food crafting section)
        const repairList = document.getElementById('repairList');
        if (repairList) {
            // Clear existing content
            repairList.innerHTML = '';
            
            // Add header for Repair Station section
            const repairHeader = document.createElement('h3');
            repairHeader.textContent = '🔧 Repair Station';
            repairHeader.style.color = '#4caf50';
            repairHeader.style.marginTop = '30px';
            repairHeader.style.marginBottom = '15px';
            repairHeader.style.paddingTop = '20px';
            repairHeader.style.borderTop = '2px solid #4caf50';
            repairList.appendChild(repairHeader);
            
            let hasRepairableItems = false;
            
            // Show repairable weapons
            for (let weapon in this.ownedItems.weapons) {
                const count = this.getItemCount('weapons', weapon);
                const durability = this.getItemDurability('weapons', weapon);
                if (count <= 0 || durability >= 100) continue; // Skip if no items or already at full durability
                
                hasRepairableItems = true;
                const missingDurability = 100 - durability;
                
                // Calculate material cost (50-80% of crafting cost based on upgrade tier, scaled by missing durability)
                const recipe = this.recipes.weapons[weapon];
                const repairCost = {};
                if (recipe) {
                    // Higher upgrade tiers cost more to repair (but not too much more)
                    let repairCostMultiplier = 0.5; // Base: 50% of crafting cost
                    const upgradeLevel = this.weaponUpgrades[weapon] || 0;
                    // Each upgrade tier adds 10% to repair cost (tier 1: +10%, tier 2: +20%, tier 3: +30%, tier 4: +40%)
                    // But cap at 80% total (not too expensive)
                    repairCostMultiplier = Math.min(0.8, 0.5 + (upgradeLevel * 0.1));
                    
                    for (let material in recipe) {
                        repairCost[material] = Math.ceil((recipe[material] * repairCostMultiplier) * (missingDurability / 100));
                    }
                }
                const canRepair = recipe && Object.keys(repairCost).every(mat => this.inventory[mat] >= repairCost[mat]);
                const costText = recipe ? Object.keys(repairCost).map(mat => `${this.getMaterialDisplayName(mat)}: ${repairCost[mat]}`).join(', ') : 'N/A';
                
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #fff;">${weapon.toUpperCase()} WEAPON</strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Durability: ${Math.round(durability)}% → 100%
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Cost: ${costText}
                        </div>
                    </div>
                    <button class="craft-btn" ${!canRepair ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.repairItem('weapons', '${weapon}'); game.updateCraftingUI(); game.updateInventoryUI();" style="background: #4caf50;">
                        Repair
                    </button>
                `;
                repairList.appendChild(item);
            }
            
            // Show repairable ships
            for (let ship in this.ownedItems.ships) {
                const count = this.getItemCount('ships', ship);
                const durability = this.getItemDurability('ships', ship);
                if (count <= 0 || durability >= 100) continue;
                
                hasRepairableItems = true;
                const missingDurability = 100 - durability;
                
                // Calculate material cost (50% of crafting cost, scaled by missing durability)
                const recipe = this.recipes.ships[ship];
                const repairCost = {};
                if (recipe) {
                    for (let material in recipe) {
                        repairCost[material] = Math.ceil((recipe[material] * 0.5) * (missingDurability / 100));
                    }
                }
                const canRepair = recipe && Object.keys(repairCost).every(mat => this.inventory[mat] >= repairCost[mat]);
                const costText = recipe ? Object.keys(repairCost).map(mat => `${this.getMaterialDisplayName(mat)}: ${repairCost[mat]}`).join(', ') : 'N/A';
                
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #fff;">${ship.toUpperCase()} SHIP</strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Durability: ${Math.round(durability)}% → 100%
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Cost: ${costText}
                        </div>
                    </div>
                    <button class="craft-btn" ${!canRepair ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.repairItem('ships', '${ship}'); game.updateCraftingUI(); game.updateInventoryUI();" style="background: #4caf50;">
                        Repair
                    </button>
                `;
                repairList.appendChild(item);
            }
            
            // Show repairable shields
            for (let shield in this.ownedItems.shields) {
                const count = this.getItemCount('shields', shield);
                const durability = this.getItemDurability('shields', shield);
                if (count <= 0 || durability >= 100) continue;
                
                hasRepairableItems = true;
                const missingDurability = 100 - durability;
                
                // Calculate material cost (50% of crafting cost, scaled by missing durability)
                const recipe = this.recipes.shields[shield];
                const repairCost = {};
                if (recipe) {
                    for (let material in recipe) {
                        repairCost[material] = Math.ceil((recipe[material] * 0.5) * (missingDurability / 100));
                    }
                }
                const canRepair = recipe && Object.keys(repairCost).every(mat => this.inventory[mat] >= repairCost[mat]);
                const costText = recipe ? Object.keys(repairCost).map(mat => `${this.getMaterialDisplayName(mat)}: ${repairCost[mat]}`).join(', ') : 'N/A';
                
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #fff;">${shield.toUpperCase()}</strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Durability: ${Math.round(durability)}% → 100%
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Cost: ${costText}
                        </div>
                    </div>
                    <button class="craft-btn" ${!canRepair ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.repairItem('shields', '${shield}'); game.updateCraftingUI(); game.updateInventoryUI();" style="background: #4caf50;">
                        Repair
                    </button>
                `;
                repairList.appendChild(item);
            }
            
            // Show repairable upgrades
            for (let upgrade in this.ownedItems.upgrades) {
                const count = this.getItemCount('upgrades', upgrade);
                const durability = this.getItemDurability('upgrades', upgrade);
                if (count <= 0 || durability >= 100) continue;
                
                hasRepairableItems = true;
                const missingDurability = 100 - durability;
                
                // Calculate material cost (50% of crafting cost, scaled by missing durability)
                const recipe = this.recipes.upgrades[upgrade];
                const repairCost = {};
                if (recipe) {
                    for (let material in recipe) {
                        repairCost[material] = Math.ceil((recipe[material] * 0.5) * (missingDurability / 100));
                    }
                }
                const canRepair = recipe && Object.keys(repairCost).every(mat => this.inventory[mat] >= repairCost[mat]);
                const costText = recipe ? Object.keys(repairCost).map(mat => `${this.getMaterialDisplayName(mat)}: ${repairCost[mat]}`).join(', ') : 'N/A';
                
                const item = document.createElement('div');
                item.className = 'craft-item';
                item.innerHTML = `
                    <div>
                        <strong style="color: #fff;">${upgrade.toUpperCase()}</strong>
                        <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                            Durability: ${Math.round(durability)}% → 100%
                        </div>
                        <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                            Cost: ${costText}
                        </div>
                    </div>
                    <button class="craft-btn" ${!canRepair ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.repairItem('upgrades', '${upgrade}'); game.updateCraftingUI(); game.updateInventoryUI();" style="background: #4caf50;">
                        Repair
                    </button>
                `;
                repairList.appendChild(item);
            }
            
            // Show repairable tools (hammer)
            if (this.ownedItems.tools) {
                for (let tool in this.ownedItems.tools) {
                    const count = this.getItemCount('tools', tool);
                    const durability = this.getItemDurability('tools', tool);
                    if (count <= 0 || durability >= 100) continue;
                    
                    hasRepairableItems = true;
                    const missingDurability = 100 - durability;
                    
                    // Calculate material cost (50% of crafting cost, scaled by missing durability)
                    const recipe = this.recipes.tools[tool];
                    const repairCost = {};
                    if (recipe) {
                        for (let material in recipe) {
                            repairCost[material] = Math.ceil((recipe[material] * 0.5) * (missingDurability / 100));
                        }
                    }
                    const canRepair = recipe && Object.keys(repairCost).every(mat => this.inventory[mat] >= repairCost[mat]);
                    const costText = recipe ? Object.keys(repairCost).map(mat => `${this.getMaterialDisplayName(mat)}: ${repairCost[mat]}`).join(', ') : 'N/A';
                    
                    const item = document.createElement('div');
                    item.className = 'craft-item';
                    item.innerHTML = `
                        <div>
                            <strong style="color: #fff;">${tool.toUpperCase()}</strong>
                            <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                                Durability: ${Math.round(durability)}% → 100%
                            </div>
                            <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                                Cost: ${costText}
                            </div>
                        </div>
                        <button class="craft-btn" ${!canRepair ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.repairItem('tools', '${tool}'); game.updateCraftingUI(); game.updateInventoryUI();" style="background: #4caf50;">
                            Repair
                        </button>
                    `;
                    repairList.appendChild(item);
                }
            }
            
            if (!hasRepairableItems) {
                const noItems = document.createElement('div');
                noItems.style.color = '#aaa';
                noItems.style.textAlign = 'center';
                noItems.style.padding = '20px';
                noItems.textContent = 'No items need repair (all items at 100% durability)';
                repairList.appendChild(noItems);
            }
        }
        
        // Food Crafting Section (only if survival is unlocked)
        if (this.survivalUnlocked) {
            // Try to find or create food list container
            let foodList = document.getElementById('foodList');
            if (!foodList) {
                // Create food list container if it doesn't exist
                const craftingUI = document.getElementById('craftingUI');
                if (craftingUI) {
                    foodList = document.createElement('div');
                    foodList.id = 'foodList';
                    foodList.className = 'craft-list';
                    foodList.style.marginTop = '20px';
                    foodList.style.paddingTop = '20px';
                    foodList.style.borderTop = '2px solid #4fc3f7';
                    
                    const foodHeader = document.createElement('h3');
                    foodHeader.textContent = '🍽️ Food Crafting (Survival System)';
                    foodHeader.style.color = '#ff9800';
                    foodHeader.style.marginBottom = '15px';
                    foodList.appendChild(foodHeader);
                    
                    // Insert food list before repair section (so Repair Station appears after food crafting)
                    const repairList = document.getElementById('repairList');
                    if (repairList && repairList.parentNode) {
                        // Find the craft-section that contains repairList
                        const repairSection = repairList.closest('.craft-section');
                        if (repairSection && repairSection.parentNode) {
                            // Insert foodList before the repair section
                            repairSection.parentNode.insertBefore(foodList, repairSection);
                        } else {
                            // Fallback: insert before repairList
                            repairList.parentNode.insertBefore(foodList, repairList);
                        }
                    } else {
                        // Fallback: append to craftingUI
                        craftingUI.appendChild(foodList);
                    }
                }
            }
            
            if (foodList) {
                // Clear existing food items (but keep header)
                const existingItems = foodList.querySelectorAll('.craft-item');
                existingItems.forEach(item => item.remove());
                
                // Food item data with descriptions
                const foodData = {
                    basicMeal: { hunger: 20, methane: 0, description: 'Basic nutrition - restores 20 hunger' },
                    proteinBar: { hunger: 35, methane: 0, description: 'High protein - restores 35 hunger' },
                    energyDrink: { hunger: 35, methane: 5, description: 'Quick energy - restores 35 hunger, +5 methane' },
                    balancedMeal: { hunger: 50, methane: 0, description: 'Complete nutrition - restores 50 hunger' },
                    superFood: { hunger: 100, methane: 15, description: 'Ultimate nutrition - restores 100 hunger, +15 methane' },
                    methaneSnack: { hunger: 10, methane: 10, description: 'Quick methane boost - restores 10 hunger, +10 methane' }
                };
                
                // Show all food recipes
                for (let foodName in this.recipes.consumables) {
                    // Skip non-food items (like atomSplit)
                    if (!foodData[foodName]) continue;
                    
                    const recipe = this.recipes.consumables[foodName];
                    const foodInfo = foodData[foodName];
                    // Check if we have all required materials (handle undefined as 0)
                    const canCraft = Object.keys(recipe).every(mat => (this.inventory[mat] || 0) >= recipe[mat]);
                    const ownedCount = this.foodInventory[foodName] || 0;
                    
                    const item = document.createElement('div');
                    item.className = 'craft-item';
                    item.innerHTML = `
                        <div>
                            <strong style="color: #ff9800;">${foodName.toUpperCase().replace(/([A-Z])/g, ' $1').trim()}</strong>
                            <div style="font-size: 0.85em; color: #ff9800; margin-top: 3px;">
                                ${foodInfo.description}
                            </div>
                            <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                                ${Object.keys(recipe).map(mat => `${this.getMaterialDisplayName(mat)}: ${recipe[mat]}`).join(', ')}
                            </div>
                            ${ownedCount > 0 ? `<div style="font-size: 0.85em; color: #4caf50; margin-top: 5px;">✓ Owned: ${ownedCount}</div>` : ''}
                        </div>
                        <button class="craft-btn" ${!canCraft ? 'disabled' : ''} tabindex="-1" onclick="event.stopPropagation(); event.preventDefault(); game.craftFood('${foodName}'); game.updateCraftingUI();">
                            Craft
                        </button>
                    `;
                    foodList.appendChild(item);
                }
            }
        }
        
        // CRITICAL FIX: Restore scroll position IMMEDIATELY and MULTIPLE TIMES to prevent auto-scrolling
        // The browser may try to scroll multiple times during DOM updates, so we need to be aggressive
        
        // Immediate restore (synchronous, before any async operations)
        if (scrollableContainer && savedScrollTop >= 0) {
            scrollableContainer.scrollTop = savedScrollTop;
        }
        
        // Restore individual lists immediately
        if (weaponsList && weaponsListScroll >= 0) {
            weaponsList.scrollTop = weaponsListScroll;
        }
        if (shipsList && shipsListScroll >= 0) {
            shipsList.scrollTop = shipsListScroll;
        }
        if (shieldsList && shieldsListScroll >= 0) {
            shieldsList.scrollTop = shieldsListScroll;
        }
        
        // Restore again after a microtask (catches immediate DOM updates)
        Promise.resolve().then(() => {
            if (scrollableContainer && savedScrollTop >= 0) {
                scrollableContainer.scrollTop = savedScrollTop;
            }
            if (weaponsList && weaponsListScroll >= 0) {
                weaponsList.scrollTop = weaponsListScroll;
            }
            if (shipsList && shipsListScroll >= 0) {
                shipsList.scrollTop = shipsListScroll;
            }
            if (shieldsList && shieldsListScroll >= 0) {
                shieldsList.scrollTop = shieldsListScroll;
            }
        });
        
        // Restore after requestAnimationFrame (catches layout updates)
        requestAnimationFrame(() => {
            if (scrollableContainer && savedScrollTop >= 0) {
                scrollableContainer.scrollTop = savedScrollTop;
            }
            if (weaponsList && weaponsListScroll >= 0) {
                weaponsList.scrollTop = weaponsListScroll;
            }
            if (shipsList && shipsListScroll >= 0) {
                shipsList.scrollTop = shipsListScroll;
            }
            if (shieldsList && shieldsListScroll >= 0) {
                shieldsList.scrollTop = shieldsListScroll;
            }
            
            // Double-check after another frame (catches any delayed scrolls)
            requestAnimationFrame(() => {
                if (scrollableContainer && savedScrollTop >= 0) {
                    scrollableContainer.scrollTop = savedScrollTop;
                }
                if (weaponsList && weaponsListScroll >= 0) {
                    weaponsList.scrollTop = weaponsListScroll;
                }
                if (shipsList && shipsListScroll >= 0) {
                    shipsList.scrollTop = shipsListScroll;
                }
                if (shieldsList && shieldsListScroll >= 0) {
                    shieldsList.scrollTop = shieldsListScroll;
                }
            });
        });
    }
    
    repairItem(type, name) {
        // Only allow repairing during level-up
        if (!this.levelUpState) {
            return false;
        }
        
        const durability = this.getItemDurability(type, name);
        if (durability >= 100) {
            return false; // Already at full durability
        }
        
        const missingDurability = 100 - durability;
        
        // Get original crafting recipe to calculate repair cost (50% of crafting cost)
        let recipe = null;
        if (type === 'weapons' && this.recipes.weapons[name]) {
            recipe = this.recipes.weapons[name];
        } else if (type === 'ships' && this.recipes.ships[name]) {
            recipe = this.recipes.ships[name];
        } else if (type === 'shields' && this.recipes.shields[name]) {
            recipe = this.recipes.shields[name];
        } else if (type === 'upgrades' && this.recipes.upgrades[name]) {
            recipe = this.recipes.upgrades[name];
        } else if (type === 'tools' && this.recipes.tools[name]) {
            recipe = this.recipes.tools[name];
        }
        
        if (!recipe) {
            return false; // No recipe found
        }
        
        // Calculate repair cost: 50% of crafting cost, scaled by missing durability
        // Higher upgrade tiers cost more to repair (but not too much more)
        let repairCostMultiplier = 0.5; // Base: 50% of crafting cost
        
        // If repairing a weapon, add upgrade tier costs (each tier adds 10% more repair cost)
        if (type === 'weapons') {
            const upgradeLevel = this.weaponUpgrades[name] || 0;
            // Each upgrade tier adds 10% to repair cost (tier 1: +10%, tier 2: +20%, tier 3: +30%, tier 4: +40%)
            // But cap at 80% total (not too expensive)
            repairCostMultiplier = Math.min(0.8, 0.5 + (upgradeLevel * 0.1));
        }
        
        const repairCost = {};
        for (let material in recipe) {
            // Cost = base repair cost (50-80% of crafting cost), scaled by durability percentage missing
            repairCost[material] = Math.ceil((recipe[material] * repairCostMultiplier) * (missingDurability / 100));
        }
        
        // Check if player has enough materials
        for (let material in repairCost) {
            if (this.inventory[material] < repairCost[material]) {
                return false; // Not enough materials
            }
        }
        
        // Deduct materials and repair to full durability
        for (let material in repairCost) {
            this.inventory[material] -= repairCost[material];
        }
        this.setItemDurability(type, name, 100);
        
        // Reset use time for omnidirectional upgrade if repairing automatic weapon
        if (type === 'weapons' && name === 'automatic') {
            this.weaponUseTime['omnidirectional'] = 0;
        }
        
        // Reset shot count for weapons (repairing resets use-based decay counter)
        if (type === 'weapons') {
            this.weaponShotsFired[name] = 0;
        }
        
        this.updateStats();
        // Store scroll position before updating UI
        const repairList = document.getElementById('repairList');
        const scrollPosition = repairList ? repairList.scrollTop : 0;
        
        this.updateCraftingUI();
        this.updateInventoryUI();
        
        // Restore scroll position after UI update (don't auto-scroll)
        if (repairList) {
            repairList.scrollTop = scrollPosition;
        }
        
        // Don't call clearGamepadSelection() here - it causes unwanted scrolling
        // Just remove gamepad selection without scrolling
        document.querySelectorAll('.gamepad-selected').forEach(item => {
            item.classList.remove('gamepad-selected');
        });
        
        return true;
    }
    
    toggleHammer() {
        // Legacy function - use equipHammer/unequipHammer instead
        // This is kept for backwards compatibility but should not be used
        if (this.hammerEquipped) {
            this.unequipHammer();
        } else {
            this.equipHammer();
        }
    }
    
    updateRepairableItems() {
        // Find all items that can be repaired (durability < 100)
        this.repairableItems = [];
        
        // Check weapons
        for (let weapon in this.ownedItems.weapons) {
            const durability = this.getItemDurability('weapons', weapon);
            if (durability < 100 && this.currentWeapons.includes(weapon)) {
                this.repairableItems.push({ type: 'weapons', name: weapon, durability });
            }
        }
        
        // Check ships
        for (let ship in this.ownedItems.ships) {
            const durability = this.getItemDurability('ships', ship);
            if (durability < 100 && this.currentShip === ship) {
                this.repairableItems.push({ type: 'ships', name: ship, durability });
            }
        }
        
        // Check shields
        for (let shield in this.ownedItems.shields) {
            const durability = this.getItemDurability('shields', shield);
            if (durability < 100 && this.currentShield === shield) {
                this.repairableItems.push({ type: 'shields', name: shield, durability });
            }
        }
        
        // Check upgrades
        for (let upgrade in this.ownedItems.upgrades) {
            const durability = this.getItemDurability('upgrades', upgrade);
            if (durability < 100 && this.currentUpgrades.includes(upgrade)) {
                this.repairableItems.push({ type: 'upgrades', name: upgrade, durability });
            }
        }
    }
    
    useHammer() {
        // Use hammer to repair items in-game
        if (!this.hammerEquipped) {
            return false;
        }
        
        const hammerDurability = this.getItemDurability('tools', 'hammer');
        if (hammerDurability <= 0) {
            this.hammerEquipped = false; // Hammer broken
            return false;
        }
        
        // Find nearest repairable item
        this.updateRepairableItems();
        if (this.repairableItems.length === 0) {
            return false; // Nothing to repair
        }
        
        // Use selected repair item if in repair selection mode, otherwise find closest
        let closestItem = null;
        
        if (this.repairSelectionMode && this.repairableItems.length > 0) {
            // Use selected item from repair selection
            closestItem = this.repairableItems[this.repairSelectedIndex];
        } else {
            // Find closest repairable item to player (lowest durability)
            let closestDist = Infinity;
            this.repairableItems.forEach(item => {
                // Calculate distance (for equipped items, use player position)
                const dist = 0; // All equipped items are "at" player position
                if (dist < closestDist || (dist === closestDist && item.durability < closestItem.durability)) {
                    closestDist = dist;
                    closestItem = item;
                }
            });
        }
        
        if (!closestItem) {
            return false;
        }
        
        // Repair the item (restore 10% durability per use)
        const currentDurability = this.getItemDurability(closestItem.type, closestItem.name);
        const newDurability = Math.min(100, currentDurability + 10);
        this.setItemDurability(closestItem.type, closestItem.name, newDurability);
        
        // Hammer loses 2% durability per use
        const hammerItem = this.ownedItems.tools.hammer;
        if (hammerItem && typeof hammerItem === 'object') {
            hammerItem.durability = Math.max(0, hammerItem.durability - 2);
            
            if (hammerItem.durability <= 0) {
                hammerItem.count--;
                if (hammerItem.count > 0) {
                    hammerItem.durability = 100;
                } else {
                    delete this.ownedItems.tools.hammer;
                    this.hammerEquipped = false;
                }
            }
        }
        
        // Reset use-based decay counters for repaired weapon
        if (closestItem.type === 'weapons') {
            this.weaponShotsFired[closestItem.name] = 0;
        }
        
        this.updateRepairableItems();
        this.updateInventoryUI();
        return true;
    }

    updateShopUI() {
        const tokenDisplay = document.getElementById('tokenDisplay');
        const upgradesList = document.getElementById('upgradesList');
        const shopInstructions = document.getElementById('shopInstructions');
        
        if (tokenDisplay) {
            tokenDisplay.textContent = this.inventory.tokens;
        }
        
        if (shopInstructions) {
            if (this.levelUpState) {
                shopInstructions.textContent = `Level ${this.level} Complete! Upgrade your stats or craft items.`;
            } else {
                shopInstructions.textContent = 'Available only during level-up';
            }
        }
        
        if (upgradesList) {
            upgradesList.innerHTML = '';
            // Dynamic costs that increase with each purchase
            const speedUpgrades = this.upgradeLevels.speed || 0;
            const fireRateUpgrades = this.upgradeLevels.fireRate || 0;
            const healthPacksOwned = (this.ownedItems.consumables && this.ownedItems.consumables.healthPack) || 0;
            
            // Calculate costs based on upgrade levels and game progression
            // Costs scale logarithmically with level to prevent exponential growth at high levels
            // Using log(level + 1) to avoid log(1) = 0, and scaling by 0.5 for reasonable growth
            const baseCostMultiplier = 1 + (Math.log(this.level + 1) * 0.5); // Logarithmic scaling prevents exponential cost growth
            
            const upgrades = [
                // Tier 1: Core Combat Stats
                { 
                    name: '⚡ Speed', 
                    stat: 'speed', 
                    cost: Math.floor((10 + (speedUpgrades * 5)) * baseCostMultiplier),
                    current: this.playerStats.speed,
                    description: `Current: ${this.playerStats.speed} (Next: +30)`,
                    category: 'combat'
                },
                { 
                    name: '🔥 Fire Rate', 
                    stat: 'fireRate', 
                    cost: Math.floor((15 + (fireRateUpgrades * 5)) * baseCostMultiplier),
                    current: this.playerStats.fireRate.toFixed(2),
                    description: `Current: ${this.playerStats.fireRate.toFixed(2)}/s (Next: +0.2/s)`,
                    category: 'combat'
                },
                { 
                    name: '💥 Damage', 
                    stat: 'damage', 
                    cost: Math.floor((20 + (this.upgradeLevels.damage || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.damage,
                    description: `Base: ${this.playerStats.baseDamage} → Current: ${this.playerStats.damage} (Next: +2)`,
                    category: 'combat'
                },
                { 
                    name: '🚀 Projectile Speed', 
                    stat: 'projectileSpeed', 
                    cost: Math.floor((20 + (this.upgradeLevels.projectileSpeed || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.projectileSpeed.toFixed(1) + '%',
                    description: `Current: +${this.playerStats.projectileSpeed.toFixed(1)}% (Next: +10%)`,
                    category: 'combat'
                },
                { 
                    name: '🎯 Critical Hit Chance', 
                    stat: 'criticalHitChance', 
                    cost: Math.floor((30 + (this.upgradeLevels.criticalHitChance || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.criticalHitChance.toFixed(1) + '%',
                    description: `Current: ${this.playerStats.criticalHitChance.toFixed(1)}% (Next: +2%, Max: 100%)`,
                    category: 'combat'
                },
                { 
                    name: '⚔️ Critical Hit Damage', 
                    stat: 'criticalHitDamage', 
                    cost: Math.floor((35 + (this.upgradeLevels.criticalHitDamage || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.criticalHitDamage.toFixed(2) + 'x',
                    description: `Current: ${this.playerStats.criticalHitDamage.toFixed(2)}x (Next: +0.05x)`,
                    category: 'combat'
                },
                // Tier 2: Defense Stats
                { 
                    name: '🛡️ Shield Capacity', 
                    stat: 'shieldCapacityBonus', 
                    cost: Math.floor((30 + (this.upgradeLevels.shieldCapacityBonus || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.shieldCapacityBonus.toFixed(1) + '%',
                    description: `Current: +${this.playerStats.shieldCapacityBonus.toFixed(1)}% (Next: +5%, Max: 100%)`,
                    category: 'defense'
                },
                { 
                    name: '🔋 Shield Regeneration', 
                    stat: 'shieldRegenBonus', 
                    cost: Math.floor((35 + (this.upgradeLevels.shieldRegenBonus || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.shieldRegenBonus.toFixed(1) + '/s',
                    description: `Current: +${this.playerStats.shieldRegenBonus.toFixed(1)}/s (Next: +1/s)`,
                    category: 'defense'
                },
                { 
                    name: '🛡️ Damage Reduction', 
                    stat: 'damageReduction', 
                    cost: Math.floor((40 + (this.upgradeLevels.damageReduction || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.damageReduction.toFixed(1) + '%',
                    description: `Current: ${this.playerStats.damageReduction.toFixed(1)}% (Next: +1%, Max: 50%)`,
                    category: 'defense'
                },
                { 
                    name: '✨ Evasion', 
                    stat: 'evasion', 
                    cost: Math.floor((40 + (this.upgradeLevels.evasion || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.evasion.toFixed(1) + '%',
                    description: `Current: ${this.playerStats.evasion.toFixed(1)}% (Next: +1%, Max: 30%)`,
                    category: 'defense'
                },
                // Tier 3: Economy/Progression
                { 
                    name: '💎 Material Drop Rate', 
                    stat: 'materialDropRate', 
                    cost: Math.floor((25 + (this.upgradeLevels.materialDropRate || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.materialDropRate.toFixed(1) + '%',
                    description: `Current: +${this.playerStats.materialDropRate.toFixed(1)}% (Next: +5%)`,
                    category: 'economy'
                },
                { 
                    name: '💰 Token Drop Rate', 
                    stat: 'tokenDropRate', 
                    cost: Math.floor((30 + (this.upgradeLevels.tokenDropRate || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.tokenDropRate.toFixed(1) + '%',
                    description: `Current: +${this.playerStats.tokenDropRate.toFixed(1)}% (Next: +5%)`,
                    category: 'economy'
                },
                { 
                    name: '⏱️ Level Time Reduction', 
                    stat: 'levelTimeReduction', 
                    cost: Math.floor((45 + (this.upgradeLevels.levelTimeReduction || 0) * 7) * baseCostMultiplier),
                    current: this.playerStats.levelTimeReduction.toFixed(1) + '%',
                    description: `Current: -${this.playerStats.levelTimeReduction.toFixed(1)}% time per level (Next: -3%, Max: 40% = 18s per level)`,
                    category: 'economy'
                },
                // Tier 4: Quality of Life
                { 
                    name: '❤️ Max Health', 
                    stat: 'maxHealth', 
                    cost: Math.floor((25 + (this.upgradeLevels.maxHealth || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.maxHealth,
                    description: `Current: ${this.playerStats.maxHealth} HP (Next: +10)`,
                    category: 'quality'
                },
                { 
                    name: '💚 Health Regeneration', 
                    stat: 'healthRegen', 
                    cost: Math.floor((30 + (this.upgradeLevels.healthRegen || 0) * 5) * baseCostMultiplier),
                    current: this.playerStats.healthRegen.toFixed(1) + ' HP/s',
                    description: `Current: ${this.playerStats.healthRegen.toFixed(1)} HP/s (Next: +0.5 HP/s)`,
                    category: 'quality'
                },
                // Consumables
                { 
                    name: '💉 Health Pack', 
                    stat: 'health', 
                    cost: Math.floor((20 + (healthPacksOwned * 5)) * baseCostMultiplier),
                    current: healthPacksOwned,
                    description: `Owned: ${healthPacksOwned} packs (Restores 50 HP each)`,
                    category: 'consumable'
                }
            ];
            
            // Organize upgrades by category
            const categories = {
                combat: { name: '⚔️ Combat Stats', upgrades: [] },
                defense: { name: '🛡️ Defense Stats', upgrades: [] },
                economy: { name: '💰 Economy/Progression', upgrades: [] },
                quality: { name: '✨ Quality of Life', upgrades: [] },
                consumable: { name: '💉 Consumables', upgrades: [] }
            };
            
            upgrades.forEach(upgrade => {
                if (categories[upgrade.category]) {
                    categories[upgrade.category].upgrades.push(upgrade);
                }
            });
            
            // Display upgrades by category
            Object.keys(categories).forEach(categoryKey => {
                const category = categories[categoryKey];
                if (category.upgrades.length === 0) return;
                
                // Category header
                const categoryHeader = document.createElement('div');
                categoryHeader.style.cssText = 'font-size: 1.1em; font-weight: bold; color: #4fc3f7; margin-top: 15px; margin-bottom: 8px; padding-bottom: 5px; border-bottom: 1px solid #4fc3f7;';
                categoryHeader.textContent = category.name;
                upgradesList.appendChild(categoryHeader);
                
                // Category upgrades
                category.upgrades.forEach(upgrade => {
                    const canAfford = this.inventory.tokens >= upgrade.cost;
                    const item = document.createElement('div');
                    item.className = 'shop-item';
                    item.innerHTML = `
                        <div>
                            <strong style="color: #4fc3f7;">${upgrade.name}</strong>
                            <div style="font-size: 0.85em; color: #4fc3f7; margin-top: 3px;">
                                ${upgrade.description}
                            </div>
                            <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                                Cost: ${upgrade.cost} tokens
                            </div>
                        </div>
                        <button class="shop-btn" ${!canAfford ? 'disabled' : ''} onclick="event.stopPropagation(); game.upgradeStat('${upgrade.stat}', ${upgrade.cost}); game.updateShopUI(); game.updateInventoryUI();">
                            Buy
                        </button>
                    `;
                    upgradesList.appendChild(item);
                });
            });
        }
    }

    updateStats() {
        // OPTIMIZATION: Use cached DOM elements and only update when values change
        const accuracy = this.hits + this.misses > 0 
            ? (this.hits / (this.hits + this.misses) * 100).toFixed(1) + '%'
            : '100%';
        
        // Use cached elements
        const scoreEl = this._cachedElements.scoreValue;
        const hitsEl = this._cachedElements.hitsValue;
        const missesEl = this._cachedElements.missesValue;
        const accuracyEl = this._cachedElements.accuracyDisplay;
        const targetEl = this._cachedElements.targetCount;
        
        // Only update DOM if value changed
        if (scoreEl && this._lastUIValues.score !== this.score) {
            scoreEl.textContent = this.score;
            this._lastUIValues.score = this.score;
        }
        if (hitsEl && this._lastUIValues.hits !== this.hits) {
            hitsEl.textContent = this.hits;
            this._lastUIValues.hits = this.hits;
        }
        if (missesEl && this._lastUIValues.misses !== this.misses) {
            missesEl.textContent = this.misses;
            this._lastUIValues.misses = this.misses;
        }
        if (accuracyEl && this._lastUIValues.accuracy !== accuracy) {
            accuracyEl.textContent = accuracy;
            this._lastUIValues.accuracy = accuracy;
        }
        if (targetEl) {
            const targetCount = this.mode === 'bell' ? this.pairs.length * 2 : this.targets.length;
            if (this._lastUIValues.targetCount !== targetCount) {
                targetEl.textContent = targetCount;
                this._lastUIValues.targetCount = targetCount;
            }
        }
        
        // Update inventory display using cached elements - only when values change
        const invQuantum = this._cachedElements.invQuantum;
        const invEnergy = this._cachedElements.invEnergy;
        const invMetal = this._cachedElements.invMetal;
        const invCrystals = this._cachedElements.invCrystals;
        const invTokens = this._cachedElements.invTokens;
        
        if (invQuantum && this._lastUIValues.quantumParticles !== this.inventory.quantumParticles) {
            invQuantum.textContent = this.inventory.quantumParticles;
            this._lastUIValues.quantumParticles = this.inventory.quantumParticles;
        }
        if (invEnergy && this._lastUIValues.energyCores !== this.inventory.energyCores) {
            invEnergy.textContent = this.inventory.energyCores;
            this._lastUIValues.energyCores = this.inventory.energyCores;
        }
        if (invMetal && this._lastUIValues.metalScraps !== this.inventory.metalScraps) {
            invMetal.textContent = this.inventory.metalScraps;
            this._lastUIValues.metalScraps = this.inventory.metalScraps;
        }
        if (invCrystals && this._lastUIValues.crystals !== this.inventory.crystals) {
            invCrystals.textContent = this.inventory.crystals;
            this._lastUIValues.crystals = this.inventory.crystals;
        }
        if (invTokens && this._lastUIValues.tokens !== this.inventory.tokens) {
            invTokens.textContent = this.inventory.tokens;
            this._lastUIValues.tokens = this.inventory.tokens;
        }
        
        
        // Update save feature UI (show/hide button and hint) using cached elements - only when state changes
        const loadSaveBtn = this._cachedElements.loadSaveBtn;
        const saveHint = this._cachedElements.saveHint;
        
        if (this._lastUIValues.saveUnlocked !== this.hiddenSequence.saveUnlocked) {
            if (this.hiddenSequence.saveUnlocked) {
                // Save feature unlocked - show button and enable it
                if (loadSaveBtn) {
                    loadSaveBtn.style.display = 'block';
                    loadSaveBtn.disabled = false;
                    loadSaveBtn.style.opacity = '1';
                    loadSaveBtn.style.cursor = 'pointer';
                    loadSaveBtn.textContent = '💾 Load Last Save (V) - 2 Levels Back';
                }
                if (saveHint) {
                    saveHint.style.display = 'block';
                }
            } else {
                // Save feature locked - hide button and hint
                if (loadSaveBtn) {
                    loadSaveBtn.style.display = 'none';
                    loadSaveBtn.disabled = true;
                }
                if (saveHint) {
                    saveHint.style.display = 'none';
                }
            }
            this._lastUIValues.saveUnlocked = this.hiddenSequence.saveUnlocked;
        }
        
        // Update top scores display (async load) using cached elements
        this.loadTopScores().then(({ topScore, topLevel }) => {
            const topScoreEl = this._cachedElements.topScoreDisplay;
            const topLevelEl = this._cachedElements.topLevelDisplay;
            if (topScoreEl) topScoreEl.textContent = topScore;
            if (topLevelEl) topLevelEl.textContent = topLevel;
        });
    }

    draw() {
        // Draw cutscene if active
        if (this.gameState === 'cutscene') {
            // Debug: Log first draw call for cutscene
            if (!this._cutsceneDrawCallLogged) {
                console.log(`[Draw] draw() called with gameState='cutscene', cutsceneId='${this.cutsceneId}'`);
                this._cutsceneDrawCallLogged = true;
            }
            this.drawCutscene();
            return;
        }
        
        // Reset debug flag when not in cutscene
        if (this._cutsceneDrawCallLogged) {
            this._cutsceneDrawCallLogged = false;
        }
        
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw background - boss mode has special background, otherwise mode-specific backgrounds
        if (this.bossMode) {
            this.drawBossBackground();
        } else {
            // Mode-specific enhanced backgrounds
            if (this.mode === 'bell') {
                this.drawBellModeBackground();
            } else if (this.mode === 'individual') {
                this.drawIndividualModeBackground();
            } else {
                // Ensemble QM mode (default)
                this.drawEnsembleModeBackground();
            }
        }
        
        // Draw game when playing or paused (tutorial is just an overlay)
        if (this.gameState === 'playing' || this.gameState === 'paused') {
            // Boss mode combines all three modes
            if (this.bossMode) {
                // Boss mode: show targets, pairs, obstacles, and boss enemies
                this.drawTargets();
                this.drawPairs();
                this.drawBossEnemies();
            } else if (this.mode === 'bell') {
                this.drawPairs();
                this.drawEnemyShips();
            } else {
                this.drawTargets();
            }
            
            this.drawObstacles();
            this.drawItems();
            this.drawBullets();
            this.drawLaserBeam(); // Draw laser beam if active
            this.drawParticles();
            this.drawPlayer();
            this.drawAutoCollectorField(); // Draw auto-collector magnetic field
            this.drawCompleteDescriptionMatrix(); // Draw complete description matrix effects
            this.drawEnsembleBypass(); // Draw ensemble bypass effects
            this.drawTransformationTimeScanner(); // Draw transformation time scanner effects
            this.drawIndividualSystemAmplifier(); // Draw individual system amplifier effects
            this.drawCrosshair();
            this.drawCursor(); // Draw custom cursor (the + symbol)
            this.drawHUD();
            
            // Draw food materials inventory UI (top-left corner) if survival is unlocked
            if (this.survivalUnlocked) {
                this.drawFoodMaterialsUI();
            }
            
            // Update materials inventory UI transparency based on player position (every frame)
            this.updateMaterialsInventoryTransparency();
            
            // Draw repairable items indicator when hammer is equipped
            if (this.hammerEquipped) {
                this.drawRepairableItemsIndicator();
            }
            
            // Boss puzzle hints removed - players must figure it out themselves
            
            if (this.mode === 'ensemble' && !this.bossMode) {
                this.drawEnsembleOverlay();
            }
            
            // Dev mode: Debug info display
            if (this.devMode && this.devShowDebug) {
                this.drawDebugInfo();
            }
        } else if (this.gameState === 'gameover') {
            this.drawGameOver();
        } else if (this.gameState === 'leaderboard') {
            // Still draw game in background with mode-specific background
            if (this.mode === 'bell') {
                this.drawBellModeBackground();
            } else if (this.mode === 'individual') {
                this.drawIndividualModeBackground();
            } else {
                this.drawEnsembleModeBackground();
            }
            this.drawPlayer();
        }
    }
    
    drawBossBackground() {
        const time = this.time || 0;
        
        // OPTIMIZED: Reduced complexity for better performance in boss mode
        // Deep dark purple/red gradient background - simplified to single gradient
        const gradient = this.ctx.createRadialGradient(
            this.canvas.width / 2, 
            this.canvas.height / 2, 
            0,
            this.canvas.width / 2, 
            this.canvas.height / 2, 
            Math.max(this.canvas.width, this.canvas.height) * 0.8
        );
        gradient.addColorStop(0, '#0a0515');
        gradient.addColorStop(0.2, '#1a0a2e');
        gradient.addColorStop(0.4, '#16213e');
        gradient.addColorStop(0.7, '#0f0f1e');
        gradient.addColorStop(1, '#050510');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // OPTIMIZED: Reduced from 4 layers to 2 layers, and from 30 to 15 connections per layer
        // This reduces rendering from 120 lines to 30 lines per frame
        for (let layer = 0; layer < 2; layer++) {
            const layerAlpha = 0.2 - layer * 0.05;
            const layerOffset = time * 0.08 * (layer + 1);
            const layerColor = layer % 2 === 0 ? '139, 0, 255' : '156, 39, 176';
            
            // OPTIMIZED: Simplified gradient - single color instead of multi-stop gradient
            this.ctx.strokeStyle = `rgba(${layerColor}, ${layerAlpha})`;
            this.ctx.lineWidth = 1.5 + layer * 0.5;
            // OPTIMIZED: Reduced shadow blur for better performance
            this.ctx.shadowBlur = 4 + layer;
            this.ctx.shadowColor = `rgba(${layerColor}, ${layerAlpha * 0.8})`;
            
            // OPTIMIZED: Reduced from 30 to 15 connections per layer
            for (let i = 0; i < 15; i++) {
                const x1 = ((i * 137.5 + layerOffset * 50) % this.canvas.width);
                const y1 = ((i * 197.3 + layerOffset * 30) % this.canvas.height);
                const x2 = (((i + 5) * 137.5 + layerOffset * 50) % this.canvas.width);
                const y2 = (((i + 5) * 197.3 + layerOffset * 30) % this.canvas.height);
                
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
            }
            this.ctx.shadowBlur = 0;
        }
        
        // OPTIMIZED: Reduced from 50 nodes to 25 nodes, and simplified rendering
        // Removed expensive multi-layer gradients and shadows
        const pulse = Math.sin(time * 2) * 0.3 + 0.7;
        for (let i = 0; i < 25; i++) {
            const x = (i * 137.5) % this.canvas.width;
            const y = (i * 197.3) % this.canvas.height;
            const nodePulse = Math.sin(time * 2 + i * 0.2) * 0.3 + 0.7;
            const size = 2.5 + Math.sin(time * 1.5 + i) * 1;
            
            // OPTIMIZED: Single simple glow instead of multiple gradient layers
            this.ctx.fillStyle = `rgba(139, 0, 255, ${0.3 * pulse * nodePulse})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size * 2, 0, Math.PI * 2);
            this.ctx.fill();
            
            // OPTIMIZED: Simple inner core without expensive gradient
            this.ctx.fillStyle = `rgba(200, 100, 255, ${0.6 * pulse * nodePulse})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // OPTIMIZED: Reduced from 15 to 8 energy flow particles
        for (let i = 0; i < 8; i++) {
            const flowPos = (time * 0.4 + i * 0.15) % 1;
            const x1 = (i * 137.5) % this.canvas.width;
            const y1 = (i * 197.3) % this.canvas.height;
            const x2 = ((i + 5) * 137.5) % this.canvas.width;
            const y2 = ((i + 5) * 197.3) % this.canvas.height;
            const flowX = x1 + (x2 - x1) * flowPos;
            const flowY = y1 + (y2 - y1) * flowPos;
            
            // OPTIMIZED: Simplified energy particle - single circle without expensive gradient
            this.ctx.fillStyle = `rgba(200, 100, 255, 0.8)`;
            this.ctx.beginPath();
            this.ctx.arc(flowX, flowY, 4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // OPTIMIZED: Reduced from 25 to 12 intersection nodes, simplified rendering
        for (let i = 0; i < 12; i++) {
            const nodeX = (i * 137.5) % this.canvas.width;
            const nodeY = (i * 197.3) % this.canvas.height;
            const intersectionPulse = Math.sin(time * 1.8 + i * 0.3) * 0.4 + 0.6;
            
            // OPTIMIZED: Simple glow without expensive gradient
            this.ctx.fillStyle = `rgba(200, 100, 255, ${0.4 * intersectionPulse})`;
            this.ctx.beginPath();
            this.ctx.arc(nodeX, nodeY, 8, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // OPTIMIZED: Reduced from 8 to 4 energy clouds, simplified gradient
        for (let i = 0; i < 4; i++) {
            const cloudX = (i * 300 + time * 15) % (this.canvas.width + 200) - 100;
            const cloudY = (i * 250 + time * 12) % (this.canvas.height + 200) - 100;
            const cloudSize = 180 + Math.sin(time * 0.8 + i) * 40;
            const cloudPulse = Math.sin(time * 0.5 + i) * 0.2 + 0.8;
            
            // OPTIMIZED: Simple fill instead of expensive gradient
            this.ctx.fillStyle = `rgba(10, 5, 20, ${0.3 * cloudPulse})`;
            this.ctx.beginPath();
            this.ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // OPTIMIZED: Reduced from 3 to 2 neural field waves
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        for (let wave = 0; wave < 2; wave++) {
            const wavePhase = (time * 0.3 + wave * 0.5) % 1;
            const waveRadius = Math.max(this.canvas.width, this.canvas.height) * 0.3 * wavePhase;
            const waveAlpha = (1 - wavePhase) * 0.15;
            
            this.ctx.strokeStyle = `rgba(139, 0, 255, ${waveAlpha})`;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([8, 8]);
            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, waveRadius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        this.ctx.setLineDash([]);
    }
    
    checkDNAHelixPuzzle() {
        // Check if both DNA strands were destroyed in order (strand1 first, then strand2)
        if (!this.bossPuzzleState) return;
        
        if (this.bossPuzzleState.strand1Destroyed && this.bossPuzzleState.strand2Destroyed) {
            // Both strands destroyed in order - core is vulnerable
            this.bossPuzzleState.coreVulnerable = true;
            const core = this.obstacles.find(o => o.isBoss && o.bossPart === 'core' && o.bossType === 'dnaHelix');
            if (core) {
                core.canTakeDamage = true;
                console.log('[DNA Helix Boss] Core is now vulnerable! Both strands destroyed in order.');
            } else {
                console.warn('[DNA Helix Boss] Core not found when trying to make it vulnerable!');
            }
        }
    }
    
    drawBossPuzzleHint() {
        // Show puzzle hint for boss battles
        if (!this.currentBoss || !this.bossPuzzleState) return;
        
        const bossNumber = Math.floor(this.level / 15);
        let hintText = '';
        let bossName = '';
        
        if (this.currentBoss.bossType === 'neurotransmitter') {
            // Level 15: Neurotransmitter boss
            bossName = '🧠 NEUROTRANSMITTER BOSS';
            const vesiclesRemaining = this.bossPuzzleState.totalVesicles - this.bossPuzzleState.vesiclesDestroyed;
            hintText = vesiclesRemaining > 0 
                ? `Destroy ${vesiclesRemaining} vesicle${vesiclesRemaining > 1 ? 's' : ''} first!`
                : 'Neuron core is now vulnerable!';
        } else if (this.currentBoss.bossType === 'dnaHelix') {
            // Level 30: DNA Helix boss - order-based: strand1 first, then strand2, then core
            bossName = '🧬 DNA HELIX BOSS';
            if (!this.bossPuzzleState.strand1Destroyed && !this.bossPuzzleState.strand2Destroyed) {
                hintText = 'Destroy strand 1 (green) first!';
            } else if (this.bossPuzzleState.strand1Destroyed && !this.bossPuzzleState.strand2Destroyed) {
                hintText = 'Now destroy strand 2 (cyan)!';
            } else if (this.bossPuzzleState.strand1Destroyed && this.bossPuzzleState.strand2Destroyed && this.bossPuzzleState.coreVulnerable) {
                hintText = 'Core is now vulnerable!';
            } else {
                hintText = 'Destroy strand 1 (green) first, then strand 2 (cyan)!';
            }
        } else if (this.currentBoss.bossType === 'proteinComplex') {
            // Level 45: Protein Complex boss
            bossName = '🔬 PROTEIN COMPLEX BOSS';
            const nextOrder = this.bossPuzzleState.nextSubunitOrder;
            const remaining = this.bossPuzzleState.totalSubunits - this.bossPuzzleState.subunitsDestroyed;
            if (remaining > 0) {
                hintText = `Destroy subunit ${nextOrder} (${remaining} remaining, must be in order!)`;
            } else {
                hintText = 'All subunits destroyed! Core is now vulnerable!';
            }
        } else if (this.currentBoss.bossType === 'cellMembrane') {
            // Level 60: Cell Membrane boss
            bossName = '🦠 CELL MEMBRANE BOSS';
            if (!this.bossPuzzleState.outerMembraneDestroyed) {
                hintText = 'Destroy outer membrane first!';
            } else if (!this.bossPuzzleState.innerMembraneDestroyed) {
                hintText = 'Destroy inner membrane next!';
            } else {
                hintText = 'Nucleus is now vulnerable!';
            }
        } else if (this.currentBoss.bossType === 'advanced') {
            // Level 75+: Advanced bosses
            bossName = '⚛️ ADVANCED BOSS';
            hintText = 'Destroy the core!';
        }
        
        if (hintText) {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            this.ctx.fillRect(10, 10, 500, 50);
            this.ctx.fillStyle = '#ff6b6b';
            this.ctx.font = 'bold 16px Arial';
            this.ctx.textAlign = 'left';
            this.ctx.fillText(bossName, 20, 35);
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '14px Arial';
            this.ctx.fillText(hintText, 20, 55);
        }
    }

    // Enhanced Ensemble QM Mode Background - Quantum field with particles
    drawEnsembleModeBackground() {
        const time = this.time || 0;
        
        // Rich deep space gradient background
        const gradient = this.ctx.createRadialGradient(
            this.canvas.width / 2, 
            this.canvas.height / 2, 
            0,
            this.canvas.width / 2, 
            this.canvas.height / 2, 
            Math.max(this.canvas.width, this.canvas.height) * 0.9
        );
        gradient.addColorStop(0, '#0a0a1a');
        gradient.addColorStop(0.3, '#1a1a2e');
        gradient.addColorStop(0.7, '#0f0f1e');
        gradient.addColorStop(1, '#050510');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Enhanced starfield with varying sizes and twinkling
        for (let i = 0; i < 300; i++) {
            const seed = i * 137.5;
            const x = (seed) % this.canvas.width;
            const y = (seed * 1.618) % this.canvas.height;
            const twinkle = Math.sin(time * 0.5 + i * 0.1) * 0.3 + 0.7;
            const size = (i % 4) + 0.5; // Varying star sizes
            
            this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * twinkle})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Quantum field particles (enhanced blue particles with glow)
        for (let i = 0; i < 40; i++) {
            const angle = time * 0.2 + i * 0.4;
            const radius = 80 + i * 18;
            const x = this.canvas.width / 2 + Math.cos(angle) * radius;
            const y = this.canvas.height / 2 + Math.sin(angle) * radius;
            const pulse = Math.sin(time * 2 + i * 0.2) * 0.3 + 0.7;
            const particleSize = 2 + Math.sin(time * 1.5 + i) * 0.5;
            
            // Outer glow
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = 'rgba(79, 195, 247, 0.6)';
            this.ctx.fillStyle = `rgba(79, 195, 247, ${0.4 * pulse})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            
            // Inner bright core
            this.ctx.fillStyle = `rgba(129, 212, 250, ${0.8 * pulse})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, particleSize * 0.5, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Enhanced quantum field lines (energy connections with flow)
        this.ctx.strokeStyle = 'rgba(79, 195, 247, 0.15)';
        this.ctx.lineWidth = 1.5;
        for (let i = 0; i < 20; i++) {
            const angle1 = time * 0.1 + i * 0.3;
            const angle2 = time * 0.1 + (i + 4) * 0.3;
            const radius = 120 + (i % 5) * 30;
            const x1 = this.canvas.width / 2 + Math.cos(angle1) * radius;
            const y1 = this.canvas.height / 2 + Math.sin(angle1) * radius;
            const x2 = this.canvas.width / 2 + Math.cos(angle2) * radius;
            const y2 = this.canvas.height / 2 + Math.sin(angle2) * radius;
            
            // Connection line
            this.ctx.shadowBlur = 5;
            this.ctx.shadowColor = 'rgba(79, 195, 247, 0.3)';
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Energy flow along connection
            const flowPos = (time * 0.3 + i * 0.1) % 1;
            const flowX = x1 + (x2 - x1) * flowPos;
            const flowY = y1 + (y2 - y1) * flowPos;
            const flowPulse = Math.sin(time * 3 + i) * 0.3 + 0.7;
            
            this.ctx.fillStyle = `rgba(129, 212, 250, ${0.8 * flowPulse})`;
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = 'rgba(79, 195, 247, 0.8)';
            this.ctx.beginPath();
            this.ctx.arc(flowX, flowY, 2.5, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
        
        // Quantum field nodes (intersection points)
        for (let i = 0; i < 25; i++) {
            const angle = time * 0.1 + i * 0.5;
            const radius = 100 + (i % 6) * 35;
            const x = this.canvas.width / 2 + Math.cos(angle) * radius;
            const y = this.canvas.height / 2 + Math.sin(angle) * radius;
            const nodePulse = Math.sin(time * 1.8 + i * 0.3) * 0.4 + 0.6;
            const nodeSize = 2 + Math.sin(time * 2 + i) * 0.8;
            
            // Outer glow
            this.ctx.shadowBlur = 12;
            this.ctx.shadowColor = 'rgba(79, 195, 247, 0.7)';
            this.ctx.fillStyle = `rgba(79, 195, 247, ${0.5 * nodePulse})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, nodeSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            
            // Inner bright core
            this.ctx.fillStyle = `rgba(129, 212, 250, ${0.9 * nodePulse})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, nodeSize * 0.5, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Central quantum core (ensemble focus point)
        const corePulse = Math.sin(time * 2) * 0.2 + 0.8;
        const coreSize = 5 + Math.sin(time * 2.5) * 1.5;
        
        // Outer pulsing rings
        for (let i = 1; i <= 4; i++) {
            const ringRadius = coreSize * i * 2;
            const ringAlpha = (0.2 / i) * corePulse;
            const ringPulse = Math.sin(time * 2 + i * 0.4) * 0.3 + 0.7;
            this.ctx.strokeStyle = `rgba(79, 195, 247, ${ringAlpha * ringPulse})`;
            this.ctx.lineWidth = 1.5;
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = 'rgba(79, 195, 247, 0.4)';
            this.ctx.beginPath();
            this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, ringRadius, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
        }
        
        // Central core with enhanced glow
        this.ctx.shadowBlur = 25;
        this.ctx.shadowColor = 'rgba(79, 195, 247, 0.9)';
        this.ctx.fillStyle = `rgba(129, 212, 250, ${0.95 * corePulse})`;
        this.ctx.beginPath();
        this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, coreSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Inner bright core
        this.ctx.fillStyle = `rgba(255, 255, 255, ${corePulse})`;
        this.ctx.beginPath();
        this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, coreSize * 0.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Quantum field waves (expanding from center)
        for (let i = 1; i <= 3; i++) {
            const waveRadius = 180 + i * 90 + Math.sin(time * 1.2 + i) * 40;
            const waveAlpha = (0.12 / i) * (0.7 + Math.sin(time * 1.8 + i) * 0.3);
            this.ctx.strokeStyle = `rgba(79, 195, 247, ${waveAlpha})`;
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, waveRadius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        
        // Subtle nebula clouds (background depth)
        for (let i = 0; i < 4; i++) {
            const cloudX = (i * 400 + time * 15) % (this.canvas.width + 300) - 150;
            const cloudY = (i * 350 + time * 12) % (this.canvas.height + 300) - 150;
            const cloudSize = 200 + Math.sin(time * 0.8 + i) * 50;
            
            const cloudGradient = this.ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, cloudSize);
            cloudGradient.addColorStop(0, 'rgba(26, 26, 46, 0.3)');
            cloudGradient.addColorStop(0.5, 'rgba(15, 15, 30, 0.2)');
            cloudGradient.addColorStop(1, 'rgba(10, 10, 20, 0)');
            this.ctx.fillStyle = cloudGradient;
            this.ctx.beginPath();
            this.ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }
    
    // Enhanced Individual Mode Background - Precision energy field
    drawIndividualModeBackground() {
        const time = this.time || 0;
        
        // Rich dark background with amber/gold accents
        const gradient = this.ctx.createRadialGradient(
            this.canvas.width / 2, 
            this.canvas.height / 2, 
            0,
            this.canvas.width / 2, 
            this.canvas.height / 2, 
            Math.max(this.canvas.width, this.canvas.height) * 0.8
        );
        gradient.addColorStop(0, '#1a1a1e');
        gradient.addColorStop(0.4, '#0f0f1e');
        gradient.addColorStop(0.8, '#0a0a0a');
        gradient.addColorStop(1, '#050505');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Enhanced precise starfield with golden tint
        for (let i = 0; i < 250; i++) {
            const seed = i * 197.3;
            const x = (seed) % this.canvas.width;
            const y = (seed * 1.414) % this.canvas.height;
            const twinkle = Math.sin(time * 0.8 + i * 0.1) * 0.3 + 0.7;
            const size = (i % 4) + 0.5;
            
            // Golden/amber tinted stars
            const goldTint = Math.sin(time * 0.4 + i * 0.2) * 0.2 + 0.8;
            this.ctx.fillStyle = `rgba(255, 200, 100, ${0.9 * twinkle * goldTint})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Floating energy nodes (precision points scattered across space)
        for (let i = 0; i < 35; i++) {
            const nodeX = ((i * 137.5) % this.canvas.width);
            const nodeY = ((i * 197.3) % this.canvas.height);
            const nodePulse = Math.sin(time * 1.5 + i * 0.3) * 0.4 + 0.6;
            const nodeSize = 1.5 + Math.sin(time * 2 + i) * 0.5;
            
            // Outer glow
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = 'rgba(255, 200, 100, 0.6)';
            this.ctx.fillStyle = `rgba(255, 200, 100, ${0.4 * nodePulse})`;
            this.ctx.beginPath();
            this.ctx.arc(nodeX, nodeY, nodeSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            
            // Inner bright core
            this.ctx.fillStyle = `rgba(255, 220, 150, ${0.9 * nodePulse})`;
            this.ctx.beginPath();
            this.ctx.arc(nodeX, nodeY, nodeSize * 0.4, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Energy particles (individual precision particles orbiting)
        for (let i = 0; i < 20; i++) {
            const angle = time * 0.3 + i * 0.4;
            const radius = 100 + i * 20;
            const x = this.canvas.width / 2 + Math.cos(angle) * radius;
            const y = this.canvas.height / 2 + Math.sin(angle) * radius;
            const particlePulse = Math.sin(time * 2 + i) * 0.3 + 0.7;
            
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = 'rgba(255, 200, 100, 0.7)';
            this.ctx.fillStyle = `rgba(255, 200, 100, ${0.6 * particlePulse})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 2.5, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
        
        // Energy trails connecting nearby nodes (subtle connections)
        this.ctx.strokeStyle = 'rgba(255, 200, 100, 0.12)';
        this.ctx.lineWidth = 1;
        for (let i = 0; i < 20; i++) {
            const x1 = ((i * 137.5) % this.canvas.width);
            const y1 = ((i * 197.3) % this.canvas.height);
            const x2 = (((i + 7) * 137.5) % this.canvas.width);
            const y2 = (((i + 7) * 197.3) % this.canvas.height);
            const dist = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            
            // Only connect if nodes are relatively close
            if (dist < 300) {
                const trailPulse = Math.sin(time * 1.2 + i) * 0.2 + 0.8;
                this.ctx.strokeStyle = `rgba(255, 200, 100, ${0.12 * trailPulse})`;
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.stroke();
            }
        }
        
        // Central precision core (enhanced center point)
        const corePulse = Math.sin(time * 2) * 0.2 + 0.8;
        const coreSize = 5 + Math.sin(time * 3) * 1.5;
        
        // Outer pulsing rings
        for (let i = 1; i <= 4; i++) {
            const ringRadius = coreSize * i * 1.8;
            const ringAlpha = (0.25 / i) * corePulse;
            const ringPulse = Math.sin(time * 2.5 + i * 0.5) * 0.3 + 0.7;
            this.ctx.strokeStyle = `rgba(255, 200, 100, ${ringAlpha * ringPulse})`;
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, ringRadius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        
        // Central core with enhanced glow
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = 'rgba(255, 200, 100, 0.9)';
        this.ctx.fillStyle = `rgba(255, 220, 150, ${0.95 * corePulse})`;
        this.ctx.beginPath();
        this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, coreSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Inner bright core
        this.ctx.fillStyle = `rgba(255, 255, 200, ${corePulse})`;
        this.ctx.beginPath();
        this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, coreSize * 0.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Subtle energy waves (expanding from center)
        for (let i = 1; i <= 3; i++) {
            const waveRadius = 150 + i * 80 + Math.sin(time * 1.5 + i) * 30;
            const waveAlpha = (0.15 / i) * (0.7 + Math.sin(time * 2 + i) * 0.3);
            this.ctx.strokeStyle = `rgba(255, 200, 100, ${waveAlpha})`;
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, waveRadius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }
    
    // Enhanced Bell Pairs Mode Background - Entangled quantum field
    drawBellModeBackground() {
        const time = this.time || 0;
        
        // Deep blue/purple quantum field background
        const gradient = this.ctx.createRadialGradient(
            this.canvas.width / 2, 
            this.canvas.height / 2, 
            0,
            this.canvas.width / 2, 
            this.canvas.height / 2, 
            Math.max(this.canvas.width, this.canvas.height) * 0.9
        );
        gradient.addColorStop(0, '#1a0a2e');
        gradient.addColorStop(0.4, '#16213e');
        gradient.addColorStop(0.8, '#0f0f1e');
        gradient.addColorStop(1, '#0a0a1a');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Quantum entangled stars (cyan/blue)
        for (let i = 0; i < 180; i++) {
            const seed = i * 137.5;
            const x = (seed) % this.canvas.width;
            const y = (seed * 1.618) % this.canvas.height;
            const twinkle = Math.sin(time * 0.6 + i * 0.1) * 0.4 + 0.6;
            const size = (i % 3) + 1;
            
            // Cyan/blue tinted stars
            const blueTint = Math.sin(time * 0.3 + i) * 0.3 + 0.7;
            this.ctx.fillStyle = `rgba(129, 212, 250, ${0.9 * twinkle * blueTint})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Entangled particle pairs (connected particles)
        this.ctx.strokeStyle = 'rgba(79, 195, 247, 0.25)';
        this.ctx.lineWidth = 1;
        for (let i = 0; i < 20; i++) {
            const angle1 = time * 0.15 + i * 0.3;
            const angle2 = time * 0.15 + i * 0.3 + Math.PI;
            const radius = 80 + (i % 5) * 40;
            const x1 = this.canvas.width / 2 + Math.cos(angle1) * radius;
            const y1 = this.canvas.height / 2 + Math.sin(angle1) * radius;
            const x2 = this.canvas.width / 2 + Math.cos(angle2) * radius;
            const y2 = this.canvas.height / 2 + Math.sin(angle2) * radius;
            
            // Draw connection line
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
            
            // Draw particles
            const pulse = Math.sin(time * 2 + i) * 0.3 + 0.7;
            this.ctx.fillStyle = `rgba(79, 195, 247, ${0.6 * pulse})`;
            this.ctx.beginPath();
            this.ctx.arc(x1, y1, 2, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(x2, y2, 2, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // Quantum correlation waves
        this.ctx.strokeStyle = 'rgba(79, 195, 247, 0.15)';
        this.ctx.lineWidth = 1.5;
        for (let i = 1; i <= 3; i++) {
            const waveRadius = 100 + i * 50 + Math.sin(time * 1.5 + i) * 20;
            this.ctx.beginPath();
            this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, waveRadius, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }
    
    // Legacy function name for compatibility
    drawStars() {
        this.drawEnsembleModeBackground();
    }

    drawShield(x, y, shield, currentShield, maxShield) {
        const playerCollisionRadius = this.getPlayerCollisionRadius(this.player);
        const shieldRadius = playerCollisionRadius + 10;
        const shieldPercent = currentShield / maxShield;
        const time = Date.now() * 0.001; // Time in seconds for animations
        
        // Shield type determines visual style
        const shieldType = this.currentShield;
        
        // Basic Shield - Enhanced Design
        if (shieldType === 'basic') {
            // Calculate shield health-based opacity and color intensity
            const baseOpacity = Math.max(0.3, shieldPercent);
            const glowIntensity = shieldPercent;
            
            // Outer glow layer (largest, most transparent)
            const outerGlowGradient = this.ctx.createRadialGradient(x, y, shieldRadius * 0.8, x, y, shieldRadius * 1.5);
            outerGlowGradient.addColorStop(0, `rgba(79, 195, 247, ${0.15 * glowIntensity})`);
            outerGlowGradient.addColorStop(0.5, `rgba(79, 195, 247, ${0.08 * glowIntensity})`);
            outerGlowGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
            this.ctx.fillStyle = outerGlowGradient;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 1.5, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Pulsing outer ring (animated)
            const pulsePhase = Math.sin(time * 2) * 0.5 + 0.5; // 0 to 1
            const pulseRadius = shieldRadius + 5 + (pulsePhase * 3);
            const pulseGradient = this.ctx.createRadialGradient(x, y, pulseRadius - 2, x, y, pulseRadius + 2);
            pulseGradient.addColorStop(0, `rgba(129, 212, 250, ${0.4 * glowIntensity * pulsePhase})`);
            pulseGradient.addColorStop(1, 'rgba(129, 212, 250, 0)');
            this.ctx.strokeStyle = pulseGradient;
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.arc(x, y, pulseRadius, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Main shield ring (primary protection layer)
            const mainGradient = this.ctx.createLinearGradient(
                x - shieldRadius, y - shieldRadius,
                x + shieldRadius, y + shieldRadius
            );
            // Health-based color: bright cyan when full, darker when low
            const healthColor = shieldPercent > 0.5 
                ? `rgba(79, 195, 247, ${baseOpacity})`
                : `rgba(255, ${100 + 155 * shieldPercent}, ${100 + 155 * shieldPercent}, ${baseOpacity})`; // Yellow/orange when low
            mainGradient.addColorStop(0, healthColor);
            mainGradient.addColorStop(0.5, `rgba(129, 212, 250, ${baseOpacity})`);
            mainGradient.addColorStop(1, healthColor);
            
            this.ctx.strokeStyle = mainGradient;
            this.ctx.lineWidth = 4;
            this.ctx.shadowBlur = 15;
            this.ctx.shadowColor = `rgba(79, 195, 247, ${0.8 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Inner glow layer
            const innerGlowGradient = this.ctx.createRadialGradient(x, y, shieldRadius * 0.3, x, y, shieldRadius * 0.9);
            innerGlowGradient.addColorStop(0, `rgba(79, 195, 247, ${0.3 * glowIntensity})`);
            innerGlowGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
            this.ctx.fillStyle = innerGlowGradient;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.9, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Rotating energy rings (2 rings rotating in opposite directions)
            this.ctx.save();
            this.ctx.translate(x, y);
            
            // Ring 1 - clockwise rotation
            this.ctx.rotate(time * 0.5);
            const ring1Gradient = this.ctx.createLinearGradient(-shieldRadius, 0, shieldRadius, 0);
            ring1Gradient.addColorStop(0, `rgba(79, 195, 247, ${0.2 * glowIntensity})`);
            ring1Gradient.addColorStop(0.5, `rgba(129, 212, 250, ${0.4 * glowIntensity})`);
            ring1Gradient.addColorStop(1, `rgba(79, 195, 247, ${0.2 * glowIntensity})`);
            this.ctx.strokeStyle = ring1Gradient;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([8, 4]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.85, shieldRadius * 0.85, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 2 - counter-clockwise rotation
            this.ctx.rotate(-time * 0.8);
            const ring2Gradient = this.ctx.createLinearGradient(0, -shieldRadius, 0, shieldRadius);
            ring2Gradient.addColorStop(0, `rgba(129, 212, 250, ${0.3 * glowIntensity})`);
            ring2Gradient.addColorStop(0.5, `rgba(79, 195, 247, ${0.5 * glowIntensity})`);
            ring2Gradient.addColorStop(1, `rgba(129, 212, 250, ${0.3 * glowIntensity})`);
            this.ctx.strokeStyle = ring2Gradient;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([6, 6]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.75, shieldRadius * 0.75, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            this.ctx.setLineDash([]);
            this.ctx.restore();
            
            // Energy sparkles (8 sparkles orbiting around shield)
            const sparkleCount = 8;
            for (let i = 0; i < sparkleCount; i++) {
                const angle = (time * 0.3 + (i / sparkleCount) * Math.PI * 2);
                const sparkleX = x + Math.cos(angle) * shieldRadius;
                const sparkleY = y + Math.sin(angle) * shieldRadius;
                const sparkleSize = 2 + Math.sin(time * 3 + i) * 1;
                const sparkleAlpha = 0.6 + Math.sin(time * 4 + i) * 0.4;
                
                this.ctx.fillStyle = `rgba(129, 212, 250, ${sparkleAlpha * glowIntensity})`;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = `rgba(79, 195, 247, ${0.8 * glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Energy flow particles (small particles flowing along the shield perimeter)
            const particleCount = 12;
            for (let i = 0; i < particleCount; i++) {
                const particlePhase = (time * 0.4 + (i / particleCount) * Math.PI * 2) % (Math.PI * 2);
                const particleX = x + Math.cos(particlePhase) * shieldRadius;
                const particleY = y + Math.sin(particlePhase) * shieldRadius;
                const particleSize = 1.5;
                
                this.ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * glowIntensity})`;
                this.ctx.shadowBlur = 6;
                this.ctx.shadowColor = `rgba(79, 195, 247, ${glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Central core glow (bright center point)
            const coreGradient = this.ctx.createRadialGradient(x, y, 0, x, y, shieldRadius * 0.2);
            coreGradient.addColorStop(0, `rgba(255, 255, 255, ${0.4 * glowIntensity})`);
            coreGradient.addColorStop(0.5, `rgba(129, 212, 250, ${0.2 * glowIntensity})`);
            coreGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
            this.ctx.fillStyle = coreGradient;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.2, 0, Math.PI * 2);
            this.ctx.fill();
        } else if (shieldType === 'reinforced') {
            // Reinforced Shield - Armored, Robust Design
            const baseOpacity = Math.max(0.4, shieldPercent);
            const glowIntensity = shieldPercent;
            
            // Outer armored glow (stronger than basic)
            const outerArmorGlow = this.ctx.createRadialGradient(x, y, shieldRadius * 0.9, x, y, shieldRadius * 1.8);
            outerArmorGlow.addColorStop(0, `rgba(100, 181, 246, ${0.25 * glowIntensity})`);
            outerArmorGlow.addColorStop(0.4, `rgba(100, 181, 246, ${0.15 * glowIntensity})`);
            outerArmorGlow.addColorStop(0.8, `rgba(100, 181, 246, ${0.05 * glowIntensity})`);
            outerArmorGlow.addColorStop(1, 'rgba(100, 181, 246, 0)');
            this.ctx.fillStyle = outerArmorGlow;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 1.8, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Dual pulsing rings (stronger armor indication)
            const pulsePhase1 = Math.sin(time * 1.8) * 0.5 + 0.5;
            const pulsePhase2 = Math.sin(time * 1.8 + Math.PI) * 0.5 + 0.5;
            
            // Outer pulse ring
            const pulseRadius1 = shieldRadius + 8 + (pulsePhase1 * 4);
            const pulseGradient1 = this.ctx.createRadialGradient(x, y, pulseRadius1 - 3, x, y, pulseRadius1 + 3);
            pulseGradient1.addColorStop(0, `rgba(100, 181, 246, ${0.6 * glowIntensity * pulsePhase1})`);
            pulseGradient1.addColorStop(1, 'rgba(100, 181, 246, 0)');
            this.ctx.strokeStyle = pulseGradient1;
            this.ctx.lineWidth = 5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, pulseRadius1, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Inner pulse ring
            const pulseRadius2 = shieldRadius + 3 + (pulsePhase2 * 3);
            const pulseGradient2 = this.ctx.createRadialGradient(x, y, pulseRadius2 - 2, x, y, pulseRadius2 + 2);
            pulseGradient2.addColorStop(0, `rgba(144, 202, 249, ${0.5 * glowIntensity * pulsePhase2})`);
            pulseGradient2.addColorStop(1, 'rgba(144, 202, 249, 0)');
            this.ctx.strokeStyle = pulseGradient2;
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.arc(x, y, pulseRadius2, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Main reinforced shield ring (thicker, more robust)
            const mainReinforcedGradient = this.ctx.createLinearGradient(
                x - shieldRadius, y - shieldRadius,
                x + shieldRadius, y + shieldRadius
            );
            // Health-based color: bright blue when full, orange/red when low
            const healthColor = shieldPercent > 0.5 
                ? `rgba(100, 181, 246, ${baseOpacity})`
                : `rgba(255, ${120 + 135 * shieldPercent}, ${80 + 100 * shieldPercent}, ${baseOpacity})`;
            mainReinforcedGradient.addColorStop(0, healthColor);
            mainReinforcedGradient.addColorStop(0.25, `rgba(144, 202, 249, ${baseOpacity})`);
            mainReinforcedGradient.addColorStop(0.5, `rgba(100, 181, 246, ${baseOpacity * 1.2})`);
            mainReinforcedGradient.addColorStop(0.75, `rgba(144, 202, 249, ${baseOpacity})`);
            mainReinforcedGradient.addColorStop(1, healthColor);
            
            this.ctx.strokeStyle = mainReinforcedGradient;
            this.ctx.lineWidth = 6; // Thicker than basic
            this.ctx.shadowBlur = 20;
            this.ctx.shadowColor = `rgba(100, 181, 246, ${0.9 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Secondary reinforced ring (inner reinforcement layer)
            const secondaryGradient = this.ctx.createLinearGradient(
                x - shieldRadius * 0.9, y - shieldRadius * 0.9,
                x + shieldRadius * 0.9, y + shieldRadius * 0.9
            );
            secondaryGradient.addColorStop(0, `rgba(144, 202, 249, ${baseOpacity * 0.6})`);
            secondaryGradient.addColorStop(0.5, `rgba(100, 181, 246, ${baseOpacity * 0.8})`);
            secondaryGradient.addColorStop(1, `rgba(144, 202, 249, ${baseOpacity * 0.6})`);
            
            this.ctx.strokeStyle = secondaryGradient;
            this.ctx.lineWidth = 3;
            this.ctx.shadowBlur = 12;
            this.ctx.shadowColor = `rgba(144, 202, 249, ${0.7 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.92, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Inner armored glow (stronger than basic)
            const innerArmorGlow = this.ctx.createRadialGradient(x, y, shieldRadius * 0.2, x, y, shieldRadius * 0.95);
            innerArmorGlow.addColorStop(0, `rgba(100, 181, 246, ${0.4 * glowIntensity})`);
            innerArmorGlow.addColorStop(0.5, `rgba(144, 202, 249, ${0.25 * glowIntensity})`);
            innerArmorGlow.addColorStop(1, 'rgba(100, 181, 246, 0)');
            this.ctx.fillStyle = innerArmorGlow;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.95, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Hexagonal reinforcement pattern (armored look)
            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(time * 0.3);
            
            const hexCount = 6;
            const hexRadius = shieldRadius * 0.85;
            for (let i = 0; i < hexCount; i++) {
                const hexAngle = (i / hexCount) * Math.PI * 2;
                const hexX = Math.cos(hexAngle) * hexRadius;
                const hexY = Math.sin(hexAngle) * hexRadius;
                const hexSize = 8 + Math.sin(time * 2 + i) * 2;
                
                // Draw hexagonal reinforcement nodes
                this.ctx.fillStyle = `rgba(144, 202, 249, ${0.7 * glowIntensity})`;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = `rgba(100, 181, 246, ${0.8 * glowIntensity})`;
                this.ctx.beginPath();
                for (let j = 0; j < 6; j++) {
                    const nodeAngle = (j / 6) * Math.PI * 2;
                    const nodeX = hexX + Math.cos(nodeAngle) * hexSize;
                    const nodeY = hexY + Math.sin(nodeAngle) * hexSize;
                    if (j === 0) {
                        this.ctx.moveTo(nodeX, nodeY);
                    } else {
                        this.ctx.lineTo(nodeX, nodeY);
                    }
                }
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            this.ctx.restore();
            
            // Rotating reinforcement rings (3 rings for stronger appearance)
            this.ctx.save();
            this.ctx.translate(x, y);
            
            // Ring 1 - outer reinforcement
            this.ctx.rotate(time * 0.4);
            const ring1Reinforced = this.ctx.createLinearGradient(-shieldRadius, 0, shieldRadius, 0);
            ring1Reinforced.addColorStop(0, `rgba(100, 181, 246, ${0.3 * glowIntensity})`);
            ring1Reinforced.addColorStop(0.5, `rgba(144, 202, 249, ${0.5 * glowIntensity})`);
            ring1Reinforced.addColorStop(1, `rgba(100, 181, 246, ${0.3 * glowIntensity})`);
            this.ctx.strokeStyle = ring1Reinforced;
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([10, 5]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.9, shieldRadius * 0.9, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 2 - middle reinforcement
            this.ctx.rotate(-time * 0.6);
            const ring2Reinforced = this.ctx.createLinearGradient(0, -shieldRadius, 0, shieldRadius);
            ring2Reinforced.addColorStop(0, `rgba(144, 202, 249, ${0.4 * glowIntensity})`);
            ring2Reinforced.addColorStop(0.5, `rgba(100, 181, 246, ${0.6 * glowIntensity})`);
            ring2Reinforced.addColorStop(1, `rgba(144, 202, 249, ${0.4 * glowIntensity})`);
            this.ctx.strokeStyle = ring2Reinforced;
            this.ctx.lineWidth = 2.5;
            this.ctx.setLineDash([8, 8]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.8, shieldRadius * 0.8, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 3 - inner reinforcement
            this.ctx.rotate(time * 0.5);
            const ring3Reinforced = this.ctx.createLinearGradient(-shieldRadius * 0.7, -shieldRadius * 0.7, shieldRadius * 0.7, shieldRadius * 0.7);
            ring3Reinforced.addColorStop(0, `rgba(100, 181, 246, ${0.35 * glowIntensity})`);
            ring3Reinforced.addColorStop(0.5, `rgba(144, 202, 249, ${0.55 * glowIntensity})`);
            ring3Reinforced.addColorStop(1, `rgba(100, 181, 246, ${0.35 * glowIntensity})`);
            this.ctx.strokeStyle = ring3Reinforced;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([6, 10]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.7, shieldRadius * 0.7, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            this.ctx.setLineDash([]);
            this.ctx.restore();
            
            // Reinforced energy sparkles (12 sparkles - more than basic)
            const sparkleCount = 12;
            for (let i = 0; i < sparkleCount; i++) {
                const angle = (time * 0.25 + (i / sparkleCount) * Math.PI * 2);
                const sparkleX = x + Math.cos(angle) * shieldRadius;
                const sparkleY = y + Math.sin(angle) * shieldRadius;
                const sparkleSize = 2.5 + Math.sin(time * 2.5 + i) * 1.2;
                const sparkleAlpha = 0.7 + Math.sin(time * 3.5 + i) * 0.3;
                
                this.ctx.fillStyle = `rgba(144, 202, 249, ${sparkleAlpha * glowIntensity})`;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = `rgba(100, 181, 246, ${0.9 * glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Reinforced energy flow particles (more particles, stronger flow)
            const particleCount = 16;
            for (let i = 0; i < particleCount; i++) {
                const particlePhase = (time * 0.35 + (i / particleCount) * Math.PI * 2) % (Math.PI * 2);
                const particleX = x + Math.cos(particlePhase) * shieldRadius;
                const particleY = y + Math.sin(particlePhase) * shieldRadius;
                const particleSize = 2;
                
                this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * glowIntensity})`;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = `rgba(100, 181, 246, ${glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Central reinforced core (stronger than basic)
            const coreReinforcedGradient = this.ctx.createRadialGradient(x, y, 0, x, y, shieldRadius * 0.25);
            coreReinforcedGradient.addColorStop(0, `rgba(255, 255, 255, ${0.5 * glowIntensity})`);
            coreReinforcedGradient.addColorStop(0.4, `rgba(144, 202, 249, ${0.3 * glowIntensity})`);
            coreReinforcedGradient.addColorStop(0.8, `rgba(100, 181, 246, ${0.15 * glowIntensity})`);
            coreReinforcedGradient.addColorStop(1, 'rgba(100, 181, 246, 0)');
            this.ctx.fillStyle = coreReinforcedGradient;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.25, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Armor plating effect (segmented appearance)
            const segmentCount = 8;
            for (let i = 0; i < segmentCount; i++) {
                const segmentAngle = (i / segmentCount) * Math.PI * 2;
                const segmentStartAngle = segmentAngle - (Math.PI / segmentCount);
                const segmentEndAngle = segmentAngle + (Math.PI / segmentCount);
                
                // Draw subtle armor segments
                this.ctx.strokeStyle = `rgba(100, 181, 246, ${0.2 * glowIntensity})`;
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(
                    x + Math.cos(segmentStartAngle) * shieldRadius * 0.95,
                    y + Math.sin(segmentStartAngle) * shieldRadius * 0.95
                );
                this.ctx.lineTo(
                    x + Math.cos(segmentEndAngle) * shieldRadius * 0.95,
                    y + Math.sin(segmentEndAngle) * shieldRadius * 0.95
                );
                this.ctx.closePath();
                this.ctx.stroke();
            }
        } else if (shieldType === 'quantum') {
            // Quantum Shield - Advanced Quantum-Themed Design with Regeneration Effects
            const baseOpacity = Math.max(0.5, shieldPercent);
            const glowIntensity = shieldPercent;
            
            // Quantum field outer aura (larger, more ethereal)
            const quantumAura = this.ctx.createRadialGradient(x, y, shieldRadius * 0.95, x, y, shieldRadius * 2.2);
            quantumAura.addColorStop(0, `rgba(156, 39, 176, ${0.2 * glowIntensity})`);
            quantumAura.addColorStop(0.3, `rgba(123, 31, 162, ${0.15 * glowIntensity})`);
            quantumAura.addColorStop(0.6, `rgba(79, 195, 247, ${0.1 * glowIntensity})`);
            quantumAura.addColorStop(1, 'rgba(156, 39, 176, 0)');
            this.ctx.fillStyle = quantumAura;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 2.2, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Triple quantum pulse rings (regeneration indicator)
            const pulsePhase1 = Math.sin(time * 2.2) * 0.5 + 0.5;
            const pulsePhase2 = Math.sin(time * 2.2 + Math.PI * 0.67) * 0.5 + 0.5;
            const pulsePhase3 = Math.sin(time * 2.2 + Math.PI * 1.33) * 0.5 + 0.5;
            
            // Outer quantum pulse
            const quantumPulse1 = shieldRadius + 10 + (pulsePhase1 * 5);
            const pulseGrad1 = this.ctx.createRadialGradient(x, y, quantumPulse1 - 4, x, y, quantumPulse1 + 4);
            pulseGrad1.addColorStop(0, `rgba(156, 39, 176, ${0.7 * glowIntensity * pulsePhase1})`);
            pulseGrad1.addColorStop(1, 'rgba(156, 39, 176, 0)');
            this.ctx.strokeStyle = pulseGrad1;
            this.ctx.lineWidth = 6;
            this.ctx.beginPath();
            this.ctx.arc(x, y, quantumPulse1, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Middle quantum pulse
            const quantumPulse2 = shieldRadius + 6 + (pulsePhase2 * 4);
            const pulseGrad2 = this.ctx.createRadialGradient(x, y, quantumPulse2 - 3, x, y, quantumPulse2 + 3);
            pulseGrad2.addColorStop(0, `rgba(79, 195, 247, ${0.6 * glowIntensity * pulsePhase2})`);
            pulseGrad2.addColorStop(1, 'rgba(79, 195, 247, 0)');
            this.ctx.strokeStyle = pulseGrad2;
            this.ctx.lineWidth = 5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, quantumPulse2, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Inner quantum pulse
            const quantumPulse3 = shieldRadius + 2 + (pulsePhase3 * 3);
            const pulseGrad3 = this.ctx.createRadialGradient(x, y, quantumPulse3 - 2, x, y, quantumPulse3 + 2);
            pulseGrad3.addColorStop(0, `rgba(186, 104, 200, ${0.5 * glowIntensity * pulsePhase3})`);
            pulseGrad3.addColorStop(1, 'rgba(186, 104, 200, 0)');
            this.ctx.strokeStyle = pulseGrad3;
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.arc(x, y, quantumPulse3, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Main quantum shield ring (purple/cyan quantum colors)
            const quantumMainGradient = this.ctx.createLinearGradient(
                x - shieldRadius, y - shieldRadius,
                x + shieldRadius, y + shieldRadius
            );
            // Health-based: bright purple/cyan when full, darker when low
            const quantumHealthColor = shieldPercent > 0.5 
                ? `rgba(156, 39, 176, ${baseOpacity})`
                : `rgba(255, ${100 + 100 * shieldPercent}, ${150 + 105 * shieldPercent}, ${baseOpacity})`;
            quantumMainGradient.addColorStop(0, quantumHealthColor);
            quantumMainGradient.addColorStop(0.25, `rgba(123, 31, 162, ${baseOpacity})`);
            quantumMainGradient.addColorStop(0.5, `rgba(79, 195, 247, ${baseOpacity * 1.1})`);
            quantumMainGradient.addColorStop(0.75, `rgba(123, 31, 162, ${baseOpacity})`);
            quantumMainGradient.addColorStop(1, quantumHealthColor);
            
            this.ctx.strokeStyle = quantumMainGradient;
            this.ctx.lineWidth = 7; // Thicker for quantum shield
            this.ctx.shadowBlur = 25;
            this.ctx.shadowColor = `rgba(156, 39, 176, ${0.9 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Secondary quantum ring (entanglement layer)
            const quantumSecondaryGradient = this.ctx.createLinearGradient(
                x - shieldRadius * 0.95, y - shieldRadius * 0.95,
                x + shieldRadius * 0.95, y + shieldRadius * 0.95
            );
            quantumSecondaryGradient.addColorStop(0, `rgba(186, 104, 200, ${baseOpacity * 0.7})`);
            quantumSecondaryGradient.addColorStop(0.5, `rgba(79, 195, 247, ${baseOpacity * 0.9})`);
            quantumSecondaryGradient.addColorStop(1, `rgba(186, 104, 200, ${baseOpacity * 0.7})`);
            
            this.ctx.strokeStyle = quantumSecondaryGradient;
            this.ctx.lineWidth = 4;
            this.ctx.shadowBlur = 18;
            this.ctx.shadowColor = `rgba(79, 195, 247, ${0.8 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.94, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Quantum field inner glow (stronger, more vibrant)
            const quantumInnerGlow = this.ctx.createRadialGradient(x, y, shieldRadius * 0.15, x, y, shieldRadius * 0.98);
            quantumInnerGlow.addColorStop(0, `rgba(156, 39, 176, ${0.5 * glowIntensity})`);
            quantumInnerGlow.addColorStop(0.4, `rgba(123, 31, 162, ${0.35 * glowIntensity})`);
            quantumInnerGlow.addColorStop(0.7, `rgba(79, 195, 247, ${0.25 * glowIntensity})`);
            quantumInnerGlow.addColorStop(1, 'rgba(156, 39, 176, 0)');
            this.ctx.fillStyle = quantumInnerGlow;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.98, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Quantum entanglement pattern (8 quantum nodes)
            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(time * 0.4);
            
            const quantumNodeCount = 8;
            const quantumNodeRadius = shieldRadius * 0.88;
            for (let i = 0; i < quantumNodeCount; i++) {
                const nodeAngle = (i / quantumNodeCount) * Math.PI * 2;
                const nodeX = Math.cos(nodeAngle) * quantumNodeRadius;
                const nodeY = Math.sin(nodeAngle) * quantumNodeRadius;
                const nodeSize = 10 + Math.sin(time * 3 + i) * 3;
                const nodePulse = Math.sin(time * 2 + i) * 0.3 + 0.7;
                
                // Quantum node (glowing orb)
                const nodeGradient = this.ctx.createRadialGradient(nodeX, nodeY, 0, nodeX, nodeY, nodeSize);
                nodeGradient.addColorStop(0, `rgba(255, 255, 255, ${0.8 * glowIntensity * nodePulse})`);
                nodeGradient.addColorStop(0.4, `rgba(186, 104, 200, ${0.6 * glowIntensity * nodePulse})`);
                nodeGradient.addColorStop(0.8, `rgba(79, 195, 247, ${0.4 * glowIntensity * nodePulse})`);
                nodeGradient.addColorStop(1, 'rgba(156, 39, 176, 0)');
                this.ctx.fillStyle = nodeGradient;
                this.ctx.shadowBlur = 15;
                this.ctx.shadowColor = `rgba(156, 39, 176, ${0.9 * glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(nodeX, nodeY, nodeSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Quantum connection lines (entanglement bonds)
                if (i < quantumNodeCount - 1) {
                    const nextNodeAngle = ((i + 1) / quantumNodeCount) * Math.PI * 2;
                    const nextNodeX = Math.cos(nextNodeAngle) * quantumNodeRadius;
                    const nextNodeY = Math.sin(nextNodeAngle) * quantumNodeRadius;
                    
                    const bondGradient = this.ctx.createLinearGradient(nodeX, nodeY, nextNodeX, nextNodeY);
                    bondGradient.addColorStop(0, `rgba(156, 39, 176, ${0.3 * glowIntensity})`);
                    bondGradient.addColorStop(0.5, `rgba(79, 195, 247, ${0.5 * glowIntensity})`);
                    bondGradient.addColorStop(1, `rgba(156, 39, 176, ${0.3 * glowIntensity})`);
                    this.ctx.strokeStyle = bondGradient;
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([4, 4]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(nodeX, nodeY);
                    this.ctx.lineTo(nextNodeX, nextNodeY);
                    this.ctx.stroke();
                }
            }
            this.ctx.setLineDash([]);
            this.ctx.restore();
            
            // Quantum rotating rings (4 rings for advanced appearance)
            this.ctx.save();
            this.ctx.translate(x, y);
            
            // Ring 1 - outer quantum field
            this.ctx.rotate(time * 0.35);
            const quantumRing1 = this.ctx.createLinearGradient(-shieldRadius, 0, shieldRadius, 0);
            quantumRing1.addColorStop(0, `rgba(156, 39, 176, ${0.35 * glowIntensity})`);
            quantumRing1.addColorStop(0.5, `rgba(79, 195, 247, ${0.55 * glowIntensity})`);
            quantumRing1.addColorStop(1, `rgba(156, 39, 176, ${0.35 * glowIntensity})`);
            this.ctx.strokeStyle = quantumRing1;
            this.ctx.lineWidth = 3.5;
            this.ctx.setLineDash([12, 6]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.92, shieldRadius * 0.92, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 2 - middle quantum field
            this.ctx.rotate(-time * 0.5);
            const quantumRing2 = this.ctx.createLinearGradient(0, -shieldRadius, 0, shieldRadius);
            quantumRing2.addColorStop(0, `rgba(79, 195, 247, ${0.4 * glowIntensity})`);
            quantumRing2.addColorStop(0.5, `rgba(186, 104, 200, ${0.6 * glowIntensity})`);
            quantumRing2.addColorStop(1, `rgba(79, 195, 247, ${0.4 * glowIntensity})`);
            this.ctx.strokeStyle = quantumRing2;
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([10, 8]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.85, shieldRadius * 0.85, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 3 - inner quantum field
            this.ctx.rotate(time * 0.45);
            const quantumRing3 = this.ctx.createLinearGradient(-shieldRadius * 0.75, -shieldRadius * 0.75, shieldRadius * 0.75, shieldRadius * 0.75);
            quantumRing3.addColorStop(0, `rgba(186, 104, 200, ${0.4 * glowIntensity})`);
            quantumRing3.addColorStop(0.5, `rgba(156, 39, 176, ${0.6 * glowIntensity})`);
            quantumRing3.addColorStop(1, `rgba(186, 104, 200, ${0.4 * glowIntensity})`);
            this.ctx.strokeStyle = quantumRing3;
            this.ctx.lineWidth = 2.5;
            this.ctx.setLineDash([8, 10]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.75, shieldRadius * 0.75, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 4 - innermost quantum field
            this.ctx.rotate(-time * 0.3);
            const quantumRing4 = this.ctx.createLinearGradient(-shieldRadius * 0.6, 0, shieldRadius * 0.6, 0);
            quantumRing4.addColorStop(0, `rgba(79, 195, 247, ${0.35 * glowIntensity})`);
            quantumRing4.addColorStop(0.5, `rgba(156, 39, 176, ${0.55 * glowIntensity})`);
            quantumRing4.addColorStop(1, `rgba(79, 195, 247, ${0.35 * glowIntensity})`);
            this.ctx.strokeStyle = quantumRing4;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([6, 12]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.65, shieldRadius * 0.65, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            this.ctx.setLineDash([]);
            this.ctx.restore();
            
            // Quantum sparkles (16 sparkles - more than reinforced)
            const quantumSparkleCount = 16;
            for (let i = 0; i < quantumSparkleCount; i++) {
                const angle = (time * 0.2 + (i / quantumSparkleCount) * Math.PI * 2);
                const sparkleX = x + Math.cos(angle) * shieldRadius;
                const sparkleY = y + Math.sin(angle) * shieldRadius;
                const sparkleSize = 3 + Math.sin(time * 2 + i) * 1.5;
                const sparkleAlpha = 0.8 + Math.sin(time * 3 + i) * 0.2;
                const sparkleColor = i % 2 === 0 ? 'rgba(186, 104, 200' : 'rgba(79, 195, 247';
                
                this.ctx.fillStyle = `${sparkleColor}, ${sparkleAlpha * glowIntensity})`;
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = i % 2 === 0 ? `rgba(156, 39, 176, ${0.9 * glowIntensity})` : `rgba(79, 195, 247, ${0.9 * glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Quantum energy flow particles (regeneration effect - 20 particles)
            const quantumParticleCount = 20;
            for (let i = 0; i < quantumParticleCount; i++) {
                const particlePhase = (time * 0.3 + (i / quantumParticleCount) * Math.PI * 2) % (Math.PI * 2);
                const particleX = x + Math.cos(particlePhase) * shieldRadius;
                const particleY = y + Math.sin(particlePhase) * shieldRadius;
                const particleSize = 2.5;
                const particleColor = i % 3 === 0 ? 'rgba(156, 39, 176' : i % 3 === 1 ? 'rgba(79, 195, 247' : 'rgba(186, 104, 200';
                
                this.ctx.fillStyle = `${particleColor}, ${0.9 * glowIntensity})`;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = `${particleColor}, ${glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Quantum central core (most advanced)
            const quantumCoreGradient = this.ctx.createRadialGradient(x, y, 0, x, y, shieldRadius * 0.3);
            quantumCoreGradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * glowIntensity})`);
            quantumCoreGradient.addColorStop(0.3, `rgba(186, 104, 200, ${0.4 * glowIntensity})`);
            quantumCoreGradient.addColorStop(0.6, `rgba(79, 195, 247, ${0.3 * glowIntensity})`);
            quantumCoreGradient.addColorStop(0.9, `rgba(156, 39, 176, ${0.15 * glowIntensity})`);
            quantumCoreGradient.addColorStop(1, 'rgba(156, 39, 176, 0)');
            this.ctx.fillStyle = quantumCoreGradient;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.3, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Quantum field waves (expanding rings showing regeneration)
            if (shield.regen > 0) {
                const wavePhase = (time * 0.8) % 1;
                const waveRadius = shieldRadius * (0.7 + wavePhase * 0.3);
                const waveAlpha = (1 - wavePhase) * 0.4 * glowIntensity;
                
                this.ctx.strokeStyle = `rgba(79, 195, 247, ${waveAlpha})`;
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([6, 6]);
                this.ctx.beginPath();
                this.ctx.arc(x, y, waveRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
        } else if (shieldType === 'ontologicalReality') {
            // Ontological Reality Shield - Reality-Warping, Ontological Design
            const baseOpacity = Math.max(0.6, shieldPercent);
            const glowIntensity = shieldPercent;
            
            // Reality field outer aura (massive, reality-warping effect)
            const realityAura = this.ctx.createRadialGradient(x, y, shieldRadius * 1.0, x, y, shieldRadius * 2.5);
            realityAura.addColorStop(0, `rgba(255, 152, 0, ${0.25 * glowIntensity})`);
            realityAura.addColorStop(0.2, `rgba(255, 193, 7, ${0.2 * glowIntensity})`);
            realityAura.addColorStop(0.4, `rgba(255, 235, 59, ${0.15 * glowIntensity})`);
            realityAura.addColorStop(0.7, `rgba(156, 39, 176, ${0.1 * glowIntensity})`);
            realityAura.addColorStop(1, 'rgba(255, 152, 0, 0)');
            this.ctx.fillStyle = realityAura;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 2.5, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Quadruple reality pulse rings (powerful ontological waves)
            const pulsePhase1 = Math.sin(time * 2.5) * 0.5 + 0.5;
            const pulsePhase2 = Math.sin(time * 2.5 + Math.PI * 0.5) * 0.5 + 0.5;
            const pulsePhase3 = Math.sin(time * 2.5 + Math.PI) * 0.5 + 0.5;
            const pulsePhase4 = Math.sin(time * 2.5 + Math.PI * 1.5) * 0.5 + 0.5;
            
            // Outer reality pulse
            const realityPulse1 = shieldRadius + 12 + (pulsePhase1 * 6);
            const pulseGrad1 = this.ctx.createRadialGradient(x, y, realityPulse1 - 5, x, y, realityPulse1 + 5);
            pulseGrad1.addColorStop(0, `rgba(255, 152, 0, ${0.8 * glowIntensity * pulsePhase1})`);
            pulseGrad1.addColorStop(1, 'rgba(255, 152, 0, 0)');
            this.ctx.strokeStyle = pulseGrad1;
            this.ctx.lineWidth = 7;
            this.ctx.beginPath();
            this.ctx.arc(x, y, realityPulse1, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Second reality pulse
            const realityPulse2 = shieldRadius + 8 + (pulsePhase2 * 5);
            const pulseGrad2 = this.ctx.createRadialGradient(x, y, realityPulse2 - 4, x, y, realityPulse2 + 4);
            pulseGrad2.addColorStop(0, `rgba(255, 193, 7, ${0.7 * glowIntensity * pulsePhase2})`);
            pulseGrad2.addColorStop(1, 'rgba(255, 193, 7, 0)');
            this.ctx.strokeStyle = pulseGrad2;
            this.ctx.lineWidth = 6;
            this.ctx.beginPath();
            this.ctx.arc(x, y, realityPulse2, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Third reality pulse
            const realityPulse3 = shieldRadius + 4 + (pulsePhase3 * 4);
            const pulseGrad3 = this.ctx.createRadialGradient(x, y, realityPulse3 - 3, x, y, realityPulse3 + 3);
            pulseGrad3.addColorStop(0, `rgba(255, 235, 59, ${0.6 * glowIntensity * pulsePhase3})`);
            pulseGrad3.addColorStop(1, 'rgba(255, 235, 59, 0)');
            this.ctx.strokeStyle = pulseGrad3;
            this.ctx.lineWidth = 5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, realityPulse3, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Fourth reality pulse
            const realityPulse4 = shieldRadius + 1 + (pulsePhase4 * 3);
            const pulseGrad4 = this.ctx.createRadialGradient(x, y, realityPulse4 - 2, x, y, realityPulse4 + 2);
            pulseGrad4.addColorStop(0, `rgba(156, 39, 176, ${0.5 * glowIntensity * pulsePhase4})`);
            pulseGrad4.addColorStop(1, 'rgba(156, 39, 176, 0)');
            this.ctx.strokeStyle = pulseGrad4;
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.arc(x, y, realityPulse4, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Main ontological reality shield ring (thickest, most powerful)
            const realityMainGradient = this.ctx.createLinearGradient(
                x - shieldRadius, y - shieldRadius,
                x + shieldRadius, y + shieldRadius
            );
            // Health-based: bright orange/gold when full, darker when low
            const realityHealthColor = shieldPercent > 0.5 
                ? `rgba(255, 152, 0, ${baseOpacity})`
                : `rgba(255, ${80 + 100 * shieldPercent}, ${50 + 50 * shieldPercent}, ${baseOpacity})`;
            realityMainGradient.addColorStop(0, realityHealthColor);
            realityMainGradient.addColorStop(0.2, `rgba(255, 193, 7, ${baseOpacity})`);
            realityMainGradient.addColorStop(0.4, `rgba(255, 235, 59, ${baseOpacity * 1.1})`);
            realityMainGradient.addColorStop(0.5, `rgba(156, 39, 176, ${baseOpacity * 1.2})`);
            realityMainGradient.addColorStop(0.6, `rgba(255, 235, 59, ${baseOpacity * 1.1})`);
            realityMainGradient.addColorStop(0.8, `rgba(255, 193, 7, ${baseOpacity})`);
            realityMainGradient.addColorStop(1, realityHealthColor);
            
            this.ctx.strokeStyle = realityMainGradient;
            this.ctx.lineWidth = 9; // Thickest for ontological reality
            this.ctx.shadowBlur = 30;
            this.ctx.shadowColor = `rgba(255, 152, 0, ${1.0 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Secondary reality ring (ontological layer)
            const realitySecondaryGradient = this.ctx.createLinearGradient(
                x - shieldRadius * 0.96, y - shieldRadius * 0.96,
                x + shieldRadius * 0.96, y + shieldRadius * 0.96
            );
            realitySecondaryGradient.addColorStop(0, `rgba(255, 193, 7, ${baseOpacity * 0.8})`);
            realitySecondaryGradient.addColorStop(0.5, `rgba(156, 39, 176, ${baseOpacity * 1.0})`);
            realitySecondaryGradient.addColorStop(1, `rgba(255, 193, 7, ${baseOpacity * 0.8})`);
            
            this.ctx.strokeStyle = realitySecondaryGradient;
            this.ctx.lineWidth = 5;
            this.ctx.shadowBlur = 22;
            this.ctx.shadowColor = `rgba(255, 193, 7, ${0.9 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.96, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Tertiary reality ring (inner ontological layer)
            const realityTertiaryGradient = this.ctx.createLinearGradient(
                x - shieldRadius * 0.92, y - shieldRadius * 0.92,
                x + shieldRadius * 0.92, y + shieldRadius * 0.92
            );
            realityTertiaryGradient.addColorStop(0, `rgba(255, 235, 59, ${baseOpacity * 0.7})`);
            realityTertiaryGradient.addColorStop(0.5, `rgba(255, 152, 0, ${baseOpacity * 0.9})`);
            realityTertiaryGradient.addColorStop(1, `rgba(255, 235, 59, ${baseOpacity * 0.7})`);
            
            this.ctx.strokeStyle = realityTertiaryGradient;
            this.ctx.lineWidth = 4;
            this.ctx.shadowBlur = 18;
            this.ctx.shadowColor = `rgba(255, 235, 59, ${0.8 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.92, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Reality field inner glow (powerful ontological field)
            const realityInnerGlow = this.ctx.createRadialGradient(x, y, shieldRadius * 0.1, x, y, shieldRadius * 1.0);
            realityInnerGlow.addColorStop(0, `rgba(255, 255, 255, ${0.6 * glowIntensity})`);
            realityInnerGlow.addColorStop(0.2, `rgba(255, 235, 59, ${0.5 * glowIntensity})`);
            realityInnerGlow.addColorStop(0.4, `rgba(255, 193, 7, ${0.4 * glowIntensity})`);
            realityInnerGlow.addColorStop(0.6, `rgba(255, 152, 0, ${0.3 * glowIntensity})`);
            realityInnerGlow.addColorStop(0.8, `rgba(156, 39, 176, ${0.2 * glowIntensity})`);
            realityInnerGlow.addColorStop(1, 'rgba(255, 152, 0, 0)');
            this.ctx.fillStyle = realityInnerGlow;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 1.0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Ontological geometric pattern (12 reality nodes forming dodecagon)
            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(time * 0.35);
            
            const realityNodeCount = 12;
            const realityNodeRadius = shieldRadius * 0.9;
            for (let i = 0; i < realityNodeCount; i++) {
                const nodeAngle = (i / realityNodeCount) * Math.PI * 2;
                const nodeX = Math.cos(nodeAngle) * realityNodeRadius;
                const nodeY = Math.sin(nodeAngle) * realityNodeRadius;
                const nodeSize = 12 + Math.sin(time * 2.5 + i) * 4;
                const nodePulse = Math.sin(time * 2 + i) * 0.3 + 0.7;
                
                // Reality node (solid ontological point)
                const nodeGradient = this.ctx.createRadialGradient(nodeX, nodeY, 0, nodeX, nodeY, nodeSize);
                nodeGradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 * glowIntensity * nodePulse})`);
                nodeGradient.addColorStop(0.3, `rgba(255, 235, 59, ${0.7 * glowIntensity * nodePulse})`);
                nodeGradient.addColorStop(0.6, `rgba(255, 193, 7, ${0.5 * glowIntensity * nodePulse})`);
                nodeGradient.addColorStop(1, 'rgba(255, 152, 0, 0)');
                this.ctx.fillStyle = nodeGradient;
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = `rgba(255, 152, 0, ${1.0 * glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(nodeX, nodeY, nodeSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Reality connection lines (ontological bonds)
                if (i < realityNodeCount - 1) {
                    const nextNodeAngle = ((i + 1) / realityNodeCount) * Math.PI * 2;
                    const nextNodeX = Math.cos(nextNodeAngle) * realityNodeRadius;
                    const nextNodeY = Math.sin(nextNodeAngle) * realityNodeRadius;
                    
                    const bondGradient = this.ctx.createLinearGradient(nodeX, nodeY, nextNodeX, nextNodeY);
                    bondGradient.addColorStop(0, `rgba(255, 193, 7, ${0.4 * glowIntensity})`);
                    bondGradient.addColorStop(0.5, `rgba(255, 235, 59, ${0.6 * glowIntensity})`);
                    bondGradient.addColorStop(1, `rgba(255, 193, 7, ${0.4 * glowIntensity})`);
                    this.ctx.strokeStyle = bondGradient;
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([6, 3]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(nodeX, nodeY);
                    this.ctx.lineTo(nextNodeX, nextNodeY);
                    this.ctx.stroke();
                }
            }
            this.ctx.setLineDash([]);
            this.ctx.restore();
            
            // Reality-warping rotating rings (5 rings for ultimate appearance)
            this.ctx.save();
            this.ctx.translate(x, y);
            
            // Ring 1 - outer reality field
            this.ctx.rotate(time * 0.3);
            const realityRing1 = this.ctx.createLinearGradient(-shieldRadius, 0, shieldRadius, 0);
            realityRing1.addColorStop(0, `rgba(255, 152, 0, ${0.4 * glowIntensity})`);
            realityRing1.addColorStop(0.5, `rgba(255, 235, 59, ${0.6 * glowIntensity})`);
            realityRing1.addColorStop(1, `rgba(255, 152, 0, ${0.4 * glowIntensity})`);
            this.ctx.strokeStyle = realityRing1;
            this.ctx.lineWidth = 4;
            this.ctx.setLineDash([14, 7]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.94, shieldRadius * 0.94, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 2 - middle reality field
            this.ctx.rotate(-time * 0.4);
            const realityRing2 = this.ctx.createLinearGradient(0, -shieldRadius, 0, shieldRadius);
            realityRing2.addColorStop(0, `rgba(255, 193, 7, ${0.45 * glowIntensity})`);
            realityRing2.addColorStop(0.5, `rgba(156, 39, 176, ${0.65 * glowIntensity})`);
            realityRing2.addColorStop(1, `rgba(255, 193, 7, ${0.45 * glowIntensity})`);
            this.ctx.strokeStyle = realityRing2;
            this.ctx.lineWidth = 3.5;
            this.ctx.setLineDash([12, 9]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.88, shieldRadius * 0.88, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 3 - inner reality field
            this.ctx.rotate(time * 0.5);
            const realityRing3 = this.ctx.createLinearGradient(-shieldRadius * 0.8, -shieldRadius * 0.8, shieldRadius * 0.8, shieldRadius * 0.8);
            realityRing3.addColorStop(0, `rgba(255, 235, 59, ${0.5 * glowIntensity})`);
            realityRing3.addColorStop(0.5, `rgba(255, 152, 0, ${0.7 * glowIntensity})`);
            realityRing3.addColorStop(1, `rgba(255, 235, 59, ${0.5 * glowIntensity})`);
            this.ctx.strokeStyle = realityRing3;
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([10, 11]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.8, shieldRadius * 0.8, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 4 - deeper reality field
            this.ctx.rotate(-time * 0.35);
            const realityRing4 = this.ctx.createLinearGradient(-shieldRadius * 0.7, 0, shieldRadius * 0.7, 0);
            realityRing4.addColorStop(0, `rgba(156, 39, 176, ${0.4 * glowIntensity})`);
            realityRing4.addColorStop(0.5, `rgba(255, 193, 7, ${0.6 * glowIntensity})`);
            realityRing4.addColorStop(1, `rgba(156, 39, 176, ${0.4 * glowIntensity})`);
            this.ctx.strokeStyle = realityRing4;
            this.ctx.lineWidth = 2.5;
            this.ctx.setLineDash([8, 13]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.7, shieldRadius * 0.7, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 5 - innermost reality field
            this.ctx.rotate(time * 0.4);
            const realityRing5 = this.ctx.createLinearGradient(-shieldRadius * 0.6, -shieldRadius * 0.6, shieldRadius * 0.6, shieldRadius * 0.6);
            realityRing5.addColorStop(0, `rgba(255, 152, 0, ${0.35 * glowIntensity})`);
            realityRing5.addColorStop(0.5, `rgba(255, 235, 59, ${0.55 * glowIntensity})`);
            realityRing5.addColorStop(1, `rgba(255, 152, 0, ${0.35 * glowIntensity})`);
            this.ctx.strokeStyle = realityRing5;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([6, 14]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.6, shieldRadius * 0.6, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            this.ctx.setLineDash([]);
            this.ctx.restore();
            
            // Reality sparkles (20 sparkles - most advanced)
            const realitySparkleCount = 20;
            for (let i = 0; i < realitySparkleCount; i++) {
                const angle = (time * 0.15 + (i / realitySparkleCount) * Math.PI * 2);
                const sparkleX = x + Math.cos(angle) * shieldRadius;
                const sparkleY = y + Math.sin(angle) * shieldRadius;
                const sparkleSize = 3.5 + Math.sin(time * 2 + i) * 2;
                const sparkleAlpha = 0.9 + Math.sin(time * 2.5 + i) * 0.1;
                const sparkleColor = i % 3 === 0 ? 'rgba(255, 152, 0' : i % 3 === 1 ? 'rgba(255, 235, 59' : 'rgba(156, 39, 176';
                
                this.ctx.fillStyle = `${sparkleColor}, ${sparkleAlpha * glowIntensity})`;
                this.ctx.shadowBlur = 15;
                this.ctx.shadowColor = `${sparkleColor}, ${1.0 * glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Reality energy flow particles (24 particles - maximum flow)
            const realityParticleCount = 24;
            for (let i = 0; i < realityParticleCount; i++) {
                const particlePhase = (time * 0.25 + (i / realityParticleCount) * Math.PI * 2) % (Math.PI * 2);
                const particleX = x + Math.cos(particlePhase) * shieldRadius;
                const particleY = y + Math.sin(particlePhase) * shieldRadius;
                const particleSize = 3;
                const particleColor = i % 4 === 0 ? 'rgba(255, 152, 0' : i % 4 === 1 ? 'rgba(255, 193, 7' : i % 4 === 2 ? 'rgba(255, 235, 59' : 'rgba(156, 39, 176';
                
                this.ctx.fillStyle = `${particleColor}, ${1.0 * glowIntensity})`;
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = `${particleColor}, ${glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Ontological reality central core (most powerful)
            const realityCoreGradient = this.ctx.createRadialGradient(x, y, 0, x, y, shieldRadius * 0.35);
            realityCoreGradient.addColorStop(0, `rgba(255, 255, 255, ${0.7 * glowIntensity})`);
            realityCoreGradient.addColorStop(0.2, `rgba(255, 235, 59, ${0.5 * glowIntensity})`);
            realityCoreGradient.addColorStop(0.4, `rgba(255, 193, 7, ${0.4 * glowIntensity})`);
            realityCoreGradient.addColorStop(0.6, `rgba(255, 152, 0, ${0.3 * glowIntensity})`);
            realityCoreGradient.addColorStop(0.8, `rgba(156, 39, 176, ${0.2 * glowIntensity})`);
            realityCoreGradient.addColorStop(1, 'rgba(255, 152, 0, 0)');
            this.ctx.fillStyle = realityCoreGradient;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.35, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Reality-warping waves (expanding rings showing fast regeneration)
            if (shield.regen > 0) {
                const wavePhase1 = (time * 1.0) % 1;
                const wavePhase2 = (time * 1.0 + 0.33) % 1;
                const wavePhase3 = (time * 1.0 + 0.67) % 1;
                
                // Wave 1
                const waveRadius1 = shieldRadius * (0.6 + wavePhase1 * 0.4);
                const waveAlpha1 = (1 - wavePhase1) * 0.5 * glowIntensity;
                this.ctx.strokeStyle = `rgba(255, 193, 7, ${waveAlpha1})`;
                this.ctx.lineWidth = 4;
                this.ctx.setLineDash([8, 4]);
                this.ctx.beginPath();
                this.ctx.arc(x, y, waveRadius1, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Wave 2
                const waveRadius2 = shieldRadius * (0.6 + wavePhase2 * 0.4);
                const waveAlpha2 = (1 - wavePhase2) * 0.5 * glowIntensity;
                this.ctx.strokeStyle = `rgba(255, 235, 59, ${waveAlpha2})`;
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.arc(x, y, waveRadius2, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Wave 3
                const waveRadius3 = shieldRadius * (0.6 + wavePhase3 * 0.4);
                const waveAlpha3 = (1 - wavePhase3) * 0.5 * glowIntensity;
                this.ctx.strokeStyle = `rgba(156, 39, 176, ${waveAlpha3})`;
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.arc(x, y, waveRadius3, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
            }
        } else if (shieldType === 'individualSystemBarrier') {
            // Individual System Barrier - Ultimate Complete Protection Design
            const baseOpacity = Math.max(0.7, shieldPercent);
            const glowIntensity = shieldPercent;
            
            // Ultimate barrier outer aura (massive, all-encompassing)
            const barrierAura = this.ctx.createRadialGradient(x, y, shieldRadius * 1.05, x, y, shieldRadius * 3.0);
            barrierAura.addColorStop(0, `rgba(156, 39, 176, ${0.3 * glowIntensity})`);
            barrierAura.addColorStop(0.15, `rgba(123, 31, 162, ${0.25 * glowIntensity})`);
            barrierAura.addColorStop(0.3, `rgba(79, 195, 247, ${0.2 * glowIntensity})`);
            barrierAura.addColorStop(0.5, `rgba(255, 152, 0, ${0.15 * glowIntensity})`);
            barrierAura.addColorStop(0.7, `rgba(76, 175, 80, ${0.1 * glowIntensity})`);
            barrierAura.addColorStop(1, 'rgba(156, 39, 176, 0)');
            this.ctx.fillStyle = barrierAura;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 3.0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Quintuple ultimate pulse rings (most powerful)
            const pulsePhase1 = Math.sin(time * 3.0) * 0.5 + 0.5;
            const pulsePhase2 = Math.sin(time * 3.0 + Math.PI * 0.4) * 0.5 + 0.5;
            const pulsePhase3 = Math.sin(time * 3.0 + Math.PI * 0.8) * 0.5 + 0.5;
            const pulsePhase4 = Math.sin(time * 3.0 + Math.PI * 1.2) * 0.5 + 0.5;
            const pulsePhase5 = Math.sin(time * 3.0 + Math.PI * 1.6) * 0.5 + 0.5;
            
            // Outer ultimate pulse
            const barrierPulse1 = shieldRadius + 15 + (pulsePhase1 * 8);
            const pulseGrad1 = this.ctx.createRadialGradient(x, y, barrierPulse1 - 6, x, y, barrierPulse1 + 6);
            pulseGrad1.addColorStop(0, `rgba(156, 39, 176, ${0.9 * glowIntensity * pulsePhase1})`);
            pulseGrad1.addColorStop(1, 'rgba(156, 39, 176, 0)');
            this.ctx.strokeStyle = pulseGrad1;
            this.ctx.lineWidth = 8;
            this.ctx.beginPath();
            this.ctx.arc(x, y, barrierPulse1, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Second ultimate pulse
            const barrierPulse2 = shieldRadius + 11 + (pulsePhase2 * 7);
            const pulseGrad2 = this.ctx.createRadialGradient(x, y, barrierPulse2 - 5, x, y, barrierPulse2 + 5);
            pulseGrad2.addColorStop(0, `rgba(79, 195, 247, ${0.85 * glowIntensity * pulsePhase2})`);
            pulseGrad2.addColorStop(1, 'rgba(79, 195, 247, 0)');
            this.ctx.strokeStyle = pulseGrad2;
            this.ctx.lineWidth = 7;
            this.ctx.beginPath();
            this.ctx.arc(x, y, barrierPulse2, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Third ultimate pulse
            const barrierPulse3 = shieldRadius + 7 + (pulsePhase3 * 6);
            const pulseGrad3 = this.ctx.createRadialGradient(x, y, barrierPulse3 - 4, x, y, barrierPulse3 + 4);
            pulseGrad3.addColorStop(0, `rgba(255, 152, 0, ${0.8 * glowIntensity * pulsePhase3})`);
            pulseGrad3.addColorStop(1, 'rgba(255, 152, 0, 0)');
            this.ctx.strokeStyle = pulseGrad3;
            this.ctx.lineWidth = 6;
            this.ctx.beginPath();
            this.ctx.arc(x, y, barrierPulse3, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Fourth ultimate pulse
            const barrierPulse4 = shieldRadius + 3 + (pulsePhase4 * 5);
            const pulseGrad4 = this.ctx.createRadialGradient(x, y, barrierPulse4 - 3, x, y, barrierPulse4 + 3);
            pulseGrad4.addColorStop(0, `rgba(76, 175, 80, ${0.75 * glowIntensity * pulsePhase4})`);
            pulseGrad4.addColorStop(1, 'rgba(76, 175, 80, 0)');
            this.ctx.strokeStyle = pulseGrad4;
            this.ctx.lineWidth = 5;
            this.ctx.beginPath();
            this.ctx.arc(x, y, barrierPulse4, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Fifth ultimate pulse
            const barrierPulse5 = shieldRadius + 1 + (pulsePhase5 * 4);
            const pulseGrad5 = this.ctx.createRadialGradient(x, y, barrierPulse5 - 2, x, y, barrierPulse5 + 2);
            pulseGrad5.addColorStop(0, `rgba(123, 31, 162, ${0.7 * glowIntensity * pulsePhase5})`);
            pulseGrad5.addColorStop(1, 'rgba(123, 31, 162, 0)');
            this.ctx.strokeStyle = pulseGrad5;
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.arc(x, y, barrierPulse5, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Main ultimate barrier ring (thickest, most powerful)
            const barrierMainGradient = this.ctx.createLinearGradient(
                x - shieldRadius, y - shieldRadius,
                x + shieldRadius, y + shieldRadius
            );
            // Health-based: vibrant purple/cyan/gold when full
            const barrierHealthColor = shieldPercent > 0.5 
                ? `rgba(156, 39, 176, ${baseOpacity})`
                : `rgba(255, ${60 + 80 * shieldPercent}, ${40 + 40 * shieldPercent}, ${baseOpacity})`;
            barrierMainGradient.addColorStop(0, barrierHealthColor);
            barrierMainGradient.addColorStop(0.15, `rgba(123, 31, 162, ${baseOpacity})`);
            barrierMainGradient.addColorStop(0.3, `rgba(79, 195, 247, ${baseOpacity * 1.1})`);
            barrierMainGradient.addColorStop(0.45, `rgba(255, 152, 0, ${baseOpacity * 1.2})`);
            barrierMainGradient.addColorStop(0.5, `rgba(76, 175, 80, ${baseOpacity * 1.3})`);
            barrierMainGradient.addColorStop(0.55, `rgba(255, 152, 0, ${baseOpacity * 1.2})`);
            barrierMainGradient.addColorStop(0.7, `rgba(79, 195, 247, ${baseOpacity * 1.1})`);
            barrierMainGradient.addColorStop(0.85, `rgba(123, 31, 162, ${baseOpacity})`);
            barrierMainGradient.addColorStop(1, barrierHealthColor);
            
            this.ctx.strokeStyle = barrierMainGradient;
            this.ctx.lineWidth = 12; // Thickest for ultimate barrier
            this.ctx.shadowBlur = 35;
            this.ctx.shadowColor = `rgba(156, 39, 176, ${1.0 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Secondary ultimate barrier ring
            const barrierSecondaryGradient = this.ctx.createLinearGradient(
                x - shieldRadius * 0.97, y - shieldRadius * 0.97,
                x + shieldRadius * 0.97, y + shieldRadius * 0.97
            );
            barrierSecondaryGradient.addColorStop(0, `rgba(79, 195, 247, ${baseOpacity * 0.9})`);
            barrierSecondaryGradient.addColorStop(0.5, `rgba(156, 39, 176, ${baseOpacity * 1.1})`);
            barrierSecondaryGradient.addColorStop(1, `rgba(79, 195, 247, ${baseOpacity * 0.9})`);
            
            this.ctx.strokeStyle = barrierSecondaryGradient;
            this.ctx.lineWidth = 6;
            this.ctx.shadowBlur = 28;
            this.ctx.shadowColor = `rgba(79, 195, 247, ${0.95 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.97, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Tertiary ultimate barrier ring
            const barrierTertiaryGradient = this.ctx.createLinearGradient(
                x - shieldRadius * 0.94, y - shieldRadius * 0.94,
                x + shieldRadius * 0.94, y + shieldRadius * 0.94
            );
            barrierTertiaryGradient.addColorStop(0, `rgba(255, 152, 0, ${baseOpacity * 0.85})`);
            barrierTertiaryGradient.addColorStop(0.5, `rgba(76, 175, 80, ${baseOpacity * 1.05})`);
            barrierTertiaryGradient.addColorStop(1, `rgba(255, 152, 0, ${baseOpacity * 0.85})`);
            
            this.ctx.strokeStyle = barrierTertiaryGradient;
            this.ctx.lineWidth = 5;
            this.ctx.shadowBlur = 24;
            this.ctx.shadowColor = `rgba(255, 152, 0, ${0.9 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.94, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Quaternary ultimate barrier ring
            const barrierQuaternaryGradient = this.ctx.createLinearGradient(
                x - shieldRadius * 0.91, y - shieldRadius * 0.91,
                x + shieldRadius * 0.91, y + shieldRadius * 0.91
            );
            barrierQuaternaryGradient.addColorStop(0, `rgba(76, 175, 80, ${baseOpacity * 0.8})`);
            barrierQuaternaryGradient.addColorStop(0.5, `rgba(156, 39, 176, ${baseOpacity * 1.0})`);
            barrierQuaternaryGradient.addColorStop(1, `rgba(76, 175, 80, ${baseOpacity * 0.8})`);
            
            this.ctx.strokeStyle = barrierQuaternaryGradient;
            this.ctx.lineWidth = 4;
            this.ctx.shadowBlur = 20;
            this.ctx.shadowColor = `rgba(76, 175, 80, ${0.85 * glowIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.91, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Ultimate barrier inner glow (most powerful field)
            const barrierInnerGlow = this.ctx.createRadialGradient(x, y, shieldRadius * 0.05, x, y, shieldRadius * 1.02);
            barrierInnerGlow.addColorStop(0, `rgba(255, 255, 255, ${0.7 * glowIntensity})`);
            barrierInnerGlow.addColorStop(0.1, `rgba(156, 39, 176, ${0.6 * glowIntensity})`);
            barrierInnerGlow.addColorStop(0.25, `rgba(79, 195, 247, ${0.5 * glowIntensity})`);
            barrierInnerGlow.addColorStop(0.4, `rgba(255, 152, 0, ${0.4 * glowIntensity})`);
            barrierInnerGlow.addColorStop(0.55, `rgba(76, 175, 80, ${0.35 * glowIntensity})`);
            barrierInnerGlow.addColorStop(0.7, `rgba(123, 31, 162, ${0.25 * glowIntensity})`);
            barrierInnerGlow.addColorStop(0.85, `rgba(79, 195, 247, ${0.15 * glowIntensity})`);
            barrierInnerGlow.addColorStop(1, 'rgba(156, 39, 176, 0)');
            this.ctx.fillStyle = barrierInnerGlow;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 1.02, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Complete system geometric pattern (16 nodes - ultimate protection)
            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(time * 0.3);
            
            const barrierNodeCount = 16;
            const barrierNodeRadius = shieldRadius * 0.93;
            for (let i = 0; i < barrierNodeCount; i++) {
                const nodeAngle = (i / barrierNodeCount) * Math.PI * 2;
                const nodeX = Math.cos(nodeAngle) * barrierNodeRadius;
                const nodeY = Math.sin(nodeAngle) * barrierNodeRadius;
                const nodeSize = 14 + Math.sin(time * 2 + i) * 5;
                const nodePulse = Math.sin(time * 1.8 + i) * 0.3 + 0.7;
                
                // Ultimate barrier node (most powerful)
                const nodeGradient = this.ctx.createRadialGradient(nodeX, nodeY, 0, nodeX, nodeY, nodeSize);
                const nodeColorIndex = i % 4;
                if (nodeColorIndex === 0) {
                    nodeGradient.addColorStop(0, `rgba(255, 255, 255, ${0.95 * glowIntensity * nodePulse})`);
                    nodeGradient.addColorStop(0.3, `rgba(156, 39, 176, ${0.75 * glowIntensity * nodePulse})`);
                    nodeGradient.addColorStop(1, 'rgba(156, 39, 176, 0)');
                } else if (nodeColorIndex === 1) {
                    nodeGradient.addColorStop(0, `rgba(255, 255, 255, ${0.95 * glowIntensity * nodePulse})`);
                    nodeGradient.addColorStop(0.3, `rgba(79, 195, 247, ${0.75 * glowIntensity * nodePulse})`);
                    nodeGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
                } else if (nodeColorIndex === 2) {
                    nodeGradient.addColorStop(0, `rgba(255, 255, 255, ${0.95 * glowIntensity * nodePulse})`);
                    nodeGradient.addColorStop(0.3, `rgba(255, 152, 0, ${0.75 * glowIntensity * nodePulse})`);
                    nodeGradient.addColorStop(1, 'rgba(255, 152, 0, 0)');
                } else {
                    nodeGradient.addColorStop(0, `rgba(255, 255, 255, ${0.95 * glowIntensity * nodePulse})`);
                    nodeGradient.addColorStop(0.3, `rgba(76, 175, 80, ${0.75 * glowIntensity * nodePulse})`);
                    nodeGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
                }
                this.ctx.fillStyle = nodeGradient;
                this.ctx.shadowBlur = 25;
                this.ctx.shadowColor = `rgba(156, 39, 176, ${1.0 * glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(nodeX, nodeY, nodeSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Complete system connection lines (ultimate bonds)
                if (i < barrierNodeCount - 1) {
                    const nextNodeAngle = ((i + 1) / barrierNodeCount) * Math.PI * 2;
                    const nextNodeX = Math.cos(nextNodeAngle) * barrierNodeRadius;
                    const nextNodeY = Math.sin(nextNodeAngle) * barrierNodeRadius;
                    
                    const bondGradient = this.ctx.createLinearGradient(nodeX, nodeY, nextNodeX, nextNodeY);
                    bondGradient.addColorStop(0, `rgba(156, 39, 176, ${0.5 * glowIntensity})`);
                    bondGradient.addColorStop(0.25, `rgba(79, 195, 247, ${0.7 * glowIntensity})`);
                    bondGradient.addColorStop(0.5, `rgba(255, 152, 0, ${0.8 * glowIntensity})`);
                    bondGradient.addColorStop(0.75, `rgba(76, 175, 80, ${0.7 * glowIntensity})`);
                    bondGradient.addColorStop(1, `rgba(156, 39, 176, ${0.5 * glowIntensity})`);
                    this.ctx.strokeStyle = bondGradient;
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([8, 4]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(nodeX, nodeY);
                    this.ctx.lineTo(nextNodeX, nextNodeY);
                    this.ctx.stroke();
                }
            }
            this.ctx.setLineDash([]);
            this.ctx.restore();
            
            // Ultimate rotating rings (6 rings - maximum complexity)
            this.ctx.save();
            this.ctx.translate(x, y);
            
            // Ring 1 - outer ultimate field
            this.ctx.rotate(time * 0.25);
            const barrierRing1 = this.ctx.createLinearGradient(-shieldRadius, 0, shieldRadius, 0);
            barrierRing1.addColorStop(0, `rgba(156, 39, 176, ${0.45 * glowIntensity})`);
            barrierRing1.addColorStop(0.5, `rgba(79, 195, 247, ${0.65 * glowIntensity})`);
            barrierRing1.addColorStop(1, `rgba(156, 39, 176, ${0.45 * glowIntensity})`);
            this.ctx.strokeStyle = barrierRing1;
            this.ctx.lineWidth = 4.5;
            this.ctx.setLineDash([16, 8]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.96, shieldRadius * 0.96, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 2 - second ultimate field
            this.ctx.rotate(-time * 0.35);
            const barrierRing2 = this.ctx.createLinearGradient(0, -shieldRadius, 0, shieldRadius);
            barrierRing2.addColorStop(0, `rgba(79, 195, 247, ${0.5 * glowIntensity})`);
            barrierRing2.addColorStop(0.5, `rgba(255, 152, 0, ${0.7 * glowIntensity})`);
            barrierRing2.addColorStop(1, `rgba(79, 195, 247, ${0.5 * glowIntensity})`);
            this.ctx.strokeStyle = barrierRing2;
            this.ctx.lineWidth = 4;
            this.ctx.setLineDash([14, 10]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.9, shieldRadius * 0.9, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 3 - third ultimate field
            this.ctx.rotate(time * 0.45);
            const barrierRing3 = this.ctx.createLinearGradient(-shieldRadius * 0.85, -shieldRadius * 0.85, shieldRadius * 0.85, shieldRadius * 0.85);
            barrierRing3.addColorStop(0, `rgba(255, 152, 0, ${0.55 * glowIntensity})`);
            barrierRing3.addColorStop(0.5, `rgba(76, 175, 80, ${0.75 * glowIntensity})`);
            barrierRing3.addColorStop(1, `rgba(255, 152, 0, ${0.55 * glowIntensity})`);
            this.ctx.strokeStyle = barrierRing3;
            this.ctx.lineWidth = 3.5;
            this.ctx.setLineDash([12, 12]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.85, shieldRadius * 0.85, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 4 - fourth ultimate field
            this.ctx.rotate(-time * 0.3);
            const barrierRing4 = this.ctx.createLinearGradient(-shieldRadius * 0.75, 0, shieldRadius * 0.75, 0);
            barrierRing4.addColorStop(0, `rgba(76, 175, 80, ${0.5 * glowIntensity})`);
            barrierRing4.addColorStop(0.5, `rgba(156, 39, 176, ${0.7 * glowIntensity})`);
            barrierRing4.addColorStop(1, `rgba(76, 175, 80, ${0.5 * glowIntensity})`);
            this.ctx.strokeStyle = barrierRing4;
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([10, 14]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.75, shieldRadius * 0.75, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 5 - fifth ultimate field
            this.ctx.rotate(time * 0.4);
            const barrierRing5 = this.ctx.createLinearGradient(-shieldRadius * 0.65, -shieldRadius * 0.65, shieldRadius * 0.65, shieldRadius * 0.65);
            barrierRing5.addColorStop(0, `rgba(123, 31, 162, ${0.45 * glowIntensity})`);
            barrierRing5.addColorStop(0.5, `rgba(79, 195, 247, ${0.65 * glowIntensity})`);
            barrierRing5.addColorStop(1, `rgba(123, 31, 162, ${0.45 * glowIntensity})`);
            this.ctx.strokeStyle = barrierRing5;
            this.ctx.lineWidth = 2.5;
            this.ctx.setLineDash([8, 16]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.65, shieldRadius * 0.65, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Ring 6 - innermost ultimate field
            this.ctx.rotate(-time * 0.35);
            const barrierRing6 = this.ctx.createLinearGradient(-shieldRadius * 0.55, 0, shieldRadius * 0.55, 0);
            barrierRing6.addColorStop(0, `rgba(156, 39, 176, ${0.4 * glowIntensity})`);
            barrierRing6.addColorStop(0.5, `rgba(255, 152, 0, ${0.6 * glowIntensity})`);
            barrierRing6.addColorStop(1, `rgba(156, 39, 176, ${0.4 * glowIntensity})`);
            this.ctx.strokeStyle = barrierRing6;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([6, 18]);
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, shieldRadius * 0.55, shieldRadius * 0.55, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            this.ctx.setLineDash([]);
            this.ctx.restore();
            
            // Ultimate sparkles (24 sparkles - maximum)
            const barrierSparkleCount = 24;
            for (let i = 0; i < barrierSparkleCount; i++) {
                const angle = (time * 0.12 + (i / barrierSparkleCount) * Math.PI * 2);
                const sparkleX = x + Math.cos(angle) * shieldRadius;
                const sparkleY = y + Math.sin(angle) * shieldRadius;
                const sparkleSize = 4 + Math.sin(time * 1.8 + i) * 2.5;
                const sparkleAlpha = 1.0;
                const sparkleColorIndex = i % 5;
                let sparkleColor;
                if (sparkleColorIndex === 0) sparkleColor = 'rgba(156, 39, 176';
                else if (sparkleColorIndex === 1) sparkleColor = 'rgba(79, 195, 247';
                else if (sparkleColorIndex === 2) sparkleColor = 'rgba(255, 152, 0';
                else if (sparkleColorIndex === 3) sparkleColor = 'rgba(76, 175, 80';
                else sparkleColor = 'rgba(123, 31, 162';
                
                this.ctx.fillStyle = `${sparkleColor}, ${sparkleAlpha * glowIntensity})`;
                this.ctx.shadowBlur = 18;
                this.ctx.shadowColor = `${sparkleColor}, ${1.0 * glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Ultimate energy flow particles (30 particles - maximum flow)
            const barrierParticleCount = 30;
            for (let i = 0; i < barrierParticleCount; i++) {
                const particlePhase = (time * 0.2 + (i / barrierParticleCount) * Math.PI * 2) % (Math.PI * 2);
                const particleX = x + Math.cos(particlePhase) * shieldRadius;
                const particleY = y + Math.sin(particlePhase) * shieldRadius;
                const particleSize = 3.5;
                const particleColorIndex = i % 5;
                let particleColor;
                if (particleColorIndex === 0) particleColor = 'rgba(156, 39, 176';
                else if (particleColorIndex === 1) particleColor = 'rgba(79, 195, 247';
                else if (particleColorIndex === 2) particleColor = 'rgba(255, 152, 0';
                else if (particleColorIndex === 3) particleColor = 'rgba(76, 175, 80';
                else particleColor = 'rgba(123, 31, 162';
                
                this.ctx.fillStyle = `${particleColor}, ${1.0 * glowIntensity})`;
                this.ctx.shadowBlur = 14;
                this.ctx.shadowColor = `${particleColor}, ${glowIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Ultimate barrier central core (most powerful)
            const barrierCoreGradient = this.ctx.createRadialGradient(x, y, 0, x, y, shieldRadius * 0.4);
            barrierCoreGradient.addColorStop(0, `rgba(255, 255, 255, ${0.8 * glowIntensity})`);
            barrierCoreGradient.addColorStop(0.15, `rgba(156, 39, 176, ${0.6 * glowIntensity})`);
            barrierCoreGradient.addColorStop(0.3, `rgba(79, 195, 247, ${0.5 * glowIntensity})`);
            barrierCoreGradient.addColorStop(0.45, `rgba(255, 152, 0, ${0.4 * glowIntensity})`);
            barrierCoreGradient.addColorStop(0.6, `rgba(76, 175, 80, ${0.35 * glowIntensity})`);
            barrierCoreGradient.addColorStop(0.75, `rgba(123, 31, 162, ${0.25 * glowIntensity})`);
            barrierCoreGradient.addColorStop(0.9, `rgba(79, 195, 247, ${0.15 * glowIntensity})`);
            barrierCoreGradient.addColorStop(1, 'rgba(156, 39, 176, 0)');
            this.ctx.fillStyle = barrierCoreGradient;
            this.ctx.beginPath();
            this.ctx.arc(x, y, shieldRadius * 0.4, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Ultimate regeneration waves (quadruple waves showing ultra-fast regeneration)
            if (shield.regen > 0) {
                const wavePhase1 = (time * 1.2) % 1;
                const wavePhase2 = (time * 1.2 + 0.25) % 1;
                const wavePhase3 = (time * 1.2 + 0.5) % 1;
                const wavePhase4 = (time * 1.2 + 0.75) % 1;
                
                // Wave 1
                const waveRadius1 = shieldRadius * (0.5 + wavePhase1 * 0.5);
                const waveAlpha1 = (1 - wavePhase1) * 0.6 * glowIntensity;
                this.ctx.strokeStyle = `rgba(156, 39, 176, ${waveAlpha1})`;
                this.ctx.lineWidth = 5;
                this.ctx.setLineDash([10, 5]);
                this.ctx.beginPath();
                this.ctx.arc(x, y, waveRadius1, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Wave 2
                const waveRadius2 = shieldRadius * (0.5 + wavePhase2 * 0.5);
                const waveAlpha2 = (1 - wavePhase2) * 0.6 * glowIntensity;
                this.ctx.strokeStyle = `rgba(79, 195, 247, ${waveAlpha2})`;
                this.ctx.lineWidth = 5;
                this.ctx.beginPath();
                this.ctx.arc(x, y, waveRadius2, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Wave 3
                const waveRadius3 = shieldRadius * (0.5 + wavePhase3 * 0.5);
                const waveAlpha3 = (1 - wavePhase3) * 0.6 * glowIntensity;
                this.ctx.strokeStyle = `rgba(255, 152, 0, ${waveAlpha3})`;
                this.ctx.lineWidth = 5;
                this.ctx.beginPath();
                this.ctx.arc(x, y, waveRadius3, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Wave 4
                const waveRadius4 = shieldRadius * (0.5 + wavePhase4 * 0.5);
                const waveAlpha4 = (1 - wavePhase4) * 0.6 * glowIntensity;
                this.ctx.strokeStyle = `rgba(76, 175, 80, ${waveAlpha4})`;
                this.ctx.lineWidth = 5;
                this.ctx.beginPath();
                this.ctx.arc(x, y, waveRadius4, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
            }
        } else {
            // Fallback for other shield types
            const playerCollisionRadius = this.getPlayerCollisionRadius(this.player);
            this.ctx.strokeStyle = `rgba(79, 195, 247, ${shieldPercent})`;
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.arc(x, y, playerCollisionRadius + 10, 0, Math.PI * 2);
            this.ctx.stroke();
        }
    }

    drawPlayer() {
        const ship = this.equipmentStats.ships[this.currentShip];
        // Safety check: ensure ship exists, fallback to basic
        if (!ship) {
            console.warn(`[Ship] Ship '${this.currentShip}' not found during draw, falling back to basic`);
            this.currentShip = 'basic';
            if (!this.ownedItems.ships.basic) {
                this.ownedItems.ships.basic = { count: 1, durability: 100 };
            }
            // Recursive call with basic ship (will work now)
            return this.drawPlayer();
        }
        const shipColor = ship.color || '#4fc3f7';
        const shipSize = this.player.size;
        
        // Draw shield (before rotation, so it stays circular)
        // Use actual collision radius for shield to match ship visual extent
        const shield = this.equipmentStats.shields[this.currentShield];
        if (shield.capacity > 0 && this.playerStats.shield > 0) {
            this.drawShield(this.player.x, this.player.y, shield, this.playerStats.shield, this.playerStats.maxShield);
        }
        
        // Save context, translate to player position, rotate, then draw ship
        this.ctx.save();
        this.ctx.translate(this.player.x, this.player.y);
        this.ctx.rotate(this.player.angle);
        
        // Draw ship based on type (now relative to origin after translate/rotate)
        this.ctx.fillStyle = shipColor;
        this.ctx.beginPath();
        
        if (ship.shape === 'triangle' || !ship.shape) {
            // ATOMIC FIGHTER - Real fighter jet (F-22/F-35 style) fused with Star Wars aesthetics
            // Swept-back wings, narrow fuselage, dual engines, cockpit canopy, vertical stabilizers
            
            // Main fuselage gradient (fighter jet style - metallic cyan to deep blue)
            // More compact: shorter nose and tail, wider midsection
            const fuselageGradient = this.ctx.createLinearGradient(0, -shipSize * 1.0, 0, shipSize * 0.8);
            fuselageGradient.addColorStop(0, '#00e5ff'); // Bright atomic cyan at nose
            fuselageGradient.addColorStop(0.2, '#4fc3f7'); // Cyan
            fuselageGradient.addColorStop(0.4, '#2196f3'); // Medium blue
            fuselageGradient.addColorStop(0.6, '#2196f3'); // Medium blue (wider midsection)
            fuselageGradient.addColorStop(0.8, '#1565c0'); // Deep blue
            fuselageGradient.addColorStop(1, '#0d47a1'); // Dark atomic blue at tail
            this.ctx.fillStyle = fuselageGradient;
            
            // Main fuselage body - COMPACT design with more noticeable midsection
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.0); // Sharp nose tip (reduced from 1.3)
            
            // Left side - compact fighter jet fuselage with wider midsection
            this.ctx.lineTo(-shipSize * 0.15, -shipSize * 0.75); // Nose to upper fuselage
            this.ctx.lineTo(-shipSize * 0.22, -shipSize * 0.45); // Upper to cockpit area
            this.ctx.lineTo(-shipSize * 0.32, -shipSize * 0.1); // Cockpit to mid (wider here - more noticeable)
            this.ctx.lineTo(-shipSize * 0.35, shipSize * 0.15); // Mid to wing root (wider midsection)
            this.ctx.lineTo(-shipSize * 0.32, shipSize * 0.5); // Wing root area (slightly wider)
            this.ctx.lineTo(-shipSize * 0.25, shipSize * 0.8); // Tail end (reduced from 1.1)
            
            // Right side (mirror)
            this.ctx.lineTo(shipSize * 0.25, shipSize * 0.8);
            this.ctx.lineTo(shipSize * 0.32, shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.35, shipSize * 0.15);
            this.ctx.lineTo(shipSize * 0.32, -shipSize * 0.1);
            this.ctx.lineTo(shipSize * 0.22, -shipSize * 0.45);
            this.ctx.lineTo(shipSize * 0.15, -shipSize * 0.75);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Swept-back wings - adjusted for compact design
            const wingGradient = this.ctx.createLinearGradient(0, shipSize * 0.1, 0, shipSize * 0.5);
            wingGradient.addColorStop(0, '#2196f3'); // Medium blue at root
            wingGradient.addColorStop(0.5, '#1565c0'); // Dark blue mid
            wingGradient.addColorStop(1, '#0d47a1'); // Darker blue at tip
            this.ctx.fillStyle = wingGradient;
            
            // Left wing - adjusted for compact fuselage
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.35, shipSize * 0.15); // Wing root (attached to wider midsection)
            this.ctx.lineTo(-shipSize * 0.85, shipSize * 0.08); // Forward wing tip (swept back, shorter)
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.45); // Rear wing tip (shorter)
            this.ctx.lineTo(-shipSize * 0.32, shipSize * 0.5); // Back to wing root
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right wing (mirror)
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.35, shipSize * 0.15);
            this.ctx.lineTo(shipSize * 0.85, shipSize * 0.08);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.45);
            this.ctx.lineTo(shipSize * 0.32, shipSize * 0.5);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Side rocket pods - integrated into wings (Star Wars style, like X-wing engines)
            const podGradient = this.ctx.createLinearGradient(-shipSize * 1.0, shipSize * 0.3, -shipSize * 1.0, shipSize * 0.7);
            podGradient.addColorStop(0, '#00bcd4'); // Bright cyan
            podGradient.addColorStop(0.5, '#0097a7'); // Medium cyan
            podGradient.addColorStop(1, '#006064'); // Dark cyan
            
            // Left rocket pod - integrated into wing
            this.ctx.fillStyle = podGradient;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 1.0, shipSize * 0.3);
            this.ctx.lineTo(-shipSize * 1.15, shipSize * 0.35);
            this.ctx.lineTo(-shipSize * 1.1, shipSize * 0.65);
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.5);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right rocket pod
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 1.0, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 1.15, shipSize * 0.35);
            this.ctx.lineTo(shipSize * 1.1, shipSize * 0.65);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.5);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Vertical stabilizers - adjusted for compact design
            this.ctx.fillStyle = fuselageGradient;
            // Left stabilizer (shorter for compact design)
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.25, shipSize * 0.65);
            this.ctx.lineTo(-shipSize * 0.33, shipSize * 0.75);
            this.ctx.lineTo(-shipSize * 0.28, shipSize * 0.9);
            this.ctx.lineTo(-shipSize * 0.2, shipSize * 0.85);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right stabilizer (shorter for compact design)
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.25, shipSize * 0.65);
            this.ctx.lineTo(shipSize * 0.33, shipSize * 0.75);
            this.ctx.lineTo(shipSize * 0.28, shipSize * 0.9);
            this.ctx.lineTo(shipSize * 0.2, shipSize * 0.85);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Stabilizer leading edge highlights (metallic)
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.25, shipSize * 0.65);
            this.ctx.lineTo(-shipSize * 0.28, shipSize * 0.9);
            this.ctx.moveTo(shipSize * 0.25, shipSize * 0.65);
            this.ctx.lineTo(shipSize * 0.28, shipSize * 0.9);
            this.ctx.stroke();
            
            // Stabilizer panel lines
            this.ctx.strokeStyle = 'rgba(100, 180, 255, 0.5)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.3, shipSize * 0.8);
            this.ctx.lineTo(-shipSize * 0.25, shipSize * 0.85);
            this.ctx.moveTo(shipSize * 0.3, shipSize * 0.8);
            this.ctx.lineTo(shipSize * 0.25, shipSize * 0.85);
            this.ctx.stroke();
            
            // Realistic 3D shading - highlights and shadows for depth (adjusted for compact design)
            // Top highlight (sunlight reflection)
            const topHighlight = this.ctx.createLinearGradient(0, -shipSize * 1.0, 0, -shipSize * 0.2);
            topHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            topHighlight.addColorStop(0.3, 'rgba(200, 255, 255, 0.3)');
            topHighlight.addColorStop(1, 'rgba(0, 0, 0, 0)');
            this.ctx.fillStyle = topHighlight;
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.0);
            this.ctx.lineTo(-shipSize * 0.2, -shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.2, -shipSize * 0.4);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Side shadows for depth (emphasizing wider midsection)
            const sideShadow = this.ctx.createLinearGradient(-shipSize * 0.35, 0, 0, 0);
            sideShadow.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            sideShadow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            this.ctx.fillStyle = sideShadow;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.35, -shipSize * 0.1);
            this.ctx.lineTo(-shipSize * 0.35, shipSize * 0.5);
            this.ctx.lineTo(-shipSize * 0.28, shipSize * 0.45);
            this.ctx.lineTo(-shipSize * 0.28, -shipSize * 0.05);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Midsection highlight (making it more noticeable)
            const midHighlight = this.ctx.createLinearGradient(-shipSize * 0.35, 0, shipSize * 0.35, 0);
            midHighlight.addColorStop(0, 'rgba(0, 0, 0, 0)');
            midHighlight.addColorStop(0.5, 'rgba(150, 220, 255, 0.25)');
            midHighlight.addColorStop(1, 'rgba(0, 0, 0, 0)');
            this.ctx.fillStyle = midHighlight;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.35, -shipSize * 0.05);
            this.ctx.lineTo(-shipSize * 0.35, shipSize * 0.2);
            this.ctx.lineTo(shipSize * 0.35, shipSize * 0.2);
            this.ctx.lineTo(shipSize * 0.35, -shipSize * 0.05);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Detailed panel lines and rivets (realistic fighter jet details)
            this.ctx.strokeStyle = 'rgba(79, 195, 247, 0.6)';
            this.ctx.lineWidth = 1;
            
            // Horizontal panel lines with rivets
            for (let y of [-shipSize * 0.4, 0, shipSize * 0.4]) {
                this.ctx.beginPath();
                this.ctx.moveTo(-shipSize * 0.25, y);
                this.ctx.lineTo(shipSize * 0.25, y);
                this.ctx.stroke();
                
                // Rivets along panel lines
                this.ctx.fillStyle = 'rgba(150, 200, 255, 0.8)';
                for (let x = -shipSize * 0.2; x <= shipSize * 0.2; x += shipSize * 0.1) {
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // Vertical panel lines
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.2, -shipSize * 0.6);
            this.ctx.lineTo(-shipSize * 0.2, shipSize * 0.5);
            this.ctx.moveTo(shipSize * 0.2, -shipSize * 0.6);
            this.ctx.lineTo(shipSize * 0.2, shipSize * 0.5);
            this.ctx.stroke();
            
            // Wing panel details - more realistic
            this.ctx.strokeStyle = 'rgba(100, 180, 255, 0.5)';
            this.ctx.lineWidth = 1;
            // Left wing panels
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.5, shipSize * 0.25);
            this.ctx.lineTo(-shipSize * 0.8, shipSize * 0.2);
            this.ctx.moveTo(-shipSize * 0.6, shipSize * 0.35);
            this.ctx.lineTo(-shipSize * 0.85, shipSize * 0.3);
            this.ctx.stroke();
            // Right wing panels
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.5, shipSize * 0.25);
            this.ctx.lineTo(shipSize * 0.8, shipSize * 0.2);
            this.ctx.moveTo(shipSize * 0.6, shipSize * 0.35);
            this.ctx.lineTo(shipSize * 0.85, shipSize * 0.3);
            this.ctx.stroke();
            
            // Wing leading edge highlights (metallic shine)
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            this.ctx.lineWidth = 2.5;
            this.ctx.beginPath();
            // Left wing leading edge
            this.ctx.moveTo(-shipSize * 0.3, shipSize * 0.2);
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.1);
            // Right wing leading edge
            this.ctx.moveTo(shipSize * 0.3, shipSize * 0.2);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.1);
            this.ctx.stroke();
            
            // Wing trailing edge details
            this.ctx.strokeStyle = 'rgba(150, 200, 255, 0.6)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            // Left trailing edge
            this.ctx.moveTo(-shipSize * 0.35, shipSize * 0.6);
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.5);
            // Right trailing edge
            this.ctx.moveTo(shipSize * 0.35, shipSize * 0.6);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.5);
            this.ctx.stroke();
            
            // Weapon hardpoints visible on wings (realistic detail)
            this.ctx.fillStyle = 'rgba(100, 100, 120, 0.8)';
            // Left wing hardpoints
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.65, shipSize * 0.3, shipSize * 0.05, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.75, shipSize * 0.4, shipSize * 0.04, shipSize * 0.06, 0, 0, Math.PI * 2);
            this.ctx.fill();
            // Right wing hardpoints
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.65, shipSize * 0.3, shipSize * 0.05, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.75, shipSize * 0.4, shipSize * 0.04, shipSize * 0.06, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Air intakes visible on fuselage sides (realistic fighter jet detail)
            this.ctx.fillStyle = 'rgba(50, 50, 70, 0.9)';
            // Left intake
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.25, shipSize * 0.0, shipSize * 0.08, shipSize * 0.12, 0, 0, Math.PI * 2);
            this.ctx.fill();
            // Right intake
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.25, shipSize * 0.0, shipSize * 0.08, shipSize * 0.12, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Intake highlights
            this.ctx.strokeStyle = 'rgba(150, 200, 255, 0.7)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.25, shipSize * 0.0, shipSize * 0.08, shipSize * 0.12, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.25, shipSize * 0.0, shipSize * 0.08, shipSize * 0.12, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Fighter jet cockpit canopy - bubble style (F-22/F-35 inspired) with realistic details
            // Adjusted position for compact design
            const cockpitGradient = this.ctx.createRadialGradient(0, -shipSize * 0.4, 0, 0, -shipSize * 0.4, shipSize * 0.25);
            cockpitGradient.addColorStop(0, 'rgba(200, 255, 255, 0.95)');
            cockpitGradient.addColorStop(0.2, 'rgba(150, 255, 255, 0.8)');
            cockpitGradient.addColorStop(0.4, 'rgba(100, 255, 255, 0.6)');
            cockpitGradient.addColorStop(0.7, 'rgba(50, 200, 255, 0.4)');
            cockpitGradient.addColorStop(1, 'rgba(0, 150, 255, 0.2)');
            this.ctx.fillStyle = cockpitGradient;
            this.ctx.beginPath();
            // Fighter jet canopy shape - more elongated, bubble style (adjusted for compact)
            this.ctx.ellipse(0, -shipSize * 0.4, shipSize * 0.22, shipSize * 0.28, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit frame - fighter jet style with multiple frame segments
            this.ctx.strokeStyle = 'rgba(0, 188, 212, 0.95)';
            this.ctx.lineWidth = 2.5;
            this.ctx.stroke();
            
            // Additional frame details (realistic canopy structure)
            this.ctx.strokeStyle = 'rgba(0, 150, 200, 0.8)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            // Front frame
            this.ctx.arc(0, -shipSize * 0.55, shipSize * 0.15, 0.3, Math.PI - 0.3);
            this.ctx.stroke();
            // Side frames
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.15, -shipSize * 0.5);
            this.ctx.lineTo(-shipSize * 0.18, -shipSize * 0.3);
            this.ctx.moveTo(shipSize * 0.15, -shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.18, -shipSize * 0.3);
            this.ctx.stroke();
            
            // HUD elements visible in cockpit (realistic detail)
            this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
            this.ctx.lineWidth = 1;
            // HUD crosshair
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 0.45);
            this.ctx.lineTo(0, -shipSize * 0.4);
            this.ctx.moveTo(-shipSize * 0.05, -shipSize * 0.425);
            this.ctx.lineTo(shipSize * 0.05, -shipSize * 0.425);
            this.ctx.stroke();
            
            // Pilot seat visible (subtle detail)
            this.ctx.fillStyle = 'rgba(30, 30, 40, 0.6)';
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.35, shipSize * 0.12, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit reflection highlights (realistic glass effect)
            const reflectionGradient = this.ctx.createLinearGradient(-shipSize * 0.15, -shipSize * 0.5, shipSize * 0.15, -shipSize * 0.3);
            reflectionGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            reflectionGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            reflectionGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            this.ctx.fillStyle = reflectionGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.4, shipSize * 0.15, shipSize * 0.2, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Time variable for animations (needed for sensor pulse and energy lines)
            const time = Date.now() * 0.01;
            
            // Nose cone - fighter jet style with atomic sensor - ENHANCED (adjusted for compact design)
            const sensorGradient = this.ctx.createRadialGradient(0, -shipSize * 1.0, 0, 0, -shipSize * 1.0, shipSize * 0.12);
            sensorGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            sensorGradient.addColorStop(0.3, 'rgba(0, 255, 255, 0.95)');
            sensorGradient.addColorStop(0.6, 'rgba(0, 200, 255, 0.8)');
            sensorGradient.addColorStop(1, 'rgba(0, 150, 200, 0.5)');
            this.ctx.fillStyle = sensorGradient;
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 1.0, shipSize * 0.12, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Sensor inner core (pulsing effect)
            const sensorPulse = 0.9 + Math.sin(time * 3) * 0.1;
            this.ctx.fillStyle = `rgba(255, 255, 255, ${sensorPulse})`;
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 1.0, shipSize * 0.05, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Atomic energy lines - radiating from nose (unique quantum element) - ENHANCED
            this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
            this.ctx.lineWidth = 1.5;
            for (let i = 0; i < 6; i++) { // Increased from 4
                const angle = (Math.PI * 2 * i) / 6;
                const lineLength = shipSize * 0.25; // Adjusted for compact design
                const pulse = 0.7 + Math.sin(time * 2 + i) * 0.3;
                this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 * pulse})`;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -shipSize * 1.0);
                this.ctx.lineTo(Math.cos(angle) * lineLength, -shipSize * 1.0 + Math.sin(angle) * lineLength);
                this.ctx.stroke();
            }
            
            // Additional sensor rings (realistic detail)
            this.ctx.strokeStyle = 'rgba(0, 200, 255, 0.4)';
            this.ctx.lineWidth = 1;
            for (let ring = 1; ring <= 2; ring++) {
                this.ctx.beginPath();
                this.ctx.arc(0, -shipSize * 1.0, shipSize * (0.08 + ring * 0.02), 0, Math.PI * 2);
                this.ctx.stroke();
            }
            
            // Rocket pod details - enhanced with realistic details
            // Panel lines with rivets
            this.ctx.strokeStyle = 'rgba(0, 188, 212, 0.7)';
            this.ctx.lineWidth = 1.5;
            // Left pod panel lines
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 1.05, shipSize * 0.4);
            this.ctx.lineTo(-shipSize * 1.05, shipSize * 0.6);
            this.ctx.moveTo(-shipSize * 0.95, shipSize * 0.35);
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.65);
            this.ctx.stroke();
            // Right pod panel lines
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 1.05, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 1.05, shipSize * 0.6);
            this.ctx.moveTo(shipSize * 0.95, shipSize * 0.35);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.65);
            this.ctx.stroke();
            
            // Pod rivets
            this.ctx.fillStyle = 'rgba(150, 220, 255, 0.9)';
            for (let y = shipSize * 0.4; y <= shipSize * 0.6; y += shipSize * 0.05) {
                this.ctx.beginPath();
                this.ctx.arc(-shipSize * 1.0, y, 1.2, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(shipSize * 1.0, y, 1.2, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Rocket pod engine cores with turbine detail (realistic)
            const coreGradient = this.ctx.createRadialGradient(-shipSize * 1.0, shipSize * 0.5, 0, -shipSize * 1.0, shipSize * 0.5, shipSize * 0.08);
            coreGradient.addColorStop(0, 'rgba(0, 255, 255, 1.0)');
            coreGradient.addColorStop(0.4, 'rgba(0, 200, 255, 0.9)');
            coreGradient.addColorStop(0.7, 'rgba(0, 150, 200, 0.7)');
            coreGradient.addColorStop(1, 'rgba(0, 100, 150, 0.5)');
            this.ctx.fillStyle = coreGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 1.0, shipSize * 0.5, shipSize * 0.08, shipSize * 0.1, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 1.0, shipSize * 0.5, shipSize * 0.08, shipSize * 0.1, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Turbine blades visible in engine cores (rotating effect)
            const turbineTime = Date.now() * 0.01;
            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
            this.ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6 + turbineTime * 0.5;
                const bladeLength = shipSize * 0.06;
                // Left pod turbine
                this.ctx.beginPath();
                this.ctx.moveTo(-shipSize * 1.0, shipSize * 0.5);
                this.ctx.lineTo(-shipSize * 1.0 + Math.cos(angle) * bladeLength, shipSize * 0.5 + Math.sin(angle) * bladeLength);
                this.ctx.stroke();
                // Right pod turbine
                this.ctx.beginPath();
                this.ctx.moveTo(shipSize * 1.0, shipSize * 0.5);
                this.ctx.lineTo(shipSize * 1.0 + Math.cos(angle) * bladeLength, shipSize * 0.5 + Math.sin(angle) * bladeLength);
                this.ctx.stroke();
            }
            
            // Pod highlights (metallic shine)
            const podHighlight = this.ctx.createLinearGradient(-shipSize * 1.1, shipSize * 0.3, -shipSize * 0.9, shipSize * 0.5);
            podHighlight.addColorStop(0, 'rgba(255, 255, 255, 0)');
            podHighlight.addColorStop(0.5, 'rgba(200, 255, 255, 0.4)');
            podHighlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
            this.ctx.fillStyle = podHighlight;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 1.1, shipSize * 0.4);
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.5);
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.4);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 1.1, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.4);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Engine flames (animated based on time)
            // Note: time variable already defined above for sensor animations
            let flameIntensity = 0.7 + Math.sin(time) * 0.3; // Pulsing effect
            
            // Boost enhancement - larger, brighter flames when boost is active
            if (this.boostActive) {
                flameIntensity = 1.2 + Math.sin(time * 3) * 0.4; // Much more intense and faster pulsing
            }
            
            // Main engine flame - ENHANCED: Larger and more impressive
            const flameGradient = this.ctx.createLinearGradient(0, shipSize * 0.8, 0, shipSize * (this.boostActive ? 2.2 : 1.6));
            if (this.boostActive) {
                // Boost colors - purple/pink flames (enhanced)
                flameGradient.addColorStop(0, `rgba(233, 30, 99, ${1.0 * flameIntensity})`); // Bright pink at base
                flameGradient.addColorStop(0.15, `rgba(156, 39, 176, ${0.95 * flameIntensity})`); // Purple
                flameGradient.addColorStop(0.3, `rgba(255, 100, 150, ${0.85 * flameIntensity})`); // Pink-orange
                flameGradient.addColorStop(0.5, `rgba(255, 150, 50, ${0.75 * flameIntensity})`); // Orange
                flameGradient.addColorStop(0.7, `rgba(255, 200, 100, ${0.6 * flameIntensity})`); // Yellow
                flameGradient.addColorStop(0.9, `rgba(255, 255, 150, ${0.4 * flameIntensity})`); // Light yellow
                flameGradient.addColorStop(1, `rgba(255, 255, 200, ${0.2 * flameIntensity})`); // White at tip
            } else {
                flameGradient.addColorStop(0, `rgba(100, 255, 255, ${1.0 * flameIntensity})`); // Bright cyan at base
                flameGradient.addColorStop(0.2, `rgba(150, 220, 255, ${0.9 * flameIntensity})`); // Light cyan
                flameGradient.addColorStop(0.4, `rgba(255, 150, 50, ${0.8 * flameIntensity})`); // Orange middle
                flameGradient.addColorStop(0.6, `rgba(255, 100, 0, ${0.65 * flameIntensity})`); // Red-orange
                flameGradient.addColorStop(0.8, `rgba(255, 50, 0, ${0.45 * flameIntensity})`); // Dark red
                flameGradient.addColorStop(1, `rgba(200, 0, 0, ${0.25 * flameIntensity})`); // Very dark red at tip
            }
            
            this.ctx.fillStyle = flameGradient;
            this.ctx.beginPath();
            // Flame shape - wider at base, narrows to tip (ENHANCED: Much larger)
            const flameWidth = shipSize * (this.boostActive ? 0.5 : 0.35) * (1 + Math.sin(time * (this.boostActive ? 4 : 2)) * 0.25);
            const flameLength = shipSize * (this.boostActive ? 1.2 : 0.8) * flameIntensity; // Increased from 0.8/0.5
            this.ctx.moveTo(-flameWidth, shipSize * 0.8);
            this.ctx.lineTo(0, shipSize * 0.8 + flameLength);
            this.ctx.lineTo(flameWidth, shipSize * 0.8);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Additional outer flame layer for more intensity
            const outerFlameGradient = this.ctx.createLinearGradient(0, shipSize * 0.8, 0, shipSize * (this.boostActive ? 2.0 : 1.4));
            if (this.boostActive) {
                outerFlameGradient.addColorStop(0, `rgba(233, 30, 99, ${0.4 * flameIntensity})`);
                outerFlameGradient.addColorStop(0.5, `rgba(255, 150, 50, ${0.3 * flameIntensity})`);
                outerFlameGradient.addColorStop(1, `rgba(255, 200, 100, ${0.1 * flameIntensity})`);
            } else {
                outerFlameGradient.addColorStop(0, `rgba(100, 200, 255, ${0.5 * flameIntensity})`);
                outerFlameGradient.addColorStop(0.5, `rgba(255, 100, 0, ${0.3 * flameIntensity})`);
                outerFlameGradient.addColorStop(1, `rgba(255, 50, 0, ${0.1 * flameIntensity})`);
            }
            this.ctx.fillStyle = outerFlameGradient;
            this.ctx.beginPath();
            const outerFlameWidth = flameWidth * 1.4;
            const outerFlameLength = flameLength * 0.9;
            this.ctx.moveTo(-outerFlameWidth, shipSize * 0.8);
            this.ctx.lineTo(0, shipSize * 0.8 + outerFlameLength);
            this.ctx.lineTo(outerFlameWidth, shipSize * 0.8);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Enhanced glow during boost
            if (this.boostActive) {
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = 'rgba(233, 30, 99, 0.8)';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Secondary flame (smaller, offset) - ENHANCED: Larger and more visible
            const flame2Gradient = this.ctx.createLinearGradient(0, shipSize * 0.8, 0, shipSize * (this.boostActive ? 1.8 : 1.3));
            if (this.boostActive) {
                flame2Gradient.addColorStop(0, `rgba(156, 39, 176, ${0.9 * flameIntensity})`);
                flame2Gradient.addColorStop(0.4, `rgba(233, 30, 99, ${0.7 * flameIntensity})`);
                flame2Gradient.addColorStop(0.7, `rgba(255, 150, 100, ${0.5 * flameIntensity})`);
                flame2Gradient.addColorStop(1, `rgba(255, 200, 150, ${0.25 * flameIntensity})`);
            } else {
                flame2Gradient.addColorStop(0, `rgba(79, 195, 247, ${0.75 * flameIntensity})`);
                flame2Gradient.addColorStop(0.4, `rgba(255, 200, 100, ${0.55 * flameIntensity})`);
                flame2Gradient.addColorStop(0.7, `rgba(255, 100, 50, ${0.35 * flameIntensity})`);
                flame2Gradient.addColorStop(1, `rgba(200, 50, 0, ${0.15 * flameIntensity})`);
            }
            
            this.ctx.fillStyle = flame2Gradient;
            this.ctx.beginPath();
            const flame2Width = shipSize * (this.boostActive ? 0.3 : 0.2) * (1 + Math.cos(time * (this.boostActive ? 2.5 : 1.5)) * 0.2);
            const flame2Length = shipSize * (this.boostActive ? 0.7 : 0.45) * flameIntensity; // Increased from 0.5/0.3
            this.ctx.moveTo(-flame2Width * 0.7, shipSize * 0.8);
            this.ctx.lineTo(0, shipSize * 0.8 + flame2Length);
            this.ctx.lineTo(flame2Width * 0.7, shipSize * 0.8);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Additional boost particles - ENHANCED: More particles and better effects
            if (this.boostActive) {
                for (let i = 0; i < 12; i++) { // Increased from 8
                    const particleAngle = (Math.PI * 2 * i) / 12 + time * 2.5;
                    const particleDist = shipSize * 1.1; // Increased from 0.9
                    const particleX = Math.cos(particleAngle) * particleDist;
                    const particleY = shipSize * 0.8 + Math.sin(particleAngle) * particleDist * 0.6;
                    const particleSize = 2.5 + Math.sin(time * 6 + i) * 1.5; // Increased size variation
                    const particleAlpha = 0.8 + Math.sin(time * 4 + i) * 0.2;
                    this.ctx.fillStyle = `rgba(233, 30, 99, ${particleAlpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Additional smaller particles for more detail
                    if (i % 2 === 0) {
                        this.ctx.fillStyle = `rgba(255, 200, 100, ${particleAlpha * 0.6})`;
                        this.ctx.beginPath();
                        this.ctx.arc(particleX * 0.7, particleY * 1.1, particleSize * 0.6, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
            
            // Heat distortion effect around engines (realistic detail)
            if (this.boostActive) {
                this.ctx.strokeStyle = `rgba(255, 200, 100, ${0.3 * flameIntensity})`;
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const distortionY = shipSize * 0.8 + i * shipSize * 0.15;
                    const distortionWidth = shipSize * (0.3 + i * 0.1) * (1 + Math.sin(time * 3 + i) * 0.1);
                    this.ctx.beginPath();
                    this.ctx.moveTo(-distortionWidth, distortionY);
                    this.ctx.quadraticCurveTo(0, distortionY + shipSize * 0.05, distortionWidth, distortionY);
                    this.ctx.stroke();
                }
            }
            
            // Engine core glow with turbine detail (realistic)
            const mainEngineGradient = this.ctx.createRadialGradient(0, shipSize * 0.8, 0, 0, shipSize * 0.8, shipSize * 0.12);
            mainEngineGradient.addColorStop(0, `rgba(100, 255, 255, ${0.95 * flameIntensity})`);
            mainEngineGradient.addColorStop(0.4, `rgba(100, 200, 255, ${0.85 * flameIntensity})`);
            mainEngineGradient.addColorStop(0.7, `rgba(50, 150, 200, ${0.7 * flameIntensity})`);
            mainEngineGradient.addColorStop(1, `rgba(0, 100, 150, ${0.5 * flameIntensity})`);
            this.ctx.fillStyle = mainEngineGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.8, shipSize * 0.12, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Main engine turbine blades (rotating)
            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.lineWidth = 1.5;
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8 + time * 0.8;
                const bladeLength = shipSize * 0.08;
                this.ctx.beginPath();
                this.ctx.moveTo(0, shipSize * 0.8);
                this.ctx.lineTo(Math.cos(angle) * bladeLength, shipSize * 0.8 + Math.sin(angle) * bladeLength * 0.6);
                this.ctx.stroke();
            }
            
            // Engine nozzle details (realistic fighter jet)
            this.ctx.strokeStyle = 'rgba(150, 200, 255, 0.8)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.8, shipSize * 0.13, shipSize * 0.09, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Engine nozzle inner ring
            this.ctx.strokeStyle = 'rgba(100, 150, 200, 0.6)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.8, shipSize * 0.1, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Side rocket pod engines - fighter jet style (positioned on wing pods)
            const rocketFlameGradient = this.ctx.createLinearGradient(0, shipSize * 0.7, 0, shipSize * (this.boostActive ? 1.4 : 1.1));
            if (this.boostActive) {
                rocketFlameGradient.addColorStop(0, `rgba(0, 255, 255, ${0.9 * flameIntensity})`);
                rocketFlameGradient.addColorStop(0.3, `rgba(156, 39, 176, ${0.7 * flameIntensity})`);
                rocketFlameGradient.addColorStop(0.6, `rgba(233, 30, 99, ${0.5 * flameIntensity})`);
                rocketFlameGradient.addColorStop(1, `rgba(255, 150, 50, ${0.3 * flameIntensity})`);
            } else {
                rocketFlameGradient.addColorStop(0, `rgba(0, 255, 255, ${0.8 * flameIntensity})`);
                rocketFlameGradient.addColorStop(0.4, `rgba(79, 195, 247, ${0.6 * flameIntensity})`);
                rocketFlameGradient.addColorStop(0.7, `rgba(255, 150, 50, ${0.4 * flameIntensity})`);
                rocketFlameGradient.addColorStop(1, `rgba(255, 100, 0, ${0.2 * flameIntensity})`);
            }
            
            this.ctx.fillStyle = rocketFlameGradient;
            // Left rocket pod engine (on wing)
            const leftRocketFlameWidth = shipSize * (this.boostActive ? 0.3 : 0.2) * (1 + Math.sin(time * (this.boostActive ? 3 : 1.5)) * 0.2);
            const leftRocketFlameLength = shipSize * (this.boostActive ? 0.7 : 0.4) * flameIntensity;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 1.0 - leftRocketFlameWidth * 0.5, shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 1.0, shipSize * 0.7 + leftRocketFlameLength);
            this.ctx.lineTo(-shipSize * 1.0 + leftRocketFlameWidth * 0.5, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right rocket pod engine (on wing)
            const rightRocketFlameWidth = shipSize * (this.boostActive ? 0.3 : 0.2) * (1 + Math.sin(time * (this.boostActive ? 3 : 1.5)) * 0.2);
            const rightRocketFlameLength = shipSize * (this.boostActive ? 0.7 : 0.4) * flameIntensity;
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 1.0 - rightRocketFlameWidth * 0.5, shipSize * 0.7);
            this.ctx.lineTo(shipSize * 1.0, shipSize * 0.7 + rightRocketFlameLength);
            this.ctx.lineTo(shipSize * 1.0 + rightRocketFlameWidth * 0.5, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Rocket pod engine cores glow (updated positions)
            this.ctx.fillStyle = `rgba(0, 255, 255, ${0.9 * flameIntensity})`;
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 1.0, shipSize * 0.5, shipSize * 0.1, shipSize * 0.12, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 1.0, shipSize * 0.5, shipSize * 0.1, shipSize * 0.12, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Additional boost particles from rocket pods
            if (this.boostActive) {
                for (let i = 0; i < 6; i++) {
                    const particleAngle = (Math.PI * 2 * i) / 6 + time * 2.5;
                    // Left pod particles
                    const leftParticleDist = shipSize * 1.0;
                    const leftParticleX = -shipSize * 1.0 + Math.cos(particleAngle) * leftParticleDist * 0.3;
                    const leftParticleY = shipSize * 0.7 + Math.sin(particleAngle) * leftParticleDist * 0.5;
                    const particleSize = 2.5 + Math.sin(time * 6 + i) * 1.5;
                    this.ctx.fillStyle = `rgba(0, 255, 255, ${0.8 + Math.sin(time * 4 + i) * 0.2})`;
                    this.ctx.beginPath();
                    this.ctx.arc(leftParticleX, leftParticleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Right pod particles
                    const rightParticleX = shipSize * 1.0 + Math.cos(particleAngle) * leftParticleDist * 0.3;
                    const rightParticleY = shipSize * 0.7 + Math.sin(particleAngle) * leftParticleDist * 0.5;
                    this.ctx.beginPath();
                    this.ctx.arc(rightParticleX, rightParticleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // Reset fill style for other ships
            this.ctx.fillStyle = shipColor;
        } else if (this.currentShip === 'individualStabilizer') {
            // Enhanced Individual Stabilizer - high-tier scientific vessel
            // Orange/amber color scheme for stabilization theme
            
            // Main body gradient (bright orange to deep amber)
            const bodyGradient = this.ctx.createLinearGradient(0, -shipSize * 1.4, 0, shipSize * 0.7);
            bodyGradient.addColorStop(0, '#ff6b00'); // Bright orange at front
            bodyGradient.addColorStop(0.3, '#ff8c00'); // Deep orange
            bodyGradient.addColorStop(0.6, '#ffa500'); // Amber
            bodyGradient.addColorStop(1, '#ff8c42'); // Dark amber at back
            this.ctx.fillStyle = bodyGradient;
            
            // Scientific/advanced ship shape - sleek but with stabilization features
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.4); // Sharp front point
            
            // Left side - advanced design
            this.ctx.lineTo(-shipSize * 0.28, -shipSize * 0.9); // Front to upper
            this.ctx.lineTo(-shipSize * 0.45, -shipSize * 0.5); // Upper to mid
            this.ctx.lineTo(-shipSize * 0.6, -shipSize * 0.1); // Mid to lower
            this.ctx.lineTo(-shipSize * 0.65, shipSize * 0.3); // Lower to wing
            this.ctx.lineTo(-shipSize * 0.5, shipSize * 0.6); // Wing tip
            this.ctx.lineTo(-shipSize * 0.25, shipSize * 0.7); // Wing to tail
            this.ctx.lineTo(0, shipSize * 0.7); // Tail center
            
            // Right side (mirror)
            this.ctx.lineTo(shipSize * 0.25, shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.5, shipSize * 0.6);
            this.ctx.lineTo(shipSize * 0.65, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.6, -shipSize * 0.1);
            this.ctx.lineTo(shipSize * 0.45, -shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.28, -shipSize * 0.9);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Stabilization fins/panels
            this.ctx.fillStyle = 'rgba(255, 140, 66, 0.8)';
            // Left stabilization fin
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.5, shipSize * 0.4);
            this.ctx.lineTo(-shipSize * 0.6, shipSize * 0.55);
            this.ctx.lineTo(-shipSize * 0.45, shipSize * 0.6);
            this.ctx.closePath();
            this.ctx.fill();
            // Right stabilization fin
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.5, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.6, shipSize * 0.55);
            this.ctx.lineTo(shipSize * 0.45, shipSize * 0.6);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Scientific panel lines
            this.ctx.strokeStyle = 'rgba(255, 200, 150, 0.6)';
            this.ctx.lineWidth = 1.5;
            // Horizontal lines
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.4, -shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.4, -shipSize * 0.3);
            this.ctx.moveTo(-shipSize * 0.5, shipSize * 0.1);
            this.ctx.lineTo(shipSize * 0.5, shipSize * 0.1);
            this.ctx.stroke();
            
            // Central body accent - scientific core
            this.ctx.fillStyle = 'rgba(255, 180, 100, 0.7)';
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.0);
            this.ctx.lineTo(-shipSize * 0.2, -shipSize * 0.4);
            this.ctx.lineTo(0, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.2, -shipSize * 0.4);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Advanced cockpit - scientific observation dome
            const cockpitGradient = this.ctx.createRadialGradient(0, -shipSize * 0.8, 0, 0, -shipSize * 0.8, shipSize * 0.22);
            cockpitGradient.addColorStop(0, 'rgba(255, 240, 200, 0.95)');
            cockpitGradient.addColorStop(0.4, 'rgba(255, 200, 150, 0.7)');
            cockpitGradient.addColorStop(0.8, 'rgba(255, 150, 100, 0.4)');
            cockpitGradient.addColorStop(1, 'rgba(255, 100, 50, 0.2)');
            this.ctx.fillStyle = cockpitGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.8, shipSize * 0.16, shipSize * 0.2, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit frame - advanced materials
            this.ctx.strokeStyle = 'rgba(255, 140, 66, 0.9)';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
            
            // Scientific sensor array (front)
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 1.4, shipSize * 0.06, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Stabilization ports (side vents)
            this.ctx.fillStyle = 'rgba(200, 100, 50, 0.6)';
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.45, -shipSize * 0.2, shipSize * 0.07, shipSize * 0.12, -0.3, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.45, -shipSize * 0.2, shipSize * 0.07, shipSize * 0.12, 0.3, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Engine flames - powerful and stable (stabilization theme)
            const time = Date.now() * 0.01;
            const flameIntensity = 0.8 + Math.sin(time) * 0.15; // Stable, consistent
            
            // Main engine - triple exhaust (advanced propulsion)
            const flameGradient1 = this.ctx.createLinearGradient(-shipSize * 0.15, shipSize * 0.7, -shipSize * 0.15, shipSize * 1.3);
            flameGradient1.addColorStop(0, `rgba(255, 200, 100, ${0.95 * flameIntensity})`);
            flameGradient1.addColorStop(0.2, `rgba(255, 150, 50, ${0.85 * flameIntensity})`);
            flameGradient1.addColorStop(0.5, `rgba(255, 100, 0, ${0.7 * flameIntensity})`);
            flameGradient1.addColorStop(0.8, `rgba(255, 50, 0, ${0.5 * flameIntensity})`);
            flameGradient1.addColorStop(1, `rgba(200, 0, 0, ${0.3 * flameIntensity})`);
            
            this.ctx.fillStyle = flameGradient1;
            this.ctx.beginPath();
            const flame1Width = shipSize * 0.18 * (1 + Math.sin(time * 2) * 0.2);
            const flame1Length = shipSize * 0.6 * flameIntensity;
            this.ctx.moveTo(-shipSize * 0.2, shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 0.15, shipSize * 0.7 + flame1Length);
            this.ctx.lineTo(-shipSize * 0.1, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Center exhaust
            const flameGradient2 = this.ctx.createLinearGradient(0, shipSize * 0.7, 0, shipSize * 1.35);
            flameGradient2.addColorStop(0, `rgba(255, 220, 120, ${0.98 * flameIntensity})`);
            flameGradient2.addColorStop(0.2, `rgba(255, 170, 60, ${0.88 * flameIntensity})`);
            flameGradient2.addColorStop(0.5, `rgba(255, 120, 0, ${0.75 * flameIntensity})`);
            flameGradient2.addColorStop(0.8, `rgba(255, 60, 0, ${0.55 * flameIntensity})`);
            flameGradient2.addColorStop(1, `rgba(220, 0, 0, ${0.35 * flameIntensity})`);
            
            this.ctx.fillStyle = flameGradient2;
            this.ctx.beginPath();
            const flame2Width = shipSize * 0.2 * (1 + Math.cos(time * 2) * 0.2);
            const flame2Length = shipSize * 0.65 * flameIntensity;
            this.ctx.moveTo(-shipSize * 0.1, shipSize * 0.7);
            this.ctx.lineTo(0, shipSize * 0.7 + flame2Length);
            this.ctx.lineTo(shipSize * 0.1, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right exhaust
            this.ctx.fillStyle = flameGradient1;
            this.ctx.beginPath();
            const flame3Width = shipSize * 0.18 * (1 + Math.sin(time * 2 + 1) * 0.2);
            const flame3Length = shipSize * 0.6 * flameIntensity;
            this.ctx.moveTo(shipSize * 0.1, shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.15, shipSize * 0.7 + flame3Length);
            this.ctx.lineTo(shipSize * 0.2, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Engine cores - bright orange
            this.ctx.fillStyle = `rgba(255, 200, 100, ${0.95 * flameIntensity})`;
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.15, shipSize * 0.7, shipSize * 0.06, shipSize * 0.05, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.7, shipSize * 0.07, shipSize * 0.06, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.15, shipSize * 0.7, shipSize * 0.06, shipSize * 0.05, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Stabilization indicator lights (pulsing orange/amber)
            const lightIntensity = 0.7 + Math.sin(time * 2.5) * 0.3;
            this.ctx.fillStyle = `rgba(255, 200, 100, ${lightIntensity})`;
            // Top indicator
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 0.6, shipSize * 0.045, 0, Math.PI * 2);
            this.ctx.fill();
            // Side indicators
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 0.35, shipSize * 0.2, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 0.35, shipSize * 0.2, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Reset fill style
            this.ctx.fillStyle = shipColor;
        } else if (ship.shape === 'sleek') {
            // VELOCITY INTERCEPTOR - Enhanced fast ship: F-16/F-18 style fused with Star Wars/Star Trek racing aesthetics
            // Streamlined racing interceptor with extreme speed focus
            // Orange/red color scheme for speed theme
            
            // Main fuselage gradient (metallic orange to deep red) - fighter jet style
            const fuselageGradient = this.ctx.createLinearGradient(0, -shipSize * 1.4, 0, shipSize * 0.7);
            fuselageGradient.addColorStop(0, '#ff9800'); // Bright orange at nose
            fuselageGradient.addColorStop(0.2, '#ff6b00'); // Deep orange
            fuselageGradient.addColorStop(0.4, '#ff5722'); // Orange-red
            fuselageGradient.addColorStop(0.6, '#f44336'); // Red-orange
            fuselageGradient.addColorStop(0.8, '#e53935'); // Deep red
            fuselageGradient.addColorStop(1, '#c62828'); // Dark red at tail
            this.ctx.fillStyle = fuselageGradient;
            
            // Main fuselage body - streamlined racing interceptor design
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.4); // Ultra-sharp nose tip (longer than basic for speed)
            
            // Left side - streamlined racing fighter jet fuselage
            this.ctx.lineTo(-shipSize * 0.12, -shipSize * 1.0); // Nose to upper body (narrower than basic)
            this.ctx.lineTo(-shipSize * 0.18, -shipSize * 0.6); // Upper to cockpit area
            this.ctx.lineTo(-shipSize * 0.22, -shipSize * 0.2); // Cockpit to mid (very streamlined)
            this.ctx.lineTo(-shipSize * 0.25, shipSize * 0.1); // Mid to wing root
            this.ctx.lineTo(-shipSize * 0.22, shipSize * 0.4); // Wing root area
            this.ctx.lineTo(-shipSize * 0.18, shipSize * 0.7); // Tail end
            
            // Right side (mirror)
            this.ctx.lineTo(shipSize * 0.18, shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.22, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.25, shipSize * 0.1);
            this.ctx.lineTo(shipSize * 0.22, -shipSize * 0.2);
            this.ctx.lineTo(shipSize * 0.18, -shipSize * 0.6);
            this.ctx.lineTo(shipSize * 0.12, -shipSize * 1.0);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Delta wings - swept-back racing design (Star Wars/Star Trek inspired)
            const wingGradient = this.ctx.createLinearGradient(0, shipSize * 0.05, 0, shipSize * 0.5);
            wingGradient.addColorStop(0, '#ff6b00'); // Deep orange at root
            wingGradient.addColorStop(0.5, '#f44336'); // Red-orange mid
            wingGradient.addColorStop(1, '#c62828'); // Dark red at tip
            this.ctx.fillStyle = wingGradient;
            
            // Left delta wing - aggressive swept-back design
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.25, shipSize * 0.1); // Wing root
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.05); // Forward wing tip (very swept back)
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.4); // Rear wing tip
            this.ctx.lineTo(-shipSize * 0.22, shipSize * 0.4); // Back to wing root
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right delta wing (mirror)
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.25, shipSize * 0.1);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.05);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.22, shipSize * 0.4);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Wingtip maneuvering thrusters (Star Trek style - for extreme agility)
            const thrusterGradient = this.ctx.createLinearGradient(-shipSize * 0.95, shipSize * 0.35, -shipSize * 0.95, shipSize * 0.45);
            thrusterGradient.addColorStop(0, '#ff9800'); // Bright orange
            thrusterGradient.addColorStop(0.5, '#ff6b00'); // Deep orange
            thrusterGradient.addColorStop(1, '#f44336'); // Red-orange
            this.ctx.fillStyle = thrusterGradient;
            
            // Left wingtip thruster
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.95, shipSize * 0.35);
            this.ctx.lineTo(-shipSize * 1.05, shipSize * 0.38);
            this.ctx.lineTo(-shipSize * 1.0, shipSize * 0.45);
            this.ctx.lineTo(-shipSize * 0.92, shipSize * 0.42);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right wingtip thruster
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.95, shipSize * 0.35);
            this.ctx.lineTo(shipSize * 1.05, shipSize * 0.38);
            this.ctx.lineTo(shipSize * 1.0, shipSize * 0.45);
            this.ctx.lineTo(shipSize * 0.92, shipSize * 0.42);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Vertical stabilizer - racing style (single large fin)
            this.ctx.fillStyle = fuselageGradient;
            this.ctx.beginPath();
            this.ctx.moveTo(0, shipSize * 0.5);
            this.ctx.lineTo(-shipSize * 0.08, shipSize * 0.6);
            this.ctx.lineTo(0, shipSize * 0.85);
            this.ctx.lineTo(shipSize * 0.08, shipSize * 0.6);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Stabilizer leading edge highlight (metallic)
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(0, shipSize * 0.5);
            this.ctx.lineTo(0, shipSize * 0.85);
            this.ctx.stroke();
            
            // Stabilizer panel lines
            this.ctx.strokeStyle = 'rgba(255, 200, 100, 0.5)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.05, shipSize * 0.65);
            this.ctx.lineTo(shipSize * 0.05, shipSize * 0.7);
            this.ctx.stroke();
            
            // Realistic 3D shading - highlights and shadows
            // Top highlight (sunlight reflection)
            const topHighlight = this.ctx.createLinearGradient(0, -shipSize * 1.4, 0, -shipSize * 0.3);
            topHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            topHighlight.addColorStop(0.3, 'rgba(255, 240, 200, 0.3)');
            topHighlight.addColorStop(1, 'rgba(0, 0, 0, 0)');
            this.ctx.fillStyle = topHighlight;
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.4);
            this.ctx.lineTo(-shipSize * 0.15, -shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.15, -shipSize * 0.5);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Side shadows for depth
            const sideShadow = this.ctx.createLinearGradient(-shipSize * 0.25, 0, 0, 0);
            sideShadow.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            sideShadow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            this.ctx.fillStyle = sideShadow;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.25, -shipSize * 0.1);
            this.ctx.lineTo(-shipSize * 0.25, shipSize * 0.4);
            this.ctx.lineTo(-shipSize * 0.2, shipSize * 0.35);
            this.ctx.lineTo(-shipSize * 0.2, -shipSize * 0.05);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Detailed panel lines and rivets (realistic fighter jet details)
            this.ctx.strokeStyle = 'rgba(255, 152, 0, 0.6)';
            this.ctx.lineWidth = 1;
            
            // Horizontal panel lines with rivets
            for (let y of [-shipSize * 0.5, 0, shipSize * 0.3]) {
                this.ctx.beginPath();
                this.ctx.moveTo(-shipSize * 0.2, y);
                this.ctx.lineTo(shipSize * 0.2, y);
                this.ctx.stroke();
                
                // Rivets along panel lines
                this.ctx.fillStyle = 'rgba(255, 220, 150, 0.8)';
                for (let x = -shipSize * 0.15; x <= shipSize * 0.15; x += shipSize * 0.08) {
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 1.2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // Vertical panel lines
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.15, -shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 0.15, shipSize * 0.3);
            this.ctx.moveTo(shipSize * 0.15, -shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.15, shipSize * 0.3);
            this.ctx.stroke();
            
            // Wing panel details - racing style
            this.ctx.strokeStyle = 'rgba(255, 180, 100, 0.5)';
            this.ctx.lineWidth = 1;
            // Left wing panels
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.4, shipSize * 0.2);
            this.ctx.lineTo(-shipSize * 0.85, shipSize * 0.15);
            this.ctx.moveTo(-shipSize * 0.5, shipSize * 0.3);
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.25);
            this.ctx.stroke();
            // Right wing panels
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.4, shipSize * 0.2);
            this.ctx.lineTo(shipSize * 0.85, shipSize * 0.15);
            this.ctx.moveTo(shipSize * 0.5, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.25);
            this.ctx.stroke();
            
            // Wing leading edge highlights (metallic shine)
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            this.ctx.lineWidth = 2.5;
            this.ctx.beginPath();
            // Left wing leading edge
            this.ctx.moveTo(-shipSize * 0.25, shipSize * 0.15);
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.05);
            // Right wing leading edge
            this.ctx.moveTo(shipSize * 0.25, shipSize * 0.15);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.05);
            this.ctx.stroke();
            
            // Wing trailing edge details
            this.ctx.strokeStyle = 'rgba(255, 200, 150, 0.6)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            // Left trailing edge
            this.ctx.moveTo(-shipSize * 0.22, shipSize * 0.5);
            this.ctx.lineTo(-shipSize * 0.98, shipSize * 0.45);
            // Right trailing edge
            this.ctx.moveTo(shipSize * 0.22, shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.98, shipSize * 0.45);
            this.ctx.stroke();
            
            // Racing stripes (speed lines) - Star Wars style
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            this.ctx.lineWidth = 2;
            this.ctx.shadowBlur = 4;
            this.ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            this.ctx.beginPath();
            // Forward stripe
            this.ctx.moveTo(0, -shipSize * 1.2);
            this.ctx.lineTo(0, -shipSize * 0.4);
            // Side stripes
            this.ctx.moveTo(-shipSize * 0.15, -shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 0.22, shipSize * 0.2);
            this.ctx.moveTo(shipSize * 0.15, -shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.22, shipSize * 0.2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Air intakes visible on fuselage sides (realistic fighter jet detail)
            this.ctx.fillStyle = 'rgba(150, 50, 30, 0.9)';
            // Left intake
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.2, -shipSize * 0.1, shipSize * 0.07, shipSize * 0.1, -0.1, 0, Math.PI * 2);
            this.ctx.fill();
            // Right intake
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.2, -shipSize * 0.1, shipSize * 0.07, shipSize * 0.1, 0.1, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Intake highlights
            this.ctx.strokeStyle = 'rgba(255, 200, 100, 0.7)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.2, -shipSize * 0.1, shipSize * 0.07, shipSize * 0.1, -0.1, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.2, -shipSize * 0.1, shipSize * 0.07, shipSize * 0.1, 0.1, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Fighter jet cockpit canopy - streamlined racing style (F-16 inspired) with Star Trek elements
            const cockpitGradient = this.ctx.createRadialGradient(0, -shipSize * 0.5, 0, 0, -shipSize * 0.5, shipSize * 0.2);
            cockpitGradient.addColorStop(0, 'rgba(255, 250, 220, 0.95)');
            cockpitGradient.addColorStop(0.2, 'rgba(255, 230, 180, 0.8)');
            cockpitGradient.addColorStop(0.4, 'rgba(255, 200, 120, 0.6)');
            cockpitGradient.addColorStop(0.7, 'rgba(255, 150, 80, 0.4)');
            cockpitGradient.addColorStop(1, 'rgba(255, 100, 50, 0.2)');
            this.ctx.fillStyle = cockpitGradient;
            this.ctx.beginPath();
            // Streamlined racing canopy shape
            this.ctx.ellipse(0, -shipSize * 0.5, shipSize * 0.18, shipSize * 0.22, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit frame - racing style with multiple frame segments
            this.ctx.strokeStyle = 'rgba(255, 152, 0, 0.95)';
            this.ctx.lineWidth = 2.5;
            this.ctx.stroke();
            
            // Additional frame details (realistic canopy structure)
            this.ctx.strokeStyle = 'rgba(255, 120, 0, 0.8)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            // Front frame
            this.ctx.arc(0, -shipSize * 0.65, shipSize * 0.12, 0.3, Math.PI - 0.3);
            this.ctx.stroke();
            // Side frames
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.12, -shipSize * 0.6);
            this.ctx.lineTo(-shipSize * 0.15, -shipSize * 0.35);
            this.ctx.moveTo(shipSize * 0.12, -shipSize * 0.6);
            this.ctx.lineTo(shipSize * 0.15, -shipSize * 0.35);
            this.ctx.stroke();
            
            // HUD elements visible in cockpit (realistic detail)
            this.ctx.strokeStyle = 'rgba(255, 200, 0, 0.6)';
            this.ctx.lineWidth = 1;
            // HUD crosshair
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 0.55);
            this.ctx.lineTo(0, -shipSize * 0.48);
            this.ctx.moveTo(-shipSize * 0.04, -shipSize * 0.515);
            this.ctx.lineTo(shipSize * 0.04, -shipSize * 0.515);
            this.ctx.stroke();
            
            // Speed indicator lines (racing HUD)
            this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            this.ctx.lineWidth = 0.8;
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 0.5 - Math.PI * 0.25;
                const lineLength = shipSize * 0.1;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -shipSize * 0.5);
                this.ctx.lineTo(Math.cos(angle) * lineLength, -shipSize * 0.5 + Math.sin(angle) * lineLength);
                this.ctx.stroke();
            }
            
            // Pilot seat visible (subtle detail)
            this.ctx.fillStyle = 'rgba(40, 30, 30, 0.6)';
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.4, shipSize * 0.1, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit reflection highlights (realistic glass effect)
            const reflectionGradient = this.ctx.createLinearGradient(-shipSize * 0.12, -shipSize * 0.6, shipSize * 0.12, -shipSize * 0.35);
            reflectionGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            reflectionGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            reflectionGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            this.ctx.fillStyle = reflectionGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.5, shipSize * 0.12, shipSize * 0.18, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Time variable for animations
            const time = Date.now() * 0.015; // Faster animation for speed
            
            // Nose cone - racing interceptor style with speed sensor
            const sensorGradient = this.ctx.createRadialGradient(0, -shipSize * 1.4, 0, 0, -shipSize * 1.4, shipSize * 0.1);
            sensorGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            sensorGradient.addColorStop(0.3, 'rgba(255, 200, 0, 0.95)');
            sensorGradient.addColorStop(0.6, 'rgba(255, 150, 0, 0.8)');
            sensorGradient.addColorStop(1, 'rgba(255, 100, 0, 0.5)');
            this.ctx.fillStyle = sensorGradient;
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 1.4, shipSize * 0.1, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Sensor inner core (pulsing effect - faster for speed theme)
            const sensorPulse = 0.9 + Math.sin(time * 4) * 0.1; // Faster pulse
            this.ctx.fillStyle = `rgba(255, 255, 255, ${sensorPulse})`;
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 1.4, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Speed energy lines - radiating from nose (racing theme)
            this.ctx.strokeStyle = 'rgba(255, 200, 0, 0.6)';
            this.ctx.lineWidth = 1.5;
            this.ctx.shadowBlur = 3;
            this.ctx.shadowColor = 'rgba(255, 200, 0, 0.5)';
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6;
                const lineLength = shipSize * 0.3;
                const pulse = 0.7 + Math.sin(time * 3 + i) * 0.3; // Faster pulse
                this.ctx.strokeStyle = `rgba(255, 200, 0, ${0.5 * pulse})`;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -shipSize * 1.4);
                this.ctx.lineTo(Math.cos(angle) * lineLength, -shipSize * 1.4 + Math.sin(angle) * lineLength);
                this.ctx.stroke();
            }
            this.ctx.shadowBlur = 0;
            
            // Additional sensor rings (realistic detail)
            this.ctx.strokeStyle = 'rgba(255, 150, 0, 0.4)';
            this.ctx.lineWidth = 1;
            for (let ring = 1; ring <= 2; ring++) {
                this.ctx.beginPath();
                this.ctx.arc(0, -shipSize * 1.4, shipSize * (0.07 + ring * 0.02), 0, Math.PI * 2);
                this.ctx.stroke();
            }
            
            // Wingtip thruster details - enhanced with realistic details
            // Panel lines
            this.ctx.strokeStyle = 'rgba(255, 152, 0, 0.7)';
            this.ctx.lineWidth = 1.5;
            // Left thruster panel lines
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 1.0, shipSize * 0.36);
            this.ctx.lineTo(-shipSize * 1.0, shipSize * 0.44);
            this.ctx.stroke();
            // Right thruster panel lines
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 1.0, shipSize * 0.36);
            this.ctx.lineTo(shipSize * 1.0, shipSize * 0.44);
            this.ctx.stroke();
            
            // Thruster cores with turbine detail
            const thrusterCoreGradient = this.ctx.createRadialGradient(-shipSize * 1.0, shipSize * 0.4, 0, -shipSize * 1.0, shipSize * 0.4, shipSize * 0.06);
            thrusterCoreGradient.addColorStop(0, 'rgba(255, 200, 0, 1.0)');
            thrusterCoreGradient.addColorStop(0.4, 'rgba(255, 150, 0, 0.9)');
            thrusterCoreGradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.7)');
            thrusterCoreGradient.addColorStop(1, 'rgba(255, 50, 0, 0.5)');
            this.ctx.fillStyle = thrusterCoreGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 1.0, shipSize * 0.4, shipSize * 0.06, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 1.0, shipSize * 0.4, shipSize * 0.06, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Turbine blades visible in thruster cores (rotating effect)
            const turbineTime = Date.now() * 0.01;
            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
            this.ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6 + turbineTime * 0.8; // Faster rotation
                const bladeLength = shipSize * 0.05;
                // Left thruster turbine
                this.ctx.beginPath();
                this.ctx.moveTo(-shipSize * 1.0, shipSize * 0.4);
                this.ctx.lineTo(-shipSize * 1.0 + Math.cos(angle) * bladeLength, shipSize * 0.4 + Math.sin(angle) * bladeLength);
                this.ctx.stroke();
                // Right thruster turbine
                this.ctx.beginPath();
                this.ctx.moveTo(shipSize * 1.0, shipSize * 0.4);
                this.ctx.lineTo(shipSize * 1.0 + Math.cos(angle) * bladeLength, shipSize * 0.4 + Math.sin(angle) * bladeLength);
                this.ctx.stroke();
            }
            
            // Thruster highlights (metallic shine)
            const thrusterHighlight = this.ctx.createLinearGradient(-shipSize * 1.05, shipSize * 0.35, -shipSize * 0.95, shipSize * 0.4);
            thrusterHighlight.addColorStop(0, 'rgba(255, 255, 255, 0)');
            thrusterHighlight.addColorStop(0.5, 'rgba(255, 240, 200, 0.4)');
            thrusterHighlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
            this.ctx.fillStyle = thrusterHighlight;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 1.05, shipSize * 0.37);
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.4);
            this.ctx.lineTo(-shipSize * 0.92, shipSize * 0.37);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 1.05, shipSize * 0.37);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.92, shipSize * 0.37);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Engine flames (animated based on time) - ENHANCED for speed
            let flameIntensity = 0.85 + Math.sin(time) * 0.15; // More intense for fast ship
            
            // Boost enhancement - larger, brighter flames when boost is active
            if (this.boostActive) {
                flameIntensity = 1.3 + Math.sin(time * 4) * 0.4; // Much more intense and faster pulsing
            }
            
            // Main engine flame - dual exhaust (F-16/F-18 style) - ENHANCED
            const flameGradient = this.ctx.createLinearGradient(0, shipSize * 0.7, 0, shipSize * (this.boostActive ? 2.0 : 1.5));
            if (this.boostActive) {
                // Boost colors - bright orange/yellow flames
                flameGradient.addColorStop(0, `rgba(255, 200, 0, ${1.0 * flameIntensity})`); // Bright yellow at base
                flameGradient.addColorStop(0.15, `rgba(255, 150, 0, ${0.95 * flameIntensity})`); // Orange
                flameGradient.addColorStop(0.3, `rgba(255, 100, 0, ${0.85 * flameIntensity})`); // Deep orange
                flameGradient.addColorStop(0.5, `rgba(255, 50, 0, ${0.75 * flameIntensity})`); // Red-orange
                flameGradient.addColorStop(0.7, `rgba(255, 0, 0, ${0.6 * flameIntensity})`); // Red
                flameGradient.addColorStop(1, `rgba(200, 0, 0, ${0.3 * flameIntensity})`); // Dark red at tip
            } else {
                flameGradient.addColorStop(0, `rgba(255, 150, 50, ${1.0 * flameIntensity})`); // Bright orange at base
                flameGradient.addColorStop(0.2, `rgba(255, 100, 0, ${0.9 * flameIntensity})`); // Orange
                flameGradient.addColorStop(0.4, `rgba(255, 50, 0, ${0.8 * flameIntensity})`); // Red-orange
                flameGradient.addColorStop(0.6, `rgba(255, 0, 0, ${0.65 * flameIntensity})`); // Red
                flameGradient.addColorStop(0.8, `rgba(200, 0, 0, ${0.45 * flameIntensity})`); // Dark red
                flameGradient.addColorStop(1, `rgba(150, 0, 0, ${0.25 * flameIntensity})`); // Very dark red at tip
            }
            
            this.ctx.fillStyle = flameGradient;
            this.ctx.beginPath();
            // Flame shape - wider at base, narrows to tip (ENHANCED: Larger for speed)
            const flameWidth = shipSize * (this.boostActive ? 0.45 : 0.32) * (1 + Math.sin(time * (this.boostActive ? 4 : 2.5)) * 0.3);
            const flameLength = shipSize * (this.boostActive ? 1.3 : 0.9) * flameIntensity;
            this.ctx.moveTo(-flameWidth, shipSize * 0.7);
            this.ctx.lineTo(0, shipSize * 0.7 + flameLength);
            this.ctx.lineTo(flameWidth, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Additional outer flame layer for more intensity
            const outerFlameGradient = this.ctx.createLinearGradient(0, shipSize * 0.7, 0, shipSize * (this.boostActive ? 1.8 : 1.3));
            if (this.boostActive) {
                outerFlameGradient.addColorStop(0, `rgba(255, 200, 0, ${0.4 * flameIntensity})`);
                outerFlameGradient.addColorStop(0.5, `rgba(255, 100, 0, ${0.3 * flameIntensity})`);
                outerFlameGradient.addColorStop(1, `rgba(255, 50, 0, ${0.1 * flameIntensity})`);
            } else {
                outerFlameGradient.addColorStop(0, `rgba(255, 150, 50, ${0.5 * flameIntensity})`);
                outerFlameGradient.addColorStop(0.5, `rgba(255, 50, 0, ${0.3 * flameIntensity})`);
                outerFlameGradient.addColorStop(1, `rgba(200, 0, 0, ${0.1 * flameIntensity})`);
            }
            this.ctx.fillStyle = outerFlameGradient;
            this.ctx.beginPath();
            const outerFlameWidth = flameWidth * 1.4;
            const outerFlameLength = flameLength * 0.9;
            this.ctx.moveTo(-outerFlameWidth, shipSize * 0.7);
            this.ctx.lineTo(0, shipSize * 0.7 + outerFlameLength);
            this.ctx.lineTo(outerFlameWidth, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Enhanced glow during boost
            if (this.boostActive) {
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = 'rgba(255, 200, 0, 0.8)';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Secondary flame (smaller, offset) - ENHANCED
            const flame2Gradient = this.ctx.createLinearGradient(0, shipSize * 0.7, 0, shipSize * (this.boostActive ? 1.6 : 1.2));
            if (this.boostActive) {
                flame2Gradient.addColorStop(0, `rgba(255, 180, 80, ${0.9 * flameIntensity})`);
                flame2Gradient.addColorStop(0.4, `rgba(255, 120, 0, ${0.7 * flameIntensity})`);
                flame2Gradient.addColorStop(0.7, `rgba(255, 50, 0, ${0.5 * flameIntensity})`);
                flame2Gradient.addColorStop(1, `rgba(255, 0, 0, ${0.25 * flameIntensity})`);
            } else {
                flame2Gradient.addColorStop(0, `rgba(255, 130, 40, ${0.75 * flameIntensity})`);
                flame2Gradient.addColorStop(0.4, `rgba(255, 80, 0, ${0.55 * flameIntensity})`);
                flame2Gradient.addColorStop(0.7, `rgba(255, 30, 0, ${0.35 * flameIntensity})`);
                flame2Gradient.addColorStop(1, `rgba(200, 0, 0, ${0.15 * flameIntensity})`);
            }
            
            this.ctx.fillStyle = flame2Gradient;
            this.ctx.beginPath();
            const flame2Width = shipSize * (this.boostActive ? 0.28 : 0.2) * (1 + Math.cos(time * (this.boostActive ? 3 : 2)) * 0.25);
            const flame2Length = shipSize * (this.boostActive ? 0.8 : 0.55) * flameIntensity;
            this.ctx.moveTo(-flame2Width * 0.7, shipSize * 0.7);
            this.ctx.lineTo(0, shipSize * 0.7 + flame2Length);
            this.ctx.lineTo(flame2Width * 0.7, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Additional boost particles - ENHANCED: More particles for speed theme
            if (this.boostActive) {
                for (let i = 0; i < 14; i++) {
                    const particleAngle = (Math.PI * 2 * i) / 14 + time * 3;
                    const particleDist = shipSize * 1.2;
                    const particleX = Math.cos(particleAngle) * particleDist;
                    const particleY = shipSize * 0.7 + Math.sin(particleAngle) * particleDist * 0.6;
                    const particleSize = 3 + Math.sin(time * 7 + i) * 2;
                    const particleAlpha = 0.85 + Math.sin(time * 5 + i) * 0.15;
                    this.ctx.fillStyle = `rgba(255, 200, 0, ${particleAlpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Additional smaller particles for more detail
                    if (i % 2 === 0) {
                        this.ctx.fillStyle = `rgba(255, 150, 50, ${particleAlpha * 0.7})`;
                        this.ctx.beginPath();
                        this.ctx.arc(particleX * 0.8, particleY * 1.1, particleSize * 0.7, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
            
            // Heat distortion effect around engines (realistic detail)
            if (this.boostActive) {
                this.ctx.strokeStyle = `rgba(255, 200, 100, ${0.3 * flameIntensity})`;
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const distortionY = shipSize * 0.7 + i * shipSize * 0.15;
                    const distortionWidth = shipSize * (0.3 + i * 0.1) * (1 + Math.sin(time * 3 + i) * 0.1);
                    this.ctx.beginPath();
                    this.ctx.moveTo(-distortionWidth, distortionY);
                    this.ctx.quadraticCurveTo(0, distortionY + shipSize * 0.05, distortionWidth, distortionY);
                    this.ctx.stroke();
                }
            }
            
            // Engine core glow with turbine detail (realistic)
            const mainEngineGradient = this.ctx.createRadialGradient(0, shipSize * 0.7, 0, 0, shipSize * 0.7, shipSize * 0.1);
            mainEngineGradient.addColorStop(0, `rgba(255, 200, 100, ${0.95 * flameIntensity})`);
            mainEngineGradient.addColorStop(0.4, `rgba(255, 150, 50, ${0.85 * flameIntensity})`);
            mainEngineGradient.addColorStop(0.7, `rgba(255, 100, 0, ${0.7 * flameIntensity})`);
            mainEngineGradient.addColorStop(1, `rgba(255, 50, 0, ${0.5 * flameIntensity})`);
            this.ctx.fillStyle = mainEngineGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.7, shipSize * 0.1, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Main engine turbine blades (rotating)
            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.lineWidth = 1.5;
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8 + time * 1.0; // Faster rotation for speed
                const bladeLength = shipSize * 0.08;
                this.ctx.beginPath();
                this.ctx.moveTo(0, shipSize * 0.7);
                this.ctx.lineTo(Math.cos(angle) * bladeLength, shipSize * 0.7 + Math.sin(angle) * bladeLength * 0.6);
                this.ctx.stroke();
            }
            
            // Engine nozzle details (realistic fighter jet)
            this.ctx.strokeStyle = 'rgba(255, 200, 150, 0.8)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.7, shipSize * 0.11, shipSize * 0.09, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Engine nozzle inner ring
            this.ctx.strokeStyle = 'rgba(255, 150, 100, 0.6)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.7, shipSize * 0.08, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Wingtip thruster flames - Star Trek style maneuvering thrusters
            const wingtipFlameGradient = this.ctx.createLinearGradient(0, shipSize * 0.4, 0, shipSize * (this.boostActive ? 1.0 : 0.7));
            if (this.boostActive) {
                wingtipFlameGradient.addColorStop(0, `rgba(255, 200, 0, ${0.8 * flameIntensity})`);
                wingtipFlameGradient.addColorStop(0.4, `rgba(255, 100, 0, ${0.6 * flameIntensity})`);
                wingtipFlameGradient.addColorStop(1, `rgba(255, 50, 0, ${0.3 * flameIntensity})`);
            } else {
                wingtipFlameGradient.addColorStop(0, `rgba(255, 150, 50, ${0.7 * flameIntensity})`);
                wingtipFlameGradient.addColorStop(0.5, `rgba(255, 80, 0, ${0.5 * flameIntensity})`);
                wingtipFlameGradient.addColorStop(1, `rgba(255, 30, 0, ${0.25 * flameIntensity})`);
            }
            
            this.ctx.fillStyle = wingtipFlameGradient;
            // Left wingtip thruster flame
            const leftWingtipFlameWidth = shipSize * (this.boostActive ? 0.25 : 0.18) * (1 + Math.sin(time * 2.5) * 0.2);
            const leftWingtipFlameLength = shipSize * (this.boostActive ? 0.6 : 0.4) * flameIntensity;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 1.0 - leftWingtipFlameWidth * 0.5, shipSize * 0.4);
            this.ctx.lineTo(-shipSize * 1.0, shipSize * 0.4 + leftWingtipFlameLength);
            this.ctx.lineTo(-shipSize * 1.0 + leftWingtipFlameWidth * 0.5, shipSize * 0.4);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right wingtip thruster flame
            const rightWingtipFlameWidth = shipSize * (this.boostActive ? 0.25 : 0.18) * (1 + Math.sin(time * 2.5 + 1) * 0.2);
            const rightWingtipFlameLength = shipSize * (this.boostActive ? 0.6 : 0.4) * flameIntensity;
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 1.0 - rightWingtipFlameWidth * 0.5, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 1.0, shipSize * 0.4 + rightWingtipFlameLength);
            this.ctx.lineTo(shipSize * 1.0 + rightWingtipFlameWidth * 0.5, shipSize * 0.4);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Wingtip thruster cores glow
            this.ctx.fillStyle = `rgba(255, 200, 0, ${0.9 * flameIntensity})`;
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 1.0, shipSize * 0.4, shipSize * 0.08, shipSize * 0.1, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 1.0, shipSize * 0.4, shipSize * 0.08, shipSize * 0.1, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Additional boost particles from wingtip thrusters
            if (this.boostActive) {
                for (let i = 0; i < 6; i++) {
                    const particleAngle = (Math.PI * 2 * i) / 6 + time * 3;
                    // Left thruster particles
                    const leftParticleDist = shipSize * 1.0;
                    const leftParticleX = -shipSize * 1.0 + Math.cos(particleAngle) * leftParticleDist * 0.3;
                    const leftParticleY = shipSize * 0.4 + Math.sin(particleAngle) * leftParticleDist * 0.5;
                    const particleSize = 2.5 + Math.sin(time * 6 + i) * 1.5;
                    this.ctx.fillStyle = `rgba(255, 200, 0, ${0.8 + Math.sin(time * 4 + i) * 0.2})`;
                    this.ctx.beginPath();
                    this.ctx.arc(leftParticleX, leftParticleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Right thruster particles
                    const rightParticleX = shipSize * 1.0 + Math.cos(particleAngle) * leftParticleDist * 0.3;
                    const rightParticleY = shipSize * 0.4 + Math.sin(particleAngle) * leftParticleDist * 0.5;
                    this.ctx.beginPath();
                    this.ctx.arc(rightParticleX, rightParticleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // Speed indicator lights (pulsing - faster for speed theme)
            const lightIntensity = 0.6 + Math.sin(time * 4) * 0.4; // Faster pulse
            this.ctx.fillStyle = `rgba(100, 255, 100, ${lightIntensity})`;
            this.ctx.shadowBlur = 6;
            this.ctx.shadowColor = 'rgba(100, 255, 100, 0.8)';
            // Front indicators
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 0.2, -shipSize * 0.5, shipSize * 0.045, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 0.2, -shipSize * 0.5, shipSize * 0.045, 0, Math.PI * 2);
            this.ctx.fill();
            // Wing indicators
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 0.7, shipSize * 0.25, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 0.7, shipSize * 0.25, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            
            // Reset fill style
            this.ctx.fillStyle = shipColor;
        } else if (ship.shape === 'rapid') {
            // MODULAR RAPID-FIRE INTERCEPTOR - Futuristic multi-component design
            // Inspired by: Su-47 forward-swept wings, Eurofighter canards, Star Wars modular pods, Halo Sabre
            // Purple/violet color scheme with modular weapon pods and forward-swept canards (distinct from fast ship's orange)
            
            const time = Date.now() * 0.02; // Faster animation for rapid theme
            const pulseIntensity = 0.6 + Math.sin(time * 4) * 0.4; // Fast pulsing
            
            // CENTRAL CORE BODY - Main fuselage (compact, angular)
            const coreGradient = this.ctx.createLinearGradient(0, -shipSize * 1.2, 0, shipSize * 0.6);
            coreGradient.addColorStop(0, '#9c27b0'); // Bright purple at nose
            coreGradient.addColorStop(0.3, '#7b1fa2'); // Deep purple
            coreGradient.addColorStop(0.6, '#6a1b9a'); // Dark purple
            coreGradient.addColorStop(1, '#4a148c'); // Deep violet at tail
            this.ctx.fillStyle = coreGradient;
            
            // Central core body - compact angular design
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.2); // Sharp nose tip
            
            // Left side - angular core
            this.ctx.lineTo(-shipSize * 0.15, -shipSize * 0.8); // Nose to upper
            this.ctx.lineTo(-shipSize * 0.2, -shipSize * 0.4); // Upper to mid
            this.ctx.lineTo(-shipSize * 0.22, 0); // Mid to lower
            this.ctx.lineTo(-shipSize * 0.2, shipSize * 0.3); // Lower to wing connection
            this.ctx.lineTo(-shipSize * 0.15, shipSize * 0.5); // Wing connection
            this.ctx.lineTo(0, shipSize * 0.6); // Tail center
            
            // Right side (mirror)
            this.ctx.lineTo(shipSize * 0.15, shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.2, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.22, 0);
            this.ctx.lineTo(shipSize * 0.2, -shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.15, -shipSize * 0.8);
            this.ctx.closePath();
            this.ctx.fill();
            
            // FORWARD-SWEPT CANARDS - Small front wings (Su-47 style, Eurofighter inspired)
            const canardGradient = this.ctx.createLinearGradient(0, -shipSize * 0.9, 0, -shipSize * 0.5);
            canardGradient.addColorStop(0, '#ab47bc'); // Bright purple
            canardGradient.addColorStop(0.5, '#8e24aa'); // Medium purple
            canardGradient.addColorStop(1, '#6a1b9a'); // Deep purple
            this.ctx.fillStyle = canardGradient;
            
            // Left forward-swept canard (small front wing)
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.15, -shipSize * 0.7); // Root (attached to core)
            this.ctx.lineTo(-shipSize * 0.5, -shipSize * 0.9); // Forward-swept tip (sweeps forward!)
            this.ctx.lineTo(-shipSize * 0.45, -shipSize * 0.6); // Rear edge
            this.ctx.lineTo(-shipSize * 0.18, -shipSize * 0.65); // Back to root
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right forward-swept canard
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.15, -shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.5, -shipSize * 0.9);
            this.ctx.lineTo(shipSize * 0.45, -shipSize * 0.6);
            this.ctx.lineTo(shipSize * 0.18, -shipSize * 0.65);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Canard leading edge highlights (metallic)
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            this.ctx.lineWidth = 2.5;
            this.ctx.beginPath();
            // Left canard leading edge
            this.ctx.moveTo(-shipSize * 0.15, -shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 0.5, -shipSize * 0.9);
            // Right canard leading edge
            this.ctx.moveTo(shipSize * 0.15, -shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.5, -shipSize * 0.9);
            this.ctx.stroke();
            
            // MAIN DELTA WINGS - Large swept-back wings
            const wingGradient = this.ctx.createLinearGradient(0, shipSize * 0.1, 0, shipSize * 0.6);
            wingGradient.addColorStop(0, '#7b1fa2'); // Deep purple at root
            wingGradient.addColorStop(0.5, '#6a1b9a'); // Dark purple mid
            wingGradient.addColorStop(1, '#4a148c'); // Deep violet at tip
            this.ctx.fillStyle = wingGradient;
            
            // Left main delta wing
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.2, shipSize * 0.3); // Wing root (attached to core)
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.2); // Forward wing tip (swept back)
            this.ctx.lineTo(-shipSize * 1.0, shipSize * 0.55); // Rear wing tip
            this.ctx.lineTo(-shipSize * 0.25, shipSize * 0.6); // Back to root
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right main delta wing
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.2, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.2);
            this.ctx.lineTo(shipSize * 1.0, shipSize * 0.55);
            this.ctx.lineTo(shipSize * 0.25, shipSize * 0.6);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Wing leading edge highlights (metallic)
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            this.ctx.lineWidth = 2.5;
            this.ctx.beginPath();
            // Left wing leading edge
            this.ctx.moveTo(-shipSize * 0.2, shipSize * 0.35);
            this.ctx.lineTo(-shipSize * 1.0, shipSize * 0.25);
            // Right wing leading edge
            this.ctx.moveTo(shipSize * 0.2, shipSize * 0.35);
            this.ctx.lineTo(shipSize * 1.0, shipSize * 0.25);
            this.ctx.stroke();
            
            // MODULAR WEAPON PODS - Separate components (Star Wars X-wing style, but more futuristic)
            // These appear as separate modular units attached to wings
            const podGradient = this.ctx.createLinearGradient(0, shipSize * 0.4, 0, shipSize * 0.7);
            podGradient.addColorStop(0, 'rgba(186, 104, 200, 0.95)'); // Bright purple
            podGradient.addColorStop(0.3, 'rgba(156, 39, 176, 0.9)'); // Medium purple
            podGradient.addColorStop(0.7, 'rgba(123, 31, 162, 0.85)'); // Deep purple
            podGradient.addColorStop(1, 'rgba(106, 27, 154, 0.8)'); // Dark purple
            this.ctx.fillStyle = podGradient;
            
            // Left modular weapon pod (separate component on wing)
            this.ctx.beginPath();
            // Pod shape - angular, modular design
            this.ctx.moveTo(-shipSize * 0.7, shipSize * 0.4); // Front top
            this.ctx.lineTo(-shipSize * 0.85, shipSize * 0.45); // Front bottom
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.6); // Rear bottom
            this.ctx.lineTo(-shipSize * 0.75, shipSize * 0.65); // Rear top
            this.ctx.lineTo(-shipSize * 0.65, shipSize * 0.55); // Top edge
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right modular weapon pod
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.7, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.85, shipSize * 0.45);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.6);
            this.ctx.lineTo(shipSize * 0.75, shipSize * 0.65);
            this.ctx.lineTo(shipSize * 0.65, shipSize * 0.55);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Weapon pod connection points (visible attachment to wing)
            this.ctx.fillStyle = 'rgba(186, 104, 200, 0.8)';
            // Left pod connection
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.65, shipSize * 0.45);
            this.ctx.lineTo(-shipSize * 0.5, shipSize * 0.4);
            this.ctx.lineTo(-shipSize * 0.5, shipSize * 0.5);
            this.ctx.lineTo(-shipSize * 0.65, shipSize * 0.55);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right pod connection
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.65, shipSize * 0.45);
            this.ctx.lineTo(shipSize * 0.5, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.5, shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.65, shipSize * 0.55);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Rapid-fire weapon barrels (multiple barrels per pod)
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            // Left pod barrels (4 barrels for rapid fire)
            for (let i = 0; i < 4; i++) {
                this.ctx.beginPath();
                this.ctx.arc(-shipSize * 0.8 + i * shipSize * 0.04, shipSize * 0.52, shipSize * 0.022, 0, Math.PI * 2);
                this.ctx.fill();
            }
            // Right pod barrels
            for (let i = 0; i < 4; i++) {
                this.ctx.beginPath();
                this.ctx.arc(shipSize * 0.8 - i * shipSize * 0.04, shipSize * 0.52, shipSize * 0.022, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Weapon pod panel lines (modular component details)
            this.ctx.strokeStyle = 'rgba(186, 104, 200, 0.7)';
            this.ctx.lineWidth = 1.5;
            // Left pod panels
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.75, shipSize * 0.45);
            this.ctx.lineTo(-shipSize * 0.75, shipSize * 0.6);
            this.ctx.moveTo(-shipSize * 0.8, shipSize * 0.48);
            this.ctx.lineTo(-shipSize * 0.8, shipSize * 0.58);
            this.ctx.stroke();
            // Right pod panels
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.75, shipSize * 0.45);
            this.ctx.lineTo(shipSize * 0.75, shipSize * 0.6);
            this.ctx.moveTo(shipSize * 0.8, shipSize * 0.48);
            this.ctx.lineTo(shipSize * 0.8, shipSize * 0.58);
            this.ctx.stroke();
            
            // Pod energy indicators (rapid-fire ready lights)
            const podLightPulse = 0.7 + Math.sin(time * 6) * 0.3; // Very fast pulse
            this.ctx.fillStyle = `rgba(186, 104, 200, ${podLightPulse})`;
            this.ctx.shadowBlur = 5;
            this.ctx.shadowColor = 'rgba(186, 104, 200, 0.8)';
            // Left pod indicator
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 0.775, shipSize * 0.525, shipSize * 0.03, 0, Math.PI * 2);
            this.ctx.fill();
            // Right pod indicator
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 0.775, shipSize * 0.525, shipSize * 0.03, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            
            // Realistic 3D shading - highlights and shadows for depth
            // Top highlight (sunlight reflection on core)
            const topHighlight = this.ctx.createLinearGradient(0, -shipSize * 1.2, 0, -shipSize * 0.3);
            topHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            topHighlight.addColorStop(0.3, 'rgba(255, 240, 200, 0.3)');
            topHighlight.addColorStop(1, 'rgba(0, 0, 0, 0)');
            this.ctx.fillStyle = topHighlight;
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.2);
            this.ctx.lineTo(-shipSize * 0.12, -shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.12, -shipSize * 0.5);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Side shadows for depth
            const sideShadow = this.ctx.createLinearGradient(-shipSize * 0.22, 0, 0, 0);
            sideShadow.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            sideShadow.addColorStop(1, 'rgba(0, 0, 0, 0)');
            this.ctx.fillStyle = sideShadow;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.22, -shipSize * 0.2);
            this.ctx.lineTo(-shipSize * 0.22, shipSize * 0.4);
            this.ctx.lineTo(-shipSize * 0.18, shipSize * 0.35);
            this.ctx.lineTo(-shipSize * 0.18, -shipSize * 0.15);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Detailed panel lines and rivets (realistic fighter jet details)
            this.ctx.strokeStyle = 'rgba(255, 152, 0, 0.6)';
            this.ctx.lineWidth = 1;
            
            // Horizontal panel lines with rivets
            for (let y of [-shipSize * 0.5, 0, shipSize * 0.25]) {
                this.ctx.beginPath();
                this.ctx.moveTo(-shipSize * 0.18, y);
                this.ctx.lineTo(shipSize * 0.18, y);
                this.ctx.stroke();
                
                // Rivets along panel lines
                this.ctx.fillStyle = 'rgba(255, 220, 150, 0.8)';
                for (let x = -shipSize * 0.15; x <= shipSize * 0.15; x += shipSize * 0.08) {
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 1.2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // Vertical panel lines
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.12, -shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 0.12, shipSize * 0.3);
            this.ctx.moveTo(shipSize * 0.12, -shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.12, shipSize * 0.3);
            this.ctx.stroke();
            
            // Wing panel details - futuristic style
            this.ctx.strokeStyle = 'rgba(156, 39, 176, 0.5)';
            this.ctx.lineWidth = 1;
            // Left wing panels
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.3, shipSize * 0.35);
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.3);
            this.ctx.moveTo(-shipSize * 0.4, shipSize * 0.45);
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.4);
            this.ctx.stroke();
            // Right wing panels
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.3, shipSize * 0.35);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.3);
            this.ctx.moveTo(shipSize * 0.4, shipSize * 0.45);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.4);
            this.ctx.stroke();
            
            // Canard panel details
            this.ctx.strokeStyle = 'rgba(186, 104, 200, 0.5)';
            this.ctx.beginPath();
            // Left canard panels
            this.ctx.moveTo(-shipSize * 0.2, -shipSize * 0.75);
            this.ctx.lineTo(-shipSize * 0.45, -shipSize * 0.85);
            this.ctx.stroke();
            // Right canard panels
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.2, -shipSize * 0.75);
            this.ctx.lineTo(shipSize * 0.45, -shipSize * 0.85);
            this.ctx.stroke();
            
            // Air intakes visible on core sides (realistic fighter jet detail)
            this.ctx.fillStyle = 'rgba(150, 50, 30, 0.9)';
            // Left intake
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.18, -shipSize * 0.1, shipSize * 0.06, shipSize * 0.1, -0.1, 0, Math.PI * 2);
            this.ctx.fill();
            // Right intake
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.18, -shipSize * 0.1, shipSize * 0.06, shipSize * 0.1, 0.1, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Intake highlights
            this.ctx.strokeStyle = 'rgba(255, 200, 100, 0.7)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.18, -shipSize * 0.1, shipSize * 0.06, shipSize * 0.1, -0.1, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.18, -shipSize * 0.1, shipSize * 0.06, shipSize * 0.1, 0.1, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Fighter jet cockpit canopy - futuristic modular style with Star Trek elements
            const cockpitGradient = this.ctx.createRadialGradient(0, -shipSize * 0.5, 0, 0, -shipSize * 0.5, shipSize * 0.2);
            cockpitGradient.addColorStop(0, 'rgba(255, 250, 220, 0.95)');
            cockpitGradient.addColorStop(0.2, 'rgba(255, 230, 180, 0.8)');
            cockpitGradient.addColorStop(0.4, 'rgba(255, 200, 120, 0.6)');
            cockpitGradient.addColorStop(0.7, 'rgba(255, 150, 80, 0.4)');
            cockpitGradient.addColorStop(1, 'rgba(255, 100, 50, 0.2)');
            this.ctx.fillStyle = cockpitGradient;
            this.ctx.beginPath();
            // Futuristic angular canopy shape
            this.ctx.ellipse(0, -shipSize * 0.5, shipSize * 0.16, shipSize * 0.2, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit frame - modular design with multiple segments
            this.ctx.strokeStyle = 'rgba(156, 39, 176, 0.95)';
            this.ctx.lineWidth = 2.5;
            this.ctx.stroke();
            
            // Additional frame details (modular structure)
            this.ctx.strokeStyle = 'rgba(123, 31, 162, 0.8)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            // Front frame
            this.ctx.arc(0, -shipSize * 0.65, shipSize * 0.12, 0.3, Math.PI - 0.3);
            this.ctx.stroke();
            // Side frames
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.12, -shipSize * 0.6);
            this.ctx.lineTo(-shipSize * 0.15, -shipSize * 0.35);
            this.ctx.moveTo(shipSize * 0.12, -shipSize * 0.6);
            this.ctx.lineTo(shipSize * 0.15, -shipSize * 0.35);
            this.ctx.stroke();
            
            // HUD elements visible in cockpit (rapid-fire targeting system)
            this.ctx.strokeStyle = `rgba(186, 104, 200, ${pulseIntensity})`;
            this.ctx.lineWidth = 1;
            this.ctx.shadowBlur = 3;
            this.ctx.shadowColor = 'rgba(186, 104, 200, 0.6)';
            // HUD crosshair with rapid-fire indicators
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 0.55);
            this.ctx.lineTo(0, -shipSize * 0.48);
            this.ctx.moveTo(-shipSize * 0.05, -shipSize * 0.515);
            this.ctx.lineTo(shipSize * 0.05, -shipSize * 0.515);
            // Rapid-fire rate indicator lines (8 directions for modular pods)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const radius = shipSize * 0.1;
                this.ctx.moveTo(Math.cos(angle) * radius * 0.5, -shipSize * 0.5 + Math.sin(angle) * radius * 0.5);
                this.ctx.lineTo(Math.cos(angle) * radius, -shipSize * 0.5 + Math.sin(angle) * radius);
            }
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Pilot seat visible (subtle detail)
            this.ctx.fillStyle = 'rgba(40, 30, 30, 0.6)';
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.4, shipSize * 0.1, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit reflection highlights (realistic glass effect)
            const reflectionGradient = this.ctx.createLinearGradient(-shipSize * 0.12, -shipSize * 0.6, shipSize * 0.12, -shipSize * 0.35);
            reflectionGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            reflectionGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            reflectionGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            this.ctx.fillStyle = reflectionGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.5, shipSize * 0.12, shipSize * 0.18, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Nose cone - modular rapid-fire sensor array
            const sensorPulse = 0.8 + Math.sin(time * 5) * 0.2; // Very fast pulse
            const sensorGradient = this.ctx.createRadialGradient(0, -shipSize * 1.2, 0, 0, -shipSize * 1.2, shipSize * 0.12);
            sensorGradient.addColorStop(0, `rgba(255, 255, 255, ${sensorPulse})`);
            sensorGradient.addColorStop(0.3, `rgba(186, 104, 200, ${sensorPulse * 0.95})`);
            sensorGradient.addColorStop(0.6, `rgba(156, 39, 176, ${sensorPulse * 0.8})`);
            sensorGradient.addColorStop(1, `rgba(123, 31, 162, ${sensorPulse * 0.5})`);
            this.ctx.fillStyle = sensorGradient;
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 1.2, shipSize * 0.12, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Sensor inner core (pulsing effect)
            this.ctx.fillStyle = `rgba(255, 255, 255, ${sensorPulse})`;
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 1.2, shipSize * 0.05, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Rapid-fire energy lines - radiating from nose (modular sensor array)
            this.ctx.strokeStyle = `rgba(186, 104, 200, ${0.7 * pulseIntensity})`;
            this.ctx.lineWidth = 2;
            this.ctx.shadowBlur = 6;
            this.ctx.shadowColor = 'rgba(186, 104, 200, 0.6)';
            for (let i = 0; i < 8; i++) { // 8 lines for modular theme
                const angle = (Math.PI * 2 * i) / 8;
                const lineLength = shipSize * 0.35;
                const linePulse = 0.6 + Math.sin(time * 3 + i) * 0.4;
                this.ctx.strokeStyle = `rgba(186, 104, 200, ${0.6 * linePulse})`;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -shipSize * 1.2);
                this.ctx.lineTo(Math.cos(angle) * lineLength, -shipSize * 1.2 + Math.sin(angle) * lineLength);
                this.ctx.stroke();
            }
            this.ctx.shadowBlur = 0;
            
            // Additional sensor rings (modular array detail)
            this.ctx.strokeStyle = 'rgba(156, 39, 176, 0.4)';
            this.ctx.lineWidth = 1;
            for (let ring = 1; ring <= 2; ring++) {
                this.ctx.beginPath();
                this.ctx.arc(0, -shipSize * 1.2, shipSize * (0.08 + ring * 0.02), 0, Math.PI * 2);
                this.ctx.stroke();
            }
            
            // MODULAR MULTI-ENGINE SYSTEM - Futuristic quad-engine design
            // Main central engine + 2 side engines + pod engines = 4 total engines
            const flameIntensity = 0.9 + Math.sin(time * 3) * 0.1; // More intense and faster
            
            // Boost enhancement - even more intense flames
            if (this.boostActive) {
                flameIntensity = 1.4 + Math.sin(time * 5) * 0.4; // Extreme intensity
            }
            
            // MAIN CENTRAL ENGINE - Core body exhaust (largest)
            const mainFlameGradient = this.ctx.createLinearGradient(0, shipSize * 0.6, 0, shipSize * (this.boostActive ? 2.2 : 1.6));
            if (this.boostActive) {
                mainFlameGradient.addColorStop(0, `rgba(200, 150, 255, ${1.0 * flameIntensity})`); // Bright purple-white
                mainFlameGradient.addColorStop(0.15, `rgba(186, 104, 200, ${0.95 * flameIntensity})`); // Bright purple
                mainFlameGradient.addColorStop(0.3, `rgba(156, 39, 176, ${0.85 * flameIntensity})`); // Medium purple
                mainFlameGradient.addColorStop(0.5, `rgba(123, 31, 162, ${0.75 * flameIntensity})`); // Deep purple
                mainFlameGradient.addColorStop(0.7, `rgba(106, 27, 154, ${0.6 * flameIntensity})`); // Dark purple
                mainFlameGradient.addColorStop(1, `rgba(74, 20, 140, ${0.3 * flameIntensity})`); // Deep violet
            } else {
                mainFlameGradient.addColorStop(0, `rgba(186, 104, 200, ${1.0 * flameIntensity})`); // Bright purple
                mainFlameGradient.addColorStop(0.2, `rgba(156, 39, 176, ${0.9 * flameIntensity})`); // Medium purple
                mainFlameGradient.addColorStop(0.4, `rgba(123, 31, 162, ${0.8 * flameIntensity})`); // Deep purple
                mainFlameGradient.addColorStop(0.6, `rgba(106, 27, 154, ${0.65 * flameIntensity})`); // Dark purple
                mainFlameGradient.addColorStop(0.8, `rgba(74, 20, 140, ${0.45 * flameIntensity})`); // Deep violet
                mainFlameGradient.addColorStop(1, `rgba(49, 27, 146, ${0.25 * flameIntensity})`); // Very dark violet
            }
            
            this.ctx.fillStyle = mainFlameGradient;
            this.ctx.beginPath();
            const mainFlameWidth = shipSize * (this.boostActive ? 0.45 : 0.32) * (1 + Math.sin(time * 3) * 0.3);
            const mainFlameLength = shipSize * (this.boostActive ? 1.4 : 1.0) * flameIntensity;
            this.ctx.moveTo(-mainFlameWidth, shipSize * 0.6);
            this.ctx.lineTo(0, shipSize * 0.6 + mainFlameLength);
            this.ctx.lineTo(mainFlameWidth, shipSize * 0.6);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Additional outer flame layer for more intensity
            const outerFlameGradient = this.ctx.createLinearGradient(0, shipSize * 0.6, 0, shipSize * (this.boostActive ? 1.9 : 1.4));
            if (this.boostActive) {
                outerFlameGradient.addColorStop(0, `rgba(200, 150, 255, ${0.4 * flameIntensity})`);
                outerFlameGradient.addColorStop(0.5, `rgba(156, 39, 176, ${0.3 * flameIntensity})`);
                outerFlameGradient.addColorStop(1, `rgba(123, 31, 162, ${0.1 * flameIntensity})`);
            } else {
                outerFlameGradient.addColorStop(0, `rgba(186, 104, 200, ${0.5 * flameIntensity})`);
                outerFlameGradient.addColorStop(0.5, `rgba(123, 31, 162, ${0.3 * flameIntensity})`);
                outerFlameGradient.addColorStop(1, `rgba(74, 20, 140, ${0.1 * flameIntensity})`);
            }
            this.ctx.fillStyle = outerFlameGradient;
            this.ctx.beginPath();
            const outerFlameWidth = mainFlameWidth * 1.4;
            const outerFlameLength = mainFlameLength * 0.9;
            this.ctx.moveTo(-outerFlameWidth, shipSize * 0.6);
            this.ctx.lineTo(0, shipSize * 0.6 + outerFlameLength);
            this.ctx.lineTo(outerFlameWidth, shipSize * 0.6);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Enhanced glow during boost
            if (this.boostActive) {
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = 'rgba(255, 200, 0, 0.8)';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // LEFT SIDE ENGINE - Modular engine pod
            const sideFlameGradient = this.ctx.createLinearGradient(-shipSize * 0.25, shipSize * 0.55, -shipSize * 0.25, shipSize * (this.boostActive ? 1.7 : 1.3));
            if (this.boostActive) {
                sideFlameGradient.addColorStop(0, `rgba(186, 104, 200, ${0.95 * flameIntensity})`);
                sideFlameGradient.addColorStop(0.3, `rgba(156, 39, 176, ${0.8 * flameIntensity})`);
                sideFlameGradient.addColorStop(0.6, `rgba(123, 31, 162, ${0.6 * flameIntensity})`);
                sideFlameGradient.addColorStop(1, `rgba(74, 20, 140, ${0.3 * flameIntensity})`);
            } else {
                sideFlameGradient.addColorStop(0, `rgba(171, 71, 188, ${0.9 * flameIntensity})`);
                sideFlameGradient.addColorStop(0.4, `rgba(156, 39, 176, ${0.75 * flameIntensity})`);
                sideFlameGradient.addColorStop(0.7, `rgba(123, 31, 162, ${0.55 * flameIntensity})`);
                sideFlameGradient.addColorStop(1, `rgba(74, 20, 140, ${0.25 * flameIntensity})`);
            }
            
            this.ctx.fillStyle = sideFlameGradient;
            this.ctx.beginPath();
            const leftFlameWidth = shipSize * (this.boostActive ? 0.28 : 0.2) * (1 + Math.cos(time * 3 + 1) * 0.25);
            const leftFlameLength = shipSize * (this.boostActive ? 1.0 : 0.75) * flameIntensity;
            this.ctx.moveTo(-shipSize * 0.3, shipSize * 0.55);
            this.ctx.lineTo(-shipSize * 0.25, shipSize * 0.55 + leftFlameLength);
            this.ctx.lineTo(-shipSize * 0.2, shipSize * 0.55);
            this.ctx.closePath();
            this.ctx.fill();
            
            // RIGHT SIDE ENGINE - Modular engine pod
            this.ctx.fillStyle = sideFlameGradient;
            this.ctx.beginPath();
            const rightFlameWidth = shipSize * (this.boostActive ? 0.28 : 0.2) * (1 + Math.cos(time * 3 + 2) * 0.25);
            const rightFlameLength = shipSize * (this.boostActive ? 1.0 : 0.75) * flameIntensity;
            this.ctx.moveTo(shipSize * 0.2, shipSize * 0.55);
            this.ctx.lineTo(shipSize * 0.25, shipSize * 0.55 + rightFlameLength);
            this.ctx.lineTo(shipSize * 0.3, shipSize * 0.55);
            this.ctx.closePath();
            this.ctx.fill();
            
            // WEAPON POD ENGINES - Modular pods have their own engines (futuristic design)
            const podEngineGradient = this.ctx.createLinearGradient(0, shipSize * 0.65, 0, shipSize * (this.boostActive ? 1.2 : 0.9));
            if (this.boostActive) {
                podEngineGradient.addColorStop(0, `rgba(186, 104, 200, ${0.85 * flameIntensity})`);
                podEngineGradient.addColorStop(0.4, `rgba(156, 39, 176, ${0.65 * flameIntensity})`);
                podEngineGradient.addColorStop(1, `rgba(123, 31, 162, ${0.3 * flameIntensity})`);
            } else {
                podEngineGradient.addColorStop(0, `rgba(171, 71, 188, ${0.75 * flameIntensity})`);
                podEngineGradient.addColorStop(0.5, `rgba(156, 39, 176, ${0.55 * flameIntensity})`);
                podEngineGradient.addColorStop(1, `rgba(123, 31, 162, ${0.25 * flameIntensity})`);
            }
            
            this.ctx.fillStyle = podEngineGradient;
            // Left pod engine
            const leftPodFlameWidth = shipSize * (this.boostActive ? 0.22 : 0.16) * (1 + Math.sin(time * 2.5) * 0.2);
            const leftPodFlameLength = shipSize * (this.boostActive ? 0.7 : 0.5) * flameIntensity;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.9 - leftPodFlameWidth * 0.5, shipSize * 0.65);
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.65 + leftPodFlameLength);
            this.ctx.lineTo(-shipSize * 0.9 + leftPodFlameWidth * 0.5, shipSize * 0.65);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right pod engine
            const rightPodFlameWidth = shipSize * (this.boostActive ? 0.22 : 0.16) * (1 + Math.sin(time * 2.5 + 1) * 0.2);
            const rightPodFlameLength = shipSize * (this.boostActive ? 0.7 : 0.5) * flameIntensity;
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.9 - rightPodFlameWidth * 0.5, shipSize * 0.65);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.65 + rightPodFlameLength);
            this.ctx.lineTo(shipSize * 0.9 + rightPodFlameWidth * 0.5, shipSize * 0.65);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Engine cores - bright purple (all 4 engines)
            this.ctx.fillStyle = `rgba(186, 104, 200, ${0.95 * flameIntensity})`;
            // Main engine core
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.6, shipSize * 0.11, shipSize * 0.09, 0, 0, Math.PI * 2);
            this.ctx.fill();
            // Left side engine core
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.25, shipSize * 0.55, shipSize * 0.08, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.fill();
            // Right side engine core
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.25, shipSize * 0.55, shipSize * 0.08, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.fill();
            // Left pod engine core
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.9, shipSize * 0.65, shipSize * 0.07, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            // Right pod engine core
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.9, shipSize * 0.65, shipSize * 0.07, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Engine turbine blades (rotating) - all engines
            this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.lineWidth = 1.5;
            const turbineTime = Date.now() * 0.01;
            // Main engine turbines
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8 + turbineTime * 1.2; // Faster rotation
                const bladeLength = shipSize * 0.09;
                this.ctx.beginPath();
                this.ctx.moveTo(0, shipSize * 0.6);
                this.ctx.lineTo(Math.cos(angle) * bladeLength, shipSize * 0.6 + Math.sin(angle) * bladeLength * 0.6);
                this.ctx.stroke();
            }
            // Side engine turbines
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6 + turbineTime * 1.2;
                const bladeLength = shipSize * 0.07;
                // Left side
                this.ctx.beginPath();
                this.ctx.moveTo(-shipSize * 0.25, shipSize * 0.55);
                this.ctx.lineTo(-shipSize * 0.25 + Math.cos(angle) * bladeLength, shipSize * 0.55 + Math.sin(angle) * bladeLength * 0.6);
                this.ctx.stroke();
                // Right side
                this.ctx.beginPath();
                this.ctx.moveTo(shipSize * 0.25, shipSize * 0.55);
                this.ctx.lineTo(shipSize * 0.25 + Math.cos(angle) * bladeLength, shipSize * 0.55 + Math.sin(angle) * bladeLength * 0.6);
                this.ctx.stroke();
            }
            // Pod engine turbines
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6 + turbineTime * 1.2;
                const bladeLength = shipSize * 0.06;
                // Left pod
                this.ctx.beginPath();
                this.ctx.moveTo(-shipSize * 0.9, shipSize * 0.65);
                this.ctx.lineTo(-shipSize * 0.9 + Math.cos(angle) * bladeLength, shipSize * 0.65 + Math.sin(angle) * bladeLength * 0.6);
                this.ctx.stroke();
                // Right pod
                this.ctx.beginPath();
                this.ctx.moveTo(shipSize * 0.9, shipSize * 0.65);
                this.ctx.lineTo(shipSize * 0.9 + Math.cos(angle) * bladeLength, shipSize * 0.65 + Math.sin(angle) * bladeLength * 0.6);
                this.ctx.stroke();
            }
            
            // Engine nozzle details (realistic fighter jet)
            this.ctx.strokeStyle = 'rgba(186, 104, 200, 0.8)';
            this.ctx.lineWidth = 2;
            // Main engine nozzle
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.6, shipSize * 0.12, shipSize * 0.1, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            // Side engine nozzles
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.25, shipSize * 0.55, shipSize * 0.09, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.25, shipSize * 0.55, shipSize * 0.09, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            // Pod engine nozzles
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.9, shipSize * 0.65, shipSize * 0.08, shipSize * 0.09, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.9, shipSize * 0.65, shipSize * 0.08, shipSize * 0.09, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Engine nozzle inner rings
            this.ctx.strokeStyle = 'rgba(156, 39, 176, 0.6)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.6, shipSize * 0.09, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.25, shipSize * 0.55, shipSize * 0.07, shipSize * 0.06, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.25, shipSize * 0.55, shipSize * 0.07, shipSize * 0.06, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.9, shipSize * 0.65, shipSize * 0.06, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.9, shipSize * 0.65, shipSize * 0.06, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Rapid-fire particles - enhanced boost effect (from all 4 engines)
            if (this.boostActive) {
                for (let i = 0; i < 20; i++) { // More particles for modular multi-engine theme
                    const particleAngle = (Math.PI * 2 * i) / 20 + time * 3.5;
                    const particleDist = shipSize * 1.3;
                    const particleX = Math.cos(particleAngle) * particleDist * 0.5;
                    const particleY = shipSize * 0.6 + Math.sin(particleAngle) * particleDist * 0.6;
                    const particleSize = 3.5 + Math.sin(time * 8 + i) * 2.5;
                    const particleAlpha = 0.9 + Math.sin(time * 6 + i) * 0.1;
                    this.ctx.fillStyle = `rgba(186, 104, 200, ${particleAlpha})`;
                    this.ctx.shadowBlur = 4;
                    this.ctx.shadowColor = 'rgba(186, 104, 200, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                    
                    // Additional smaller particles
                    if (i % 2 === 0) {
                        this.ctx.fillStyle = `rgba(156, 39, 176, ${particleAlpha * 0.7})`;
                        this.ctx.beginPath();
                        this.ctx.arc(particleX * 0.8, particleY * 1.1, particleSize * 0.7, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
                
                // Additional particles from pod engines
                for (let i = 0; i < 8; i++) {
                    const podParticleAngle = (Math.PI * 2 * i) / 8 + time * 4;
                    // Left pod particles
                    const leftPodParticleX = -shipSize * 0.9 + Math.cos(podParticleAngle) * shipSize * 0.3;
                    const leftPodParticleY = shipSize * 0.65 + Math.sin(podParticleAngle) * shipSize * 0.4;
                    const podParticleSize = 2.5 + Math.sin(time * 7 + i) * 1.5;
                    this.ctx.fillStyle = `rgba(186, 104, 200, ${0.8 + Math.sin(time * 5 + i) * 0.2})`;
                    this.ctx.beginPath();
                    this.ctx.arc(leftPodParticleX, leftPodParticleY, podParticleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Right pod particles
                    const rightPodParticleX = shipSize * 0.9 + Math.cos(podParticleAngle) * shipSize * 0.3;
                    const rightPodParticleY = shipSize * 0.65 + Math.sin(podParticleAngle) * shipSize * 0.4;
                    this.ctx.beginPath();
                    this.ctx.arc(rightPodParticleX, rightPodParticleY, podParticleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            // Heat distortion effect around engines (realistic detail)
            if (this.boostActive) {
                this.ctx.strokeStyle = `rgba(186, 104, 200, ${0.3 * flameIntensity})`;
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const distortionY = shipSize * 0.6 + i * shipSize * 0.15;
                    const distortionWidth = shipSize * (0.35 + i * 0.1) * (1 + Math.sin(time * 3 + i) * 0.1);
                    this.ctx.beginPath();
                    this.ctx.moveTo(-distortionWidth, distortionY);
                    this.ctx.quadraticCurveTo(0, distortionY + shipSize * 0.05, distortionWidth, distortionY);
                    this.ctx.stroke();
                }
            }
            
            // Rapid-fire indicator lights (fast pulsing) - modular design
            const rapidLightIntensity = 0.7 + Math.sin(time * 6) * 0.3; // Very fast pulse
            this.ctx.fillStyle = `rgba(186, 104, 200, ${rapidLightIntensity})`;
            this.ctx.shadowBlur = 6;
            this.ctx.shadowColor = 'rgba(186, 104, 200, 0.8)';
            // Top indicator (on core)
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 0.4, shipSize * 0.05, 0, Math.PI * 2);
            this.ctx.fill();
            // Canard indicators
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 0.4, -shipSize * 0.8, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 0.4, -shipSize * 0.8, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            // Wing tip indicators
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 1.0, shipSize * 0.5, shipSize * 0.045, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 1.0, shipSize * 0.5, shipSize * 0.045, 0, Math.PI * 2);
            this.ctx.fill();
            // Pod indicators (already drawn above, but add more)
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 0.8, shipSize * 0.5, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 0.8, shipSize * 0.5, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            
            // Modular component connection energy lines (visible links between components)
            this.ctx.strokeStyle = `rgba(186, 104, 200, ${0.5 * pulseIntensity})`;
            this.ctx.lineWidth = 1.5;
            this.ctx.setLineDash([3, 3]);
            // Core to canard connections
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.12, -shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 0.35, -shipSize * 0.8);
            this.ctx.moveTo(shipSize * 0.12, -shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.35, -shipSize * 0.8);
            this.ctx.stroke();
            // Core to wing connections
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.18, shipSize * 0.3);
            this.ctx.lineTo(-shipSize * 0.5, shipSize * 0.35);
            this.ctx.moveTo(shipSize * 0.18, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.5, shipSize * 0.35);
            this.ctx.stroke();
            // Wing to pod connections
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.7, shipSize * 0.45);
            this.ctx.lineTo(-shipSize * 0.65, shipSize * 0.5);
            this.ctx.moveTo(shipSize * 0.7, shipSize * 0.45);
            this.ctx.lineTo(shipSize * 0.65, shipSize * 0.5);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
            
            // Reset fill style
            this.ctx.fillStyle = shipColor;
        } else if (ship.shape === 'wide') {
            // Enhanced tank ship - heavy armored design
            // Metallic gray color scheme for defensive/armored look
            
            // Main body gradient (dark gray to lighter gray)
            const bodyGradient = this.ctx.createLinearGradient(0, -shipSize * 0.8, 0, shipSize * 0.9);
            bodyGradient.addColorStop(0, '#757575'); // Dark gray at front
            bodyGradient.addColorStop(0.3, '#9e9e9e'); // Medium gray
            bodyGradient.addColorStop(0.7, '#bdbdbd'); // Light gray
            bodyGradient.addColorStop(1, '#616161'); // Dark gray at back
            this.ctx.fillStyle = bodyGradient;
            
            // Heavy armored ship shape - wide and bulky
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 0.8); // Front center
            
            // Left side - heavily armored
            this.ctx.lineTo(-shipSize * 0.4, -shipSize * 0.6); // Front to upper left
            this.ctx.lineTo(-shipSize * 0.8, -shipSize * 0.4); // Upper left corner
            this.ctx.lineTo(-shipSize * 1.0, -shipSize * 0.1); // Left front edge
            this.ctx.lineTo(-shipSize * 1.05, shipSize * 0.2); // Left mid
            this.ctx.lineTo(-shipSize * 0.95, shipSize * 0.6); // Left rear
            this.ctx.lineTo(-shipSize * 0.7, shipSize * 0.85); // Left tail
            this.ctx.lineTo(0, shipSize * 0.9); // Rear center
            
            // Right side (mirror)
            this.ctx.lineTo(shipSize * 0.7, shipSize * 0.85);
            this.ctx.lineTo(shipSize * 0.95, shipSize * 0.6);
            this.ctx.lineTo(shipSize * 1.05, shipSize * 0.2);
            this.ctx.lineTo(shipSize * 1.0, -shipSize * 0.1);
            this.ctx.lineTo(shipSize * 0.8, -shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.4, -shipSize * 0.6);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Armor plating details - raised panels
            this.ctx.fillStyle = 'rgba(97, 97, 97, 0.8)'; // Darker gray for depth
            // Front armor plate
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 0.75);
            this.ctx.lineTo(-shipSize * 0.35, -shipSize * 0.55);
            this.ctx.lineTo(-shipSize * 0.3, -shipSize * 0.5);
            this.ctx.lineTo(0, -shipSize * 0.65);
            this.ctx.lineTo(shipSize * 0.3, -shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.35, -shipSize * 0.55);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Side armor plates
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.85, -shipSize * 0.3);
            this.ctx.lineTo(-shipSize * 0.95, -shipSize * 0.05);
            this.ctx.lineTo(-shipSize * 0.9, shipSize * 0.15);
            this.ctx.lineTo(-shipSize * 0.8, shipSize * 0.1);
            this.ctx.closePath();
            this.ctx.fill();
            
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.85, -shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.95, -shipSize * 0.05);
            this.ctx.lineTo(shipSize * 0.9, shipSize * 0.15);
            this.ctx.lineTo(shipSize * 0.8, shipSize * 0.1);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Armor panel lines
            this.ctx.strokeStyle = 'rgba(66, 66, 66, 0.8)';
            this.ctx.lineWidth = 2;
            // Horizontal lines
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.6, -shipSize * 0.2);
            this.ctx.lineTo(shipSize * 0.6, -shipSize * 0.2);
            this.ctx.moveTo(-shipSize * 0.7, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.7, shipSize * 0.3);
            this.ctx.stroke();
            
            // Vertical center line
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 0.6);
            this.ctx.lineTo(0, shipSize * 0.7);
            this.ctx.stroke();
            
            // Reinforced corners
            this.ctx.fillStyle = 'rgba(97, 97, 97, 0.9)';
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 1.0, -shipSize * 0.1, shipSize * 0.08, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 1.0, -shipSize * 0.1, shipSize * 0.08, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit - heavily armored with small viewport
            const cockpitGradient = this.ctx.createRadialGradient(0, -shipSize * 0.5, 0, 0, -shipSize * 0.5, shipSize * 0.25);
            cockpitGradient.addColorStop(0, 'rgba(200, 200, 200, 0.7)');
            cockpitGradient.addColorStop(0.6, 'rgba(150, 150, 150, 0.4)');
            cockpitGradient.addColorStop(1, 'rgba(100, 100, 100, 0.2)');
            this.ctx.fillStyle = cockpitGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.5, shipSize * 0.2, shipSize * 0.15, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit armor frame
            this.ctx.strokeStyle = 'rgba(66, 66, 66, 0.9)';
            this.ctx.lineWidth = 3;
            this.ctx.stroke();
            
            // Small viewport window
            this.ctx.fillStyle = 'rgba(150, 200, 255, 0.5)';
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.5, shipSize * 0.12, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Weapon hardpoints/ports
            this.ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.6, shipSize * 0.1, shipSize * 0.1, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.6, shipSize * 0.1, shipSize * 0.1, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Engine flames - powerful but slower (tank needs strong thrust)
            const time = Date.now() * 0.008; // Slower animation for heavy ship
            const flameIntensity = 0.75 + Math.sin(time) * 0.15; // Steady, powerful
            
            // Main engine - large and powerful
            const flameGradient = this.ctx.createLinearGradient(0, shipSize * 0.9, 0, shipSize * 1.4);
            flameGradient.addColorStop(0, `rgba(150, 200, 255, ${0.9 * flameIntensity})`); // Bright blue-white
            flameGradient.addColorStop(0.2, `rgba(100, 150, 255, ${0.85 * flameIntensity})`); // Blue
            flameGradient.addColorStop(0.4, `rgba(255, 150, 100, ${0.7 * flameIntensity})`); // Orange
            flameGradient.addColorStop(0.7, `rgba(255, 100, 50, ${0.5 * flameIntensity})`); // Red-orange
            flameGradient.addColorStop(1, `rgba(200, 50, 0, ${0.3 * flameIntensity})`); // Dark red
            
            this.ctx.fillStyle = flameGradient;
            this.ctx.beginPath();
            const flameWidth = shipSize * 0.4 * (1 + Math.sin(time * 1.5) * 0.15); // Wide, steady
            const flameLength = shipSize * 0.5 * flameIntensity;
            this.ctx.moveTo(-flameWidth, shipSize * 0.9);
            this.ctx.lineTo(0, shipSize * 0.9 + flameLength);
            this.ctx.lineTo(flameWidth, shipSize * 0.9);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Secondary engine flame (larger for heavy ship)
            const flame2Gradient = this.ctx.createLinearGradient(0, shipSize * 0.9, 0, shipSize * 1.25);
            flame2Gradient.addColorStop(0, `rgba(120, 180, 255, ${0.8 * flameIntensity})`);
            flame2Gradient.addColorStop(0.5, `rgba(255, 180, 120, ${0.6 * flameIntensity})`);
            flame2Gradient.addColorStop(1, `rgba(255, 120, 80, ${0.4 * flameIntensity})`);
            
            this.ctx.fillStyle = flame2Gradient;
            this.ctx.beginPath();
            const flame2Width = shipSize * 0.3 * (1 + Math.cos(time * 1.5) * 0.1);
            const flame2Length = shipSize * 0.35 * flameIntensity;
            this.ctx.moveTo(-flame2Width * 0.7, shipSize * 0.9);
            this.ctx.lineTo(0, shipSize * 0.9 + flame2Length);
            this.ctx.lineTo(flame2Width * 0.7, shipSize * 0.9);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Engine core - large and bright
            this.ctx.fillStyle = `rgba(150, 200, 255, ${0.85 * flameIntensity})`;
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.9, shipSize * 0.15, shipSize * 0.12, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Side thrusters (for maneuvering heavy ship)
            const sideFlameGradient = this.ctx.createLinearGradient(0, shipSize * 0.7, 0, shipSize * 0.95);
            sideFlameGradient.addColorStop(0, `rgba(100, 150, 255, ${0.6 * flameIntensity})`);
            sideFlameGradient.addColorStop(1, `rgba(255, 150, 100, ${0.3 * flameIntensity})`);
            
            this.ctx.fillStyle = sideFlameGradient;
            // Left side thruster
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.7, shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 0.65, shipSize * 0.95);
            this.ctx.lineTo(-shipSize * 0.75, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            // Right side thruster
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.7, shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.65, shipSize * 0.95);
            this.ctx.lineTo(shipSize * 0.75, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Status lights (defensive indicators)
            const lightIntensity = 0.6 + Math.sin(time * 2) * 0.4;
            this.ctx.fillStyle = `rgba(100, 200, 100, ${lightIntensity})`;
            // Front status lights
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 0.5, -shipSize * 0.4, shipSize * 0.05, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 0.5, -shipSize * 0.4, shipSize * 0.05, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Armor status indicator (red when taking damage, but we'll make it steady for now)
            this.ctx.fillStyle = `rgba(200, 100, 100, ${0.7})`;
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 0.3, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Reset fill style
            this.ctx.fillStyle = shipColor;
        } else if (this.currentShip === 'completeDescriptionVessel') {
            // Enhanced Complete Description Vessel - ultimate tier ship
            // Purple/violet color scheme for ultimate power
            
            // Main body gradient (bright purple to deep violet)
            const bodyGradient = this.ctx.createLinearGradient(0, -shipSize * 1.2, 0, shipSize * 0.95);
            bodyGradient.addColorStop(0, '#8b00ff'); // Bright purple at front
            bodyGradient.addColorStop(0.2, '#9c27b0'); // Medium purple
            bodyGradient.addColorStop(0.5, '#7b1fa2'); // Deep purple
            bodyGradient.addColorStop(0.8, '#6a1b9a'); // Dark purple
            bodyGradient.addColorStop(1, '#4a148c'); // Deep violet at back
            this.ctx.fillStyle = bodyGradient;
            
            // Ultimate ship shape - perfect balance, advanced design
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.2); // Sharp front point
            
            // Left side - perfect symmetry
            this.ctx.lineTo(-shipSize * 0.32, -shipSize * 0.7); // Front to upper left
            this.ctx.lineTo(-shipSize * 0.6, -shipSize * 0.3); // Upper left wing
            this.ctx.lineTo(-shipSize * 0.8, shipSize * 0.2); // Left mid wing
            this.ctx.lineTo(-shipSize * 0.7, shipSize * 0.65); // Left rear wing
            this.ctx.lineTo(-shipSize * 0.4, shipSize * 0.85); // Left tail
            this.ctx.lineTo(0, shipSize * 0.95); // Rear center
            
            // Right side (perfect mirror)
            this.ctx.lineTo(shipSize * 0.4, shipSize * 0.85);
            this.ctx.lineTo(shipSize * 0.7, shipSize * 0.65);
            this.ctx.lineTo(shipSize * 0.8, shipSize * 0.2);
            this.ctx.lineTo(shipSize * 0.6, -shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.32, -shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Advanced wing details - energy channels
            this.ctx.strokeStyle = 'rgba(156, 39, 176, 0.7)';
            this.ctx.lineWidth = 2;
            // Leading edge energy lines
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.1);
            this.ctx.lineTo(-shipSize * 0.6, -shipSize * 0.3);
            this.ctx.moveTo(0, -shipSize * 1.1);
            this.ctx.lineTo(shipSize * 0.6, -shipSize * 0.3);
            this.ctx.stroke();
            
            // Wing energy channels
            this.ctx.strokeStyle = 'rgba(186, 104, 200, 0.6)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.5, shipSize * 0.1);
            this.ctx.lineTo(-shipSize * 0.7, shipSize * 0.6);
            this.ctx.moveTo(shipSize * 0.5, shipSize * 0.1);
            this.ctx.lineTo(shipSize * 0.7, shipSize * 0.6);
            this.ctx.stroke();
            
            // Central core - complete description matrix
            const coreGradient = this.ctx.createRadialGradient(0, -shipSize * 0.5, 0, 0, -shipSize * 0.5, shipSize * 0.3);
            coreGradient.addColorStop(0, 'rgba(186, 104, 200, 0.9)');
            coreGradient.addColorStop(0.5, 'rgba(156, 39, 176, 0.7)');
            coreGradient.addColorStop(1, 'rgba(123, 31, 162, 0.4)');
            this.ctx.fillStyle = coreGradient;
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.0);
            this.ctx.lineTo(-shipSize * 0.22, -shipSize * 0.5);
            this.ctx.lineTo(0, shipSize * 0.4);
            this.ctx.lineTo(shipSize * 0.22, -shipSize * 0.5);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Advanced cockpit - complete information display
            const cockpitGradient = this.ctx.createRadialGradient(0, -shipSize * 0.75, 0, 0, -shipSize * 0.75, shipSize * 0.24);
            cockpitGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
            cockpitGradient.addColorStop(0.3, 'rgba(200, 150, 255, 0.8)');
            cockpitGradient.addColorStop(0.6, 'rgba(156, 39, 176, 0.6)');
            cockpitGradient.addColorStop(1, 'rgba(123, 31, 162, 0.3)');
            this.ctx.fillStyle = cockpitGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.75, shipSize * 0.18, shipSize * 0.22, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit frame - ultimate materials
            this.ctx.strokeStyle = 'rgba(186, 104, 200, 0.95)';
            this.ctx.lineWidth = 2.5;
            this.ctx.stroke();
            
            // Inner cockpit display (complete information matrix)
            this.ctx.fillStyle = 'rgba(200, 150, 255, 0.7)';
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.75, shipSize * 0.12, shipSize * 0.14, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Front sensor - complete description scanner
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 1.2, shipSize * 0.07, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Energy conduits (side)
            this.ctx.fillStyle = 'rgba(186, 104, 200, 0.7)';
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.5, -shipSize * 0.2, shipSize * 0.08, shipSize * 0.14, -0.2, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.5, -shipSize * 0.2, shipSize * 0.08, shipSize * 0.14, 0.2, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Engine flames - ultimate power (quad exhaust system)
            const time = Date.now() * 0.009;
            const flameIntensity = 0.85 + Math.sin(time) * 0.1; // Powerful and stable
            
            // Left outer exhaust
            const flameGradient1 = this.ctx.createLinearGradient(-shipSize * 0.25, shipSize * 0.95, -shipSize * 0.25, shipSize * 1.5);
            flameGradient1.addColorStop(0, `rgba(186, 104, 200, ${0.95 * flameIntensity})`);
            flameGradient1.addColorStop(0.2, `rgba(156, 39, 176, ${0.9 * flameIntensity})`);
            flameGradient1.addColorStop(0.5, `rgba(255, 100, 255, ${0.75 * flameIntensity})`);
            flameGradient1.addColorStop(0.8, `rgba(255, 50, 200, ${0.6 * flameIntensity})`);
            flameGradient1.addColorStop(1, `rgba(200, 0, 150, ${0.4 * flameIntensity})`);
            
            this.ctx.fillStyle = flameGradient1;
            this.ctx.beginPath();
            const flame1Width = shipSize * 0.16 * (1 + Math.sin(time * 2) * 0.15);
            const flame1Length = shipSize * 0.55 * flameIntensity;
            this.ctx.moveTo(-shipSize * 0.3, shipSize * 0.95);
            this.ctx.lineTo(-shipSize * 0.25, shipSize * 0.95 + flame1Length);
            this.ctx.lineTo(-shipSize * 0.2, shipSize * 0.95);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Left inner exhaust
            const flameGradient2 = this.ctx.createLinearGradient(-shipSize * 0.1, shipSize * 0.95, -shipSize * 0.1, shipSize * 1.6);
            flameGradient2.addColorStop(0, `rgba(200, 150, 255, ${0.98 * flameIntensity})`);
            flameGradient2.addColorStop(0.2, `rgba(186, 104, 200, ${0.93 * flameIntensity})`);
            flameGradient2.addColorStop(0.5, `rgba(255, 120, 255, ${0.8 * flameIntensity})`);
            flameGradient2.addColorStop(0.8, `rgba(255, 70, 220, ${0.65 * flameIntensity})`);
            flameGradient2.addColorStop(1, `rgba(220, 20, 180, ${0.45 * flameIntensity})`);
            
            this.ctx.fillStyle = flameGradient2;
            this.ctx.beginPath();
            const flame2Width = shipSize * 0.18 * (1 + Math.cos(time * 2) * 0.15);
            const flame2Length = shipSize * 0.65 * flameIntensity;
            this.ctx.moveTo(-shipSize * 0.15, shipSize * 0.95);
            this.ctx.lineTo(-shipSize * 0.1, shipSize * 0.95 + flame2Length);
            this.ctx.lineTo(-shipSize * 0.05, shipSize * 0.95);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right inner exhaust
            this.ctx.fillStyle = flameGradient2;
            this.ctx.beginPath();
            const flame3Width = shipSize * 0.18 * (1 + Math.cos(time * 2 + 1) * 0.15);
            const flame3Length = shipSize * 0.65 * flameIntensity;
            this.ctx.moveTo(shipSize * 0.05, shipSize * 0.95);
            this.ctx.lineTo(shipSize * 0.1, shipSize * 0.95 + flame3Length);
            this.ctx.lineTo(shipSize * 0.15, shipSize * 0.95);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Right outer exhaust
            this.ctx.fillStyle = flameGradient1;
            this.ctx.beginPath();
            const flame4Width = shipSize * 0.16 * (1 + Math.sin(time * 2 + 1) * 0.15);
            const flame4Length = shipSize * 0.55 * flameIntensity;
            this.ctx.moveTo(shipSize * 0.2, shipSize * 0.95);
            this.ctx.lineTo(shipSize * 0.25, shipSize * 0.95 + flame4Length);
            this.ctx.lineTo(shipSize * 0.3, shipSize * 0.95);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Engine cores - bright purple
            this.ctx.fillStyle = `rgba(186, 104, 200, ${0.98 * flameIntensity})`;
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.25, shipSize * 0.95, shipSize * 0.07, shipSize * 0.06, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.1, shipSize * 0.95, shipSize * 0.08, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.1, shipSize * 0.95, shipSize * 0.08, shipSize * 0.07, 0, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.25, shipSize * 0.95, shipSize * 0.07, shipSize * 0.06, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Complete description indicators (pulsing purple/violet)
            const lightIntensity = 0.8 + Math.sin(time * 3) * 0.2;
            this.ctx.fillStyle = `rgba(186, 104, 200, ${lightIntensity})`;
            // Top indicator
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 0.5, shipSize * 0.05, 0, Math.PI * 2);
            this.ctx.fill();
            // Side indicators
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 0.4, shipSize * 0.3, shipSize * 0.045, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 0.4, shipSize * 0.3, shipSize * 0.045, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Ultimate status light (center)
            this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * lightIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 0.3, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Reset fill style
            this.ctx.fillStyle = shipColor;
        } else if (ship.shape === 'diamond') {
            // Enhanced agile ship - sleek, maneuverable design
            // Cyan/teal color scheme for agility
            
            // Main body gradient (bright cyan to teal)
            const bodyGradient = this.ctx.createLinearGradient(0, -shipSize * 1.1, 0, shipSize * 0.9);
            bodyGradient.addColorStop(0, '#00bcd4'); // Bright cyan at front
            bodyGradient.addColorStop(0.3, '#00acc1'); // Medium cyan
            bodyGradient.addColorStop(0.6, '#0097a7'); // Teal
            bodyGradient.addColorStop(1, '#00838f'); // Dark teal at back
            this.ctx.fillStyle = bodyGradient;
            
            // Agile ship shape - compact, aerodynamic diamond with swept wings
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.1); // Sharp front point
            
            // Left side - swept back design
            this.ctx.lineTo(-shipSize * 0.35, -shipSize * 0.5); // Front to upper left
            this.ctx.lineTo(-shipSize * 0.7, -shipSize * 0.1); // Upper left wing
            this.ctx.lineTo(-shipSize * 0.85, shipSize * 0.3); // Left mid wing
            this.ctx.lineTo(-shipSize * 0.6, shipSize * 0.7); // Left rear wing
            this.ctx.lineTo(0, shipSize * 0.9); // Rear center
            
            // Right side (mirror)
            this.ctx.lineTo(shipSize * 0.6, shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.85, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.7, -shipSize * 0.1);
            this.ctx.lineTo(shipSize * 0.35, -shipSize * 0.5);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Swept wing details - aerodynamic edges
            this.ctx.strokeStyle = 'rgba(0, 188, 212, 0.6)';
            this.ctx.lineWidth = 1.5;
            // Leading edge highlights
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 1.0);
            this.ctx.lineTo(-shipSize * 0.7, -shipSize * 0.1);
            this.ctx.moveTo(0, -shipSize * 1.0);
            this.ctx.lineTo(shipSize * 0.7, -shipSize * 0.1);
            this.ctx.stroke();
            
            // Wing panel lines
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.5, shipSize * 0.1);
            this.ctx.lineTo(-shipSize * 0.7, shipSize * 0.5);
            this.ctx.moveTo(shipSize * 0.5, shipSize * 0.1);
            this.ctx.lineTo(shipSize * 0.7, shipSize * 0.5);
            this.ctx.stroke();
            
            // Central body accent
            this.ctx.fillStyle = 'rgba(0, 172, 193, 0.7)';
            this.ctx.beginPath();
            this.ctx.moveTo(0, -shipSize * 0.8);
            this.ctx.lineTo(-shipSize * 0.25, -shipSize * 0.3);
            this.ctx.lineTo(0, shipSize * 0.2);
            this.ctx.lineTo(shipSize * 0.25, -shipSize * 0.3);
            this.ctx.closePath();
        this.ctx.fill();
        
            // Cockpit - streamlined teardrop
            const cockpitGradient = this.ctx.createRadialGradient(0, -shipSize * 0.7, 0, 0, -shipSize * 0.7, shipSize * 0.2);
            cockpitGradient.addColorStop(0, 'rgba(200, 255, 255, 0.9)');
            cockpitGradient.addColorStop(0.5, 'rgba(100, 255, 255, 0.6)');
            cockpitGradient.addColorStop(1, 'rgba(0, 188, 212, 0.3)');
            this.ctx.fillStyle = cockpitGradient;
            this.ctx.beginPath();
            this.ctx.ellipse(0, -shipSize * 0.7, shipSize * 0.14, shipSize * 0.18, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Cockpit frame
            this.ctx.strokeStyle = 'rgba(0, 188, 212, 0.9)';
            this.ctx.lineWidth = 1.5;
            this.ctx.stroke();
            
            // Front sensor/antenna
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 1.1, shipSize * 0.05, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Maneuvering thrusters (small, precise)
            this.ctx.fillStyle = 'rgba(0, 150, 200, 0.6)';
            // Front left thruster
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.5, -shipSize * 0.3, shipSize * 0.05, shipSize * 0.08, -0.5, 0, Math.PI * 2);
            this.ctx.fill();
            // Front right thruster
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.5, -shipSize * 0.3, shipSize * 0.05, shipSize * 0.08, 0.5, 0, Math.PI * 2);
            this.ctx.fill();
            // Rear left thruster
            this.ctx.beginPath();
            this.ctx.ellipse(-shipSize * 0.65, shipSize * 0.5, shipSize * 0.06, shipSize * 0.1, 0.3, 0, Math.PI * 2);
            this.ctx.fill();
            // Rear right thruster
            this.ctx.beginPath();
            this.ctx.ellipse(shipSize * 0.65, shipSize * 0.5, shipSize * 0.06, shipSize * 0.1, -0.3, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Engine flames - quick, responsive (agile maneuvering)
            const time = Date.now() * 0.012; // Medium-fast animation
            const flameIntensity = 0.7 + Math.sin(time) * 0.2; // Responsive pulsing
            
            // Main engine - compact but powerful
            const flameGradient = this.ctx.createLinearGradient(0, shipSize * 0.9, 0, shipSize * 1.3);
            flameGradient.addColorStop(0, `rgba(0, 255, 255, ${0.9 * flameIntensity})`); // Bright cyan
            flameGradient.addColorStop(0.3, `rgba(0, 200, 255, ${0.8 * flameIntensity})`); // Cyan-blue
            flameGradient.addColorStop(0.6, `rgba(100, 200, 255, ${0.6 * flameIntensity})`); // Light blue
            flameGradient.addColorStop(1, `rgba(150, 150, 255, ${0.3 * flameIntensity})`); // Purple-blue
            
            this.ctx.fillStyle = flameGradient;
            this.ctx.beginPath();
            const flameWidth = shipSize * 0.3 * (1 + Math.sin(time * 2) * 0.2); // Responsive width
            const flameLength = shipSize * 0.4 * flameIntensity;
            this.ctx.moveTo(-flameWidth, shipSize * 0.9);
            this.ctx.lineTo(0, shipSize * 0.9 + flameLength);
            this.ctx.lineTo(flameWidth, shipSize * 0.9);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Secondary flame - inner core
            const flame2Gradient = this.ctx.createLinearGradient(0, shipSize * 0.9, 0, shipSize * 1.15);
            flame2Gradient.addColorStop(0, `rgba(0, 255, 255, ${0.85 * flameIntensity})`);
            flame2Gradient.addColorStop(0.5, `rgba(100, 255, 255, ${0.7 * flameIntensity})`);
            flame2Gradient.addColorStop(1, `rgba(150, 200, 255, ${0.4 * flameIntensity})`);
            
            this.ctx.fillStyle = flame2Gradient;
            this.ctx.beginPath();
            const flame2Width = shipSize * 0.2 * (1 + Math.cos(time * 2) * 0.15);
            const flame2Length = shipSize * 0.25 * flameIntensity;
            this.ctx.moveTo(-flame2Width * 0.7, shipSize * 0.9);
            this.ctx.lineTo(0, shipSize * 0.9 + flame2Length);
            this.ctx.lineTo(flame2Width * 0.7, shipSize * 0.9);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Engine core - bright cyan
            this.ctx.fillStyle = `rgba(0, 255, 255, ${0.9 * flameIntensity})`;
            this.ctx.beginPath();
            this.ctx.ellipse(0, shipSize * 0.9, shipSize * 0.1, shipSize * 0.08, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Wing tip engines (for quick direction changes)
            const wingFlameGradient = this.ctx.createLinearGradient(0, shipSize * 0.7, 0, shipSize * 0.95);
            wingFlameGradient.addColorStop(0, `rgba(0, 200, 255, ${0.7 * flameIntensity})`);
            wingFlameGradient.addColorStop(1, `rgba(100, 200, 255, ${0.4 * flameIntensity})`);
            
            this.ctx.fillStyle = wingFlameGradient;
            // Left wing tip
            this.ctx.beginPath();
            this.ctx.moveTo(-shipSize * 0.6, shipSize * 0.7);
            this.ctx.lineTo(-shipSize * 0.58, shipSize * 0.95);
            this.ctx.lineTo(-shipSize * 0.62, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            // Right wing tip
            this.ctx.beginPath();
            this.ctx.moveTo(shipSize * 0.6, shipSize * 0.7);
            this.ctx.lineTo(shipSize * 0.58, shipSize * 0.95);
            this.ctx.lineTo(shipSize * 0.62, shipSize * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Evasion indicator lights (pulsing cyan)
            const lightIntensity = 0.6 + Math.sin(time * 3) * 0.4;
            this.ctx.fillStyle = `rgba(0, 255, 255, ${lightIntensity})`;
            // Top indicator
            this.ctx.beginPath();
            this.ctx.arc(0, -shipSize * 0.5, shipSize * 0.04, 0, Math.PI * 2);
            this.ctx.fill();
            // Side indicators
            this.ctx.beginPath();
            this.ctx.arc(-shipSize * 0.4, shipSize * 0.1, shipSize * 0.035, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(shipSize * 0.4, shipSize * 0.1, shipSize * 0.035, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Reset fill style
            this.ctx.fillStyle = shipColor;
        }
        
        // Apply glow effect before filling (for non-triangle shapes)
        if (ship.shape !== 'triangle' && ship.shape) {
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = shipColor;
        }
        
        this.ctx.fill();
        
        // Reset shadow for other operations
        if (ship.shape !== 'triangle' && ship.shape) {
        this.ctx.shadowBlur = 0;
        }
        
        // Draw boss hit visual effect (red/orange flash when touching boss)
        if (this.player.bossHitEffect > 0 && this.player.bossHitIntensity > 0) {
            const intensity = this.player.bossHitIntensity;
            const effectSize = shipSize * (1.2 + intensity * 0.3); // Slightly larger than ship
            
            // Outer glow - red warning effect
            const outerGlow = this.ctx.createRadialGradient(0, 0, shipSize * 0.5, 0, 0, effectSize);
            outerGlow.addColorStop(0, `rgba(255, 100, 100, ${0.8 * intensity})`);
            outerGlow.addColorStop(0.5, `rgba(255, 150, 50, ${0.5 * intensity})`);
            outerGlow.addColorStop(1, `rgba(255, 200, 100, ${0.2 * intensity})`);
            
            this.ctx.fillStyle = outerGlow;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, effectSize, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Inner flash - bright white/red core
            const innerFlash = this.ctx.createRadialGradient(0, 0, 0, 0, 0, shipSize * 0.8);
            innerFlash.addColorStop(0, `rgba(255, 255, 255, ${0.9 * intensity})`);
            innerFlash.addColorStop(0.3, `rgba(255, 200, 150, ${0.7 * intensity})`);
            innerFlash.addColorStop(0.7, `rgba(255, 100, 50, ${0.4 * intensity})`);
            innerFlash.addColorStop(1, `rgba(255, 50, 0, ${0.1 * intensity})`);
            
            this.ctx.fillStyle = innerFlash;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, shipSize * 0.8, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Pulsing border - warning indicator
            const pulseTime = Date.now() * 0.02;
            const pulseIntensity = (Math.sin(pulseTime) + 1) / 2; // 0 to 1
            this.ctx.strokeStyle = `rgba(255, 100, 50, ${0.8 * intensity * pulseIntensity})`;
            this.ctx.lineWidth = 3 + pulseIntensity * 2;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, effectSize * 0.9, 0, Math.PI * 2);
            this.ctx.stroke();
        }
        
        // Restore context before drawing bonus indicators (they need world coordinates)
        this.ctx.restore();
        
        // Draw ship bonus indicator (in world coordinates)
        if (ship.bonus === 'speedBoost') {
            // Speed lines for fast ship - need to calculate position based on rotation
            this.ctx.strokeStyle = `rgba(255, 152, 0, 0.5)`;
            this.ctx.lineWidth = 2;
            const backX = this.player.x - Math.cos(this.player.angle - Math.PI / 2) * shipSize * 1.5;
            const backY = this.player.y - Math.sin(this.player.angle - Math.PI / 2) * shipSize * 1.5;
            for (let i = 0; i < 3; i++) {
                const offsetX = -Math.cos(this.player.angle - Math.PI / 2) * i * 5;
                const offsetY = -Math.sin(this.player.angle - Math.PI / 2) * i * 5;
                this.ctx.beginPath();
                this.ctx.moveTo(backX + offsetX, backY + offsetY);
                this.ctx.lineTo(backX + offsetX - Math.cos(this.player.angle - Math.PI / 2) * shipSize * 0.3, 
                               backY + offsetY - Math.sin(this.player.angle - Math.PI / 2) * shipSize * 0.3);
                this.ctx.stroke();
            }
        } else if (ship.bonus === 'damageResist') {
            // Enhanced armor plate effect for tank - glowing defensive aura
            this.ctx.save();
            this.ctx.translate(this.player.x, this.player.y);
            this.ctx.rotate(this.player.angle);
            
            // Pulsing defensive shield effect
            const shieldPulse = 0.3 + Math.sin(Date.now() * 0.005) * 0.2;
            this.ctx.strokeStyle = `rgba(158, 158, 158, ${shieldPulse})`;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([5, 5]);
            
            // Draw defensive grid pattern
            this.ctx.beginPath();
            // Horizontal lines
            this.ctx.moveTo(-shipSize * 0.8, -shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.8, -shipSize * 0.3);
            this.ctx.moveTo(-shipSize * 0.8, shipSize * 0.3);
            this.ctx.lineTo(shipSize * 0.8, shipSize * 0.3);
            // Vertical lines
            this.ctx.moveTo(-shipSize * 0.6, -shipSize * 0.5);
            this.ctx.lineTo(-shipSize * 0.6, shipSize * 0.5);
            this.ctx.moveTo(shipSize * 0.6, -shipSize * 0.5);
            this.ctx.lineTo(shipSize * 0.6, shipSize * 0.5);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
            
            this.ctx.restore();
        } else if (ship.bonus === 'rapidFire') {
            // Enhanced rapid-fire effect - pulsing energy particles and rapid-fire indicators
            const time = Date.now() * 0.02; // Faster animation for rapid theme
            this.ctx.save();
            this.ctx.translate(this.player.x, this.player.y);
            this.ctx.rotate(this.player.angle);
            
            // Pulsing rapid-fire energy aura
            const rapidPulse = 0.4 + Math.sin(time * 5) * 0.3; // Fast pulse
            this.ctx.strokeStyle = `rgba(255, 200, 0, ${rapidPulse})`;
            this.ctx.lineWidth = 2;
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = 'rgba(255, 200, 0, 0.6)';
            this.ctx.setLineDash([4, 4]);
            
            // Rapid-fire energy rings (pulsing outward)
            for (let ring = 1; ring <= 2; ring++) {
                const ringRadius = shipSize * (0.6 + ring * 0.2) * (1 + Math.sin(time * 4 + ring) * 0.1);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }
            this.ctx.setLineDash([]);
            this.ctx.shadowBlur = 0;
            
            // Rapid-fire particles (orbiting around ship)
            for (let i = 0; i < 8; i++) {
                const particleAngle = (Math.PI * 2 * i) / 8 + time * 3; // Fast rotation
                const particleDist = shipSize * 0.8;
                const particleX = Math.cos(particleAngle) * particleDist;
                const particleY = Math.sin(particleAngle) * particleDist;
                const particleSize = 2 + Math.sin(time * 6 + i) * 1.5;
                const particleAlpha = 0.7 + Math.sin(time * 4 + i) * 0.3;
                
                this.ctx.fillStyle = `rgba(255, 200, 0, ${particleAlpha})`;
                this.ctx.shadowBlur = 4;
                this.ctx.shadowColor = 'rgba(255, 200, 0, 0.8)';
                this.ctx.beginPath();
                this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Rapid-fire energy lines (radiating from center)
            this.ctx.strokeStyle = `rgba(255, 150, 50, ${rapidPulse * 0.6})`;
            this.ctx.lineWidth = 1.5;
            for (let i = 0; i < 6; i++) {
                const lineAngle = (Math.PI * 2 * i) / 6 + time * 2;
                const lineLength = shipSize * 0.7;
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(Math.cos(lineAngle) * lineLength, Math.sin(lineAngle) * lineLength);
                this.ctx.stroke();
            }
            
            this.ctx.restore();
        } else if (ship.bonus === 'evasion') {
            // Enhanced evasion effect for agile ship - trailing motion lines
            const time = Date.now() * 0.01;
            this.ctx.strokeStyle = `rgba(0, 188, 212, 0.4)`;
            this.ctx.lineWidth = 1.5;
            this.ctx.setLineDash([3, 3]);
            
            // Draw motion trails around ship (evasion aura)
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6 + time;
                const dist = shipSize * 1.2;
                const trailLength = shipSize * 0.3;
                const startX = this.player.x + Math.cos(angle) * dist;
                const startY = this.player.y + Math.sin(angle) * dist;
                const endX = startX + Math.cos(angle + Math.PI) * trailLength;
                const endY = startY + Math.sin(angle + Math.PI) * trailLength;
                
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
            }
            this.ctx.setLineDash([]);
            
            // Pulsing evasion particles
            const pulseIntensity = 0.5 + Math.sin(time * 2) * 0.5;
            this.ctx.fillStyle = `rgba(0, 255, 255, ${pulseIntensity * 0.6})`;
            for (let i = 0; i < 4; i++) {
                const angle = (Math.PI * 2 * i) / 4 + time * 1.5;
                const dist = shipSize * 1.4;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + Math.cos(angle) * dist, this.player.y + Math.sin(angle) * dist, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
        } else if (ship.bonus === 'stabilized') {
            // Stabilization effect for Individual Stabilizer - energy field
            const time = Date.now() * 0.008;
            const pulseIntensity = 0.4 + Math.sin(time) * 0.3;
            
            // Stabilization field - pulsing energy rings
            this.ctx.strokeStyle = `rgba(255, 140, 66, ${pulseIntensity})`;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([4, 4]);
            
            // Draw concentric stabilization rings
            for (let i = 1; i <= 2; i++) {
                const radius = shipSize * (0.8 + i * 0.2);
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, radius, 0, Math.PI * 2);
                this.ctx.stroke();
            }
            this.ctx.setLineDash([]);
            
            // Stabilization particles - orbiting energy
            this.ctx.fillStyle = `rgba(255, 200, 100, ${0.7 * pulseIntensity})`;
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6 + time;
                const dist = shipSize * 1.1;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + Math.cos(angle) * dist, this.player.y + Math.sin(angle) * dist, 2.5, 0, Math.PI * 2);
                this.ctx.fill();
            }
        } else if (ship.bonus === 'complete') {
            // Complete Description effect - ultimate energy field
            const time = Date.now() * 0.007;
            const pulseIntensity = 0.5 + Math.sin(time) * 0.3;
            
            // Complete description matrix - multiple energy rings
            this.ctx.strokeStyle = `rgba(186, 104, 200, ${pulseIntensity})`;
            this.ctx.lineWidth = 2.5;
            this.ctx.setLineDash([6, 3]);
            
            // Draw multiple concentric rings (complete information layers)
            for (let i = 1; i <= 3; i++) {
                const radius = shipSize * (0.9 + i * 0.15);
                const alpha = pulseIntensity * (1 - i * 0.2);
                this.ctx.strokeStyle = `rgba(186, 104, 200, ${alpha})`;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, radius, 0, Math.PI * 2);
                this.ctx.stroke();
            }
            this.ctx.setLineDash([]);
            
            // Complete description particles - orbiting information
            this.ctx.fillStyle = `rgba(200, 150, 255, ${0.8 * pulseIntensity})`;
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8 + time;
                const dist = shipSize * 1.2;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x + Math.cos(angle) * dist, this.player.y + Math.sin(angle) * dist, 3, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Central complete description core - pulsing energy
            const coreGradient = this.ctx.createRadialGradient(this.player.x, this.player.y, 0, this.player.x, this.player.y, shipSize * 0.8);
            coreGradient.addColorStop(0, `rgba(186, 104, 200, ${0.6 * pulseIntensity})`);
            coreGradient.addColorStop(0.5, `rgba(156, 39, 176, ${0.4 * pulseIntensity})`);
            coreGradient.addColorStop(1, `rgba(123, 31, 162, ${0.2 * pulseIntensity})`);
            this.ctx.fillStyle = coreGradient;
            this.ctx.beginPath();
            this.ctx.arc(this.player.x, this.player.y, shipSize * 0.8, 0, Math.PI * 2);
            this.ctx.fill();
        }
    }

    // Check if player ship is under a UI element
    isPlayerUnderUI(uiX, uiY, uiWidth, uiHeight) {
        // Safety check: ensure player exists and is initialized
        if (!this.player || this.player.x === undefined || this.player.y === undefined) {
            return false; // Player not initialized yet, no overlap
        }
        
        try {
            const playerRadius = this.getPlayerCollisionRadius(this.player);
            const playerX = this.player.x;
            const playerY = this.player.y;
            
            // Check if player's collision circle overlaps with UI rectangle
            // Find closest point on rectangle to player center
            const closestX = Math.max(uiX, Math.min(playerX, uiX + uiWidth));
            const closestY = Math.max(uiY, Math.min(playerY, uiY + uiHeight));
            
            // Calculate distance from player center to closest point on rectangle
            const dx = playerX - closestX;
            const dy = playerY - closestY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // If distance is less than player radius, player is overlapping
            return distance < playerRadius;
        } catch (error) {
            // If any error occurs (e.g., getPlayerCollisionRadius fails), return false
            console.warn('[UI] Error checking player position:', error);
            return false;
        }
    }
    
    drawHUD() {
        // Enhanced HUD - positioned at bottom right corner (compact)
        const barWidth = 200;
        const barHeight = 20;
        const padding = 10;
        const spacing = 5;
        const x = this.canvas.width - barWidth - padding; // Right side
        let y = this.canvas.height - padding; // Start from bottom
        
        // Calculate fire rate first to determine if recharge bar will be shown
        let combinedFireRate = 0;
        const regularWeapons = this._cachedRegularWeapons.length > 0 ? this._cachedRegularWeapons : 
            this.currentWeapons.filter(name => {
                const weapon = this.equipmentStats.weapons[name];
                return weapon && !weapon.isLaser;
            });
        
        if (regularWeapons.length > 0) {
            regularWeapons.forEach(weaponName => {
                const weapon = this.equipmentStats.weapons[weaponName];
                if (!weapon) return;
                
                let weaponFireRate = weapon.fireRate || 0.5;
                
                // Apply weapon-specific upgrades
                const upgradeLevel = this.weaponUpgrades[weaponName] || 0;
                if (weaponName === 'rapid') {
                    const rapidBonuses = [0, 0.9, 1.2, 1.5, 1.8];
                    let totalBonus = 0;
                    for (let i = 1; i <= upgradeLevel && i <= 4; i++) {
                        totalBonus += rapidBonuses[i];
                    }
                    weaponFireRate += totalBonus;
                }
                
                if (weaponFireRate > combinedFireRate) {
                    combinedFireRate = weaponFireRate;
                }
            });
        } else {
            combinedFireRate = 0.5;
        }
        
        combinedFireRate += (this.playerStats.fireRate - this.playerStats.baseFireRate);
        const cooldown = 1000 / combinedFireRate;
        const showRechargeBar = cooldown > 0.2;
        
        // Calculate panel height dynamically based on actual content
        // Level/Token line (22px) + Health bar (20px) + spacing (5px) + Shield bar (20px) + spacing (5px) + Recharge bar (20px if shown) + Survival meters (if unlocked)
        let dynamicHeight = 22 + 20 + spacing + 20; // Base: Level/Token + Health + spacing + Shield
        if (showRechargeBar) {
            dynamicHeight += spacing + 20; // Add spacing + Recharge bar if shown
        }
        // Add survival meters if unlocked (Hunger + Boost = 2 bars + 2 spacing)
        if (this.survivalUnlocked) {
            dynamicHeight += spacing + 20 + spacing + 20; // Hunger bar + spacing + Boost bar
        }
        dynamicHeight += padding * 2; // Add padding top and bottom
        
        const panelHeight = dynamicHeight;
        const panelY = y - panelHeight;
        
        // Check if player is under this UI panel
        const playerUnderUI = this.isPlayerUnderUI(x - 3, panelY - 3, barWidth + 6, panelHeight + 6);
        const uiAlpha = playerUnderUI ? 0.2 : 0.95; // Make very transparent when player is under
        
        // Enhanced panel background
        const panelGradient = this.ctx.createLinearGradient(x, panelY, x, y);
        panelGradient.addColorStop(0, `rgba(10, 10, 30, ${uiAlpha})`);
        panelGradient.addColorStop(1, `rgba(26, 26, 46, ${uiAlpha})`);
        this.ctx.fillStyle = panelGradient;
        this.ctx.shadowBlur = playerUnderUI ? 0 : 15; // Disable shadow when transparent
        this.ctx.shadowColor = 'rgba(79, 195, 247, 0.5)';
        this.ctx.fillRect(x - 3, panelY - 3, barWidth + 6, panelHeight + 6);
        this.ctx.shadowBlur = 0;
        
        // Panel border (also make transparent)
        this.ctx.strokeStyle = `rgba(79, 195, 247, ${uiAlpha})`;
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(x - 3, panelY - 3, barWidth + 6, panelHeight + 6);
        
        // Level and Tokens (at top of panel, compact)
        y = panelY + 18;
        this.ctx.fillStyle = `rgba(79, 195, 247, ${uiAlpha})`;
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'left';
        this.ctx.shadowBlur = playerUnderUI ? 0 : 8;
        this.ctx.shadowColor = 'rgba(79, 195, 247, 0.8)';
        this.ctx.fillText(`Lv${this.level}`, x, y);
        this.ctx.shadowBlur = 0;
        
        this.ctx.fillStyle = `rgba(255, 193, 7, ${uiAlpha})`;
        this.ctx.font = 'bold 13px Arial';
        this.ctx.shadowBlur = playerUnderUI ? 0 : 8;
        this.ctx.shadowColor = 'rgba(255, 193, 7, 0.8)';
        this.ctx.fillText(`T: ${this.inventory.tokens}`, x + 50, y);
        this.ctx.shadowBlur = 0;
        
        y += 22;
        
        // Enhanced Health bar (compact)
        const healthPercent = Math.max(0, Math.min(1, this.playerStats.health / this.playerStats.maxHealth));
        
        // Health bar background with glow
        this.ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * uiAlpha})`;
        this.ctx.shadowBlur = playerUnderUI ? 0 : 10;
        this.ctx.shadowColor = 'rgba(244, 67, 54, 0.5)';
            this.ctx.fillRect(x, y, barWidth, barHeight);
        this.ctx.shadowBlur = 0;
        
        // Health bar fill with gradient
        if (healthPercent > 0) {
            const healthGradient = this.ctx.createLinearGradient(x + 2, y + 2, x + 2 + (healthPercent * (barWidth - 4)), y + 2);
            healthGradient.addColorStop(0, `rgba(244, 67, 54, ${uiAlpha})`);
            healthGradient.addColorStop(0.5, `rgba(229, 57, 53, ${uiAlpha})`);
            healthGradient.addColorStop(1, `rgba(198, 40, 40, ${uiAlpha})`);
            this.ctx.fillStyle = healthGradient;
            this.ctx.shadowBlur = playerUnderUI ? 0 : 8;
            this.ctx.shadowColor = 'rgba(244, 67, 54, 0.8)';
            this.ctx.fillRect(x + 2, y + 2, (healthPercent * (barWidth - 4)), barHeight - 4);
            this.ctx.shadowBlur = 0;
        }
        
        // Health text with glow (compact)
        this.ctx.fillStyle = `rgba(255, 255, 255, ${uiAlpha})`;
        this.ctx.font = 'bold 12px Arial';
        this.ctx.textAlign = 'left';
        this.ctx.shadowBlur = playerUnderUI ? 0 : 4;
        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
        this.ctx.fillText(`HP: ${Math.ceil(this.playerStats.health)}/${this.playerStats.maxHealth}`, x + 5, y + 15);
        this.ctx.shadowBlur = 0;
        
        // Enhanced Shield bar (compact)
        y += barHeight + spacing;
        this.ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * uiAlpha})`;
        this.ctx.shadowBlur = playerUnderUI ? 0 : 10;
        this.ctx.shadowColor = 'rgba(79, 195, 247, 0.5)';
        this.ctx.fillRect(x, y, barWidth, barHeight);
        this.ctx.shadowBlur = 0;
        
        if (this.playerStats.maxShield > 0) {
            const shieldPercent = Math.max(0, Math.min(1, this.playerStats.shield / this.playerStats.maxShield));
            
            // Shield bar fill with gradient
            if (shieldPercent > 0) {
                const shieldGradient = this.ctx.createLinearGradient(x + 2, y + 2, x + 2 + (shieldPercent * (barWidth - 4)), y + 2);
                shieldGradient.addColorStop(0, `rgba(79, 195, 247, ${uiAlpha})`);
                shieldGradient.addColorStop(0.5, `rgba(41, 182, 246, ${uiAlpha})`);
                shieldGradient.addColorStop(1, `rgba(2, 136, 209, ${uiAlpha})`);
                this.ctx.fillStyle = shieldGradient;
                this.ctx.shadowBlur = playerUnderUI ? 0 : 8;
                this.ctx.shadowColor = 'rgba(79, 195, 247, 0.8)';
                this.ctx.fillRect(x + 2, y + 2, (shieldPercent * (barWidth - 4)), barHeight - 4);
                this.ctx.shadowBlur = 0;
            }
            
            // Shield text with glow (compact)
            this.ctx.fillStyle = `rgba(255, 255, 255, ${uiAlpha})`;
            this.ctx.font = 'bold 12px Arial';
            this.ctx.shadowBlur = playerUnderUI ? 0 : 4;
            this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            this.ctx.fillText(`S: ${Math.ceil(this.playerStats.shield)}/${this.playerStats.maxShield}`, x + 5, y + 15);
            this.ctx.shadowBlur = 0;
        } else {
            this.ctx.fillStyle = `rgba(100, 100, 100, ${0.5 * uiAlpha})`;
            this.ctx.fillRect(x + 2, y + 2, barWidth - 4, barHeight - 4);
            this.ctx.fillStyle = `rgba(153, 153, 153, ${uiAlpha})`;
            this.ctx.font = 'bold 12px Arial';
            this.ctx.fillText('Shield: None', x + 5, y + 15);
        }
        
        // Enhanced Shooting/Recharge bar - only show when fire rate is slow enough to be meaningful
        // (Fire rate already calculated above for panel height)
        if (showRechargeBar) {
            y += barHeight + spacing;
            this.ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * uiAlpha})`;
            this.ctx.shadowBlur = playerUnderUI ? 0 : 10;
            this.ctx.shadowColor = 'rgba(255, 152, 0, 0.5)';
            this.ctx.fillRect(x, y, barWidth, barHeight);
            this.ctx.shadowBlur = 0;
            
            // Calculate recharge progress
            const now = Date.now();
            const lastShot = this.player.lastShotByWeapon && this.player.lastShotByWeapon['combined'] ? 
                this.player.lastShotByWeapon['combined'] : 0;
            const timeSinceShot = now - lastShot;
            const rechargePercent = Math.min(1, timeSinceShot / cooldown);
            
            // Enhanced Recharge/Ready bar (compact)
            if (rechargePercent < 1) {
                // Still recharging - show progress with gradient
                const rechargeGradient = this.ctx.createLinearGradient(x + 2, y + 2, x + 2 + (rechargePercent * (barWidth - 4)), y + 2);
                rechargeGradient.addColorStop(0, `rgba(255, 152, 0, ${uiAlpha})`);
                rechargeGradient.addColorStop(0.5, `rgba(255, 179, 0, ${uiAlpha})`);
                rechargeGradient.addColorStop(1, `rgba(255, 193, 7, ${uiAlpha})`);
                this.ctx.fillStyle = rechargeGradient;
                this.ctx.shadowBlur = playerUnderUI ? 0 : 8;
                this.ctx.shadowColor = 'rgba(255, 193, 7, 0.8)';
                this.ctx.fillRect(x + 2, y + 2, (rechargePercent * (barWidth - 4)), barHeight - 4);
                this.ctx.shadowBlur = 0;
                
                // Recharge text with glow (compact)
                this.ctx.fillStyle = `rgba(255, 255, 255, ${uiAlpha})`;
                this.ctx.font = 'bold 12px Arial';
                const timeLeft = ((cooldown - timeSinceShot) / 1000).toFixed(1);
                this.ctx.shadowBlur = playerUnderUI ? 0 : 4;
                this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                this.ctx.fillText(`R: ${timeLeft}s`, x + 5, y + 15);
                this.ctx.shadowBlur = 0;
            } else {
                // Ready to fire - show full bar with green gradient
                const readyGradient = this.ctx.createLinearGradient(x + 2, y + 2, x + barWidth - 2, y + 2);
                readyGradient.addColorStop(0, `rgba(76, 175, 80, ${uiAlpha})`);
                readyGradient.addColorStop(0.5, `rgba(102, 187, 106, ${uiAlpha})`);
                readyGradient.addColorStop(1, `rgba(56, 142, 60, ${uiAlpha})`);
                this.ctx.fillStyle = readyGradient;
                this.ctx.shadowBlur = playerUnderUI ? 0 : 12;
                this.ctx.shadowColor = 'rgba(76, 175, 80, 0.9)';
                this.ctx.fillRect(x + 2, y + 2, barWidth - 4, barHeight - 4);
                this.ctx.shadowBlur = 0;
                
                // Ready text with enhanced glow (compact)
                this.ctx.fillStyle = `rgba(255, 255, 255, ${uiAlpha})`;
                this.ctx.font = 'bold 12px Arial';
                this.ctx.shadowBlur = playerUnderUI ? 0 : 4;
                this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                this.ctx.fillText('Ready', x + 5, y + 15);
                this.ctx.shadowBlur = 0;
            }
        }
        
        // Survival System UI - Hunger and Boost meters (only if survival is unlocked)
        if (this.survivalUnlocked) {
            // Hunger bar
            y += barHeight + spacing;
            const hungerPercent = Math.max(0, Math.min(1, this.hunger / this.maxHunger));
            
            // Hunger bar background with glow
            this.ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * uiAlpha})`;
            this.ctx.shadowBlur = playerUnderUI ? 0 : 10;
            this.ctx.shadowColor = hungerPercent > 0.3 ? 'rgba(255, 152, 0, 0.5)' : 'rgba(244, 67, 54, 0.5)';
            this.ctx.fillRect(x, y, barWidth, barHeight);
            this.ctx.shadowBlur = 0;
            
            // Hunger bar fill with gradient (orange when full, red when low)
            if (hungerPercent > 0) {
                const hungerGradient = this.ctx.createLinearGradient(x + 2, y + 2, x + 2 + (hungerPercent * (barWidth - 4)), y + 2);
                if (hungerPercent > 0.5) {
                    hungerGradient.addColorStop(0, `rgba(255, 152, 0, ${uiAlpha})`);
                    hungerGradient.addColorStop(0.5, `rgba(255, 143, 0, ${uiAlpha})`);
                    hungerGradient.addColorStop(1, `rgba(255, 111, 0, ${uiAlpha})`);
                } else if (hungerPercent > 0.3) {
                    hungerGradient.addColorStop(0, `rgba(255, 111, 0, ${uiAlpha})`);
                    hungerGradient.addColorStop(0.5, `rgba(255, 87, 34, ${uiAlpha})`);
                    hungerGradient.addColorStop(1, `rgba(230, 74, 25, ${uiAlpha})`);
                } else {
                    hungerGradient.addColorStop(0, `rgba(244, 67, 54, ${uiAlpha})`);
                    hungerGradient.addColorStop(0.5, `rgba(229, 57, 53, ${uiAlpha})`);
                    hungerGradient.addColorStop(1, `rgba(198, 40, 40, ${uiAlpha})`);
                }
                this.ctx.fillStyle = hungerGradient;
                this.ctx.shadowBlur = playerUnderUI ? 0 : 8;
                this.ctx.shadowColor = hungerPercent > 0.3 ? 'rgba(255, 152, 0, 0.8)' : 'rgba(244, 67, 54, 0.8)';
                this.ctx.fillRect(x + 2, y + 2, (hungerPercent * (barWidth - 4)), barHeight - 4);
                this.ctx.shadowBlur = 0;
            }
            
            // Hunger text with glow
            this.ctx.fillStyle = `rgba(255, 255, 255, ${uiAlpha})`;
            this.ctx.font = 'bold 12px Arial';
            this.ctx.textAlign = 'left';
            this.ctx.shadowBlur = playerUnderUI ? 0 : 4;
            this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            const hungerStatus = this.hunger > 30 ? '🍽️' : (this.hunger > 10 ? '⚠️' : '💀');
            this.ctx.fillText(`${hungerStatus} Hunger: ${Math.ceil(this.hunger)}/${this.maxHunger}`, x + 5, y + 15);
            this.ctx.shadowBlur = 0;
            
            // Boost (Methane) bar
            y += barHeight + spacing;
            const methanePercent = Math.max(0, Math.min(1, this.methane / this.maxMethane));
            
            // Boost bar background with glow
            this.ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * uiAlpha})`;
            this.ctx.shadowBlur = playerUnderUI ? 0 : 10;
            this.ctx.shadowColor = this.boostActive ? 'rgba(156, 39, 176, 0.8)' : 'rgba(156, 39, 176, 0.5)';
            this.ctx.fillRect(x, y, barWidth, barHeight);
            this.ctx.shadowBlur = 0;
            
            // Boost bar fill with purple gradient
            if (methanePercent > 0) {
                const boostGradient = this.ctx.createLinearGradient(x + 2, y + 2, x + 2 + (methanePercent * (barWidth - 4)), y + 2);
                boostGradient.addColorStop(0, this.boostActive ? `rgba(233, 30, 99, ${uiAlpha})` : `rgba(156, 39, 176, ${uiAlpha})`);
                boostGradient.addColorStop(0.5, this.boostActive ? `rgba(194, 24, 91, ${uiAlpha})` : `rgba(123, 31, 162, ${uiAlpha})`);
                boostGradient.addColorStop(1, this.boostActive ? `rgba(173, 20, 87, ${uiAlpha})` : `rgba(106, 27, 154, ${uiAlpha})`);
                this.ctx.fillStyle = boostGradient;
                this.ctx.shadowBlur = playerUnderUI ? 0 : (this.boostActive ? 15 : 8);
                this.ctx.shadowColor = this.boostActive ? 'rgba(233, 30, 99, 0.9)' : 'rgba(156, 39, 176, 0.8)';
                this.ctx.fillRect(x + 2, y + 2, (methanePercent * (barWidth - 4)), barHeight - 4);
                this.ctx.shadowBlur = 0;
            }
            
            // Boost text with glow
            this.ctx.fillStyle = `rgba(255, 255, 255, ${uiAlpha})`;
            this.ctx.font = 'bold 12px Arial';
            this.ctx.shadowBlur = playerUnderUI ? 0 : 4;
            this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            const boostStatus = this.boostActive ? '⚡ BOOST!' : (this.methane >= this.maxMethane ? '🚀 Ready' : '💨');
            this.ctx.fillText(`${boostStatus} Methane: ${Math.ceil(this.methane)}/${this.maxMethane}`, x + 5, y + 15);
            this.ctx.shadowBlur = 0;
        }
    }
    
    drawFoodMaterialsUI() {
        // Enhanced food materials inventory UI - positioned at top left corner (like materials UI)
        if (!this.survivalUnlocked) return;
        
        const padding = 10;
        const spacing = 5;
        const itemHeight = 18;
        const x = padding;
        let y = padding;
        
        // Count biological materials
        const bioMaterials = [
            { key: 'atp', name: 'ATP', color: '#ffeb3b' },
            { key: 'aminoAcids', name: 'Amino', color: '#81c784' },
            { key: 'simpleSugars', name: 'Sugar', color: '#fff9c4' },
            { key: 'fattyAcids', name: 'Fatty', color: '#ffccbc' },
            { key: 'nucleotides', name: 'Nucleo', color: '#ce93d8' },
            { key: 'vitamins', name: 'Vitamin', color: '#ff6ec7' },
            { key: 'minerals', name: 'Mineral', color: '#b0bec5' }
        ];
        
        const hasMaterials = bioMaterials.some(mat => (this.inventory[mat.key] || 0) > 0);
        if (!hasMaterials) return; // Don't show UI if no materials
        
        // Calculate panel dimensions
        const panelWidth = 180;
        const panelHeight = (bioMaterials.length * itemHeight) + (bioMaterials.length - 1) * spacing + padding * 2;
        
        // Check if player is under this UI panel
        const playerUnderFoodUI = this.isPlayerUnderUI(x - 3, y - 3, panelWidth + 6, panelHeight + 6);
        const foodUIAlpha = playerUnderFoodUI ? 0.2 : 0.95; // Make very transparent when player is under
        
        // Enhanced panel background
        const panelGradient = this.ctx.createLinearGradient(x, y, x, y + panelHeight);
        panelGradient.addColorStop(0, `rgba(20, 20, 40, ${foodUIAlpha})`);
        panelGradient.addColorStop(1, `rgba(30, 30, 50, ${foodUIAlpha})`);
        this.ctx.fillStyle = panelGradient;
        this.ctx.shadowBlur = playerUnderFoodUI ? 0 : 15;
        this.ctx.shadowColor = 'rgba(255, 152, 0, 0.5)';
        this.ctx.fillRect(x - 3, y - 3, panelWidth + 6, panelHeight + 6);
        this.ctx.shadowBlur = 0;
        
        // Panel border
        this.ctx.strokeStyle = `rgba(255, 152, 0, ${foodUIAlpha})`;
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(x - 3, y - 3, panelWidth + 6, panelHeight + 6);
        
        // Header
        y += 16;
        this.ctx.fillStyle = `rgba(255, 152, 0, ${foodUIAlpha})`;
        this.ctx.font = 'bold 13px Arial';
        this.ctx.textAlign = 'left';
        this.ctx.shadowBlur = playerUnderFoodUI ? 0 : 8;
        this.ctx.shadowColor = 'rgba(255, 152, 0, 0.8)';
        this.ctx.fillText('🍽️ Food Materials', x, y);
        this.ctx.shadowBlur = 0;
        
        y += 20;
        
        // Draw each material
        bioMaterials.forEach((mat, index) => {
            const count = this.inventory[mat.key] || 0;
            if (count === 0 && index < bioMaterials.length - 1) return; // Skip if 0 (but show last one for spacing)
            
            // Material background
            this.ctx.fillStyle = `rgba(0, 0, 0, ${0.5 * foodUIAlpha})`;
            this.ctx.fillRect(x, y, panelWidth, itemHeight);
            
            // Material color indicator (left side)
            // Convert hex color to rgba with alpha
            const colorR = parseInt(mat.color.slice(1, 3), 16);
            const colorG = parseInt(mat.color.slice(3, 5), 16);
            const colorB = parseInt(mat.color.slice(5, 7), 16);
            this.ctx.fillStyle = `rgba(${colorR}, ${colorG}, ${colorB}, ${foodUIAlpha})`;
            this.ctx.shadowBlur = playerUnderFoodUI ? 0 : 6;
            this.ctx.shadowColor = mat.color + '80';
            this.ctx.fillRect(x + 2, y + 2, 4, itemHeight - 4);
            this.ctx.shadowBlur = 0;
            
            // Material name and count
            this.ctx.fillStyle = `rgba(255, 255, 255, ${foodUIAlpha})`;
            this.ctx.font = 'bold 11px Arial';
            this.ctx.textAlign = 'left';
            this.ctx.fillText(mat.name, x + 10, y + 13);
            
            this.ctx.fillStyle = `rgba(255, 152, 0, ${foodUIAlpha})`;
            this.ctx.font = 'bold 11px Arial';
            this.ctx.textAlign = 'right';
            this.ctx.fillText(`${count}`, x + panelWidth - 5, y + 13);
            
            y += itemHeight + spacing;
        });
    }
    
    // Update materials inventory UI transparency based on player position
    updateMaterialsInventoryTransparency() {
        const materialsInventoryEl = document.getElementById('materialsInventory');
        if (materialsInventoryEl && this.player && this.player.x !== undefined && this.player.y !== undefined) {
            try {
                // Get the element's position and size relative to viewport
                const rect = materialsInventoryEl.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                
                // Convert HTML element position to canvas coordinates
                // materialsInventory is positioned absolutely at top-right (right: 10px, top: 10px)
                // Convert viewport coordinates to canvas coordinates
                const uiX = rect.left - canvasRect.left;
                const uiY = rect.top - canvasRect.top;
                const uiWidth = rect.width;
                const uiHeight = rect.height;
                
                // Always check if player is under the materials UI (simplified - just use the coordinates)
                // The isPlayerUnderUI function will handle the collision check correctly
                const playerUnderMaterialsUI = this.isPlayerUnderUI(uiX, uiY, uiWidth, uiHeight);
                const materialsUIAlpha = playerUnderMaterialsUI ? 0.2 : 1.0; // Make very transparent when player is under
                
                // Apply opacity to the entire materials inventory element
                materialsInventoryEl.style.opacity = materialsUIAlpha;
                materialsInventoryEl.style.transition = 'opacity 0.1s ease-in-out'; // Smooth transition
            } catch (error) {
                // If any error occurs, keep UI visible
                console.warn('[UI] Error updating materials inventory transparency:', error);
                if (materialsInventoryEl) {
                    materialsInventoryEl.style.opacity = '1.0';
                }
            }
        } else if (materialsInventoryEl) {
            // Reset opacity if player not initialized
            materialsInventoryEl.style.opacity = '1.0';
        }
    }

    drawTargets() {
        const time = Date.now() * 0.005;
        
        this.targets.forEach((target, index) => {
            const targetSize = target.size || 15;
            const pulseIntensity = 0.8 + Math.sin(time + index * 0.5) * 0.2;
            
            // Enhanced blue particle - quantum particle design
            const gradient = this.ctx.createRadialGradient(target.x, target.y, 0, target.x, target.y, targetSize);
            gradient.addColorStop(0, '#81d4fa'); // Bright cyan center
            gradient.addColorStop(0.3, '#4fc3f7'); // Medium cyan
            gradient.addColorStop(0.7, '#29b6f6'); // Blue-cyan
            gradient.addColorStop(1, '#0288d1'); // Dark blue edge
            this.ctx.fillStyle = gradient;
            
            // Main particle sphere
            this.ctx.beginPath();
            this.ctx.arc(target.x, target.y, targetSize, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Enhanced glow effect
            this.ctx.shadowBlur = targetSize * 1.5;
            this.ctx.shadowColor = '#4fc3f7';
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            
            // Quantum field rings (orbiting)
            this.ctx.strokeStyle = `rgba(79, 195, 247, ${0.6 * pulseIntensity})`;
            this.ctx.lineWidth = 1.5;
            for (let i = 0; i < 2; i++) {
                const ringAngle = time * 0.8 + i * Math.PI + index * 0.3;
                const ringRadius = targetSize * 0.5;
                const ringX = target.x + Math.cos(ringAngle) * ringRadius;
                const ringY = target.y + Math.sin(ringAngle) * ringRadius;
                this.ctx.beginPath();
                this.ctx.arc(ringX, ringY, targetSize * 0.25, 0, Math.PI * 2);
                this.ctx.stroke();
            }
            
            // Bright inner core
            this.ctx.fillStyle = `rgba(129, 212, 250, ${0.9 * pulseIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(target.x, target.y, targetSize * 0.5, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Quantum sparkles
            this.ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * pulseIntensity})`;
            for (let i = 0; i < 3; i++) {
                const sparkleAngle = time * 2 + i * (Math.PI * 2 / 3) + index * 0.2;
                const sparkleDist = targetSize * 0.7;
                this.ctx.beginPath();
                this.ctx.arc(target.x + Math.cos(sparkleAngle) * sparkleDist, 
                           target.y + Math.sin(sparkleAngle) * sparkleDist, 1.5, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
    }

    drawPairs() {
        const time = Date.now() * 0.004;
        
        this.pairs.forEach((pair, pairIndex) => {
            const dx = pair.b.x - pair.a.x;
            const dy = pair.b.y - pair.a.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const midX = (pair.a.x + pair.b.x) / 2;
            const midY = (pair.a.y + pair.b.y) / 2;
            
            // Enhanced Bell pair connection - quantum entanglement bond
            const bondPulse = 0.5 + Math.sin(time * 1.5 + pairIndex) * 0.3;
            
            // Main entanglement bond with gradient
            const bondGradient = this.ctx.createLinearGradient(pair.a.x, pair.a.y, pair.b.x, pair.b.y);
            bondGradient.addColorStop(0, `rgba(79, 195, 247, ${0.6 * bondPulse})`);
            bondGradient.addColorStop(0.5, `rgba(129, 212, 250, ${0.8 * bondPulse})`);
            bondGradient.addColorStop(1, `rgba(79, 195, 247, ${0.6 * bondPulse})`);
            
            this.ctx.strokeStyle = bondGradient;
            this.ctx.lineWidth = 3;
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = 'rgba(79, 195, 247, 0.6)';
            this.ctx.beginPath();
            this.ctx.moveTo(pair.a.x, pair.a.y);
            this.ctx.lineTo(pair.b.x, pair.b.y);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Energy flow along bond (animated)
            const flowPosition = (time * 0.3 + pairIndex) % 1;
            const flowX = pair.a.x + (pair.b.x - pair.a.x) * flowPosition;
            const flowY = pair.a.y + (pair.b.y - pair.a.y) * flowPosition;
            
            this.ctx.fillStyle = `rgba(129, 212, 250, ${0.9 * bondPulse})`;
                this.ctx.beginPath();
            this.ctx.arc(flowX, flowY, 3, 0, Math.PI * 2);
                this.ctx.fill();
            
            // Quantum correlation field (pulsing rings at midpoint)
            this.ctx.strokeStyle = `rgba(79, 195, 247, ${0.4 * bondPulse})`;
            this.ctx.lineWidth = 1.5;
            for (let i = 1; i <= 2; i++) {
                const ringRadius = (distance * 0.1 * i) * bondPulse;
                this.ctx.beginPath();
                this.ctx.arc(midX, midY, ringRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            // Enhanced Bell pair particles
            [pair.a, pair.b].forEach((p, particleIndex) => {
                const particleSize = p.size || 15;
                const particlePulse = 0.8 + Math.sin(time + pairIndex + particleIndex) * 0.2;
                
                // Enhanced particle gradient
                const particleGradient = this.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, particleSize);
                particleGradient.addColorStop(0, '#81d4fa'); // Bright cyan center
                particleGradient.addColorStop(0.3, '#4fc3f7'); // Medium cyan
                particleGradient.addColorStop(0.7, '#29b6f6'); // Blue-cyan
                particleGradient.addColorStop(1, '#0288d1'); // Dark blue edge
                
                this.ctx.fillStyle = particleGradient;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, particleSize, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Enhanced glow
                this.ctx.shadowBlur = particleSize * 1.5;
                this.ctx.shadowColor = '#4fc3f7';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Bright inner core
                this.ctx.fillStyle = `rgba(129, 212, 250, ${0.9 * particlePulse})`;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, particleSize * 0.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Quantum field rings around particle
                this.ctx.strokeStyle = `rgba(79, 195, 247, ${0.5 * particlePulse})`;
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 2; i++) {
                    const ringAngle = time * 0.6 + i * Math.PI + pairIndex + particleIndex;
                    const ringRadius = particleSize * 0.4;
                    const ringX = p.x + Math.cos(ringAngle) * ringRadius;
                    const ringY = p.y + Math.sin(ringAngle) * ringRadius;
                    this.ctx.beginPath();
                    this.ctx.arc(ringX, ringY, particleSize * 0.2, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Quantum sparkles
                this.ctx.fillStyle = `rgba(255, 255, 255, ${0.7 * particlePulse})`;
                for (let i = 0; i < 3; i++) {
                    const sparkleAngle = time * 1.8 + i * (Math.PI * 2 / 3) + pairIndex + particleIndex;
                    const sparkleDist = particleSize * 0.65;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x + Math.cos(sparkleAngle) * sparkleDist, 
                               p.y + Math.sin(sparkleAngle) * sparkleDist, 1.2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            });
        });
    }

    drawObstacles() {
        // Debug: Log boss obstacles in dev mode
        if (this.devMode && this.bossMode) {
            const bossObstacles = this.obstacles.filter(o => o.isBoss);
            if (bossObstacles.length > 0 && Math.random() < 0.01) { // Log occasionally to avoid spam
                console.log('[DEV] Drawing obstacles. Boss count:', bossObstacles.length, 'Total obstacles:', this.obstacles.length);
                bossObstacles.forEach(boss => {
                    console.log('[DEV] Boss:', boss.bossPart, 'at', boss.x, boss.y, 'health:', boss.health, 'size:', boss.size);
                });
            }
        }
        
        // OPTIMIZATION: Use for loop instead of forEach for better performance
        // OPTIMIZATION: Add culling to skip off-screen obstacles
        // OPTIMIZED: Larger cull margin for late game fast-moving molecules (starts earlier)
        const level = this.level || 1;
        const isLateGame = level >= 70; // Starts earlier
        const isVeryLateGame = level >= 120;
        // Progressive cull margin: increases with level for better performance
        let cullMargin = 100;
        if (isVeryLateGame) {
            cullMargin = 250; // Very large margin for very late game
        } else if (isLateGame) {
            cullMargin = 150; // Larger margin for late game
        }
        
        for (let i = 0; i < this.obstacles.length; i++) {
            const obstacle = this.obstacles[i];
            
            // Skip if obstacle is invalid
            if (!obstacle) continue;
            // For bosses, always draw (they might be regenerating or have special drawing logic)
            // For regular obstacles, skip if health is 0
            if (!obstacle.isBoss && obstacle.health <= 0) continue;
            
            // CULLING: Skip obstacles that are far off-screen (except bosses)
            // OPTIMIZED: More aggressive culling for late game
            if (!obstacle.isBoss) {
                if (obstacle.x < -cullMargin || obstacle.x > this.canvas.width + cullMargin ||
                    obstacle.y < -cullMargin || obstacle.y > this.canvas.height + cullMargin) {
                    continue;
                }
            }
            
            this.ctx.save();
            this.ctx.translate(obstacle.x, obstacle.y);
            
            if (obstacle.isBoss) {
                // Draw boss neural network structure
                this.drawBossMolecule(obstacle);
            } else {
                // Draw regular molecule structure
                this.drawMolecule(obstacle);
            }
            
            this.ctx.restore();
            
            // Health bar only for boss (regular molecules show health by shrinking)
            if (obstacle.isBoss) {
                const barWidth = obstacle.size * 2;
                const barHeight = 6;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(obstacle.x - barWidth / 2, obstacle.y - obstacle.size - 15, barWidth, barHeight);
                const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
                this.ctx.fillStyle = '#8b00ff';
                this.ctx.fillRect(obstacle.x - barWidth / 2, obstacle.y - obstacle.size - 15, barWidth * healthPercent, barHeight);
            }
        }
    }
    
    drawMolecule(obstacle) {
        if (!obstacle.atoms || obstacle.atoms.length === 0) return;
        
        const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
        
        // OPTIMIZATION: Calculate speed for fast-moving molecule optimization
        const speed = Math.sqrt(obstacle.vx * obstacle.vx + obstacle.vy * obstacle.vy);
        const isFastMoving = speed > 3; // Fast-moving molecules
        const isVeryFastMoving = speed > 6; // Very fast-moving molecules (lowered threshold for earlier optimization)
        const obstacleCount = this.obstacles.length;
        const isManyObstacles = obstacleCount > 12; // Many obstacles on screen (lowered threshold)
        const level = this.level || 1;
        const isLateGame = level >= 70; // Late game optimization (starts earlier)
        const isVeryLateGame = level >= 120; // Very late game optimization (starts earlier)
        
        // OPTIMIZATION: Calculate size factor for large molecule optimization
        const moleculeSize = obstacle.size || obstacle.originalSize || 50;
        const isLargeMolecule = moleculeSize > 80; // Large molecules (lowered threshold)
        const isVeryLargeMolecule = moleculeSize > 120; // Very large molecules (lowered threshold)
        
        // OPTIMIZATION: Reduce visual complexity when molecule is damaged (health < 50%)
        // This prevents lag when many molecules are shrinking
        const isDamaged = healthPercent < 0.5;
        const isLowHealth = healthPercent < 0.25;
        
        // OPTIMIZATION: Further simplify fast-moving, large, or when many obstacles
        // Late game: Aggressive simplification for performance (starts at level 70)
        // Only simplify when truly needed - keep enhanced visuals for normal gameplay
        const shouldSimplify = (isVeryFastMoving && isManyObstacles) || (isDamaged && isManyObstacles) || (isVeryLateGame && isManyObstacles);
        const shouldAggressivelySimplify = (isVeryFastMoving && isVeryLargeMolecule && isManyObstacles) || (isVeryLateGame && isManyObstacles && isDamaged);
        
        // OPTIMIZATION: Use simpler rendering for damaged molecules
        if (isLowHealth) {
            // Very damaged: minimal rendering - just atoms, no bonds or effects
            for (let i = 0; i < obstacle.atoms.length; i++) {
                const atom = obstacle.atoms[i];
                const currentRadius = atom.radius * healthPercent;
                if (currentRadius > 0) {
                    this.ctx.fillStyle = atom.color;
                    this.ctx.beginPath();
                    this.ctx.arc(atom.x, atom.y, currentRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            return; // Skip all expensive effects
        }
        
        const time = Date.now() * 0.003;
        
        // Enhanced bonds (lines between atoms) with energy flow
        // OPTIMIZATION: Only simplify bonds when truly needed for performance
        if (shouldAggressivelySimplify) {
            // Very aggressive: minimal bonds, no effects (only in extreme cases)
            this.ctx.strokeStyle = `rgba(255, 150, 150, ${isDamaged ? 0.5 * healthPercent : 0.6})`;
            this.ctx.lineWidth = 1.5;
            this.ctx.shadowBlur = 0; // No shadow for performance
        } else {
            // Default: enhanced bonds with gradient and glow (restored from backup)
            const bondGradient = this.ctx.createLinearGradient(0, 0, 100, 100);
            bondGradient.addColorStop(0, 'rgba(255, 150, 150, 0.8)');
            bondGradient.addColorStop(0.5, 'rgba(255, 200, 200, 0.7)');
            bondGradient.addColorStop(1, 'rgba(255, 100, 100, 0.6)');
            this.ctx.strokeStyle = bondGradient;
            this.ctx.lineWidth = 2.5;
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = 'rgba(255, 150, 150, 0.6)';
        }
        
        if (obstacle.moleculeType === 'simple') {
            // Simple: center to all atoms
            const centerAtom = obstacle.atoms[0];
            for (let i = 1; i < obstacle.atoms.length; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(centerAtom.x, centerAtom.y);
                this.ctx.lineTo(obstacle.atoms[i].x, obstacle.atoms[i].y);
                this.ctx.stroke();
            }
        } else if (obstacle.moleculeType === 'medium') {
            // Medium: ring structure - connect each atom to its neighbors
            const centerAtom = obstacle.atoms[0];
            // Connect center to all
            for (let i = 1; i < obstacle.atoms.length; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(centerAtom.x, centerAtom.y);
                this.ctx.lineTo(obstacle.atoms[i].x, obstacle.atoms[i].y);
                this.ctx.stroke();
            }
            // Connect adjacent atoms in ring (form a closed ring)
            for (let i = 1; i < obstacle.atoms.length; i++) {
                const next = i === obstacle.atoms.length - 1 ? 1 : i + 1; // Wrap around to form ring
                this.ctx.beginPath();
                this.ctx.moveTo(obstacle.atoms[i].x, obstacle.atoms[i].y);
                this.ctx.lineTo(obstacle.atoms[next].x, obstacle.atoms[next].y);
                this.ctx.stroke();
            }
        } else if (obstacle.moleculeType === 'complex') {
            // Complex: connect all atoms to center, and nearby atoms to each other
            const centerAtom = obstacle.atoms[0];
            // Connect center to all
            for (let i = 1; i < obstacle.atoms.length; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(centerAtom.x, centerAtom.y);
                this.ctx.lineTo(obstacle.atoms[i].x, obstacle.atoms[i].y);
                this.ctx.stroke();
            }
            // Connect nearby atoms to each other (within bond distance)
            for (let i = 1; i < obstacle.atoms.length; i++) {
                for (let j = i + 1; j < obstacle.atoms.length; j++) {
                    const dx = obstacle.atoms[i].x - obstacle.atoms[j].x;
                    const dy = obstacle.atoms[i].y - obstacle.atoms[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    // Bond if atoms are close enough (within 1.5x bond length)
                    if (dist < obstacle.size * 0.9) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(obstacle.atoms[i].x, obstacle.atoms[i].y);
                        this.ctx.lineTo(obstacle.atoms[j].x, obstacle.atoms[j].y);
                        this.ctx.stroke();
                    }
                }
            }
        }
        
        this.ctx.shadowBlur = 0;
        
        // OPTIMIZATION: Use for loop instead of forEach for better performance
        // OPTIMIZATION: Reduce visual effects for damaged molecules
        for (let index = 0; index < obstacle.atoms.length; index++) {
            const atom = obstacle.atoms[index];
            const currentRadius = atom.radius * healthPercent;
            
            if (currentRadius > 0) {
                if (shouldAggressivelySimplify) {
                    // Very aggressive: minimal rendering - just solid color, no effects
                    this.ctx.fillStyle = atom.color;
                    this.ctx.beginPath();
                    this.ctx.arc(atom.x, atom.y, currentRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                } else {
                    // Default: full enhanced rendering with gradients and effects (restored from backup)
                    // Atom gradient - red with depth
                    const atomGradient = this.ctx.createRadialGradient(atom.x, atom.y, 0, atom.x, atom.y, currentRadius);
                    atomGradient.addColorStop(0, '#ff9999'); // Bright red center
                    atomGradient.addColorStop(0.4, atom.color); // Base color
                    atomGradient.addColorStop(0.8, '#cc4444'); // Darker red
                    atomGradient.addColorStop(1, '#992222'); // Very dark red edge
                    
                    this.ctx.fillStyle = atomGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(atom.x, atom.y, currentRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Enhanced glow effect
                    this.ctx.shadowBlur = currentRadius * 1.5;
                    this.ctx.shadowColor = atom.color;
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                
                    // Inner bright core
                    this.ctx.fillStyle = `rgba(255, 200, 200, ${0.8 * healthPercent})`;
                    this.ctx.beginPath();
                    this.ctx.arc(atom.x, atom.y, currentRadius * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Atom highlight (shiny spot) - rotating highlight
                    const highlightAngle = time + index;
                    const highlightX = atom.x + Math.cos(highlightAngle) * currentRadius * 0.4;
                    const highlightY = atom.y + Math.sin(highlightAngle) * currentRadius * 0.4;
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.6 * healthPercent})`;
                    this.ctx.beginPath();
                    this.ctx.arc(highlightX, highlightY, currentRadius * 0.2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Energy field around atom (subtle pulsing) - only if not aggressively simplifying
                    if (!shouldAggressivelySimplify) {
                        const fieldIntensity = 0.3 + Math.sin(time * 2 + index) * 0.2;
                        this.ctx.strokeStyle = `rgba(255, 150, 150, ${fieldIntensity * healthPercent})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(atom.x, atom.y, currentRadius * 1.3, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                }
            }
        }
    }
    
    drawBossMolecule(obstacle) {
        const time = Date.now() * 0.001;
        const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
        
        // Draw neurotransmitter boss (neuron with vesicles)
        if (obstacle.bossType === 'neurotransmitter') {
            if (obstacle.bossPart === 'neuron') {
                // Enhanced Neuron Structure Drawing
                if (!obstacle.nodes || obstacle.nodes.length === 0) {
                    // Fallback: draw enhanced circle if nodes are missing
                    const currentRadius = Math.max(10, obstacle.size * healthPercent);
                    
                    // Outer neural glow
                    const outerGlow = this.ctx.createRadialGradient(0, 0, currentRadius * 0.7, 0, 0, currentRadius * 1.5);
                    outerGlow.addColorStop(0, `rgba(139, 0, 255, ${0.3 * healthPercent})`);
                    outerGlow.addColorStop(1, 'rgba(139, 0, 255, 0)');
                    this.ctx.fillStyle = outerGlow;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, currentRadius * 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Main neuron body with gradient
                    const neuronGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, currentRadius);
                    neuronGradient.addColorStop(0, `rgba(200, 100, 255, ${healthPercent})`);
                    neuronGradient.addColorStop(0.5, `rgba(139, 0, 255, ${healthPercent})`);
                    neuronGradient.addColorStop(1, `rgba(100, 0, 200, ${healthPercent})`);
                    this.ctx.fillStyle = neuronGradient;
                    this.ctx.shadowBlur = 25;
                    this.ctx.shadowColor = `rgba(139, 0, 255, ${0.8 * healthPercent})`;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                    
                    // Pulsing outer ring
                    const pulsePhase = Math.sin(time * 2) * 0.5 + 0.5;
                    this.ctx.strokeStyle = `rgba(200, 100, 255, ${0.6 * healthPercent * pulsePhase})`;
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, currentRadius + 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Inner bright core
                    const coreGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, currentRadius * 0.4);
                    coreGradient.addColorStop(0, `rgba(255, 255, 255, ${0.7 * healthPercent})`);
                    coreGradient.addColorStop(1, 'rgba(200, 100, 255, 0)');
                    this.ctx.fillStyle = coreGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, currentRadius * 0.4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Enhanced outline
                    this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * healthPercent})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = 'rgba(139, 0, 255, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                    return;
                }
                if (obstacle.nodes && obstacle.nodes.length > 0) {
                    const coreNode = obstacle.nodes[0];
                    
                    // Enhanced connections (dendrites and axon) with energy flow
                    for (let i = 1; i < obstacle.nodes.length; i++) {
                        const node = obstacle.nodes[i];
                        const connectionLength = Math.sqrt((node.x - coreNode.x) ** 2 + (node.y - coreNode.y) ** 2);
                        
                        // Connection gradient
                        const connectionGradient = this.ctx.createLinearGradient(
                            coreNode.x, coreNode.y,
                            node.x, node.y
                        );
                        connectionGradient.addColorStop(0, `rgba(139, 0, 255, ${0.6 * healthPercent})`);
                        connectionGradient.addColorStop(0.5, `rgba(200, 100, 255, ${0.8 * healthPercent})`);
                        connectionGradient.addColorStop(1, `rgba(139, 0, 255, ${0.6 * healthPercent})`);
                        
                        this.ctx.strokeStyle = connectionGradient;
                        this.ctx.lineWidth = 3;
                        this.ctx.shadowBlur = 12;
                        this.ctx.shadowColor = 'rgba(139, 0, 255, 0.6)';
                        this.ctx.beginPath();
                        this.ctx.moveTo(coreNode.x, coreNode.y);
                        this.ctx.lineTo(node.x, node.y);
                        this.ctx.stroke();
                        
                        // Energy flow particles along connection
                        const flowPhase = (time * 0.5 + i * 0.3) % 1;
                        const flowX = coreNode.x + (node.x - coreNode.x) * flowPhase;
                        const flowY = coreNode.y + (node.y - coreNode.y) * flowPhase;
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * healthPercent})`;
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = 'rgba(200, 100, 255, 0.8)';
                        this.ctx.beginPath();
                        this.ctx.arc(flowX, flowY, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                    
                    // Enhanced nodes with gradients and effects
                    obstacle.nodes.forEach((node, index) => {
                        const currentRadius = node.radius * healthPercent;
                        if (currentRadius > 0) {
                            // Node outer glow
                            const nodeGlow = this.ctx.createRadialGradient(
                                node.x, node.y, currentRadius * 0.6,
                                node.x, node.y, currentRadius * 1.4
                            );
                            nodeGlow.addColorStop(0, `rgba(139, 0, 255, ${0.4 * healthPercent})`);
                            nodeGlow.addColorStop(1, 'rgba(139, 0, 255, 0)');
                            this.ctx.fillStyle = nodeGlow;
                            this.ctx.beginPath();
                            this.ctx.arc(node.x, node.y, currentRadius * 1.4, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Node gradient
                            const nodeGradient = this.ctx.createRadialGradient(
                                node.x, node.y, 0,
                                node.x, node.y, currentRadius
                            );
                            if (node.isCore) {
                                nodeGradient.addColorStop(0, `rgba(255, 255, 255, ${healthPercent})`);
                                nodeGradient.addColorStop(0.3, `rgba(200, 100, 255, ${healthPercent})`);
                                nodeGradient.addColorStop(1, `rgba(139, 0, 255, ${healthPercent})`);
                            } else {
                                nodeGradient.addColorStop(0, `rgba(200, 100, 255, ${healthPercent})`);
                                nodeGradient.addColorStop(0.5, `rgba(139, 0, 255, ${healthPercent})`);
                                nodeGradient.addColorStop(1, `rgba(100, 0, 200, ${healthPercent})`);
                            }
                            
                            this.ctx.fillStyle = nodeGradient;
                            this.ctx.shadowBlur = 20;
                            this.ctx.shadowColor = node.color || 'rgba(139, 0, 255, 0.8)';
                            this.ctx.beginPath();
                            this.ctx.arc(node.x, node.y, currentRadius, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.shadowBlur = 0;
                            
                            // Node inner core
                            const nodeCore = this.ctx.createRadialGradient(
                                node.x, node.y, 0,
                                node.x, node.y, currentRadius * 0.4
                            );
                            nodeCore.addColorStop(0, `rgba(255, 255, 255, ${0.6 * healthPercent})`);
                            nodeCore.addColorStop(1, 'rgba(200, 100, 255, 0)');
                            this.ctx.fillStyle = nodeCore;
                            this.ctx.beginPath();
                            this.ctx.arc(node.x, node.y, currentRadius * 0.4, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Pulsing ring around node
                            const nodePulse = Math.sin(time * 2.5 + index) * 0.5 + 0.5;
                            this.ctx.strokeStyle = `rgba(200, 100, 255, ${0.5 * healthPercent * nodePulse})`;
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.arc(node.x, node.y, currentRadius + 3, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                    });
                }
            } else if (obstacle.bossPart === 'vesicle') {
                // Enhanced Neurotransmitter Vesicle Drawing
                const currentRadius = Math.max(5, obstacle.size * healthPercent);
                const vesiclePulse = Math.sin(time * 3) * 0.3 + 0.7;
                
                // Outer vesicle glow
                const vesicleGlow = this.ctx.createRadialGradient(0, 0, currentRadius * 0.8, 0, 0, currentRadius * 1.8);
                vesicleGlow.addColorStop(0, `rgba(255, 107, 107, ${0.3 * healthPercent * vesiclePulse})`);
                vesicleGlow.addColorStop(0.5, `rgba(255, 107, 107, ${0.15 * healthPercent * vesiclePulse})`);
                vesicleGlow.addColorStop(1, 'rgba(255, 107, 107, 0)');
                this.ctx.fillStyle = vesicleGlow;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius * 1.8, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pulsing outer ring
                const pulsePhase = Math.sin(time * 2.5) * 0.5 + 0.5;
                this.ctx.strokeStyle = `rgba(255, 150, 150, ${0.6 * healthPercent * pulsePhase})`;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius + 4, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Main vesicle body with gradient
                const vesicleGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, currentRadius);
                vesicleGradient.addColorStop(0, `rgba(255, 200, 200, ${healthPercent})`);
                vesicleGradient.addColorStop(0.4, `rgba(255, 107, 107, ${healthPercent})`);
                vesicleGradient.addColorStop(0.8, `rgba(200, 50, 50, ${healthPercent})`);
                vesicleGradient.addColorStop(1, `rgba(150, 30, 30, ${healthPercent})`);
                this.ctx.fillStyle = vesicleGradient;
                this.ctx.shadowBlur = 18;
                this.ctx.shadowColor = `rgba(255, 107, 107, ${0.8 * healthPercent})`;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Inner bright core
                const vesicleCore = this.ctx.createRadialGradient(0, 0, 0, 0, 0, currentRadius * 0.5);
                vesicleCore.addColorStop(0, `rgba(255, 255, 255, ${0.8 * healthPercent})`);
                vesicleCore.addColorStop(0.6, `rgba(255, 200, 200, ${0.4 * healthPercent})`);
                vesicleCore.addColorStop(1, 'rgba(255, 107, 107, 0)');
                this.ctx.fillStyle = vesicleCore;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius * 0.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Enhanced outline
                this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * healthPercent})`;
                this.ctx.lineWidth = 2.5;
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = 'rgba(255, 107, 107, 0.8)';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Orbiting neurotransmitter particles (3 particles)
                for (let i = 0; i < 3; i++) {
                    const particleAngle = time * 2 + (i / 3) * Math.PI * 2;
                    const particleX = Math.cos(particleAngle) * (currentRadius + 8);
                    const particleY = Math.sin(particleAngle) * (currentRadius + 8);
                    const particleSize = 1.5 + Math.sin(time * 4 + i) * 0.5;
                    
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * healthPercent})`;
                    this.ctx.shadowBlur = 6;
                    this.ctx.shadowColor = 'rgba(255, 107, 107, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // Enhanced connection line to neuron
                if (this.currentBoss && this.currentBoss.bossPart === 'neuron') {
                    const dx = this.currentBoss.x - obstacle.x;
                    const dy = this.currentBoss.y - obstacle.y;
                    const connectionLength = Math.sqrt(dx * dx + dy * dy);
                    
                    // Connection gradient with energy flow
                    const connectionGradient = this.ctx.createLinearGradient(0, 0, dx, dy);
                    connectionGradient.addColorStop(0, `rgba(255, 107, 107, ${0.4 * healthPercent})`);
                    connectionGradient.addColorStop(0.5, `rgba(255, 200, 200, ${0.6 * healthPercent})`);
                    connectionGradient.addColorStop(1, `rgba(255, 107, 107, ${0.4 * healthPercent})`);
                    
                    this.ctx.strokeStyle = connectionGradient;
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([6, 4]);
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = 'rgba(255, 107, 107, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(dx, dy);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                    this.ctx.setLineDash([]);
                    
                    // Energy flow particle along connection
                    const flowPhase = (time * 0.8) % 1;
                    const flowX = dx * flowPhase;
                    const flowY = dy * flowPhase;
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * healthPercent})`;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = 'rgba(255, 107, 107, 0.9)';
                    this.ctx.beginPath();
                    this.ctx.arc(flowX, flowY, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
            }
        } else if (obstacle.bossType === 'dnaHelix') {
            // Simplified DNA Helix boss - redesigned for performance
            const time = this.time || 0;
                const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
            
            if (obstacle.bossPart === 'strand1' || obstacle.bossPart === 'strand2') {
                // Enhanced DNA Strand - improved visuals while maintaining performance
                const baseRadius = obstacle.size * healthPercent;
                if (baseRadius > 0) {
                    const isStrand1 = obstacle.bossPart === 'strand1';
                    const strandColor = isStrand1 ? '#00ff88' : '#00ccff';
                    const strandColorRGB = isStrand1 ? '0, 255, 136' : '0, 204, 255';
                    
                    // Enhanced outer glow with gradient
                    const outerGlowGradient = this.ctx.createRadialGradient(0, 0, baseRadius * 0.6, 0, 0, baseRadius * 1.5);
                    outerGlowGradient.addColorStop(0, `rgba(${strandColorRGB}, ${0.3 * healthPercent})`);
                    outerGlowGradient.addColorStop(0.5, `rgba(${strandColorRGB}, ${0.15 * healthPercent})`);
                    outerGlowGradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
                    this.ctx.fillStyle = outerGlowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, baseRadius * 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Enhanced pulsing ring with shadow
                    const pulsePhase = Math.sin(time * 2.2) * 0.5 + 0.5;
                    this.ctx.strokeStyle = `rgba(${strandColorRGB}, ${0.6 * healthPercent * pulsePhase})`;
                    this.ctx.lineWidth = 4;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = `rgba(${strandColorRGB}, 0.6)`;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, baseRadius + 6, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                    
                    // Enhanced DNA helix - proper twisted double helix structure
                    // Create helix points with proper vertical twist
                    const helixPoints = [];
                    for (let i = 0; i <= 16; i++) {
                        const t = i / 16;
                        const verticalPos = (t - 0.5) * baseRadius * 1.4;
                        const twistAngle = t * Math.PI * 5 + (isStrand1 ? 0 : Math.PI);
                        const radius = baseRadius * 0.35;
                        const x = Math.cos(twistAngle) * radius;
                        const y = verticalPos;
                        helixPoints.push({ x, y, t, angle: twistAngle });
                    }
                    
                    // Draw helix backbone with shadow
                    this.ctx.strokeStyle = `rgba(${strandColorRGB}, ${0.95 * healthPercent})`;
                    this.ctx.lineWidth = 10;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = `rgba(${strandColorRGB}, 0.7)`;
                    this.ctx.beginPath();
                    for (let i = 0; i < helixPoints.length; i++) {
                        if (i === 0) {
                            this.ctx.moveTo(helixPoints[i].x, helixPoints[i].y);
                        } else {
                            this.ctx.lineTo(helixPoints[i].x, helixPoints[i].y);
                        }
                    }
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                    
                    // Enhanced base pairs with glow - positioned along helix
                    const basePairGlowGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                    basePairGlowGradient.addColorStop(0, `rgba(${strandColorRGB}, ${0.8 * healthPercent})`);
                    basePairGlowGradient.addColorStop(0.5, `rgba(255, 255, 255, ${0.6 * healthPercent})`);
                    basePairGlowGradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
                    
                    // Find opposite strand for base pairs (if it exists)
                    const oppositeStrand = this.obstacles.find(o => 
                        o.isBoss && 
                        o.bossType === 'dnaHelix' && 
                        o.bossPart === (isStrand1 ? 'strand2' : 'strand1')
                    );
                    
                    for (let i = 0; i <= 16; i += 3) {
                        const t = i / 16;
                        const verticalPos = (t - 0.5) * baseRadius * 1.4;
                        const twistAngle = t * Math.PI * 5 + (isStrand1 ? 0 : Math.PI);
                        const radius = baseRadius * 0.35;
                        const x = Math.cos(twistAngle) * radius;
                        const y = verticalPos;
                        const basePairSize = 5 + Math.sin(time * 2 + i) * 1;
                        
                        // Base pair glow
                        this.ctx.save();
                        this.ctx.translate(x, y);
                        this.ctx.scale(basePairSize / 5, basePairSize / 5);
                        this.ctx.fillStyle = basePairGlowGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.restore();
                        
                        // Base pair core
                        this.ctx.fillStyle = `rgba(${strandColorRGB}, ${0.9 * healthPercent})`;
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = `rgba(${strandColorRGB}, 0.7)`;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, basePairSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                        
                        // Draw connection to opposite strand if it exists
                        if (oppositeStrand) {
                            const dx = oppositeStrand.x - obstacle.x;
                            const dy = oppositeStrand.y - obstacle.y;
                            const oppositeTwistAngle = t * Math.PI * 5 + (isStrand1 ? Math.PI : 0);
                            const oppositeX = Math.cos(oppositeTwistAngle) * radius;
                            const oppositeY = verticalPos;
                            
                            // Base pair connection line
                            this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 * healthPercent})`;
                            this.ctx.lineWidth = 2;
                            this.ctx.shadowBlur = 6;
                            this.ctx.shadowColor = `rgba(${strandColorRGB}, 0.5)`;
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, y);
                            this.ctx.lineTo(x + oppositeX, y + oppositeY);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                        }
                    }
                    
                    // Energy flow particle along helix
                    const flowPhase = (time * 0.5) % 1;
                    const flowIndex = Math.floor(flowPhase * helixPoints.length);
                    if (helixPoints[flowIndex]) {
                        const flowPoint = helixPoints[flowIndex];
                        
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * healthPercent})`;
                        this.ctx.shadowBlur = 12;
                        this.ctx.shadowColor = `rgba(${strandColorRGB}, 0.9)`;
                        this.ctx.beginPath();
                        this.ctx.arc(flowPoint.x, flowPoint.y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                    
                    // Enhanced connection line to core
                    if (this.currentBoss && this.currentBoss.bossPart === 'core') {
                        const dx = this.currentBoss.x - obstacle.x;
                        const dy = this.currentBoss.y - obstacle.y;
                        
                        // Connection gradient (reused)
                        const connectionGradient = this.ctx.createLinearGradient(0, 0, dx, dy);
                        connectionGradient.addColorStop(0, `rgba(${strandColorRGB}, ${0.5 * healthPercent})`);
                        connectionGradient.addColorStop(0.5, `rgba(${strandColorRGB}, ${0.7 * healthPercent})`);
                        connectionGradient.addColorStop(1, `rgba(${strandColorRGB}, ${0.5 * healthPercent})`);
                        
                        this.ctx.strokeStyle = connectionGradient;
                        this.ctx.lineWidth = 3;
                        this.ctx.setLineDash([8, 4]);
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = `rgba(${strandColorRGB}, 0.5)`;
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, 0);
                        this.ctx.lineTo(dx, dy);
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                        this.ctx.setLineDash([]);
                        
                        // Energy flow particle along connection
                        const flowPhase2 = (time * 0.7) % 1;
                        const flowX = dx * flowPhase2;
                        const flowY = dy * flowPhase2;
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * healthPercent})`;
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = `rgba(${strandColorRGB}, 0.9)`;
                        this.ctx.beginPath();
                        this.ctx.arc(flowX, flowY, 3.5, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                }
            } else if (obstacle.bossPart === 'core') {
                // Enhanced DNA Core - improved visuals while maintaining performance
                const baseRadius = obstacle.size * healthPercent * 0.5;
                
                // Enhanced outer glow with gradient
                const coreGlowGradient = this.ctx.createRadialGradient(0, 0, baseRadius * 0.7, 0, 0, baseRadius * 1.6);
                coreGlowGradient.addColorStop(0, `rgba(139, 0, 255, ${0.3 * healthPercent})`);
                coreGlowGradient.addColorStop(0.5, `rgba(0, 255, 136, ${0.2 * healthPercent})`);
                coreGlowGradient.addColorStop(1, 'rgba(139, 0, 255, 0)');
                this.ctx.fillStyle = coreGlowGradient;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, baseRadius * 1.6, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Enhanced double helix - proper DNA structure with vertical twist
                const helixStrand1Points = [];
                const helixStrand2Points = [];
                
                for (let i = 0; i <= 20; i++) {
                    const t = i / 20;
                    const verticalPos = (t - 0.5) * obstacle.size * 1.2;
                    const twistAngle = t * Math.PI * 6;
                    const radius = baseRadius * (0.25 + t * 0.35);
                    
                    // Strand 1
                    helixStrand1Points.push({
                        x: Math.cos(twistAngle) * radius,
                        y: verticalPos,
                        angle: twistAngle
                    });
                    
                    // Strand 2 (opposite side)
                    helixStrand2Points.push({
                        x: Math.cos(twistAngle + Math.PI) * radius,
                        y: verticalPos,
                        angle: twistAngle + Math.PI
                    });
                }
                
                // Draw both helix strands with shadows
                    for (let strand = 0; strand < 2; strand++) {
                    const strandColorRGB = strand === 0 ? '0, 255, 136' : '0, 204, 255';
                    const points = strand === 0 ? helixStrand1Points : helixStrand2Points;
                    
                    this.ctx.strokeStyle = `rgba(${strandColorRGB}, ${0.95 * healthPercent})`;
                    this.ctx.lineWidth = 8;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.shadowBlur = 18;
                    this.ctx.shadowColor = `rgba(${strandColorRGB}, 0.7)`;
                        this.ctx.beginPath();
                    for (let i = 0; i < points.length; i++) {
                        if (i === 0) {
                            this.ctx.moveTo(points[i].x, points[i].y);
                                } else {
                            this.ctx.lineTo(points[i].x, points[i].y);
                            }
                        }
                        this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
                
                // Enhanced base pairs - connecting the two helix strands
                const basePairGlowGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, 6);
                basePairGlowGradient.addColorStop(0, `rgba(255, 255, 255, ${0.7 * healthPercent})`);
                basePairGlowGradient.addColorStop(1, 'rgba(0, 255, 136, 0)');
                
                for (let i = 0; i <= 20; i += 3) {
                    if (helixStrand1Points[i] && helixStrand2Points[i]) {
                        const p1 = helixStrand1Points[i];
                        const p2 = helixStrand2Points[i];
                        
                        // Base pair connection with gradient
                        const connectionGradient = this.ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                        connectionGradient.addColorStop(0, `rgba(0, 255, 136, ${0.6 * healthPercent})`);
                        connectionGradient.addColorStop(0.5, `rgba(255, 255, 255, ${0.8 * healthPercent})`);
                        connectionGradient.addColorStop(1, `rgba(0, 204, 255, ${0.6 * healthPercent})`);
                        
                        this.ctx.strokeStyle = connectionGradient;
                        this.ctx.lineWidth = 3;
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                                this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                                this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                        
                        // Base pair nodes at ends
                        this.ctx.save();
                        this.ctx.translate(p1.x, p1.y);
                        this.ctx.fillStyle = basePairGlowGradient;
                            this.ctx.beginPath();
                        this.ctx.arc(0, 0, 6, 0, Math.PI * 2);
                            this.ctx.fill();
                        this.ctx.fillStyle = `rgba(0, 255, 136, ${0.9 * healthPercent})`;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 4, 0, Math.PI * 2);
                            this.ctx.fill();
                        this.ctx.restore();
                        
                        this.ctx.save();
                        this.ctx.translate(p2.x, p2.y);
                        this.ctx.fillStyle = basePairGlowGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.fillStyle = `rgba(0, 204, 255, ${0.9 * healthPercent})`;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                }
                
                // Energy flow particles along helices
                    for (let strand = 0; strand < 2; strand++) {
                    const points = strand === 0 ? helixStrand1Points : helixStrand2Points;
                    const flowPhase = (time * 0.4 + strand * 0.5) % 1;
                    const flowIndex = Math.floor(flowPhase * points.length);
                    if (points[flowIndex]) {
                        const flowPoint = points[flowIndex];
                        const strandColorRGB = strand === 0 ? '0, 255, 136' : '0, 204, 255';
                        
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * healthPercent})`;
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = `rgba(${strandColorRGB}, 0.9)`;
                        this.ctx.beginPath();
                        this.ctx.arc(flowPoint.x, flowPoint.y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                }
                
                // Enhanced central core
                const coreRadius = baseRadius * 0.3 * healthPercent;
                if (coreRadius > 0) {
                    // Core outer glow
                    const coreOuterGlow = this.ctx.createRadialGradient(0, 0, coreRadius * 0.6, 0, 0, coreRadius * 1.8);
                    coreOuterGlow.addColorStop(0, `rgba(139, 0, 255, ${0.4 * healthPercent})`);
                    coreOuterGlow.addColorStop(1, 'rgba(139, 0, 255, 0)');
                    this.ctx.fillStyle = coreOuterGlow;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, coreRadius * 1.8, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Core gradient
                    const coreGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                    coreGradient.addColorStop(0, `rgba(255, 255, 255, ${healthPercent})`);
                    coreGradient.addColorStop(0.3, `rgba(200, 100, 255, ${healthPercent})`);
                    coreGradient.addColorStop(0.7, `rgba(139, 0, 255, ${healthPercent})`);
                    coreGradient.addColorStop(1, `rgba(100, 0, 200, ${healthPercent})`);
                    this.ctx.fillStyle = coreGradient;
                    this.ctx.shadowBlur = 25;
                    this.ctx.shadowColor = 'rgba(139, 0, 255, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                    
                    // Core inner bright center
                    const coreInner = this.ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius * 0.5);
                    coreInner.addColorStop(0, `rgba(255, 255, 255, ${0.8 * healthPercent})`);
                    coreInner.addColorStop(1, 'rgba(200, 100, 255, 0)');
                    this.ctx.fillStyle = coreInner;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, coreRadius * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Enhanced pulsing ring
                    const corePulse = Math.sin(time * 2.5) * 0.5 + 0.5;
                    this.ctx.strokeStyle = `rgba(200, 100, 255, ${0.6 * healthPercent * corePulse})`;
                    this.ctx.lineWidth = 4;
                    this.ctx.shadowBlur = 12;
                    this.ctx.shadowColor = 'rgba(200, 100, 255, 0.6)';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, coreRadius + 5, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                }
            }
        } else if (obstacle.bossType === 'proteinComplex') {
            // Level 45: Protein Complex boss
            if (obstacle.bossPart === 'subunit') {
                // Draw protein subunit (orbiting around core)
                const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
                const currentRadius = Math.max(8, obstacle.size * healthPercent);
                
                // Draw subunit with protein-like structure
                // Outer shell
                this.ctx.fillStyle = obstacle.color || '#ff6b6b';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Inner core
                this.ctx.fillStyle = '#ff4444';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius * 0.6, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Glow effect
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = obstacle.color || '#ff6b6b';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // White outline for visibility
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Draw visual indicator for order instead of number
                // Use different patterns: 1=dot, 2=line, 3=triangle, 4=square
                if (obstacle.subunitOrder) {
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    
                    switch(obstacle.subunitOrder) {
                        case 1:
                            // Single dot in center
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, 4, 0, Math.PI * 2);
                            this.ctx.fill();
                            break;
                        case 2:
                            // Horizontal line
                            this.ctx.beginPath();
                            this.ctx.moveTo(-currentRadius * 0.4, 0);
                            this.ctx.lineTo(currentRadius * 0.4, 0);
                            this.ctx.stroke();
                            break;
                        case 3:
                            // Triangle
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -currentRadius * 0.4);
                            this.ctx.lineTo(-currentRadius * 0.35, currentRadius * 0.3);
                            this.ctx.lineTo(currentRadius * 0.35, currentRadius * 0.3);
                            this.ctx.closePath();
                            this.ctx.stroke();
                            break;
                        case 4:
                            // Square
                            const sqSize = currentRadius * 0.3;
                            this.ctx.strokeRect(-sqSize, -sqSize, sqSize * 2, sqSize * 2);
                            break;
                    }
                }
                
                // Draw connection line to core (if core exists)
                if (this.currentBoss && this.currentBoss.bossPart === 'core') {
                    const dx = this.currentBoss.x - obstacle.x;
                    const dy = this.currentBoss.y - obstacle.y;
                    this.ctx.strokeStyle = 'rgba(255, 107, 107, 0.4)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(dx, dy);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            } else if (obstacle.bossPart === 'core') {
                // Draw protein complex core with detailed structure
                const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
                
                if (obstacle.nodes && obstacle.nodes.length > 0) {
                    // Draw connections from core to subunit positions
                    this.ctx.strokeStyle = 'rgba(139, 0, 255, 0.5)';
                    this.ctx.lineWidth = 3;
                    const coreNode = obstacle.nodes[0];
                    for (let i = 1; i < obstacle.nodes.length; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(coreNode.x, coreNode.y);
                        this.ctx.lineTo(obstacle.nodes[i].x, obstacle.nodes[i].y);
                        this.ctx.stroke();
                    }
                    
                    // Draw nodes with health scaling
                    obstacle.nodes.forEach((node, index) => {
                        const currentRadius = node.radius * healthPercent;
                        if (currentRadius > 0) {
                            // Core node (index 0) is larger and brighter
                            if (index === 0) {
                                // Outer glow
                                this.ctx.fillStyle = '#aa00ff';
                                this.ctx.beginPath();
                                this.ctx.arc(node.x, node.y, currentRadius * 1.2, 0, Math.PI * 2);
                                this.ctx.fill();
                                this.ctx.shadowBlur = 30;
                                this.ctx.shadowColor = '#8b00ff';
                                this.ctx.fill();
                                this.ctx.shadowBlur = 0;
                            }
                            
                            // Main node
                            this.ctx.fillStyle = node.color;
                            this.ctx.beginPath();
                            this.ctx.arc(node.x, node.y, currentRadius, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.shadowBlur = 20;
                            this.ctx.shadowColor = node.color;
                            this.ctx.fill();
                            this.ctx.shadowBlur = 0;
                            
                            // White outline
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 2;
                            this.ctx.stroke();
                        }
                    });
                } else {
                    // Fallback: simple circle if nodes missing
                    const currentRadius = Math.max(20, obstacle.size * healthPercent);
                    this.ctx.fillStyle = obstacle.color || '#8b00ff';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 25;
                    this.ctx.shadowColor = obstacle.color || '#8b00ff';
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                }
            }
        } else if (obstacle.bossType === 'cellMembrane') {
            // Level 60: Cell Membrane boss
            if (obstacle.bossPart === 'outerMembrane') {
                // Draw outer membrane as a thick, pulsing ring
                const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
                const currentRadius = Math.max(30, obstacle.size * healthPercent);
                
                // Outer glow ring
                const gradient = this.ctx.createRadialGradient(0, 0, currentRadius * 0.8, 0, 0, currentRadius);
                gradient.addColorStop(0, 'rgba(255, 170, 0, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 170, 0, 0.8)');
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Main membrane ring (thick border)
                this.ctx.strokeStyle = obstacle.color || '#ffaa00';
                this.ctx.lineWidth = 15;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Inner glow
                this.ctx.shadowBlur = 25;
                this.ctx.shadowColor = obstacle.color || '#ffaa00';
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Label text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('OUTER', 0, -currentRadius * 0.3);
            } else if (obstacle.bossPart === 'innerMembrane') {
                // Draw inner membrane as a medium ring
                const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
                const currentRadius = Math.max(25, obstacle.size * healthPercent);
                
                // Outer glow ring
                const gradient = this.ctx.createRadialGradient(0, 0, currentRadius * 0.8, 0, 0, currentRadius);
                gradient.addColorStop(0, 'rgba(255, 136, 0, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 136, 0, 0.8)');
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Main membrane ring
                this.ctx.strokeStyle = obstacle.color || '#ff8800';
                this.ctx.lineWidth = 12;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Inner glow
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = obstacle.color || '#ff8800';
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Label text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('INNER', 0, -currentRadius * 0.3);
            } else if (obstacle.bossPart === 'nucleus') {
                // Draw nucleus with detailed structure
                const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
                
                if (obstacle.nodes && obstacle.nodes.length > 0) {
                    // Draw connections (organelles to nucleus)
                    this.ctx.strokeStyle = 'rgba(139, 0, 255, 0.4)';
                    this.ctx.lineWidth = 2;
                    const coreNode = obstacle.nodes[0];
                    for (let i = 1; i < obstacle.nodes.length; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(coreNode.x, coreNode.y);
                        this.ctx.lineTo(obstacle.nodes[i].x, obstacle.nodes[i].y);
                        this.ctx.stroke();
                    }
                    
                    // Draw nodes
                    obstacle.nodes.forEach((node, index) => {
                        const currentRadius = node.radius * healthPercent;
                        if (currentRadius > 0) {
                            // Core nucleus (index 0) - large and pulsing
                            if (index === 0) {
                                // Outer glow
                                this.ctx.fillStyle = '#aa00ff';
                                this.ctx.beginPath();
                                this.ctx.arc(node.x, node.y, currentRadius * 1.3, 0, Math.PI * 2);
                                this.ctx.fill();
                                this.ctx.shadowBlur = 35;
                                this.ctx.shadowColor = '#8b00ff';
                                this.ctx.fill();
                                this.ctx.shadowBlur = 0;
                            }
                            
                            // Main node
                            this.ctx.fillStyle = node.color;
                            this.ctx.beginPath();
                            this.ctx.arc(node.x, node.y, currentRadius, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.shadowBlur = 20;
                            this.ctx.shadowColor = node.color;
                            this.ctx.fill();
                            this.ctx.shadowBlur = 0;
                            
                            // White outline
                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 2;
                            this.ctx.stroke();
                        }
                    });
                    
                    // Draw "NUCLEUS" label
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('NUCLEUS', 0, 0);
                } else {
                    // Fallback: simple circle
                    const currentRadius = Math.max(20, obstacle.size * healthPercent);
                    this.ctx.fillStyle = obstacle.color || '#8b00ff';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 30;
                    this.ctx.shadowColor = obstacle.color || '#8b00ff';
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                }
            }
        } else if (obstacle.bossType === 'advanced') {
            // Level 75+: Advanced boss - Quantum Entanglement Network
            // Draw as a complex, multi-layered quantum structure
            const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
            
            if (obstacle.nodes && obstacle.nodes.length > 0) {
                // Draw quantum entanglement connections (all nodes connected)
                this.ctx.strokeStyle = 'rgba(139, 0, 255, 0.3)';
                this.ctx.lineWidth = 2;
                for (let i = 0; i < obstacle.nodes.length; i++) {
                    for (let j = i + 1; j < obstacle.nodes.length; j++) {
                        const dx = obstacle.nodes[i].x - obstacle.nodes[j].x;
                        const dy = obstacle.nodes[i].y - obstacle.nodes[j].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        // Connect nodes that are relatively close
                        if (dist < obstacle.size * 1.2) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(obstacle.nodes[i].x, obstacle.nodes[i].y);
                            this.ctx.lineTo(obstacle.nodes[j].x, obstacle.nodes[j].y);
                            this.ctx.stroke();
                        }
                    }
                }
                
                // Draw quantum field effect (pulsing rings)
                const pulseTime = this.time * 2;
                for (let ring = 0; ring < 3; ring++) {
                    const ringRadius = Math.max(0.1, (obstacle.size * 0.3) + Math.sin(pulseTime + ring) * 10);
                    const alpha = 0.2 - (ring * 0.05);
                    this.ctx.strokeStyle = `rgba(139, 0, 255, ${alpha})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Draw nodes with quantum glow effect
                obstacle.nodes.forEach((node, index) => {
                    const currentRadius = node.radius * healthPercent;
                    if (currentRadius > 0) {
                        // Core node (index 0) - brightest
                        if (index === 0) {
                            // Multiple glow layers
                            for (let glow = 0; glow < 3; glow++) {
                                const glowRadius = currentRadius * (1.2 + glow * 0.2);
                                const glowAlpha = 0.3 - (glow * 0.1);
                                this.ctx.fillStyle = `rgba(139, 0, 255, ${glowAlpha})`;
                                this.ctx.beginPath();
                                this.ctx.arc(node.x, node.y, glowRadius, 0, Math.PI * 2);
                                this.ctx.fill();
                            }
                        }
                        
                        // Main node with pulsing effect
                        const pulse = 1 + Math.sin(pulseTime + index) * 0.1;
                        const pulseRadius = currentRadius * pulse;
                        
                        this.ctx.fillStyle = node.color;
                        this.ctx.beginPath();
                        this.ctx.arc(node.x, node.y, pulseRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Quantum glow
                        this.ctx.shadowBlur = 25;
                        this.ctx.shadowColor = node.color;
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                        
                        // Bright outline
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                        
                        // Quantum sparkle effect (random particles)
                        if (Math.random() < 0.1) {
                            this.ctx.fillStyle = '#ffffff';
                            this.ctx.beginPath();
                            this.ctx.arc(
                                node.x + (Math.random() - 0.5) * currentRadius * 2,
                                node.y + (Math.random() - 0.5) * currentRadius * 2,
                                2, 0, Math.PI * 2
                            );
                            this.ctx.fill();
                        }
                    }
                });
            } else {
                // Fallback: impressive quantum sphere
                const currentRadius = Math.max(25, obstacle.size * healthPercent);
                const pulseTime = this.time * 2;
                const pulse = 1 + Math.sin(pulseTime) * 0.1;
                
                // Outer quantum field
                for (let ring = 0; ring < 4; ring++) {
                    const ringRadius = currentRadius * (1.2 + ring * 0.15);
                    const alpha = 0.15 - (ring * 0.03);
                    this.ctx.strokeStyle = `rgba(139, 0, 255, ${alpha})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Main sphere with gradient
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, currentRadius * pulse);
                gradient.addColorStop(0, '#aa00ff');
                gradient.addColorStop(0.5, '#8b00ff');
                gradient.addColorStop(1, '#6b00aa');
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius * pulse, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Quantum glow
                this.ctx.shadowBlur = 40;
                this.ctx.shadowColor = '#8b00ff';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Bright outline
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 4;
                this.ctx.stroke();
            }
        } else {
            // Generic fallback for unknown boss types
            if (!obstacle.nodes || obstacle.nodes.length === 0) {
                // Simple circle fallback
                const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
                const currentRadius = Math.max(15, obstacle.size * healthPercent);
                this.ctx.fillStyle = obstacle.color || '#8b00ff';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = obstacle.color || '#8b00ff';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                return;
            }
            
            // Generic neural network structure
            this.ctx.strokeStyle = 'rgba(139, 0, 255, 0.4)';
            this.ctx.lineWidth = 3;
            const coreNode = obstacle.nodes[0];
            for (let i = 1; i < obstacle.nodes.length; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(coreNode.x, coreNode.y);
                this.ctx.lineTo(obstacle.nodes[i].x, obstacle.nodes[i].y);
                this.ctx.stroke();
            }
            
            const healthPercent = Math.max(0, obstacle.health / obstacle.maxHealth);
            obstacle.nodes.forEach(node => {
                const currentRadius = node.radius * healthPercent;
                if (currentRadius > 0) {
                    this.ctx.fillStyle = node.color;
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, currentRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = node.color;
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
            });
        }
    }

    drawItems() {
        const hasAutoCollector = this.currentUpgrades.includes('autoCollector');
        const time = this.time || 0;
        
        this.items.forEach(item => {
            const itemSize = item.size || 8;
            const pulseIntensity = 0.7 + Math.sin(time * 2 + item.x * 0.1) * 0.3;
            
            // Draw attraction line to player if auto-collector is active
            // OPTIMIZED: Use solid colors, limit particles, only show for closer items
            if (hasAutoCollector) {
                const dx = this.player.x - item.x;
                const dy = this.player.y - item.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // OPTIMIZED: Only draw for items within 500px (reduced from 800px)
                if (dist > 0 && dist < 500) {
                    const lineAlpha = Math.max(0.2, 1 - dist / 500);
                    
                    // OPTIMIZED: Use solid color instead of gradient
                    this.ctx.strokeStyle = `rgba(0, 188, 212, ${0.5 * lineAlpha})`;
                    this.ctx.lineWidth = 1.5;
                    this.ctx.setLineDash([4, 4]);
                    // OPTIMIZED: Reduced shadow blur
                    this.ctx.shadowBlur = 4;
                    this.ctx.shadowColor = 'rgba(0, 188, 212, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(item.x, item.y);
                    this.ctx.lineTo(this.player.x, this.player.y);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                    this.ctx.setLineDash([]);
                    
                    // OPTIMIZED: Reduced particle count and limit to max 8 particles
                    const particleCount = Math.min(8, Math.floor(dist / 50)); // Reduced frequency
                    for (let i = 1; i <= particleCount; i++) {
                        const particleProgress = (i / (particleCount + 1)) + (time * 2) % 1;
                        if (particleProgress > 1) continue;
                        const particleX = item.x + dx * particleProgress;
                        const particleY = item.y + dy * particleProgress;
                        const particleSize = 1.5 + Math.sin(time * 5 + i) * 0.5;
                        
                        this.ctx.fillStyle = `rgba(0, 255, 255, ${0.7 * lineAlpha * (1 - particleProgress)})`;
                        // OPTIMIZED: Reduced shadow blur
                        this.ctx.shadowBlur = 4;
                        this.ctx.shadowColor = 'rgba(0, 188, 212, 0.4)';
                        this.ctx.beginPath();
                        this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                }
            }
            
            this.ctx.save();
            this.ctx.translate(item.x, item.y);
            
            if (item.type === 'quantumParticles') {
                // Enhanced Quantum Particles - purple atomic design
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#ba68c8');
                gradient.addColorStop(0.4, '#9c27b0');
                gradient.addColorStop(0.8, '#7b1fa2');
                gradient.addColorStop(1, '#6a1b9a');
                this.ctx.fillStyle = gradient;
                
                // Main particle sphere
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Quantum field rings (orbiting)
                this.ctx.strokeStyle = `rgba(186, 104, 200, ${0.6 * pulseIntensity})`;
                this.ctx.lineWidth = 1.5;
                for (let i = 0; i < 2; i++) {
                    const ringAngle = time * 0.5 + i * Math.PI;
                    const ringRadius = itemSize * 0.6;
                    const ringX = Math.cos(ringAngle) * ringRadius;
                    const ringY = Math.sin(ringAngle) * ringRadius;
                    this.ctx.beginPath();
                    this.ctx.arc(ringX, ringY, itemSize * 0.3, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Core glow
                this.ctx.fillStyle = `rgba(186, 104, 200, ${0.9 * pulseIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
                
            } else if (item.type === 'crystals') {
                // Enhanced Crystals - cyan crystal design
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#4dd0e1');
                gradient.addColorStop(0.3, '#00bcd4');
                gradient.addColorStop(0.7, '#0097a7');
                gradient.addColorStop(1, '#00838f');
                this.ctx.fillStyle = gradient;
                
                // Crystal shape - hexagonal
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = Math.cos(angle) * itemSize;
                    const y = Math.sin(angle) * itemSize;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                // Crystal facets
                this.ctx.strokeStyle = `rgba(77, 208, 225, ${0.8 * pulseIntensity})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.stroke();
                
                // Inner crystal core
                this.ctx.fillStyle = `rgba(0, 188, 212, ${0.9 * pulseIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 0.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Crystal sparkles
                this.ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * pulseIntensity})`;
                for (let i = 0; i < 3; i++) {
                    const sparkleAngle = time * 2 + i * (Math.PI * 2 / 3);
                    const sparkleDist = itemSize * 0.7;
                    this.ctx.beginPath();
                    this.ctx.arc(Math.cos(sparkleAngle) * sparkleDist, Math.sin(sparkleAngle) * sparkleDist, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
            } else if (item.type === 'energyCores') {
                // Enhanced Energy Cores - orange energy design
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#ffb74d');
                gradient.addColorStop(0.3, '#ff9800');
                gradient.addColorStop(0.7, '#f57c00');
                gradient.addColorStop(1, '#e65100');
                this.ctx.fillStyle = gradient;
                
                // Energy core sphere
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Energy waves (pulsing)
                this.ctx.strokeStyle = `rgba(255, 152, 0, ${0.7 * pulseIntensity})`;
                this.ctx.lineWidth = 2;
                for (let i = 1; i <= 2; i++) {
                    const waveRadius = itemSize * (0.5 + i * 0.3) * pulseIntensity;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, waveRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Core center - bright
                this.ctx.fillStyle = `rgba(255, 183, 77, ${0.95 * pulseIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 0.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Energy particles
                this.ctx.fillStyle = `rgba(255, 152, 0, ${0.8 * pulseIntensity})`;
                for (let i = 0; i < 4; i++) {
                    const particleAngle = time * 1.5 + i * (Math.PI * 2 / 4);
                    const particleDist = itemSize * 0.75;
                    this.ctx.beginPath();
                    this.ctx.arc(Math.cos(particleAngle) * particleDist, Math.sin(particleAngle) * particleDist, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
            } else if (item.type === 'metalScraps') {
                // Enhanced Metal Scraps - metallic design
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#bdbdbd');
                gradient.addColorStop(0.4, '#9e9e9e');
                gradient.addColorStop(0.8, '#757575');
                gradient.addColorStop(1, '#616161');
                this.ctx.fillStyle = gradient;
                
                // Metal scrap shape - irregular angular
                this.ctx.beginPath();
                this.ctx.moveTo(itemSize * 0.8, -itemSize * 0.3);
                this.ctx.lineTo(itemSize * 0.4, -itemSize * 0.9);
                this.ctx.lineTo(-itemSize * 0.2, -itemSize * 0.7);
                this.ctx.lineTo(-itemSize * 0.8, -itemSize * 0.2);
                this.ctx.lineTo(-itemSize * 0.6, itemSize * 0.5);
                this.ctx.lineTo(-itemSize * 0.1, itemSize * 0.9);
                this.ctx.lineTo(itemSize * 0.5, itemSize * 0.7);
                this.ctx.lineTo(itemSize * 0.9, itemSize * 0.2);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Metallic highlights
                this.ctx.strokeStyle = 'rgba(189, 189, 189, 0.8)';
                this.ctx.lineWidth = 1.5;
                this.ctx.stroke();
                
                // Metal surface details
                this.ctx.fillStyle = 'rgba(158, 158, 158, 0.6)';
                this.ctx.beginPath();
                this.ctx.moveTo(itemSize * 0.3, -itemSize * 0.5);
                this.ctx.lineTo(-itemSize * 0.3, -itemSize * 0.3);
                this.ctx.lineTo(-itemSize * 0.2, itemSize * 0.4);
                this.ctx.lineTo(itemSize * 0.4, itemSize * 0.3);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Metallic shine
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.beginPath();
                this.ctx.arc(itemSize * 0.3, -itemSize * 0.4, itemSize * 0.2, 0, Math.PI * 2);
                this.ctx.fill();
            } else if (item.type === 'atp') {
                // Enhanced ATP (Adenosine Triphosphate) - DISTINCT energy currency molecule
                // Outer glow - bright yellow/orange
                const outerGlow = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize * 2);
                outerGlow.addColorStop(0, 'rgba(255, 235, 59, 0.6)');
                outerGlow.addColorStop(0.5, 'rgba(255, 193, 7, 0.3)');
                outerGlow.addColorStop(1, 'rgba(255, 152, 0, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Main ATP molecule - triangular shape (distinct from circular regular materials)
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#ffeb3b'); // Bright yellow center (energy)
                gradient.addColorStop(0.3, '#ffc107'); // Yellow
                gradient.addColorStop(0.7, '#ff9800'); // Orange-yellow
                gradient.addColorStop(1, '#f57c00'); // Dark orange edge
                this.ctx.fillStyle = gradient;
                
                // Triangle shape (distinct from regular materials)
                this.ctx.beginPath();
                this.ctx.moveTo(0, -itemSize);
                this.ctx.lineTo(-itemSize * 0.866, itemSize * 0.5);
                this.ctx.lineTo(itemSize * 0.866, itemSize * 0.5);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Enhanced glow effect
                this.ctx.shadowBlur = itemSize * 2;
                this.ctx.shadowColor = '#ffeb3b';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Energy rings (pulsing) - more visible
                this.ctx.strokeStyle = `rgba(255, 235, 59, ${0.9 * pulseIntensity})`;
                this.ctx.lineWidth = 2;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = 'rgba(255, 235, 59, 0.8)';
                for (let i = 1; i <= 3; i++) {
                    const ringRadius = Math.max(0.1, itemSize * (0.7 + i * 0.15) * pulseIntensity);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                this.ctx.shadowBlur = 0;
                
                // Energy particles (orbiting) - more particles
                this.ctx.fillStyle = `rgba(255, 255, 200, ${0.95 * pulseIntensity})`;
                this.ctx.shadowBlur = 6;
                this.ctx.shadowColor = 'rgba(255, 235, 59, 0.9)';
                for (let i = 0; i < 4; i++) {
                    const particleAngle = time * 3 + i * (Math.PI * 2 / 4);
                    const particleDist = itemSize * 0.8;
                    this.ctx.beginPath();
                    this.ctx.arc(Math.cos(particleAngle) * particleDist, Math.sin(particleAngle) * particleDist, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.shadowBlur = 0;
                
            } else if (item.type === 'aminoAcids') {
                // Enhanced Amino Acids - DISTINCT protein building blocks
                // Outer glow - bright green
                const outerGlow = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize * 1.8);
                outerGlow.addColorStop(0, 'rgba(129, 199, 132, 0.5)');
                outerGlow.addColorStop(0.5, 'rgba(76, 175, 80, 0.3)');
                outerGlow.addColorStop(1, 'rgba(56, 142, 60, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 1.8, 0, Math.PI * 2);
                this.ctx.fill();
                
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#81c784'); // Bright green center
                gradient.addColorStop(0.3, '#66bb6a'); // Green
                gradient.addColorStop(0.7, '#4caf50'); // Medium green
                gradient.addColorStop(1, '#388e3c'); // Dark green edge
                this.ctx.fillStyle = gradient;
                
                // Amino acid shape - hexagonal (DISTINCT from regular materials)
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = Math.cos(angle) * itemSize;
                    const y = Math.sin(angle) * itemSize;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                // Enhanced glow
                this.ctx.shadowBlur = itemSize * 1.5;
                this.ctx.shadowColor = '#81c784';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Protein bond lines - more visible
                this.ctx.strokeStyle = `rgba(129, 199, 132, ${0.9 * pulseIntensity})`;
                this.ctx.lineWidth = 2;
                this.ctx.shadowBlur = 6;
                this.ctx.shadowColor = 'rgba(76, 175, 80, 0.7)';
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Inner core - brighter
                this.ctx.fillStyle = `rgba(129, 199, 132, ${0.95 * pulseIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 0.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Protein structure particles (orbiting)
                this.ctx.fillStyle = `rgba(200, 255, 200, ${0.8 * pulseIntensity})`;
                this.ctx.shadowBlur = 5;
                this.ctx.shadowColor = 'rgba(76, 175, 80, 0.8)';
                for (let i = 0; i < 3; i++) {
                    const particleAngle = time * 2 + i * (Math.PI * 2 / 3);
                    const particleDist = itemSize * 0.75;
                    this.ctx.beginPath();
                    this.ctx.arc(Math.cos(particleAngle) * particleDist, Math.sin(particleAngle) * particleDist, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.shadowBlur = 0;
                
            } else if (item.type === 'simpleSugars') {
                // Enhanced Simple Sugars - DISTINCT carbohydrate molecules
                // Outer glow - bright yellow-white
                const outerGlow = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize * 1.8);
                outerGlow.addColorStop(0, 'rgba(255, 249, 196, 0.6)');
                outerGlow.addColorStop(0.5, 'rgba(255, 245, 157, 0.3)');
                outerGlow.addColorStop(1, 'rgba(253, 216, 53, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 1.8, 0, Math.PI * 2);
                this.ctx.fill();
                
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#fff9c4'); // Bright yellow-white center
                gradient.addColorStop(0.3, '#fff59d'); // Light yellow
                gradient.addColorStop(0.7, '#fdd835'); // Yellow
                gradient.addColorStop(1, '#f9a825'); // Dark yellow edge
                this.ctx.fillStyle = gradient;
                
                // Sugar molecule shape - star shape (DISTINCT from regular materials)
                this.ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                    const outerX = Math.cos(angle) * itemSize;
                    const outerY = Math.sin(angle) * itemSize;
                    const innerAngle = angle + (Math.PI * 2) / 10;
                    const innerX = Math.cos(innerAngle) * itemSize * 0.5;
                    const innerY = Math.sin(innerAngle) * itemSize * 0.5;
                    if (i === 0) this.ctx.moveTo(outerX, outerY);
                    else this.ctx.lineTo(outerX, outerY);
                    this.ctx.lineTo(innerX, innerY);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                // Enhanced glow
                this.ctx.shadowBlur = itemSize * 1.8;
                this.ctx.shadowColor = '#fff9c4';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Sweet sparkles - more and brighter
                this.ctx.fillStyle = `rgba(255, 255, 255, ${0.95 * pulseIntensity})`;
                this.ctx.shadowBlur = 6;
                this.ctx.shadowColor = 'rgba(255, 249, 196, 0.9)';
                for (let i = 0; i < 6; i++) {
                    const sparkleAngle = time * 2 + i * (Math.PI * 2 / 6);
                    const sparkleDist = itemSize * 0.8;
                    this.ctx.beginPath();
                    this.ctx.arc(Math.cos(sparkleAngle) * sparkleDist, Math.sin(sparkleAngle) * sparkleDist, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.shadowBlur = 0;
                
            } else if (item.type === 'fattyAcids') {
                // Enhanced Fatty Acids - DISTINCT lipid molecules
                // Outer glow - orange
                const outerGlow = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize * 1.8);
                outerGlow.addColorStop(0, 'rgba(255, 204, 188, 0.5)');
                outerGlow.addColorStop(0.5, 'rgba(255, 171, 145, 0.3)');
                outerGlow.addColorStop(1, 'rgba(255, 112, 67, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 1.8, 0, Math.PI * 2);
                this.ctx.fill();
                
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#ffccbc'); // Light orange center
                gradient.addColorStop(0.3, '#ffab91'); // Orange
                gradient.addColorStop(0.7, '#ff8a65'); // Medium orange
                gradient.addColorStop(1, '#ff7043'); // Dark orange edge
                this.ctx.fillStyle = gradient;
                
                // Fatty acid shape - droplet-like (DISTINCT from regular materials)
                this.ctx.beginPath();
                this.ctx.ellipse(0, 0, itemSize, itemSize * 0.7, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Enhanced glow
                this.ctx.shadowBlur = itemSize * 1.6;
                this.ctx.shadowColor = '#ffccbc';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Lipid membrane effect - more visible
                this.ctx.strokeStyle = `rgba(255, 171, 145, ${0.9 * pulseIntensity})`;
                this.ctx.lineWidth = 2;
                this.ctx.shadowBlur = 6;
                this.ctx.shadowColor = 'rgba(255, 112, 67, 0.7)';
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
            } else if (item.type === 'nucleotides') {
                // Enhanced Nucleotides - DISTINCT DNA/RNA building blocks
                // Outer glow - purple
                const outerGlow = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize * 1.8);
                outerGlow.addColorStop(0, 'rgba(206, 147, 216, 0.5)');
                outerGlow.addColorStop(0.5, 'rgba(186, 104, 200, 0.3)');
                outerGlow.addColorStop(1, 'rgba(156, 39, 176, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 1.8, 0, Math.PI * 2);
                this.ctx.fill();
                
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#ce93d8'); // Light purple center
                gradient.addColorStop(0.3, '#ba68c8'); // Purple
                gradient.addColorStop(0.7, '#ab47bc'); // Medium purple
                gradient.addColorStop(1, '#9c27b0'); // Dark purple edge
                this.ctx.fillStyle = gradient;
                
                // Nucleotide shape - double helix inspired (DISTINCT - diamond/octagon shape)
                this.ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8 - Math.PI / 4;
                    const x = Math.cos(angle) * itemSize;
                    const y = Math.sin(angle) * itemSize;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                // Enhanced glow
                this.ctx.shadowBlur = itemSize * 1.7;
                this.ctx.shadowColor = '#ce93d8';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Helix spiral effect - more visible
                this.ctx.strokeStyle = `rgba(186, 104, 200, ${0.9 * pulseIntensity})`;
                this.ctx.lineWidth = 2.5;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = 'rgba(156, 39, 176, 0.8)';
                this.ctx.setLineDash([4, 3]);
                for (let i = 0; i < 3; i++) {
                    const helixRadius = itemSize * (0.5 + i * 0.2);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, helixRadius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                this.ctx.setLineDash([]);
                this.ctx.shadowBlur = 0;
                
            } else if (item.type === 'vitamins') {
                // Enhanced Vitamins - DISTINCT micronutrients
                // Outer glow - bright pink
                const outerGlow = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize * 2);
                outerGlow.addColorStop(0, 'rgba(255, 110, 199, 0.6)');
                outerGlow.addColorStop(0.5, 'rgba(255, 64, 129, 0.3)');
                outerGlow.addColorStop(1, 'rgba(233, 30, 99, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#ff6ec7'); // Bright pink center
                gradient.addColorStop(0.3, '#ff4081'); // Pink
                gradient.addColorStop(0.7, '#e91e63'); // Medium pink
                gradient.addColorStop(1, '#c2185b'); // Dark pink edge
                this.ctx.fillStyle = gradient;
                
                // Vitamin shape - star-like (DISTINCT - 6-pointed star)
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i) / 6 - Math.PI / 2;
                    const outerX = Math.cos(angle) * itemSize;
                    const outerY = Math.sin(angle) * itemSize;
                    const innerAngle = angle + (Math.PI * 2) / 12;
                    const innerX = Math.cos(innerAngle) * itemSize * 0.5;
                    const innerY = Math.sin(innerAngle) * itemSize * 0.5;
                    if (i === 0) this.ctx.moveTo(outerX, outerY);
                    else this.ctx.lineTo(outerX, outerY);
                    this.ctx.lineTo(innerX, innerY);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                // Enhanced glow
                this.ctx.shadowBlur = itemSize * 2;
                this.ctx.shadowColor = '#ff6ec7';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Vitamin sparkles - more and brighter
                this.ctx.fillStyle = `rgba(255, 255, 255, ${0.95 * pulseIntensity})`;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = 'rgba(255, 110, 199, 0.9)';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 0.35, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Orbiting vitamin particles
                this.ctx.fillStyle = `rgba(255, 200, 255, ${0.9 * pulseIntensity})`;
                this.ctx.shadowBlur = 6;
                this.ctx.shadowColor = 'rgba(255, 64, 129, 0.8)';
                for (let i = 0; i < 4; i++) {
                    const particleAngle = time * 2.5 + i * (Math.PI * 2 / 4);
                    const particleDist = itemSize * 0.85;
                    this.ctx.beginPath();
                    this.ctx.arc(Math.cos(particleAngle) * particleDist, Math.sin(particleAngle) * particleDist, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.shadowBlur = 0;
                
            } else if (item.type === 'minerals') {
                // Enhanced Minerals - DISTINCT essential minerals
                // Outer glow - blue-gray
                const outerGlow = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize * 1.8);
                outerGlow.addColorStop(0, 'rgba(176, 190, 197, 0.5)');
                outerGlow.addColorStop(0.5, 'rgba(144, 164, 174, 0.3)');
                outerGlow.addColorStop(1, 'rgba(96, 125, 139, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize * 1.8, 0, Math.PI * 2);
                this.ctx.fill();
                
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, itemSize);
                gradient.addColorStop(0, '#b0bec5'); // Light blue-gray center
                gradient.addColorStop(0.3, '#90a4ae'); // Blue-gray
                gradient.addColorStop(0.7, '#78909c'); // Medium blue-gray
                gradient.addColorStop(1, '#607d8b'); // Dark blue-gray edge
                this.ctx.fillStyle = gradient;
                
                // Mineral shape - square/octagon (DISTINCT from regular materials)
                this.ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    const x = Math.cos(angle) * itemSize;
                    const y = Math.sin(angle) * itemSize;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                // Enhanced glow
                this.ctx.shadowBlur = itemSize * 1.5;
                this.ctx.shadowColor = '#b0bec5';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Crystalline facets - more visible
                this.ctx.strokeStyle = `rgba(176, 190, 197, ${0.9 * pulseIntensity})`;
                this.ctx.lineWidth = 2;
                this.ctx.shadowBlur = 6;
                this.ctx.shadowColor = 'rgba(144, 164, 174, 0.7)';
                for (let i = 0; i < 4; i++) {
                    const facetAngle = (Math.PI * 2 * i) / 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(Math.cos(facetAngle) * itemSize, Math.sin(facetAngle) * itemSize);
                    this.ctx.stroke();
                }
                this.ctx.shadowBlur = 0;
                
                // Metallic shine - brighter
                this.ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * pulseIntensity})`;
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = 'rgba(176, 190, 197, 0.9)';
                this.ctx.beginPath();
                this.ctx.arc(itemSize * 0.3, -itemSize * 0.3, itemSize * 0.25, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            } else {
                // Default fallback
                this.ctx.fillStyle = '#fff';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, itemSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            this.ctx.restore();
        });
    }
    
    drawAutoCollectorField() {
        // Only draw if auto-collector is equipped
        if (!this.currentUpgrades.includes('autoCollector')) {
            return;
        }
        
        const time = this.time || 0;
        const pulsePhase = Math.sin(time * 3) * 0.3 + 0.7;
        
        // Magnetic field radius (visible range of attraction)
        const fieldRadius = 800;
        
        // Outer magnetic field glow
        const outerGlow = this.ctx.createRadialGradient(
            this.player.x, this.player.y, 0,
            this.player.x, this.player.y, fieldRadius
        );
        outerGlow.addColorStop(0, 'rgba(0, 188, 212, 0.15)');
        outerGlow.addColorStop(0.3, 'rgba(77, 208, 225, 0.1)');
        outerGlow.addColorStop(0.6, 'rgba(0, 188, 212, 0.05)');
        outerGlow.addColorStop(1, 'rgba(0, 188, 212, 0)');
        
        this.ctx.fillStyle = outerGlow;
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, fieldRadius, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Pulsing magnetic field rings
        for (let i = 0; i < 3; i++) {
            const ringRadius = fieldRadius * (0.6 + i * 0.15);
            const ringAlpha = (0.3 - i * 0.08) * pulsePhase;
            const ringPulse = Math.sin(time * 2 + i) * 0.1 + 1;
            
            this.ctx.strokeStyle = `rgba(0, 188, 212, ${ringAlpha * ringPulse})`;
            this.ctx.lineWidth = 2 - i * 0.3;
            this.ctx.setLineDash([8 + i * 2, 6 + i * 2]);
            this.ctx.shadowBlur = 10 - i * 2;
            this.ctx.shadowColor = 'rgba(0, 188, 212, 0.4)';
            this.ctx.beginPath();
            this.ctx.arc(this.player.x, this.player.y, ringRadius * ringPulse, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
        }
        this.ctx.setLineDash([]);
        
        // Magnetic field particles (orbiting around player)
        // OPTIMIZED: Reduced particle count
        const particleCount = 8; // Reduced from 12
        for (let i = 0; i < particleCount; i++) {
            const particleAngle = time * 1.5 + (i / particleCount) * Math.PI * 2;
            const particleRadius = fieldRadius * (0.4 + Math.sin(time * 2 + i) * 0.1);
            const particleX = this.player.x + Math.cos(particleAngle) * particleRadius;
            const particleY = this.player.y + Math.sin(particleAngle) * particleRadius;
            const particleSize = 2 + Math.sin(time * 4 + i) * 0.5;
            
            this.ctx.fillStyle = `rgba(0, 255, 255, ${0.6 * pulsePhase})`;
            // OPTIMIZED: Reduced shadow blur
            this.ctx.shadowBlur = 5;
            this.ctx.shadowColor = 'rgba(0, 188, 212, 0.5)';
            this.ctx.beginPath();
            this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
        
        // Center magnetic core (at player position)
        const coreSize = 15 + Math.sin(time * 4) * 2;
        const coreGradient = this.ctx.createRadialGradient(
            this.player.x, this.player.y, 0,
            this.player.x, this.player.y, coreSize
        );
        coreGradient.addColorStop(0, `rgba(0, 255, 255, ${0.8 * pulsePhase})`);
        coreGradient.addColorStop(0.5, `rgba(77, 208, 225, ${0.5 * pulsePhase})`);
        coreGradient.addColorStop(1, `rgba(0, 188, 212, 0)`);
        
        this.ctx.fillStyle = coreGradient;
        // OPTIMIZED: Reduced shadow blur
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = 'rgba(0, 255, 255, 0.6)';
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, coreSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
    }
    
    drawCompleteDescriptionMatrix() {
        // Only draw if complete description matrix is equipped
        if (!this.currentUpgrades.includes('completeDescriptionMatrix')) {
            return;
        }
        
        const time = this.time || 0;
        const pulsePhase = Math.sin(time * 2.5) * 0.3 + 0.7;
        
        // Complete description matrix field radius
        const fieldRadius = 120;
        
        // Outer complete description field glow - purple/violet theme
        const outerGlow = this.ctx.createRadialGradient(
            this.player.x, this.player.y, 0,
            this.player.x, this.player.y, fieldRadius
        );
        outerGlow.addColorStop(0, 'rgba(139, 0, 255, 0.2)');
        outerGlow.addColorStop(0.4, 'rgba(156, 39, 176, 0.15)');
        outerGlow.addColorStop(0.7, 'rgba(123, 31, 162, 0.1)');
        outerGlow.addColorStop(1, 'rgba(139, 0, 255, 0)');
        
        this.ctx.fillStyle = outerGlow;
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, fieldRadius, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Complete description matrix rings - showing complete system description
        for (let i = 0; i < 3; i++) {
            const ringRadius = fieldRadius * (0.5 + i * 0.2);
            const ringAlpha = (0.5 - i * 0.12) * pulsePhase;
            const ringPulse = Math.sin(time * 2 + i * 0.5) * 0.1 + 1;
            
            this.ctx.strokeStyle = `rgba(139, 0, 255, ${ringAlpha * ringPulse})`;
            this.ctx.lineWidth = 2.5 - i * 0.4;
            this.ctx.setLineDash([6 + i * 2, 4 + i * 2]);
            this.ctx.shadowBlur = 12 - i * 2;
            this.ctx.shadowColor = 'rgba(139, 0, 255, 0.6)';
            this.ctx.beginPath();
            this.ctx.arc(this.player.x, this.player.y, ringRadius * ringPulse, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
        }
        this.ctx.setLineDash([]);
        
        // Complete description particles (orbiting around player)
        // OPTIMIZED: Reduced particle count
        const particleCount = 6; // Reduced from 8
        for (let i = 0; i < particleCount; i++) {
            const particleAngle = time * 2 + (i / particleCount) * Math.PI * 2;
            const particleRadius = fieldRadius * (0.6 + Math.sin(time * 3 + i) * 0.1);
            const particleX = this.player.x + Math.cos(particleAngle) * particleRadius;
            const particleY = this.player.y + Math.sin(particleAngle) * particleRadius;
            const particleSize = 2.5 + Math.sin(time * 4 + i) * 0.6;
            
            // Alternating purple shades
            const particleColor = i % 2 === 0 ? '139, 0, 255' : '186, 104, 200';
            this.ctx.fillStyle = `rgba(${particleColor}, ${0.7 * pulsePhase})`;
            // OPTIMIZED: Reduced shadow blur
            this.ctx.shadowBlur = 6;
            this.ctx.shadowColor = `rgba(${particleColor}, 0.6)`;
            this.ctx.beginPath();
            this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
        
        // Complete description matrix core (at player position)
        const coreSize = 12 + Math.sin(time * 3) * 1.5;
        const coreGradient = this.ctx.createRadialGradient(
            this.player.x, this.player.y, 0,
            this.player.x, this.player.y, coreSize
        );
        coreGradient.addColorStop(0, `rgba(186, 104, 200, ${0.9 * pulsePhase})`);
        coreGradient.addColorStop(0.4, `rgba(156, 39, 176, ${0.7 * pulsePhase})`);
        coreGradient.addColorStop(0.8, `rgba(139, 0, 255, ${0.5 * pulsePhase})`);
        coreGradient.addColorStop(1, `rgba(139, 0, 255, 0)`);
        
        this.ctx.fillStyle = coreGradient;
        // OPTIMIZED: Reduced shadow blur
        this.ctx.shadowBlur = 11;
        this.ctx.shadowColor = 'rgba(139, 0, 255, 0.7)';
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, coreSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Complete description matrix pattern (geometric pattern showing complete description)
        this.ctx.save();
        this.ctx.translate(this.player.x, this.player.y);
        this.ctx.rotate(time * 1.5);
        
        // Draw geometric pattern (hexagon/octagon shape)
        const patternSize = fieldRadius * 0.7;
        this.ctx.strokeStyle = `rgba(139, 0, 255, ${0.4 * pulsePhase})`;
        this.ctx.lineWidth = 2;
        this.ctx.shadowBlur = 8;
        this.ctx.shadowColor = 'rgba(139, 0, 255, 0.5)';
        
        // Hexagon pattern
        this.ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const x = Math.cos(angle) * patternSize;
            const y = Math.sin(angle) * patternSize;
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.closePath();
        this.ctx.stroke();
        
        // Inner connections (complete description lines)
        this.ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle1 = (Math.PI / 3) * i;
            const angle2 = (Math.PI / 3) * ((i + 2) % 6);
            const x1 = Math.cos(angle1) * patternSize * 0.5;
            const y1 = Math.sin(angle1) * patternSize * 0.5;
            const x2 = Math.cos(angle2) * patternSize * 0.5;
            const y2 = Math.sin(angle2) * patternSize * 0.5;
            
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
        }
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        this.ctx.restore();
    }
    
    drawEnsembleBypass() {
        // Only draw if ensemble bypass is equipped
        if (!this.currentUpgrades.includes('ensembleBypass')) {
            return;
        }
        
        const time = this.time || 0;
        const pulsePhase = Math.sin(time * 3) * 0.3 + 0.7;
        
        // Ensemble bypass field radius
        const fieldRadius = 150;
        
        // Outer ensemble bypass field glow - gold/amber theme (bypassing ensemble)
        const outerGlow = this.ctx.createRadialGradient(
            this.player.x, this.player.y, 0,
            this.player.x, this.player.y, fieldRadius
        );
        outerGlow.addColorStop(0, 'rgba(255, 193, 7, 0.25)');
        outerGlow.addColorStop(0.3, 'rgba(255, 152, 0, 0.2)');
        outerGlow.addColorStop(0.6, 'rgba(255, 193, 7, 0.15)');
        outerGlow.addColorStop(1, 'rgba(255, 152, 0, 0)');
        
        this.ctx.fillStyle = outerGlow;
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, fieldRadius, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Ensemble bypass rings - showing bypass of ensemble limitations
        for (let i = 0; i < 4; i++) {
            const ringRadius = fieldRadius * (0.5 + i * 0.15);
            const ringAlpha = (0.6 - i * 0.12) * pulsePhase;
            const ringPulse = Math.sin(time * 2.5 + i * 0.4) * 0.15 + 1;
            
            this.ctx.strokeStyle = `rgba(255, 193, 7, ${ringAlpha * ringPulse})`;
            this.ctx.lineWidth = 2.5 - i * 0.3;
            this.ctx.setLineDash([8 + i * 2, 3 + i]);
            this.ctx.shadowBlur = 14 - i * 2;
            this.ctx.shadowColor = 'rgba(255, 193, 7, 0.7)';
            this.ctx.beginPath();
            this.ctx.arc(this.player.x, this.player.y, ringRadius * ringPulse, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
        }
        this.ctx.setLineDash([]);
        
        // Speed trail particles (showing increased movement speed)
        // OPTIMIZED: Reduced particle count
        const particleCount = 7; // Reduced from 10
        for (let i = 0; i < particleCount; i++) {
            const particleAngle = time * 3 + (i / particleCount) * Math.PI * 2;
            const particleRadius = fieldRadius * (0.55 + Math.sin(time * 4 + i) * 0.15);
            const particleX = this.player.x + Math.cos(particleAngle) * particleRadius;
            const particleY = this.player.y + Math.sin(particleAngle) * particleRadius;
            const particleSize = 2.5 + Math.sin(time * 5 + i) * 0.7;
            
            // Alternating gold/amber shades
            const particleColor = i % 2 === 0 ? '255, 193, 7' : '255, 152, 0';
            this.ctx.fillStyle = `rgba(${particleColor}, ${0.75 * pulsePhase})`;
            // OPTIMIZED: Reduced shadow blur
            this.ctx.shadowBlur = 7;
            this.ctx.shadowColor = `rgba(${particleColor}, 0.7)`;
            this.ctx.beginPath();
            this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
        
        // Ensemble bypass core (at player position)
        const coreSize = 14 + Math.sin(time * 3.5) * 2;
        const coreGradient = this.ctx.createRadialGradient(
            this.player.x, this.player.y, 0,
            this.player.x, this.player.y, coreSize
        );
        coreGradient.addColorStop(0, `rgba(255, 255, 255, ${0.95 * pulsePhase})`);
        coreGradient.addColorStop(0.3, `rgba(255, 224, 178, ${0.85 * pulsePhase})`);
        coreGradient.addColorStop(0.6, `rgba(255, 193, 7, ${0.7 * pulsePhase})`);
        coreGradient.addColorStop(1, `rgba(255, 152, 0, 0)`);
        
        this.ctx.fillStyle = coreGradient;
        // OPTIMIZED: Reduced shadow blur
        this.ctx.shadowBlur = 12;
        this.ctx.shadowColor = 'rgba(255, 193, 7, 0.7)';
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, coreSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Bypass pattern (showing breaking through ensemble limitations)
        this.ctx.save();
        this.ctx.translate(this.player.x, this.player.y);
        this.ctx.rotate(time * 2);
        
        // Outer bypass ring with gaps (showing breaking through)
        const bypassRingSize = fieldRadius * 0.8;
        this.ctx.strokeStyle = `rgba(255, 193, 7, ${0.5 * pulsePhase})`;
        this.ctx.lineWidth = 3;
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = 'rgba(255, 193, 7, 0.6)';
        
        // Draw ring with gaps (bypass effect)
        for (let i = 0; i < 8; i++) {
            const startAngle = (i / 8) * Math.PI * 2;
            const endAngle = ((i + 0.7) / 8) * Math.PI * 2; // Gap of 0.3
            this.ctx.beginPath();
            this.ctx.arc(0, 0, bypassRingSize, startAngle, endAngle);
            this.ctx.stroke();
        }
        this.ctx.shadowBlur = 0;
        
        // Inner bypass lines (showing speed/increased drops)
        this.ctx.strokeStyle = `rgba(255, 152, 0, ${0.4 * pulsePhase})`;
        this.ctx.lineWidth = 2;
        this.ctx.shadowBlur = 8;
        this.ctx.shadowColor = 'rgba(255, 152, 0, 0.5)';
        
        for (let i = 0; i < 6; i++) {
            const lineAngle = (i / 6) * Math.PI * 2;
            const lineLength = bypassRingSize * 0.6;
            const lineX = Math.cos(lineAngle) * lineLength;
            const lineY = Math.sin(lineAngle) * lineLength;
            
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(lineX, lineY);
            this.ctx.stroke();
        }
        this.ctx.shadowBlur = 0;
        
        this.ctx.restore();
        
        // Speed enhancement particles (trailing behind player when moving)
        if (this.player.vx !== 0 || this.player.vy !== 0) {
            const speed = Math.sqrt(this.player.vx ** 2 + this.player.vy ** 2);
            if (speed > 0.1) {
                const trailAngle = Math.atan2(-this.player.vy, -this.player.vx);
                const trailLength = Math.min(40, speed * 20);
                
                for (let i = 0; i < 5; i++) {
                    const trailProgress = (i + 1) / 6;
                    const trailX = this.player.x + Math.cos(trailAngle) * trailLength * trailProgress;
                    const trailY = this.player.y + Math.sin(trailAngle) * trailLength * trailProgress;
                    const trailSize = 2 + Math.sin(time * 6 + i) * 0.5;
                    
                    this.ctx.fillStyle = `rgba(255, 193, 7, ${0.6 * (1 - trailProgress)})`;
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = 'rgba(255, 193, 7, 0.7)';
                    this.ctx.beginPath();
                    this.ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
            }
        }
    }
    
    drawTransformationTimeScanner() {
        // Only draw if transformation time scanner is equipped
        if (!this.currentUpgrades.includes('transformationTimeScanner')) {
            return;
        }
        
        const time = this.time || 0;
        const pulsePhase = Math.sin(time * 2) * 0.3 + 0.7;
        
        // Scanner field around player
        const scannerRadius = 100;
        
        // Scanner core at player position
        const coreSize = 10 + Math.sin(time * 4) * 1.5;
        const coreGradient = this.ctx.createRadialGradient(
            this.player.x, this.player.y, 0,
            this.player.x, this.player.y, coreSize
        );
        coreGradient.addColorStop(0, `rgba(255, 87, 34, ${0.9 * pulsePhase})`);
        coreGradient.addColorStop(0.5, `rgba(255, 152, 0, ${0.7 * pulsePhase})`);
        coreGradient.addColorStop(1, `rgba(255, 87, 34, 0)`);
        
        this.ctx.fillStyle = coreGradient;
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = 'rgba(255, 87, 34, 0.8)';
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, coreSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Scanning waves (pulsing outward from player)
        for (let i = 0; i < 3; i++) {
            const waveProgress = ((time * 0.8 + i * 0.3) % 1);
            const waveRadius = scannerRadius * waveProgress;
            const waveAlpha = (0.4 - waveProgress * 0.3) * pulsePhase;
            
            if (waveRadius > 0 && waveRadius < scannerRadius) {
                this.ctx.strokeStyle = `rgba(255, 87, 34, ${waveAlpha})`;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([4, 4]);
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(255, 87, 34, 0.5)';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, waveRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
            }
        }
        this.ctx.setLineDash([]);
        
        // Scanning lines to enemies/obstacles (revealing weak points)
        // OPTIMIZED: Limit to visible obstacles only, reduce gradient creations, limit weak points
        const scanRange = 600;
        const maxScannedObstacles = 10; // Limit to closest 10 obstacles for performance
        const visibleObstacles = [];
        
        // First pass: collect visible obstacles with distance
        this.obstacles.forEach(obstacle => {
            if (!obstacle || obstacle.health <= 0) return;
            
            const dx = obstacle.x - this.player.x;
            const dy = obstacle.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist <= scanRange && dist > 0) {
                visibleObstacles.push({ obstacle, dist });
            }
        });
        
        // Sort by distance and limit
        visibleObstacles.sort((a, b) => a.dist - b.dist);
        const scannedObstacles = visibleObstacles.slice(0, maxScannedObstacles);
        
        // Use solid colors instead of gradients for scanning lines (much faster)
        scannedObstacles.forEach(({ obstacle, dist }) => {
            const lineAlpha = Math.max(0.2, 0.6 - dist / scanRange);
            
            // OPTIMIZED: Use solid color instead of gradient
            this.ctx.strokeStyle = `rgba(255, 87, 34, ${0.4 * lineAlpha * pulsePhase})`;
            this.ctx.lineWidth = 1;
            this.ctx.setLineDash([3, 6]);
            // OPTIMIZED: Reduced shadow blur
            this.ctx.shadowBlur = 4;
            this.ctx.shadowColor = 'rgba(255, 87, 34, 0.3)';
            this.ctx.beginPath();
            this.ctx.moveTo(this.player.x, this.player.y);
            this.ctx.lineTo(obstacle.x, obstacle.y);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            this.ctx.setLineDash([]);
            
            // Weak point indicators on obstacles (showing critical hit spots)
            // OPTIMIZED: Reduced from 3 to 2 weak points, use solid colors
            const obstacleSize = obstacle.size || 30;
            const weakPointCount = 2; // Reduced from 3
            
            for (let i = 0; i < weakPointCount; i++) {
                const weakPointAngle = (i / weakPointCount) * Math.PI * 2 + time * 1.5;
                const weakPointRadius = obstacleSize * 0.7;
                const weakPointX = obstacle.x + Math.cos(weakPointAngle) * weakPointRadius;
                const weakPointY = obstacle.y + Math.sin(weakPointAngle) * weakPointRadius;
                const weakPointSize = 3 + Math.sin(time * 5 + i) * 1;
                
                // OPTIMIZED: Use solid color with alpha instead of gradient
                this.ctx.fillStyle = `rgba(255, 87, 34, ${0.6 * lineAlpha * pulsePhase})`;
                // OPTIMIZED: Reduced shadow blur
                this.ctx.shadowBlur = 6;
                this.ctx.shadowColor = 'rgba(255, 87, 34, 0.6)';
                this.ctx.beginPath();
                this.ctx.arc(weakPointX, weakPointY, weakPointSize * 1.5, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Weak point core
                this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * lineAlpha * pulsePhase})`;
                // OPTIMIZED: Reduced shadow blur
                this.ctx.shadowBlur = 5;
                this.ctx.shadowColor = 'rgba(255, 87, 34, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(weakPointX, weakPointY, weakPointSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            // Scanning pulse on obstacle (showing it's being scanned)
            const scanPulse = Math.sin(time * 3) * 0.2 + 0.8;
            this.ctx.strokeStyle = `rgba(255, 152, 0, ${0.3 * lineAlpha * scanPulse})`;
            this.ctx.lineWidth = 1.5;
            this.ctx.setLineDash([2, 4]);
            // OPTIMIZED: Reduced shadow blur
            this.ctx.shadowBlur = 5;
            this.ctx.shadowColor = 'rgba(255, 87, 34, 0.3)';
            this.ctx.beginPath();
            this.ctx.arc(obstacle.x, obstacle.y, obstacleSize * 1.2, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            this.ctx.setLineDash([]);
        });
        
        // Scanning particles (orbiting around player)
        const particleCount = 6;
        for (let i = 0; i < particleCount; i++) {
            const particleAngle = time * 2.5 + (i / particleCount) * Math.PI * 2;
            const particleRadius = scannerRadius * 0.6;
            const particleX = this.player.x + Math.cos(particleAngle) * particleRadius;
            const particleY = this.player.y + Math.sin(particleAngle) * particleRadius;
            const particleSize = 2 + Math.sin(time * 4 + i) * 0.5;
            
            this.ctx.fillStyle = `rgba(255, 152, 0, ${0.7 * pulsePhase})`;
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = 'rgba(255, 87, 34, 0.7)';
            this.ctx.beginPath();
            this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
    }
    
    drawIndividualSystemAmplifier() {
        // Only draw if individual system amplifier is equipped
        if (!this.currentUpgrades.includes('individualSystemAmplifier')) {
            return;
        }
        
        const time = this.time || 0;
        const pulsePhase = Math.sin(time * 2.5) * 0.3 + 0.7;
        
        // Amplifier field radius (larger than other upgrades - ultimate tier)
        const fieldRadius = 180;
        
        // Outer amplifier field glow - intense cyan/teal (individual system theme)
        const outerGlow = this.ctx.createRadialGradient(
            this.player.x, this.player.y, 0,
            this.player.x, this.player.y, fieldRadius
        );
        outerGlow.addColorStop(0, 'rgba(0, 255, 255, 0.3)');
        outerGlow.addColorStop(0.3, 'rgba(77, 208, 225, 0.25)');
        outerGlow.addColorStop(0.6, 'rgba(0, 188, 212, 0.2)');
        outerGlow.addColorStop(1, 'rgba(0, 255, 255, 0)');
        
        this.ctx.fillStyle = outerGlow;
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, fieldRadius, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Amplifier rings - showing amplified individual system properties
        for (let i = 0; i < 5; i++) {
            const ringRadius = fieldRadius * (0.5 + i * 0.12);
            const ringAlpha = (0.7 - i * 0.12) * pulsePhase;
            const ringPulse = Math.sin(time * 2 + i * 0.3) * 0.15 + 1;
            
            this.ctx.strokeStyle = `rgba(0, 255, 255, ${ringAlpha * ringPulse})`;
            this.ctx.lineWidth = 3 - i * 0.4;
            this.ctx.setLineDash([10 + i * 2, 2 + i]);
            this.ctx.shadowBlur = 16 - i * 2;
            this.ctx.shadowColor = 'rgba(0, 255, 255, 0.8)';
            this.ctx.beginPath();
            this.ctx.arc(this.player.x, this.player.y, ringRadius * ringPulse, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
        }
        this.ctx.setLineDash([]);
        
        // Amplified energy particles (more particles - ultimate tier)
        // OPTIMIZED: Reduced particle count
        const particleCount = 10; // Reduced from 16
        for (let i = 0; i < particleCount; i++) {
            const particleAngle = time * 3.5 + (i / particleCount) * Math.PI * 2;
            const particleRadius = fieldRadius * (0.55 + Math.sin(time * 4 + i) * 0.2);
            const particleX = this.player.x + Math.cos(particleAngle) * particleRadius;
            const particleY = this.player.y + Math.sin(particleAngle) * particleRadius;
            const particleSize = 3 + Math.sin(time * 6 + i) * 0.8;
            
            // Alternating cyan/teal shades
            const particleColor = i % 3 === 0 ? '0, 255, 255' : (i % 3 === 1 ? '77, 208, 225' : '0, 188, 212');
            this.ctx.fillStyle = `rgba(${particleColor}, ${0.8 * pulsePhase})`;
            // OPTIMIZED: Reduced shadow blur
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = `rgba(${particleColor}, 0.7)`;
            this.ctx.beginPath();
            this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
        
        // Amplifier core (at player position) - most intense
        const coreSize = 18 + Math.sin(time * 4) * 2.5;
        const coreGradient = this.ctx.createRadialGradient(
            this.player.x, this.player.y, 0,
            this.player.x, this.player.y, coreSize
        );
        coreGradient.addColorStop(0, `rgba(255, 255, 255, ${1 * pulsePhase})`);
        coreGradient.addColorStop(0.2, `rgba(178, 235, 242, ${0.95 * pulsePhase})`);
        coreGradient.addColorStop(0.5, `rgba(77, 208, 225, ${0.85 * pulsePhase})`);
        coreGradient.addColorStop(0.8, `rgba(0, 188, 212, ${0.7 * pulsePhase})`);
        coreGradient.addColorStop(1, `rgba(0, 255, 255, 0)`);
        
        this.ctx.fillStyle = coreGradient;
        // OPTIMIZED: Reduced shadow blur
        this.ctx.shadowBlur = 13;
        this.ctx.shadowColor = 'rgba(0, 255, 255, 0.7)';
        this.ctx.beginPath();
        this.ctx.arc(this.player.x, this.player.y, coreSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Amplification pattern (showing amplified properties)
        this.ctx.save();
        this.ctx.translate(this.player.x, this.player.y);
        this.ctx.rotate(time * 1.8);
        
        // Outer amplification ring
        const ampRingSize = fieldRadius * 0.85;
        this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.6 * pulsePhase})`;
        this.ctx.lineWidth = 3;
        this.ctx.shadowBlur = 12;
        this.ctx.shadowColor = 'rgba(0, 255, 255, 0.7)';
        
        // Draw octagon pattern (8-sided - showing amplification)
        this.ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI / 4) * i;
            const x = Math.cos(angle) * ampRingSize;
            const y = Math.sin(angle) * ampRingSize;
            if (i === 0) this.ctx.moveTo(x, y);
            else this.ctx.lineTo(x, y);
        }
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Inner amplification lines (connecting to center)
        this.ctx.strokeStyle = `rgba(77, 208, 225, ${0.5 * pulsePhase})`;
        this.ctx.lineWidth = 2;
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = 'rgba(77, 208, 225, 0.6)';
        
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI / 4) * i;
            const lineLength = ampRingSize * 0.7;
            const lineX = Math.cos(angle) * lineLength;
            const lineY = Math.sin(angle) * lineLength;
            
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(lineX, lineY);
            this.ctx.stroke();
        }
        this.ctx.shadowBlur = 0;
        
        // Amplification energy nodes at vertices
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI / 4) * i;
            const nodeX = Math.cos(angle) * ampRingSize;
            const nodeY = Math.sin(angle) * ampRingSize;
            const nodeSize = 4 + Math.sin(time * 5 + i) * 1;
            
            const nodeGradient = this.ctx.createRadialGradient(nodeX, nodeY, 0, nodeX, nodeY, nodeSize);
            nodeGradient.addColorStop(0, `rgba(255, 255, 255, ${0.95 * pulsePhase})`);
            nodeGradient.addColorStop(0.5, `rgba(0, 255, 255, ${0.8 * pulsePhase})`);
            nodeGradient.addColorStop(1, `rgba(77, 208, 225, 0)`);
            
            this.ctx.fillStyle = nodeGradient;
            this.ctx.shadowBlur = 12;
            this.ctx.shadowColor = 'rgba(0, 255, 255, 0.9)';
            this.ctx.beginPath();
            this.ctx.arc(nodeX, nodeY, nodeSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
        
        this.ctx.restore();
        
        // Amplified speed trail (when moving - shows +75% speed)
        if (this.player.vx !== 0 || this.player.vy !== 0) {
            const speed = Math.sqrt(this.player.vx ** 2 + this.player.vy ** 2);
            if (speed > 0.1) {
                const trailAngle = Math.atan2(-this.player.vy, -this.player.vx);
                const trailLength = Math.min(60, speed * 30); // Longer trail for amplified speed
                
                for (let i = 0; i < 8; i++) {
                    const trailProgress = (i + 1) / 9;
                    const trailX = this.player.x + Math.cos(trailAngle) * trailLength * trailProgress;
                    const trailY = this.player.y + Math.sin(trailAngle) * trailLength * trailProgress;
                    const trailSize = 3 + Math.sin(time * 7 + i) * 0.8;
                    
                    const trailColor = i % 3 === 0 ? '0, 255, 255' : (i % 3 === 1 ? '77, 208, 225' : '0, 188, 212');
                    this.ctx.fillStyle = `rgba(${trailColor}, ${0.7 * (1 - trailProgress)})`;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = `rgba(${trailColor}, 0.8)`;
                    this.ctx.beginPath();
                    this.ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
            }
        }
        
        // Amplification waves (pulsing outward - showing amplified power)
        for (let i = 0; i < 4; i++) {
            const waveProgress = ((time * 1.2 + i * 0.25) % 1);
            const waveRadius = fieldRadius * waveProgress;
            const waveAlpha = (0.5 - waveProgress * 0.4) * pulsePhase;
            
            if (waveRadius > 0 && waveRadius < fieldRadius) {
                this.ctx.strokeStyle = `rgba(0, 255, 255, ${waveAlpha})`;
                this.ctx.lineWidth = 2.5;
                this.ctx.setLineDash([6, 3]);
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = 'rgba(0, 255, 255, 0.6)';
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, waveRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
            }
        }
        this.ctx.setLineDash([]);
    }

    drawLaserBeam() {
        if (!this.activeLaser || !this.player.laserActive) return;
        
        const beam = this.activeLaser;
        const time = this.time;
        const beamLength = Math.sqrt((beam.x2 - beam.x1) ** 2 + (beam.y2 - beam.y1) ** 2);
        const beamAngle = Math.atan2(beam.y2 - beam.y1, beam.x2 - beam.x1);
        
        // Calculate beam midpoint for effects
        const midX = (beam.x1 + beam.x2) / 2;
        const midY = (beam.y1 + beam.y2) / 2;
        
        // Enhanced outer glow layers (multiple layers for depth)
        // Layer 1 - widest outer glow
        const outerGlow1 = this.ctx.createLinearGradient(beam.x1, beam.y1, beam.x2, beam.y2);
        outerGlow1.addColorStop(0, 'rgba(244, 67, 54, 0.25)');
        outerGlow1.addColorStop(0.5, 'rgba(244, 67, 54, 0.2)');
        outerGlow1.addColorStop(1, 'rgba(244, 67, 54, 0)');
        this.ctx.strokeStyle = outerGlow1;
        this.ctx.lineWidth = beam.width * 4.5;
        this.ctx.shadowBlur = 30;
        this.ctx.shadowColor = 'rgba(244, 67, 54, 0.6)';
        this.ctx.beginPath();
        this.ctx.moveTo(beam.x1, beam.y1);
        this.ctx.lineTo(beam.x2, beam.y2);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Layer 2 - medium outer glow
        const outerGlow2 = this.ctx.createLinearGradient(beam.x1, beam.y1, beam.x2, beam.y2);
        outerGlow2.addColorStop(0, 'rgba(255, 87, 34, 0.4)');
        outerGlow2.addColorStop(0.5, 'rgba(255, 87, 34, 0.3)');
        outerGlow2.addColorStop(1, 'rgba(255, 87, 34, 0)');
        this.ctx.strokeStyle = outerGlow2;
        this.ctx.lineWidth = beam.width * 3;
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = 'rgba(255, 87, 34, 0.5)';
        this.ctx.beginPath();
        this.ctx.moveTo(beam.x1, beam.y1);
        this.ctx.lineTo(beam.x2, beam.y2);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Layer 3 - inner glow
        const outerGlow3 = this.ctx.createLinearGradient(beam.x1, beam.y1, beam.x2, beam.y2);
        outerGlow3.addColorStop(0, 'rgba(244, 67, 54, 0.6)');
        outerGlow3.addColorStop(0.5, 'rgba(244, 67, 54, 0.5)');
        outerGlow3.addColorStop(1, 'rgba(244, 67, 54, 0)');
        this.ctx.strokeStyle = outerGlow3;
        this.ctx.lineWidth = beam.width * 2;
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = 'rgba(244, 67, 54, 0.7)';
        this.ctx.beginPath();
        this.ctx.moveTo(beam.x1, beam.y1);
        this.ctx.lineTo(beam.x2, beam.y2);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Main beam with enhanced gradient
        const mainGradient = this.ctx.createLinearGradient(beam.x1, beam.y1, beam.x2, beam.y2);
        mainGradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); // Bright white at start
        mainGradient.addColorStop(0.1, 'rgba(255, 152, 152, 1)'); // Light red
        mainGradient.addColorStop(0.3, 'rgba(244, 67, 54, 1)'); // Main red
        mainGradient.addColorStop(0.7, 'rgba(211, 47, 47, 0.9)'); // Darker red
        mainGradient.addColorStop(1, 'rgba(183, 28, 28, 0)'); // Transparent at end
        this.ctx.strokeStyle = mainGradient;
        this.ctx.lineWidth = beam.width;
        this.ctx.shadowBlur = 25;
        this.ctx.shadowColor = 'rgba(244, 67, 54, 0.9)';
        this.ctx.lineCap = 'round';
        this.ctx.beginPath();
        this.ctx.moveTo(beam.x1, beam.y1);
        this.ctx.lineTo(beam.x2, beam.y2);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Core beam (bright center line)
        const coreGradient = this.ctx.createLinearGradient(beam.x1, beam.y1, beam.x2, beam.y2);
        coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        coreGradient.addColorStop(0.2, 'rgba(255, 235, 59, 0.9)'); // Yellow-white
        coreGradient.addColorStop(0.5, 'rgba(255, 152, 152, 0.8)'); // Light red
        coreGradient.addColorStop(1, 'rgba(244, 67, 54, 0)');
        this.ctx.strokeStyle = coreGradient;
        this.ctx.lineWidth = beam.width * 0.4;
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
        this.ctx.beginPath();
        this.ctx.moveTo(beam.x1, beam.y1);
        this.ctx.lineTo(beam.x2, beam.y2);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Energy particles flowing along the beam
        const particleCount = Math.floor(beamLength / 15);
        for (let i = 0; i < particleCount; i++) {
            const particleProgress = (i / particleCount) + (time * 0.8) % 1; // Animated flow
            const particleX = beam.x1 + Math.cos(beamAngle) * beamLength * particleProgress;
            const particleY = beam.y1 + Math.sin(beamAngle) * beamLength * particleProgress;
            const particleSize = 3 + Math.sin(time * 5 + i) * 1;
            
            // Particle glow
            const particleGlow = this.ctx.createRadialGradient(particleX, particleY, 0, particleX, particleY, particleSize * 2);
            particleGlow.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            particleGlow.addColorStop(0.5, 'rgba(255, 152, 152, 0.6)');
            particleGlow.addColorStop(1, 'rgba(244, 67, 54, 0)');
            this.ctx.fillStyle = particleGlow;
            this.ctx.shadowBlur = 12;
            this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
        this.ctx.beginPath();
            this.ctx.arc(particleX, particleY, particleSize * 2, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            
            // Particle core
            this.ctx.fillStyle = 'rgba(255, 255, 255, 1)';
            this.ctx.beginPath();
            this.ctx.arc(particleX, particleY, particleSize * 0.5, 0, Math.PI * 2);
        this.ctx.fill();
        }
        
        // Energy waves/ripples along the beam
        const waveCount = 8;
        for (let i = 0; i < waveCount; i++) {
            const waveProgress = (i / waveCount) + (time * 0.5) % 1;
            const waveX = beam.x1 + Math.cos(beamAngle) * beamLength * waveProgress;
            const waveY = beam.y1 + Math.sin(beamAngle) * beamLength * waveProgress;
            const waveSize = beam.width * (1.5 + Math.sin(time * 3 + i) * 0.3);
            
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 - waveProgress * 0.3})`;
            this.ctx.lineWidth = 2;
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = 'rgba(244, 67, 54, 0.6)';
            this.ctx.beginPath();
            this.ctx.arc(waveX, waveY, waveSize, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
        }
        
        // Enhanced charge indicator at start (laser emitter)
        const chargePulse = Math.sin(time * 4) * 0.2 + 0.8;
        const chargeSize = 12 * beam.charge * chargePulse;
        
        // Outer charge glow
        const chargeGlow = this.ctx.createRadialGradient(beam.x1, beam.y1, 0, beam.x1, beam.y1, chargeSize * 2.5);
        chargeGlow.addColorStop(0, 'rgba(244, 67, 54, 0.6)');
        chargeGlow.addColorStop(0.4, 'rgba(255, 87, 34, 0.4)');
        chargeGlow.addColorStop(1, 'rgba(244, 67, 54, 0)');
        this.ctx.fillStyle = chargeGlow;
        this.ctx.shadowBlur = 25;
        this.ctx.shadowColor = 'rgba(244, 67, 54, 0.8)';
        this.ctx.beginPath();
        this.ctx.arc(beam.x1, beam.y1, chargeSize * 2.5, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Charge ring
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * chargePulse})`;
        this.ctx.lineWidth = 3;
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = 'rgba(244, 67, 54, 0.9)';
        this.ctx.beginPath();
        this.ctx.arc(beam.x1, beam.y1, chargeSize * 1.2, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Charge core
        const chargeCore = this.ctx.createRadialGradient(beam.x1, beam.y1, 0, beam.x1, beam.y1, chargeSize);
        chargeCore.addColorStop(0, 'rgba(255, 255, 255, 1)');
        chargeCore.addColorStop(0.5, 'rgba(255, 235, 59, 0.9)');
        chargeCore.addColorStop(1, 'rgba(244, 67, 54, 0.8)');
        this.ctx.fillStyle = chargeCore;
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
        this.ctx.beginPath();
        this.ctx.arc(beam.x1, beam.y1, chargeSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Rotating energy rings around emitter
        this.ctx.save();
        this.ctx.translate(beam.x1, beam.y1);
        this.ctx.rotate(time * 3);
        
        for (let i = 0; i < 3; i++) {
            const ringAngle = (i / 3) * Math.PI * 2;
            const ringSize = chargeSize * (1.5 + i * 0.5);
            const ringAlpha = 0.4 - i * 0.1;
            
            this.ctx.strokeStyle = `rgba(244, 67, 54, ${ringAlpha * chargePulse})`;
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([4, 4]);
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = 'rgba(244, 67, 54, 0.5)';
            this.ctx.beginPath();
            this.ctx.arc(0, 0, ringSize, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
        }
        
        this.ctx.setLineDash([]);
        this.ctx.restore();
        
        // Impact effect at end point (if beam hits something)
        const impactSize = 8 + Math.sin(time * 6) * 2;
        const impactGlow = this.ctx.createRadialGradient(beam.x2, beam.y2, 0, beam.x2, beam.y2, impactSize * 3);
        impactGlow.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        impactGlow.addColorStop(0.3, 'rgba(255, 152, 152, 0.6)');
        impactGlow.addColorStop(0.7, 'rgba(244, 67, 54, 0.4)');
        impactGlow.addColorStop(1, 'rgba(244, 67, 54, 0)');
        this.ctx.fillStyle = impactGlow;
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = 'rgba(244, 67, 54, 0.7)';
        this.ctx.beginPath();
        this.ctx.arc(beam.x2, beam.y2, impactSize * 3, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Impact core
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
        this.ctx.beginPath();
        this.ctx.arc(beam.x2, beam.y2, impactSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
    }
    
    updateLaserBeam(deltaTime) {
        if (!this.activeLaser || !this.player.laserActive) return;
        
        const beam = this.activeLaser;
        const damagePerSecond = beam.damage * 10; // Deal damage 10 times per second
        const damage = damagePerSecond * deltaTime;
        
        // Check collision with all entities
        // Optimized: Avoid flatMap and spread operators - use manual loops for better performance
        const entities = [];
        // Add targets
        for (let i = 0; i < this.targets.length; i++) {
            entities.push(this.targets[i]);
        }
        // Add pairs (a and b)
        for (let i = 0; i < this.pairs.length; i++) {
            entities.push(this.pairs[i].a);
            entities.push(this.pairs[i].b);
        }
        // Add obstacles
        for (let i = 0; i < this.obstacles.length; i++) {
            entities.push(this.obstacles[i]);
        }
        // Add enemy ships
        for (let i = 0; i < this.enemyShips.length; i++) {
            entities.push(this.enemyShips[i]);
        }
        
        // Optimized: Use for loop instead of forEach
        for (let i = 0; i < entities.length; i++) {
            const entity = entities[i];
            // Check if entity intersects with laser beam
            if (this.lineIntersectsCircle(beam.x1, beam.y1, beam.x2, beam.y2, entity.x, entity.y, entity.size || entity.radius || 15)) {
                // Apply damage
                if (entity.health !== undefined) {
                    entity.health -= damage;
                    
                    // Handle entity destruction
                    if (entity.health <= 0) {
                        this.createExplosion(entity.x, entity.y);
                        
                        // Identify entity type by properties (since they don't have 'type' property)
                        // Enemy ships: have speed and maxHealth properties (most specific check first)
                        const isEnemyShip = entity.speed !== undefined && entity.maxHealth !== undefined && entity.moleculeType === undefined;
                        
                        // Obstacles: have moleculeType or isBoss property
                        const isObstacle = entity.moleculeType !== undefined || entity.isBoss === true;
                        
                        // Targets and pairs: have health but no moleculeType, speed, or maxHealth
                        const isTargetOrPair = !isEnemyShip && !isObstacle && entity.health !== undefined;
                        
                        // Drop items and award score (similar to bullet collision logic)
                        if (isTargetOrPair) {
                            this.dropItem(entity.x, entity.y, 'quantumParticles');
                            this.score += 10;
                            this.hits++;
                        } else if (isObstacle) {
                            // Handle obstacle/molecule destruction (reduced drop count for balance)
                            const baseDropCount = entity.isBoss ? 20 : 5; // Reduced from 9 to 5 for regular obstacles
                            const dropCount = Math.floor(baseDropCount * (entity.rewardMultiplier || 1.0));
                            for (let i = 0; i < dropCount; i++) {
                                // Drop items (similar to bullet collision)
                                const rand = Math.random();
                                let itemType;
                                if (this.mode === 'ensemble') {
                                    itemType = rand < 0.5 ? 'quantumParticles' : 'crystals';
                                } else if (this.mode === 'individual') {
                                    itemType = rand < 0.5 ? 'energyCores' : 'metalScraps';
                                } else {
                                    if (rand < 0.4) itemType = 'quantumParticles';
                                    else if (rand < 0.65) itemType = 'crystals';
                                    else if (rand < 0.85) itemType = 'metalScraps';
                                    else itemType = 'energyCores';
                                }
                                
                                const angle = (Math.PI * 2 * i) / dropCount;
                                const offset = 40;
                                const itemX = entity.x + Math.cos(angle) * offset;
                                const itemY = entity.y + Math.sin(angle) * offset;
                                // Check if item is created too close to player
                                const dxFromPlayer = itemX - this.player.x;
                                const dyFromPlayer = itemY - this.player.y;
                                const distFromPlayer = Math.sqrt(dxFromPlayer * dxFromPlayer + dyFromPlayer * dyFromPlayer);
                                const playerRadius = this.player.size || 20;
                                const itemRadius = 8;
                                const minCollectionDistance = playerRadius + itemRadius + 5;
                                
                                this.items.push({
                                    x: itemX,
                                    y: itemY,
                                    type: itemType,
                                    vx: Math.cos(angle) * 150,
                                    vy: Math.sin(angle) * 150,
                                    lifetime: 5,
                                    collected: false,
                                    createdTime: this.time, // Track when item was created
                                    size: 8, // Size for collision detection
                                    framesSinceCreation: 0, // Track frames since creation - prevents same-frame collection
                                    createdTooClose: distFromPlayer < minCollectionDistance // Flag if created too close to player
                                });
                            }
                            
                            const baseTokens = (1 + Math.floor(this.level / 2)) * (entity.isBoss ? 10 : 3);
                            this.inventory.tokens += Math.floor(baseTokens * (entity.rewardMultiplier || 1.0));
                            this.score += entity.isBoss ? 500 : 30;
                            this.hits++;
                            
                            if (entity.isBoss) {
                                for (let i = 0; i < 50; i++) {
                                    this.createExplosion(entity.x + (Math.random() - 0.5) * 200, 
                                                        entity.y + (Math.random() - 0.5) * 200);
                                }
                            }
                        } else if (isEnemyShip) {
                            // Handle enemy ship destruction
                            const dropCount = 3 + Math.floor(this.level / 2);
                            for (let i = 0; i < dropCount; i++) {
                                const rand = Math.random();
                                let itemType;
                                if (rand < 0.3) itemType = 'quantumParticles';
                                else if (rand < 0.55) itemType = 'crystals';
                                else if (rand < 0.75) itemType = 'energyCores';
                                else itemType = 'metalScraps';
                                
                                const angle = (Math.PI * 2 * i) / dropCount;
                                const offset = 30;
                                const itemX = entity.x + Math.cos(angle) * offset;
                                const itemY = entity.y + Math.sin(angle) * offset;
                                // Check if item is created too close to player
                                const dxFromPlayer = itemX - this.player.x;
                                const dyFromPlayer = itemY - this.player.y;
                                const distFromPlayer = Math.sqrt(dxFromPlayer * dxFromPlayer + dyFromPlayer * dyFromPlayer);
                                const playerRadius = this.player.size || 20;
                                const itemRadius = 8;
                                const minCollectionDistance = playerRadius + itemRadius + 5;
                                
                                this.items.push({
                                    x: itemX,
                                    y: itemY,
                                    type: itemType,
                                    vx: Math.cos(angle) * 100,
                                    vy: Math.sin(angle) * 100,
                                    lifetime: 5,
                                    collected: false,
                                    createdTime: this.time, // Track when item was created
                                    size: 8, // Size for collision detection
                                    framesSinceCreation: 0, // Track frames since creation - prevents same-frame collection
                                    createdTooClose: distFromPlayer < minCollectionDistance // Flag if created too close to player
                                });
                            }
                            // Bonus tokens for enemy ships
                            this.inventory.tokens += 5 + this.level * 2;
                            this.score += 20;
                            this.hits++;
                            this.lastEnemySpawn = Date.now();
                        }
                        
                        // Mark entity for removal
                        entity.health = 0;
                        if (entity.size !== undefined) entity.size = 0;
                    }
                }
            }
        }
        
        // Optimized: Batch updateStats instead of calling immediately
        this._statsNeedsUpdate = true;
    }
    
    lineIntersectsCircle(x1, y1, x2, y2, cx, cy, r) {
        // Check if line segment intersects circle
        const dx = x2 - x1;
        const dy = y2 - y1;
        const fx = x1 - cx;
        const fy = y1 - cy;
        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - r * r;
        const discriminant = b * b - 4 * a * c;
        
        if (discriminant < 0) return false;
        
        const t1 = (-b - Math.sqrt(discriminant)) / (2 * a);
        const t2 = (-b + Math.sqrt(discriminant)) / (2 * a);
        
        // Check if intersection point is within line segment
        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
    }

    drawBullets() {
        // Draw player bullets (photons)
        // OPTIMIZED: Smart performance optimization that preserves visual quality
        const bulletCount = this.bullets.length;
        const level = this.level || 1;
        
        // Update FPS tracking for adaptive quality
        this.frameCount++;
        const now = performance.now();
        if (now - this.lastFpsUpdate >= 1000) {
            // Calculate FPS over last second
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.lastFpsUpdate = now;
            
            // Keep FPS history (last 3 seconds)
            this.fpsHistory.push(this.fps);
            if (this.fpsHistory.length > 3) {
                this.fpsHistory.shift();
            }
            
            // Adaptive quality based on actual FPS (only reduce if performance is bad)
            if (this.fpsHistory.length > 0) {
                const avgFps = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
                if (avgFps < 30) {
                    this.adaptiveQuality = 'medium'; // Reduce quality if FPS < 30
                } else if (avgFps < 45) {
                    this.adaptiveQuality = 'high'; // Reduce quality if FPS < 45
                } else {
                    this.adaptiveQuality = 'ultra'; // Full quality if FPS >= 45
                }
            }
        }
        
        // Calculate effective fire rate multiplier from RPG stats + upgrades + stacking
        let effectiveFireRateMultiplier = 1.0;
        let weaponCount = 0;
        let hasHighTierWeapons = false;
        
        if (this.currentWeapons && this.currentWeapons.length > 0) {
            weaponCount = this.currentWeapons.length;
            
            // Calculate base fire rate from weapons
            let baseFireRate = 0;
            if (this.equipmentStats && this.equipmentStats.weapons) {
                this.currentWeapons.forEach(weaponName => {
                    const weapon = this.equipmentStats.weapons[weaponName];
                    if (weapon) {
                        baseFireRate = Math.max(baseFireRate, weapon.fireRate || 0.5);
                        
                        // Check for high-tier weapons (advanced weapons)
                        if (['transformationPredictor', 'deterministicEngine', 'individualSystemCore'].includes(weaponName)) {
                            hasHighTierWeapons = true;
                        }
                    }
                });
            }
            
            // Add RPG stat bonus
            const rpgFireRateBonus = (this.playerStats && this.playerStats.fireRate ? this.playerStats.fireRate : 0.5) - 
                                    (this.playerStats && this.playerStats.baseFireRate ? this.playerStats.baseFireRate : 0.5);
            let combinedFireRate = baseFireRate + rpgFireRateBonus;
            
            // Apply upgrade multipliers
            if (this.currentUpgrades && this.currentUpgrades.includes('completeDescriptionMatrix')) {
                combinedFireRate *= 1.3; // +30% fire rate
            }
            if (this.currentUpgrades && this.currentUpgrades.includes('individualSystemAmplifier')) {
                combinedFireRate *= 1.75; // +75% fire rate
            }
            
            // Add weapon tier bonuses (rapid upgrades)
            if (this.weaponUpgrades && this.weaponUpgrades['rapid']) {
                const rapidBonuses = [0, 0.9, 1.2, 1.5, 1.8];
                const upgradeLevel = this.weaponUpgrades['rapid'];
                let totalBonus = 0;
                for (let i = 1; i <= upgradeLevel && i <= 4; i++) {
                    totalBonus += rapidBonuses[i];
                }
                combinedFireRate += totalBonus;
            }
            
            // Calculate multiplier (higher fire rate = more bullets = need more optimization)
            effectiveFireRateMultiplier = Math.max(1.0, combinedFireRate / 0.5);
        }
        
        // Smart particle reduction: Only reduce particle counts, keep all visual effects
        // Base particle multiplier starts at 1.0, only reduces when bullet count is very high
        let particleMultiplier = 1.0;
        
        // Progressive particle reduction (only reduce particles, not effects)
        if (bulletCount >= 80) {
            particleMultiplier = 0.3; // 70% reduction for extreme bullet count
        } else if (bulletCount >= 60) {
            particleMultiplier = 0.5; // 50% reduction
        } else if (bulletCount >= 40) {
            particleMultiplier = 0.7; // 30% reduction
        } else if (bulletCount >= 25) {
            particleMultiplier = 0.85; // 15% reduction
        }
        
        // Late game: Slightly more aggressive particle reduction
        if (level >= 75 && bulletCount >= 50) {
            particleMultiplier *= 0.8; // Additional 20% reduction for end-game
        } else if (level >= 50 && bulletCount >= 40) {
            particleMultiplier *= 0.9; // Additional 10% reduction for late game
        }
        
        // High fire rate: Reduce particles more
        if (effectiveFireRateMultiplier > 3.0 && bulletCount >= 40) {
            particleMultiplier *= 0.85; // Additional 15% reduction
        } else if (effectiveFireRateMultiplier > 2.0 && bulletCount >= 30) {
            particleMultiplier *= 0.9; // Additional 10% reduction
        }
        
        // Stacked weapons: Reduce particles more
        if (weaponCount >= 4 && bulletCount >= 40) {
            particleMultiplier *= 0.85; // Additional 15% reduction
        } else if (weaponCount >= 3 && bulletCount >= 30) {
            particleMultiplier *= 0.9; // Additional 10% reduction
        }
        
        // Use adaptive quality (based on FPS) instead of bullet-count-based quality
        // This preserves visual quality unless performance actually drops
        const renderingQuality = this.adaptiveQuality;
        
        // Helper variables for conditional rendering
        const isHighBulletCount = bulletCount > 15;
        const isVeryHighBulletCount = bulletCount > 30;
        const isHighFireRate = effectiveFireRateMultiplier > 2.0;
        const isVeryHighFireRate = effectiveFireRateMultiplier > 3.0;
        
        // ALWAYS keep visual effects - only reduce particle counts
        // This preserves the enhanced look while optimizing performance
        const useGradients = true; // Always use gradients
        const useShadows = renderingQuality !== 'medium' && bulletCount < 50; // Disable shadows only if FPS is bad or bullet count very high
        const useTrails = true; // Always use trails
        const useGlow = true; // Always use glow
        const useParticles = true; // Always use particles, just reduce count
        
        // Smart culling: Only render bullets that are on-screen or very close to screen
        // More aggressive culling when bullet count is high
        let cullMargin = 200; // Default: render bullets 200px off-screen
        if (bulletCount >= 80) {
            cullMargin = 50; // Very aggressive: only render on-screen
        } else if (bulletCount >= 60) {
            cullMargin = 100; // Aggressive: render 100px off-screen
        } else if (bulletCount >= 40) {
            cullMargin = 150; // Moderate: render 150px off-screen
        }
        
        // OPTIMIZED: Use for loop instead of forEach for better performance
        for (let i = 0; i < this.bullets.length; i++) {
            const bullet = this.bullets[i];
            
            // CULLING: Skip bullets that are far off-screen (more aggressive at high bullet count)
            if (bullet.x < -cullMargin || bullet.x > this.canvas.width + cullMargin ||
                bullet.y < -cullMargin || bullet.y > this.canvas.height + cullMargin) {
                continue; // Skip rendering entirely for off-screen bullets
            }
            
            const time = this.time || 0;
            const weaponName = bullet.weaponName || 'basic';
            
            // Enhanced Basic Weapon Bullets
            if (weaponName === 'basic') {
                const bulletSize = bullet.size || 5;
                const angle = Math.atan2(bullet.vy, bullet.vx);
                
                // Always render glow (preserve visual quality)
                if (useGlow && useGradients) {
                    // Outer energy field glow
                    const outerGlow = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 3);
                    outerGlow.addColorStop(0, 'rgba(76, 175, 80, 0.4)');
                    outerGlow.addColorStop(0.5, 'rgba(76, 175, 80, 0.2)');
                    outerGlow.addColorStop(1, 'rgba(76, 175, 80, 0)');
                    this.ctx.fillStyle = outerGlow;
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bulletSize * 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // OPTIMIZATION: Only render pulsing ring if quality allows
                if (useGlow && renderingQuality !== 'low') {
                    // Pulsing outer ring
                    const pulsePhase = Math.sin(time * 4) * 0.3 + 0.7;
                    this.ctx.strokeStyle = `rgba(129, 199, 132, ${0.6 * pulsePhase})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bulletSize + 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                // Main bullet body - always use gradient (preserve visual quality)
                const bulletGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize);
                bulletGradient.addColorStop(0, '#a5d6a7'); // Bright green center
                bulletGradient.addColorStop(0.4, '#66bb6a'); // Medium green
                bulletGradient.addColorStop(0.8, '#4caf50'); // Standard green
                bulletGradient.addColorStop(1, '#388e3c'); // Dark green edge
                this.ctx.fillStyle = bulletGradient;
                
                // Only use shadows if quality allows
                if (useShadows) {
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = 'rgba(76, 175, 80, 0.6)';
                }
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
                this.ctx.fill();
                if (useShadows) {
                    this.ctx.shadowBlur = 0;
                }
                
                // OPTIMIZATION: Only render inner core if quality allows
                if (useGradients && renderingQuality !== 'low') {
                    // Inner bright core
                    const coreGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 0.5);
                    coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    coreGradient.addColorStop(0.5, 'rgba(200, 255, 200, 0.6)');
                    coreGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
                    this.ctx.fillStyle = coreGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bulletSize * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Calculate trail length (used for both trail rendering and particles)
                // Always render trail with gradient (preserve visual quality)
                const trailLength = renderingQuality === 'medium' ? 18 : 20;
                const trailGradient = this.ctx.createLinearGradient(
                    bullet.x, bullet.y,
                    bullet.x - Math.cos(angle) * trailLength,
                    bullet.y - Math.sin(angle) * trailLength
                );
                trailGradient.addColorStop(0, 'rgba(76, 175, 80, 0.8)');
                trailGradient.addColorStop(0.5, 'rgba(129, 199, 132, 0.5)');
                trailGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
                this.ctx.strokeStyle = trailGradient;
                this.ctx.lineWidth = renderingQuality === 'medium' ? 2.5 : 3;
                this.ctx.lineCap = 'round';
                if (useShadows) {
                    this.ctx.shadowBlur = 5;
                    this.ctx.shadowColor = 'rgba(76, 175, 80, 0.4)';
                }
                this.ctx.beginPath();
                this.ctx.moveTo(bullet.x, bullet.y);
                this.ctx.lineTo(bullet.x - Math.cos(angle) * trailLength, 
                              bullet.y - Math.sin(angle) * trailLength);
                this.ctx.stroke();
                if (useShadows) {
                    this.ctx.shadowBlur = 0;
                }
                
                // Always create trail particles (just reduce count based on particleMultiplier)
                const trailParticleCount = Math.max(1, Math.floor(3 * particleMultiplier));
                for (let i = 0; i < trailParticleCount; i++) {
                    const particlePos = (i + 1) / (trailParticleCount + 1);
                    const particleX = bullet.x - Math.cos(angle) * trailLength * particlePos;
                    const particleY = bullet.y - Math.sin(angle) * trailLength * particlePos;
                    const particleSize = 1.5 + Math.sin(time * 5 + i) * 0.5;
                    
                    this.ctx.fillStyle = `rgba(200, 255, 200, ${0.7 - i * 0.2})`;
                    // OPTIMIZED: Reduced shadow blur
                    this.ctx.shadowBlur = 4;
                    this.ctx.shadowColor = 'rgba(76, 175, 80, 0.4)';
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // OPTIMIZATION: Only create orbiting particles if quality allows
                if (useParticles && !isHighBulletCount) {
                    // Orbiting energy particles (2 particles)
                    for (let i = 0; i < 2; i++) {
                        const particleAngle = time * 3 + (i / 2) * Math.PI * 2;
                        const particleX = bullet.x + Math.cos(particleAngle) * (bulletSize + 4);
                        const particleY = bullet.y + Math.sin(particleAngle) * (bulletSize + 4);
                        const particleSize = 1.5 + Math.sin(time * 4 + i) * 0.5;
                        
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.8})`;
                        // OPTIMIZATION: Only use shadows if quality allows
                        if (useShadows) {
                            this.ctx.shadowBlur = 5;
                            this.ctx.shadowColor = 'rgba(76, 175, 80, 0.6)';
                        }
                        this.ctx.beginPath();
                        this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        if (useShadows) {
                            this.ctx.shadowBlur = 0;
                        }
                    }
                }
            } else if (weaponName === 'rapid') {
                // Enhanced Rapid Weapon Bullets - fast-firing orange energy projectiles
                const bulletSize = bullet.size || 4;
                const angle = Math.atan2(bullet.vy, bullet.vx);
                
                // OPTIMIZATION: Only render glow if quality allows
                if (useGlow && useGradients) {
                    // Outer energy field glow - orange/amber
                    const outerGlow = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 3.5);
                    outerGlow.addColorStop(0, 'rgba(255, 152, 0, 0.4)');
                    outerGlow.addColorStop(0.4, 'rgba(255, 183, 77, 0.25)');
                    outerGlow.addColorStop(0.7, 'rgba(255, 152, 0, 0.15)');
                    outerGlow.addColorStop(1, 'rgba(255, 152, 0, 0)');
                    this.ctx.fillStyle = outerGlow;
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bulletSize * 3.5, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // OPTIMIZATION: Only render pulsing ring if quality allows
                if (useGlow && renderingQuality !== 'low') {
                    // Pulsing outer ring - faster pulse for rapid fire
                    const pulsePhase = Math.sin(time * 6) * 0.3 + 0.7;
                    this.ctx.strokeStyle = `rgba(255, 193, 7, ${0.7 * pulsePhase})`;
                    this.ctx.lineWidth = 2.5;
                    if (useShadows) {
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = 'rgba(255, 152, 0, 0.6)';
                    }
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bulletSize + 4, 0, Math.PI * 2);
                    this.ctx.stroke();
                    if (useShadows) {
                        this.ctx.shadowBlur = 0;
                    }
                }
                
                // Main bullet body
                if (useGradients) {
                    // Use gradient
                    const bulletGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize);
                    bulletGradient.addColorStop(0, '#ffb74d'); // Bright orange center
                    bulletGradient.addColorStop(0.3, '#ff9800'); // Standard orange
                    bulletGradient.addColorStop(0.7, '#f57c00'); // Dark orange
                    bulletGradient.addColorStop(1, '#e65100'); // Very dark orange edge
                    this.ctx.fillStyle = bulletGradient;
                } else {
                    // Use solid color (much faster)
                    this.ctx.fillStyle = '#ff9800';
                }
                
                // OPTIMIZATION: Only use shadows if quality allows
                if (useShadows) {
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = 'rgba(255, 152, 0, 0.7)';
                }
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
                this.ctx.fill();
                if (useShadows) {
                    this.ctx.shadowBlur = 0;
                }
                
                // OPTIMIZATION: Only render inner core if quality allows
                if (useGradients && renderingQuality !== 'low') {
                    // Inner bright core - white to orange
                    const coreGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 0.6);
                    coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                    coreGradient.addColorStop(0.4, 'rgba(255, 224, 178, 0.7)');
                    coreGradient.addColorStop(1, 'rgba(255, 152, 0, 0)');
                    this.ctx.fillStyle = coreGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bulletSize * 0.6, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Calculate trail length (used for both trail rendering and particles)
                const trailLength = renderingQuality === 'medium' ? 18 : 25;
                
                // OPTIMIZATION: Only render trail if quality allows
                if (useTrails) {
                    // Enhanced energy trail
                    if (useGradients) {
                        const trailGradient = this.ctx.createLinearGradient(
                            bullet.x, bullet.y,
                            bullet.x - Math.cos(angle) * trailLength,
                            bullet.y - Math.sin(angle) * trailLength
                        );
                        trailGradient.addColorStop(0, 'rgba(255, 152, 0, 0.9)');
                        trailGradient.addColorStop(0.3, 'rgba(255, 193, 7, 0.7)');
                        trailGradient.addColorStop(0.6, 'rgba(255, 183, 77, 0.5)');
                        trailGradient.addColorStop(1, 'rgba(255, 152, 0, 0)');
                        this.ctx.strokeStyle = trailGradient;
                    } else {
                        // Use solid color (much faster)
                        this.ctx.strokeStyle = 'rgba(255, 152, 0, 0.6)';
                    }
                    
                    this.ctx.lineWidth = renderingQuality === 'medium' ? 3 : 4;
                    this.ctx.lineCap = 'round';
                    // OPTIMIZATION: Only use shadows if quality allows
                    if (useShadows) {
                        this.ctx.shadowBlur = 7;
                        this.ctx.shadowColor = 'rgba(255, 152, 0, 0.5)';
                    }
                    this.ctx.beginPath();
                    this.ctx.moveTo(bullet.x, bullet.y);
                    this.ctx.lineTo(bullet.x - Math.cos(angle) * trailLength, 
                                  bullet.y - Math.sin(angle) * trailLength);
                    this.ctx.stroke();
                    if (useShadows) {
                        this.ctx.shadowBlur = 0;
                    }
                }
                
                // OPTIMIZATION: Only create trail particles if quality allows
                if (useParticles) {
                    // Trail particles (4 particles for rapid fire effect)
                    // OPTIMIZED: Reduce particles when many bullets active
                    const rapidTrailCount = Math.max(1, Math.floor(4 * particleMultiplier));
                    for (let i = 0; i < rapidTrailCount; i++) {
                        const particlePos = (i + 1) / (rapidTrailCount + 1);
                        const particleX = bullet.x - Math.cos(angle) * trailLength * particlePos;
                        const particleY = bullet.y - Math.sin(angle) * trailLength * particlePos;
                        const particleSize = 2 + Math.sin(time * 6 + i) * 0.8;
                        
                        this.ctx.fillStyle = `rgba(255, 255, 200, ${0.8 - i * 0.15})`;
                        // OPTIMIZATION: Only use shadows if quality allows
                        if (useShadows) {
                            this.ctx.shadowBlur = 5;
                            this.ctx.shadowColor = 'rgba(255, 152, 0, 0.5)';
                        }
                        this.ctx.beginPath();
                        this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        if (useShadows) {
                            this.ctx.shadowBlur = 0;
                        }
                    }
                }
                
                // OPTIMIZATION: Only create orbiting particles if quality allows
                if (useParticles && !isHighBulletCount) {
                    // Orbiting energy particles (3 particles - more for rapid fire)
                    for (let i = 0; i < 3; i++) {
                        const particleAngle = time * 4 + (i / 3) * Math.PI * 2;
                        const particleX = bullet.x + Math.cos(particleAngle) * (bulletSize + 5);
                        const particleY = bullet.y + Math.sin(particleAngle) * (bulletSize + 5);
                        const particleSize = 2 + Math.sin(time * 5 + i) * 0.6;
                        
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9})`;
                        // OPTIMIZED: Reduced shadow blur
                        this.ctx.shadowBlur = 6;
                        this.ctx.shadowColor = 'rgba(255, 152, 0, 0.7)';
                        this.ctx.beginPath();
                        this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;
                    }
                }
                
                // Rapid fire energy rings (2 rotating rings)
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(time * 5);
                
                // Ring 1
                this.ctx.strokeStyle = `rgba(255, 193, 7, ${0.4 * pulsePhase})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([4, 3]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 6, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Ring 2
                this.ctx.rotate(-time * 3);
                this.ctx.strokeStyle = `rgba(255, 183, 77, ${0.3 * pulsePhase})`;
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([3, 4]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 8, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
                this.ctx.restore();
            } else if (weaponName === 'spread') {
                // Enhanced Spread Weapon Bullets - multi-shot purple energy projectiles
                const bulletSize = bullet.size || 5;
                const angle = Math.atan2(bullet.vy, bullet.vx);
                
                // Outer energy field glow - purple/magenta
                const outerGlow = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 3.2);
                outerGlow.addColorStop(0, 'rgba(156, 39, 176, 0.4)');
                outerGlow.addColorStop(0.4, 'rgba(171, 71, 188, 0.25)');
                outerGlow.addColorStop(0.7, 'rgba(156, 39, 176, 0.15)');
                outerGlow.addColorStop(1, 'rgba(156, 39, 176, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 3.2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pulsing outer ring - spread pattern effect
                const pulsePhase = Math.sin(time * 3.5) * 0.3 + 0.7;
                this.ctx.strokeStyle = `rgba(186, 104, 200, ${0.7 * pulsePhase})`;
                this.ctx.lineWidth = 2.5;
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = 'rgba(156, 39, 176, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize + 4, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Main bullet body with purple gradient
                const bulletGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize);
                bulletGradient.addColorStop(0, '#ba68c8'); // Bright purple center
                bulletGradient.addColorStop(0.3, '#ab47bc'); // Medium purple
                bulletGradient.addColorStop(0.7, '#9c27b0'); // Standard purple
                bulletGradient.addColorStop(1, '#7b1fa2'); // Dark purple edge
                this.ctx.fillStyle = bulletGradient;
                // OPTIMIZED: Reduced shadow blur
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(156, 39, 176, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Inner bright core - white to purple
                const coreGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 0.55);
                coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                coreGradient.addColorStop(0.4, 'rgba(233, 30, 99, 0.6)'); // Pink-purple
                coreGradient.addColorStop(1, 'rgba(156, 39, 176, 0)');
                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 0.55, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Enhanced energy trail - wider for spread effect
                const trailLength = 22;
                const trailGradient = this.ctx.createLinearGradient(
                    bullet.x, bullet.y,
                    bullet.x - Math.cos(angle) * trailLength,
                    bullet.y - Math.sin(angle) * trailLength
                );
                trailGradient.addColorStop(0, 'rgba(156, 39, 176, 0.9)');
                trailGradient.addColorStop(0.3, 'rgba(186, 104, 200, 0.7)');
                trailGradient.addColorStop(0.6, 'rgba(171, 71, 188, 0.5)');
                trailGradient.addColorStop(1, 'rgba(156, 39, 176, 0)');
                
                this.ctx.strokeStyle = trailGradient;
                this.ctx.lineWidth = 4;
                this.ctx.lineCap = 'round';
                // OPTIMIZED: Reduced shadow blur
                this.ctx.shadowBlur = 7;
                this.ctx.shadowColor = 'rgba(156, 39, 176, 0.5)';
                this.ctx.beginPath();
                this.ctx.moveTo(bullet.x, bullet.y);
                this.ctx.lineTo(bullet.x - Math.cos(angle) * trailLength, 
                              bullet.y - Math.sin(angle) * trailLength);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Trail particles (5 particles for spread effect)
                // OPTIMIZED: Reduce particles when many bullets active
                const spreadTrailCount = Math.max(2, Math.floor(5 * particleMultiplier));
                for (let i = 0; i < spreadTrailCount; i++) {
                    const particlePos = (i + 1) / (spreadTrailCount + 1);
                    const particleX = bullet.x - Math.cos(angle) * trailLength * particlePos;
                    const particleY = bullet.y - Math.sin(angle) * trailLength * particlePos;
                    const particleSize = 2 + Math.sin(time * 4.5 + i) * 0.7;
                    
                    this.ctx.fillStyle = `rgba(255, 200, 255, ${0.8 - i * 0.12})`;
                    // OPTIMIZED: Reduced shadow blur
                    this.ctx.shadowBlur = 5;
                    this.ctx.shadowColor = 'rgba(156, 39, 176, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // Orbiting energy particles (4 particles - spread pattern)
                for (let i = 0; i < 4; i++) {
                    const particleAngle = time * 3.5 + (i / 4) * Math.PI * 2;
                    const particleX = bullet.x + Math.cos(particleAngle) * (bulletSize + 5);
                    const particleY = bullet.y + Math.sin(particleAngle) * (bulletSize + 5);
                    const particleSize = 2 + Math.sin(time * 4.5 + i) * 0.6;
                    
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9})`;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = 'rgba(156, 39, 176, 0.9)';
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // Spread pattern energy lines (4 lines radiating outward)
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(angle);
                
                for (let i = 0; i < 4; i++) {
                    const lineAngle = (i / 4) * Math.PI * 2;
                    const lineLength = bulletSize + 6;
                    const lineX = Math.cos(lineAngle) * lineLength;
                    const lineY = Math.sin(lineAngle) * lineLength;
                    
                    const lineGradient = this.ctx.createLinearGradient(0, 0, lineX, lineY);
                    lineGradient.addColorStop(0, `rgba(156, 39, 176, ${0.6 * pulsePhase})`);
                    lineGradient.addColorStop(1, 'rgba(156, 39, 176, 0)');
                    
                    this.ctx.strokeStyle = lineGradient;
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = 'rgba(156, 39, 176, 0.6)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(lineX, lineY);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
                
                this.ctx.restore();
            } else if (weaponName.includes('+')) {
                // Enhanced Weapon Combo Bullets - blend of multiple weapons
                // OPTIMIZED: Further simplify when high fire rate or many weapons stacked
                // Parse combo weapons first to check for spread
                const comboWeapons = weaponName.split('+');
                const comboWeaponCount = comboWeapons.length;
                // OPTIMIZATION: Always simplify combo rendering when quality is medium or lower
                const shouldSimplifyCombo = renderingQuality === 'medium' || renderingQuality === 'low' || 
                                           isVeryHighFireRate || (isHighFireRate && comboWeaponCount >= 3);
                
                const hasRapid = comboWeapons.includes('rapid');
                const hasSpread = comboWeapons.includes('spread');
                const hasBasic = comboWeapons.includes('basic');
                const hasAutomatic = comboWeapons.includes('automatic');
                const hasTransformationPredictor = comboWeapons.includes('transformationPredictor');
                const hasDeterministicEngine = comboWeapons.includes('deterministicEngine');
                const hasIndividualSystemCore = comboWeapons.includes('individualSystemCore');
                
                // If spread is in the combo, use spread's normal size (5) to prevent massive bullets
                // Otherwise use the bullet's size (which may be larger for other weapons)
                const bulletSize = hasSpread ? 5 : (bullet.size || 5);
                const angle = Math.atan2(bullet.vy, bullet.vx);
                
                // Determine combo color based on weapons (prioritize high-tier weapons)
                let comboColor1, comboColor2, comboColorRGB1, comboColorRGB2;
                
                // High-tier weapon combinations (check these first)
                if (hasIndividualSystemCore) {
                    // Individual System Core combinations - cyan theme
                    if (hasDeterministicEngine) {
                        // Individual System Core + Deterministic Engine: Cyan + Deep Purple
                        comboColor1 = '#00ffff'; // Cyan
                        comboColor2 = '#8b00ff'; // Deep purple
                        comboColorRGB1 = '0, 255, 255';
                        comboColorRGB2 = '139, 0, 255';
                    } else if (hasTransformationPredictor) {
                        // Individual System Core + Transformation Predictor: Cyan + Orange
                        comboColor1 = '#00ffff'; // Cyan
                        comboColor2 = '#ff6b00'; // Orange
                        comboColorRGB1 = '0, 255, 255';
                        comboColorRGB2 = '255, 107, 0';
                    } else if (hasAutomatic) {
                        // Individual System Core + Automatic: Cyan + Light Cyan
                        comboColor1 = '#00ffff'; // Cyan
                        comboColor2 = '#00bcd4'; // Light cyan
                        comboColorRGB1 = '0, 255, 255';
                        comboColorRGB2 = '0, 188, 212';
                    } else if (hasSpread) {
                        // Individual System Core + Spread: Cyan + Purple
                        comboColor1 = '#00ffff'; // Cyan
                        comboColor2 = '#9c27b0'; // Purple
                        comboColorRGB1 = '0, 255, 255';
                        comboColorRGB2 = '156, 39, 176';
                    } else if (hasRapid) {
                        // Individual System Core + Rapid: Cyan + Orange
                        comboColor1 = '#00ffff'; // Cyan
                        comboColor2 = '#ff9800'; // Orange
                        comboColorRGB1 = '0, 255, 255';
                        comboColorRGB2 = '255, 152, 0';
                    } else if (hasBasic) {
                        // Individual System Core + Basic: Cyan + Green
                        comboColor1 = '#00ffff'; // Cyan
                        comboColor2 = '#4caf50'; // Green
                        comboColorRGB1 = '0, 255, 255';
                        comboColorRGB2 = '76, 175, 80';
                    } else {
                        // Individual System Core alone (shouldn't happen, but fallback)
                        comboColor1 = '#00ffff';
                        comboColor2 = '#00bcd4';
                        comboColorRGB1 = '0, 255, 255';
                        comboColorRGB2 = '0, 188, 212';
                    }
                } else if (hasDeterministicEngine) {
                    // Deterministic Engine combinations - deep purple theme
                    if (hasTransformationPredictor) {
                        // Deterministic Engine + Transformation Predictor: Deep Purple + Orange
                        comboColor1 = '#8b00ff'; // Deep purple
                        comboColor2 = '#ff6b00'; // Orange
                        comboColorRGB1 = '139, 0, 255';
                        comboColorRGB2 = '255, 107, 0';
                    } else if (hasAutomatic) {
                        // Deterministic Engine + Automatic: Deep Purple + Cyan
                        comboColor1 = '#8b00ff'; // Deep purple
                        comboColor2 = '#00bcd4'; // Cyan
                        comboColorRGB1 = '139, 0, 255';
                        comboColorRGB2 = '0, 188, 212';
                    } else if (hasSpread) {
                        // Deterministic Engine + Spread: Deep Purple + Purple
                        comboColor1 = '#8b00ff'; // Deep purple
                        comboColor2 = '#9c27b0'; // Purple
                        comboColorRGB1 = '139, 0, 255';
                        comboColorRGB2 = '156, 39, 176';
                    } else if (hasRapid) {
                        // Deterministic Engine + Rapid: Deep Purple + Orange
                        comboColor1 = '#8b00ff'; // Deep purple
                        comboColor2 = '#ff9800'; // Orange
                        comboColorRGB1 = '139, 0, 255';
                        comboColorRGB2 = '255, 152, 0';
                    } else if (hasBasic) {
                        // Deterministic Engine + Basic: Deep Purple + Green
                        comboColor1 = '#8b00ff'; // Deep purple
                        comboColor2 = '#4caf50'; // Green
                        comboColorRGB1 = '139, 0, 255';
                        comboColorRGB2 = '76, 175, 80';
                    } else {
                        // Deterministic Engine alone (shouldn't happen, but fallback)
                        comboColor1 = '#8b00ff';
                        comboColor2 = '#9c27b0';
                        comboColorRGB1 = '139, 0, 255';
                        comboColorRGB2 = '156, 39, 176';
                    }
                } else if (hasTransformationPredictor) {
                    // Transformation Predictor combinations - orange theme
                    if (hasAutomatic) {
                        // Transformation Predictor + Automatic: Orange + Cyan
                        comboColor1 = '#ff6b00'; // Orange
                        comboColor2 = '#00bcd4'; // Cyan
                        comboColorRGB1 = '255, 107, 0';
                        comboColorRGB2 = '0, 188, 212';
                    } else if (hasSpread) {
                        // Transformation Predictor + Spread: Orange + Purple
                        comboColor1 = '#ff6b00'; // Orange
                        comboColor2 = '#9c27b0'; // Purple
                        comboColorRGB1 = '255, 107, 0';
                        comboColorRGB2 = '156, 39, 176';
                    } else if (hasRapid) {
                        // Transformation Predictor + Rapid: Orange + Orange (bright orange)
                        comboColor1 = '#ff6b00'; // Deep orange
                        comboColor2 = '#ff9800'; // Bright orange
                        comboColorRGB1 = '255, 107, 0';
                        comboColorRGB2 = '255, 152, 0';
                    } else if (hasBasic) {
                        // Transformation Predictor + Basic: Orange + Green
                        comboColor1 = '#ff6b00'; // Orange
                        comboColor2 = '#4caf50'; // Green
                        comboColorRGB1 = '255, 107, 0';
                        comboColorRGB2 = '76, 175, 80';
                    } else {
                        // Transformation Predictor alone (shouldn't happen, but fallback)
                        comboColor1 = '#ff6b00';
                        comboColor2 = '#ff9800';
                        comboColorRGB1 = '255, 107, 0';
                        comboColorRGB2 = '255, 152, 0';
                    }
                } else if (hasAutomatic) {
                    // Automatic combinations - cyan theme
                    if (hasSpread) {
                        // Automatic + Spread: Cyan + Purple
                        comboColor1 = '#00bcd4'; // Cyan
                        comboColor2 = '#9c27b0'; // Purple
                        comboColorRGB1 = '0, 188, 212';
                        comboColorRGB2 = '156, 39, 176';
                    } else if (hasRapid) {
                        // Automatic + Rapid: Cyan + Orange
                        comboColor1 = '#00bcd4'; // Cyan
                        comboColor2 = '#ff9800'; // Orange
                        comboColorRGB1 = '0, 188, 212';
                        comboColorRGB2 = '255, 152, 0';
                    } else if (hasBasic) {
                        // Automatic + Basic: Cyan + Green
                        comboColor1 = '#00bcd4'; // Cyan
                        comboColor2 = '#4caf50'; // Green
                        comboColorRGB1 = '0, 188, 212';
                        comboColorRGB2 = '76, 175, 80';
                    } else {
                        // Automatic alone (shouldn't happen, but fallback)
                        comboColor1 = '#00bcd4';
                        comboColor2 = '#4fc3f7';
                        comboColorRGB1 = '0, 188, 212';
                        comboColorRGB2 = '79, 195, 247';
                    }
                } else if (hasRapid && hasSpread) {
                    // Rapid + Spread: Orange + Purple = Orange-Purple gradient
                    comboColor1 = '#ff9800'; // Orange
                    comboColor2 = '#9c27b0'; // Purple
                    comboColorRGB1 = '255, 152, 0';
                    comboColorRGB2 = '156, 39, 176';
                } else if (hasRapid && hasBasic) {
                    // Rapid + Basic: Orange + Green = Yellow-Orange gradient
                    comboColor1 = '#ff9800'; // Orange
                    comboColor2 = '#4caf50'; // Green
                    comboColorRGB1 = '255, 152, 0';
                    comboColorRGB2 = '76, 175, 80';
                } else if (hasSpread && hasBasic) {
                    // Spread + Basic: Purple + Green = Purple-Green gradient
                    comboColor1 = '#9c27b0'; // Purple
                    comboColor2 = '#4caf50'; // Green
                    comboColorRGB1 = '156, 39, 176';
                    comboColorRGB2 = '76, 175, 80';
                } else {
                    // Default combo (any other combination)
                    comboColor1 = '#4fc3f7'; // Cyan
                    comboColor2 = '#ff9800'; // Orange
                    comboColorRGB1 = '79, 195, 247';
                    comboColorRGB2 = '255, 152, 0';
                }
                
                // OPTIMIZATION: Only render glow if quality allows (already handled above, but keeping for consistency)
                
                // Define pulse phases for combo weapon (used in multiple places)
                const pulsePhase1 = Math.sin(time * 4) * 0.3 + 0.7;
                const pulsePhase2 = Math.sin(time * 4 + Math.PI / 2) * 0.3 + 0.7;
                
                // OPTIMIZATION: Only render pulsing rings if quality allows
                if (useGlow && renderingQuality !== 'low') {
                    // Dual pulsing outer rings
                    
                    // Ring 1 - first color
                    this.ctx.strokeStyle = `rgba(${comboColorRGB1}, ${0.6 * pulsePhase1})`;
                    this.ctx.lineWidth = 2.5;
                    if (useShadows) {
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = `rgba(${comboColorRGB1}, 0.6)`;
                    }
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bulletSize + 4, 0, Math.PI * 2);
                    this.ctx.stroke();
                    if (useShadows) {
                        this.ctx.shadowBlur = 0;
                    }
                    
                    // OPTIMIZED: Only render second ring if quality is high enough
                    if (renderingQuality === 'ultra' || renderingQuality === 'high') {
                        // Ring 2 - second color
                        this.ctx.strokeStyle = `rgba(${comboColorRGB2}, ${0.5 * pulsePhase2})`;
                        this.ctx.lineWidth = 2;
                        if (useShadows) {
                            this.ctx.shadowBlur = isHighBulletCount ? 5 : 10;
                            this.ctx.shadowColor = `rgba(${comboColorRGB2}, 0.5)`;
                        }
                        this.ctx.beginPath();
                        this.ctx.arc(bullet.x, bullet.y, bulletSize + 6, 0, Math.PI * 2);
                        this.ctx.stroke();
                        if (useShadows) {
                            this.ctx.shadowBlur = 0;
                        }
                    }
                }
                
                // Main bullet body
                // OPTIMIZATION: Use solid color when quality doesn't allow gradients
                if (!useGradients || isVeryHighBulletCount || shouldSimplifyCombo) {
                    // Very high bullet count or low quality: simple solid color (fastest)
                    this.ctx.fillStyle = comboColor1;
                } else {
                    // Normal: dual-color gradient (only if quality allows)
                    const bulletGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize);
                    if (isHighBulletCount || isHighFireRate || renderingQuality === 'medium') {
                        // High bullet count or medium quality: simpler 2-stop gradient
                        bulletGradient.addColorStop(0, comboColor1);
                        bulletGradient.addColorStop(1, comboColor2);
                    } else {
                        // Normal: 4-stop gradient
                        bulletGradient.addColorStop(0, comboColor1);
                        bulletGradient.addColorStop(0.4, comboColor2);
                        bulletGradient.addColorStop(0.7, comboColor1);
                        bulletGradient.addColorStop(1, comboColor2);
                    }
                    this.ctx.fillStyle = bulletGradient;
                }
                // OPTIMIZATION: Only use shadows if quality allows
                if (useShadows) {
                    this.ctx.shadowBlur = (isHighBulletCount || isHighFireRate) ? 6 : 12;
                    this.ctx.shadowColor = `rgba(${comboColorRGB1}, ${(isHighBulletCount || isHighFireRate) ? 0.4 : 0.7})`;
                }
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
                this.ctx.fill();
                if (useShadows) {
                    this.ctx.shadowBlur = 0;
                }
                
                // OPTIMIZATION: Only render inner core if quality allows
                if (useGradients && renderingQuality !== 'low' && !isVeryHighBulletCount && !shouldSimplifyCombo) {
                    // Inner bright core
                    const coreGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 0.6);
                    if (isHighBulletCount || isHighFireRate || renderingQuality === 'medium') {
                        // Simpler 2-stop gradient
                        coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        coreGradient.addColorStop(1, `rgba(${comboColorRGB1}, 0)`);
                    } else {
                        // Full 4-stop gradient
                        coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                        coreGradient.addColorStop(0.3, `rgba(${comboColorRGB1}, 0.6)`);
                        coreGradient.addColorStop(0.6, `rgba(${comboColorRGB2}, 0.4)`);
                        coreGradient.addColorStop(1, `rgba(${comboColorRGB1}, 0)`);
                    }
                    this.ctx.fillStyle = coreGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bulletSize * 0.6, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Calculate trail length (used for both trail rendering and particles)
                const trailLength = (isVeryHighBulletCount || shouldSimplifyCombo || renderingQuality === 'medium') ? 15 : 24;
                
                // OPTIMIZATION: Only render trail if quality allows
                if (useTrails) {
                    // Enhanced energy trail
                    if (useGradients && !isVeryHighBulletCount && !shouldSimplifyCombo) {
                        // Use gradient trail
                        const trailGradient = this.ctx.createLinearGradient(
                            bullet.x, bullet.y,
                            bullet.x - Math.cos(angle) * trailLength,
                            bullet.y - Math.sin(angle) * trailLength
                        );
                        if (isHighBulletCount || isHighFireRate || renderingQuality === 'medium') {
                            // Simpler 2-stop gradient
                            trailGradient.addColorStop(0, `rgba(${comboColorRGB1}, 0.8)`);
                            trailGradient.addColorStop(1, `rgba(${comboColorRGB2}, 0)`);
                        } else {
                            // Full 4-stop gradient
                            trailGradient.addColorStop(0, `rgba(${comboColorRGB1}, 0.9)`);
                            trailGradient.addColorStop(0.3, `rgba(${comboColorRGB2}, 0.7)`);
                            trailGradient.addColorStop(0.6, `rgba(${comboColorRGB1}, 0.5)`);
                            trailGradient.addColorStop(1, `rgba(${comboColorRGB2}, 0)`);
                        }
                        this.ctx.strokeStyle = trailGradient;
                    } else {
                        // Use solid color (much faster)
                        this.ctx.strokeStyle = `rgba(${comboColorRGB1}, 0.6)`;
                    }
                    this.ctx.lineWidth = (isHighBulletCount || isHighFireRate || renderingQuality === 'medium') ? 3 : 5;
                    this.ctx.lineCap = 'round';
                    // OPTIMIZATION: Only use shadows if quality allows
                    if (useShadows) {
                        this.ctx.shadowBlur = (isHighBulletCount || isHighFireRate) ? 4 : 8;
                        this.ctx.shadowColor = `rgba(${comboColorRGB1}, ${(isHighBulletCount || isHighFireRate) ? 0.3 : 0.6})`;
                    }
                    this.ctx.beginPath();
                    this.ctx.moveTo(bullet.x, bullet.y);
                    this.ctx.lineTo(bullet.x - Math.cos(angle) * trailLength, 
                                  bullet.y - Math.sin(angle) * trailLength);
                    this.ctx.stroke();
                    if (useShadows) {
                        this.ctx.shadowBlur = 0;
                    }
                }
                
                // OPTIMIZATION: Only create trail particles if quality allows
                if (useParticles) {
                    // Trail particles (6 particles for combo effect)
                    // OPTIMIZED: Reduce particles when many bullets active
                    const comboTrailCount = Math.max(2, Math.floor(6 * particleMultiplier));
                    for (let i = 0; i < comboTrailCount; i++) {
                        const particlePos = (i + 1) / (comboTrailCount + 1);
                        const particleX = bullet.x - Math.cos(angle) * trailLength * particlePos;
                        const particleY = bullet.y - Math.sin(angle) * trailLength * particlePos;
                        const particleSize = 2 + Math.sin(time * 5 + i) * 0.7;
                        const particleColor = i % 2 === 0 ? comboColorRGB1 : comboColorRGB2;
                        
                        this.ctx.fillStyle = `rgba(${particleColor}, ${0.8 - i * 0.1})`;
                        // OPTIMIZED: Reduced shadow blur
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = `rgba(${particleColor}, 0.5)`;
                        this.ctx.beginPath();
                        this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        if (useShadows) {
                            this.ctx.shadowBlur = 0;
                        }
                    }
                }
                
                // OPTIMIZATION: Only create orbiting particles if quality allows
                if (useParticles && !isVeryHighBulletCount && !shouldSimplifyCombo) {
                    // Orbiting energy particles - reduced when many bullets or high fire rate
                    const orbitingCount = (isHighBulletCount || isHighFireRate || renderingQuality === 'medium') ? 3 : 5;
                    for (let i = 0; i < orbitingCount; i++) {
                        const particleAngle = time * 4 + (i / orbitingCount) * Math.PI * 2;
                        const particleX = bullet.x + Math.cos(particleAngle) * (bulletSize + 6);
                        const particleY = bullet.y + Math.sin(particleAngle) * (bulletSize + 6);
                        const particleSize = 2.5 + Math.sin(time * 5 + i) * 0.6;
                        const particleColor = i % 2 === 0 ? comboColorRGB1 : comboColorRGB2;
                        
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9})`;
                        // OPTIMIZATION: Only use shadows if quality allows
                        if (useShadows) {
                            this.ctx.shadowBlur = (isHighBulletCount || isHighFireRate) ? 6 : 12;
                            this.ctx.shadowColor = `rgba(${particleColor}, ${(isHighBulletCount || isHighFireRate) ? 0.5 : 0.9})`;
                        }
                        this.ctx.beginPath();
                        this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        this.ctx.fill();
                        if (useShadows) {
                            this.ctx.shadowBlur = 0;
                        }
                    }
                }
                
                // OPTIMIZATION: Only render combo energy rings if quality allows
                if (useGlow && renderingQuality === 'ultra' && !isHighBulletCount) {
                    // Combo energy rings (3 rotating rings - dual color)
                    // Define pulse phases for this section
                    const comboPulsePhase1 = Math.sin(time * 4) * 0.3 + 0.7;
                    const comboPulsePhase2 = Math.sin(time * 4 + Math.PI / 2) * 0.3 + 0.7;
                    
                    this.ctx.save();
                    this.ctx.translate(bullet.x, bullet.y);
                    this.ctx.rotate(time * 4);
                    
                    // Ring 1 - first color
                    this.ctx.strokeStyle = `rgba(${comboColorRGB1}, ${0.5 * comboPulsePhase1})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 4]);
                    if (useShadows) {
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = `rgba(${comboColorRGB1}, 0.6)`;
                    }
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, bulletSize + 7, 0, Math.PI * 2);
                    this.ctx.stroke();
                    if (useShadows) {
                        this.ctx.shadowBlur = 0;
                    }
                    
                    // Ring 2 - second color
                    this.ctx.rotate(-time * 3);
                    this.ctx.strokeStyle = `rgba(${comboColorRGB2}, ${0.4 * comboPulsePhase2})`;
                    this.ctx.lineWidth = 1.5;
                    this.ctx.setLineDash([4, 5]);
                    if (useShadows) {
                        this.ctx.shadowBlur = 8;
                        this.ctx.shadowColor = `rgba(${comboColorRGB2}, 0.5)`;
                    }
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, bulletSize + 9, 0, Math.PI * 2);
                    this.ctx.stroke();
                    if (useShadows) {
                        this.ctx.shadowBlur = 0;
                    }
                    
                    // Ring 3 - alternating pattern
                    this.ctx.rotate(time * 2);
                    if (useGradients) {
                        const ring3Gradient = this.ctx.createLinearGradient(-bulletSize - 10, 0, bulletSize + 10, 0);
                        ring3Gradient.addColorStop(0, `rgba(${comboColorRGB1}, ${0.3 * comboPulsePhase1})`);
                        ring3Gradient.addColorStop(0.5, `rgba(${comboColorRGB2}, ${0.3 * comboPulsePhase2})`);
                        ring3Gradient.addColorStop(1, `rgba(${comboColorRGB1}, ${0.3 * comboPulsePhase1})`);
                        this.ctx.strokeStyle = ring3Gradient;
                    } else {
                        this.ctx.strokeStyle = `rgba(${comboColorRGB1}, 0.3)`;
                    }
                    this.ctx.lineWidth = 1.5;
                    this.ctx.setLineDash([3, 6]);
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, bulletSize + 11, 0, Math.PI * 2);
                    this.ctx.stroke();
                    if (useShadows) {
                        this.ctx.shadowBlur = 0;
                    }
                    
                    this.ctx.setLineDash([]);
                    this.ctx.restore();
                }
                
                // Combo-specific effects based on weapon combination
                if (hasRapid && hasSpread) {
                    // Rapid + Spread: Add spread pattern lines with rapid fire rings
                    this.ctx.save();
                    this.ctx.translate(bullet.x, bullet.y);
                    this.ctx.rotate(angle);
                    
                    // Spread pattern lines (4 lines)
                    for (let i = 0; i < 4; i++) {
                        const lineAngle = (i / 4) * Math.PI * 2;
                        const lineLength = bulletSize + 8;
                        const lineX = Math.cos(lineAngle) * lineLength;
                        const lineY = Math.sin(lineAngle) * lineLength;
                        
                        const lineGradient = this.ctx.createLinearGradient(0, 0, lineX, lineY);
                        lineGradient.addColorStop(0, `rgba(${comboColorRGB1}, ${0.5 * pulsePhase1})`);
                        lineGradient.addColorStop(1, `rgba(${comboColorRGB2}, 0)`);
                        
                        this.ctx.strokeStyle = lineGradient;
                        this.ctx.lineWidth = 2.5;
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = `rgba(${comboColorRGB1}, 0.6)`;
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, 0);
                        this.ctx.lineTo(lineX, lineY);
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                    }
                    this.ctx.restore();
                }
            } else if (weaponName === 'automatic') {
                // Enhanced Automatic Weapon Bullets - continuous-fire cyan energy projectiles
                const bulletSize = bullet.size || 4;
                const angle = Math.atan2(bullet.vy, bullet.vx);
                
                // Outer energy field glow - cyan/blue
                const outerGlow = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 4);
                outerGlow.addColorStop(0, 'rgba(0, 188, 212, 0.5)');
                outerGlow.addColorStop(0.3, 'rgba(79, 195, 247, 0.35)');
                outerGlow.addColorStop(0.6, 'rgba(0, 188, 212, 0.25)');
                outerGlow.addColorStop(1, 'rgba(0, 188, 212, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 4, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Dual pulsing outer rings - continuous fire effect
                const pulsePhase1 = Math.sin(time * 5) * 0.3 + 0.7;
                const pulsePhase2 = Math.sin(time * 5 + Math.PI / 3) * 0.3 + 0.7;
                
                // Ring 1 - cyan
                this.ctx.strokeStyle = `rgba(0, 188, 212, ${0.7 * pulsePhase1})`;
                this.ctx.lineWidth = 2.5;
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = 'rgba(0, 188, 212, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize + 5, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Ring 2 - light blue
                this.ctx.strokeStyle = `rgba(79, 195, 247, ${0.6 * pulsePhase2})`;
                this.ctx.lineWidth = 2;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(79, 195, 247, 0.6)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize + 7, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Main bullet body with cyan gradient
                const bulletGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize);
                bulletGradient.addColorStop(0, '#4dd0e1'); // Bright cyan center
                bulletGradient.addColorStop(0.3, '#26c6da'); // Medium cyan
                bulletGradient.addColorStop(0.6, '#00bcd4'); // Standard cyan
                bulletGradient.addColorStop(1, '#0097a7'); // Dark cyan edge
                this.ctx.fillStyle = bulletGradient;
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = 'rgba(0, 188, 212, 0.9)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Inner bright core - white to cyan
                const coreGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 0.6);
                coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                coreGradient.addColorStop(0.3, 'rgba(178, 235, 242, 0.7)'); // Light cyan
                coreGradient.addColorStop(0.6, 'rgba(77, 208, 225, 0.5)'); // Bright cyan
                coreGradient.addColorStop(1, 'rgba(0, 188, 212, 0)');
                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 0.6, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Enhanced energy trail - longer for continuous fire
                const trailLength = 28;
                const trailGradient = this.ctx.createLinearGradient(
                    bullet.x, bullet.y,
                    bullet.x - Math.cos(angle) * trailLength,
                    bullet.y - Math.sin(angle) * trailLength
                );
                trailGradient.addColorStop(0, 'rgba(0, 188, 212, 0.95)');
                trailGradient.addColorStop(0.2, 'rgba(79, 195, 247, 0.8)');
                trailGradient.addColorStop(0.5, 'rgba(0, 188, 212, 0.6)');
                trailGradient.addColorStop(0.8, 'rgba(77, 208, 225, 0.4)');
                trailGradient.addColorStop(1, 'rgba(0, 188, 212, 0)');
                
                this.ctx.strokeStyle = trailGradient;
                this.ctx.lineWidth = 4.5;
                this.ctx.lineCap = 'round';
                this.ctx.shadowBlur = 16;
                this.ctx.shadowColor = 'rgba(0, 188, 212, 0.8)';
                this.ctx.beginPath();
                this.ctx.moveTo(bullet.x, bullet.y);
                this.ctx.lineTo(bullet.x - Math.cos(angle) * trailLength, 
                              bullet.y - Math.sin(angle) * trailLength);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Trail particles (7 particles for continuous fire effect - most of any weapon)
                // OPTIMIZED: Reduce particles when many bullets active
                const autoTrailCount = Math.max(2, Math.floor(7 * particleMultiplier));
                for (let i = 0; i < autoTrailCount; i++) {
                    const particlePos = (i + 1) / (autoTrailCount + 1);
                    const particleX = bullet.x - Math.cos(angle) * trailLength * particlePos;
                    const particleY = bullet.y - Math.sin(angle) * trailLength * particlePos;
                    const particleSize = 2 + Math.sin(time * 6 + i) * 0.8;
                    
                    // Alternating cyan and light blue particles
                    const particleColor = i % 2 === 0 ? '0, 188, 212' : '79, 195, 247';
                    this.ctx.fillStyle = `rgba(${particleColor}, ${0.85 - i * 0.1})`;
                    // OPTIMIZED: Reduced shadow blur
                    this.ctx.shadowBlur = 6;
                    this.ctx.shadowColor = `rgba(${particleColor}, 0.7)`;
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // Orbiting energy particles (6 particles - continuous fire pattern)
                for (let i = 0; i < 6; i++) {
                    const particleAngle = time * 5 + (i / 6) * Math.PI * 2;
                    const particleX = bullet.x + Math.cos(particleAngle) * (bulletSize + 6);
                    const particleY = bullet.y + Math.sin(particleAngle) * (bulletSize + 6);
                    const particleSize = 2.5 + Math.sin(time * 6 + i) * 0.7;
                    
                    // Alternating colors
                    const particleColor = i % 2 === 0 ? '0, 188, 212' : '79, 195, 247';
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.9})`;
                    this.ctx.shadowBlur = 12;
                    this.ctx.shadowColor = `rgba(${particleColor}, 0.9)`;
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // Continuous fire energy rings (4 rotating rings - most of any weapon)
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(time * 6);
                
                // Ring 1 - cyan
                this.ctx.strokeStyle = `rgba(0, 188, 212, ${0.5 * pulsePhase1})`;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 3]);
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(0, 188, 212, 0.6)';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 8, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Ring 2 - light blue (counter-rotating)
                this.ctx.rotate(-time * 4);
                this.ctx.strokeStyle = `rgba(79, 195, 247, ${0.4 * pulsePhase2})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([4, 4]);
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = 'rgba(79, 195, 247, 0.5)';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 10, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Ring 3 - cyan (faster rotation)
                this.ctx.rotate(time * 7);
                this.ctx.strokeStyle = `rgba(0, 188, 212, ${0.35 * pulsePhase1})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([3, 5]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 12, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Ring 4 - gradient ring (outermost)
                this.ctx.rotate(-time * 3);
                const ring4Gradient = this.ctx.createLinearGradient(-bulletSize - 14, 0, bulletSize + 14, 0);
                ring4Gradient.addColorStop(0, `rgba(0, 188, 212, ${0.3 * pulsePhase1})`);
                ring4Gradient.addColorStop(0.5, `rgba(79, 195, 247, ${0.3 * pulsePhase2})`);
                ring4Gradient.addColorStop(1, `rgba(0, 188, 212, ${0.3 * pulsePhase1})`);
                this.ctx.strokeStyle = ring4Gradient;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([2, 6]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 14, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
                this.ctx.restore();
                
                // Continuous fire energy stream lines (6 lines radiating outward)
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(angle);
                
                for (let i = 0; i < 6; i++) {
                    const lineAngle = (i / 6) * Math.PI * 2;
                    const lineLength = bulletSize + 8;
                    const lineX = Math.cos(lineAngle) * lineLength;
                    const lineY = Math.sin(lineAngle) * lineLength;
                    
                    const lineGradient = this.ctx.createLinearGradient(0, 0, lineX, lineY);
                    const lineColor = i % 2 === 0 ? '0, 188, 212' : '79, 195, 247';
                    lineGradient.addColorStop(0, `rgba(${lineColor}, ${0.6 * (i % 2 === 0 ? pulsePhase1 : pulsePhase2)})`);
                    lineGradient.addColorStop(1, `rgba(${lineColor}, 0)`);
                    
                    this.ctx.strokeStyle = lineGradient;
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = `rgba(${lineColor}, 0.6)`;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(lineX, lineY);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
                
                this.ctx.restore();
            } else if (weaponName === 'transformationPredictor') {
                // Enhanced Transformation Predictor Bullets - prediction/precognition themed
                const bulletSize = bullet.size || 6;
                const angle = Math.atan2(bullet.vy, bullet.vx);
                
                // Outer prediction field glow - orange/amber with time distortion
                const outerGlow = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 3.8);
                outerGlow.addColorStop(0, 'rgba(255, 107, 0, 0.5)');
                outerGlow.addColorStop(0.3, 'rgba(255, 152, 0, 0.35)');
                outerGlow.addColorStop(0.6, 'rgba(255, 193, 7, 0.25)');
                outerGlow.addColorStop(1, 'rgba(255, 107, 0, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 3.8, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Prediction rings - multiple rings showing future positions
                const predictionPhase = Math.sin(time * 4) * 0.3 + 0.7;
                for (let i = 0; i < 3; i++) {
                    const ringSize = bulletSize + 4 + i * 3;
                    const ringAlpha = (0.6 - i * 0.15) * predictionPhase;
                    const ringOffset = i * 0.3; // Slight offset for prediction effect
                    
                    this.ctx.strokeStyle = `rgba(255, 152, 0, ${ringAlpha})`;
                    this.ctx.lineWidth = 2 - i * 0.3;
                    this.ctx.setLineDash([3, 2 + i]);
                    this.ctx.shadowBlur = 10 - i * 2;
                    this.ctx.shadowColor = 'rgba(255, 107, 0, 0.6)';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, ringSize, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
                this.ctx.setLineDash([]);
                
                // Main bullet body with orange/amber gradient
                const bulletGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize);
                bulletGradient.addColorStop(0, '#ffb74d'); // Bright orange center
                bulletGradient.addColorStop(0.3, '#ff9800'); // Standard orange
                bulletGradient.addColorStop(0.6, '#ff6b00'); // Deep orange
                bulletGradient.addColorStop(1, '#e65100'); // Dark orange edge
                this.ctx.fillStyle = bulletGradient;
                // OPTIMIZED: Reduced shadow blur
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = 'rgba(255, 107, 0, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Inner bright core - white to orange (prediction energy)
                const coreGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 0.65);
                coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                coreGradient.addColorStop(0.3, 'rgba(255, 224, 178, 0.8)');
                coreGradient.addColorStop(0.6, 'rgba(255, 183, 77, 0.6)');
                coreGradient.addColorStop(1, 'rgba(255, 107, 0, 0)');
                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 0.65, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Prediction trail - shows future path
                const trailLength = 30;
                const trailGradient = this.ctx.createLinearGradient(
                    bullet.x, bullet.y,
                    bullet.x - Math.cos(angle) * trailLength,
                    bullet.y - Math.sin(angle) * trailLength
                );
                trailGradient.addColorStop(0, 'rgba(255, 107, 0, 0.95)');
                trailGradient.addColorStop(0.2, 'rgba(255, 152, 0, 0.8)');
                trailGradient.addColorStop(0.5, 'rgba(255, 193, 7, 0.6)');
                trailGradient.addColorStop(0.8, 'rgba(255, 224, 178, 0.4)');
                trailGradient.addColorStop(1, 'rgba(255, 107, 0, 0)');
                
                this.ctx.strokeStyle = trailGradient;
                this.ctx.lineWidth = 5;
                this.ctx.lineCap = 'round';
                this.ctx.shadowBlur = 18;
                this.ctx.shadowColor = 'rgba(255, 107, 0, 0.8)';
                this.ctx.beginPath();
                this.ctx.moveTo(bullet.x, bullet.y);
                this.ctx.lineTo(bullet.x - Math.cos(angle) * trailLength, 
                              bullet.y - Math.sin(angle) * trailLength);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Future glimpse particles (showing predicted path)
                // OPTIMIZED: Reduce particles when many bullets active
                const predictorTrailCount = Math.max(2, Math.floor(8 * particleMultiplier));
                for (let i = 0; i < predictorTrailCount; i++) {
                    const particlePos = (i + 1) / (predictorTrailCount + 1);
                    const particleX = bullet.x - Math.cos(angle) * trailLength * particlePos;
                    const particleY = bullet.y - Math.sin(angle) * trailLength * particlePos;
                    const particleSize = 2.5 + Math.sin(time * 5 + i) * 0.8;
                    
                    // Prediction particles - brighter and more visible
                    this.ctx.fillStyle = `rgba(255, 255, 200, ${0.9 - i * 0.1})`;
                    // OPTIMIZED: Reduced shadow blur
                    this.ctx.shadowBlur = 7;
                    this.ctx.shadowColor = 'rgba(255, 107, 0, 0.6)';
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // Precognition orbiting particles (8 particles - prediction pattern)
                for (let i = 0; i < 8; i++) {
                    const particleAngle = time * 4.5 + (i / 8) * Math.PI * 2;
                    const particleX = bullet.x + Math.cos(particleAngle) * (bulletSize + 7);
                    const particleY = bullet.y + Math.sin(particleAngle) * (bulletSize + 7);
                    const particleSize = 2.5 + Math.sin(time * 5.5 + i) * 0.7;
                    
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.95})`;
                    this.ctx.shadowBlur = 14;
                    this.ctx.shadowColor = 'rgba(255, 107, 0, 0.9)';
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // Prediction time rings (rotating rings showing future states)
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(time * 4);
                
                // Ring 1 - prediction timeline
                this.ctx.strokeStyle = `rgba(255, 152, 0, ${0.5 * predictionPhase})`;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([6, 2]);
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = 'rgba(255, 107, 0, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 8, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Ring 2 - future glimpse (counter-rotating)
                this.ctx.rotate(-time * 3);
                this.ctx.strokeStyle = `rgba(255, 193, 7, ${0.4 * predictionPhase})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([4, 3]);
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(255, 152, 0, 0.6)';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 10, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Ring 3 - transformation time indicator
                this.ctx.rotate(time * 5);
                this.ctx.strokeStyle = `rgba(255, 224, 178, ${0.3 * predictionPhase})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([3, 4]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 12, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
                this.ctx.restore();
                
                // Prediction targeting lines (showing precise future impact)
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(angle);
                
                // Forward prediction line (main trajectory)
                const forwardLineGradient = this.ctx.createLinearGradient(0, 0, bulletSize + 10, 0);
                forwardLineGradient.addColorStop(0, `rgba(255, 107, 0, ${0.7 * predictionPhase})`);
                forwardLineGradient.addColorStop(0.5, `rgba(255, 193, 7, ${0.5 * predictionPhase})`);
                forwardLineGradient.addColorStop(1, 'rgba(255, 107, 0, 0)');
                
                this.ctx.strokeStyle = forwardLineGradient;
                this.ctx.lineWidth = 3;
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = 'rgba(255, 107, 0, 0.7)';
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(bulletSize + 10, 0);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Side prediction indicators (showing alternative paths)
                for (let i = 0; i < 4; i++) {
                    const sideAngle = (i - 1.5) * 0.3; // Slight angles to show prediction spread
                    const sideLength = bulletSize + 6;
                    const sideX = Math.cos(sideAngle) * sideLength;
                    const sideY = Math.sin(sideAngle) * sideLength;
                    
                    const sideGradient = this.ctx.createLinearGradient(0, 0, sideX, sideY);
                    sideGradient.addColorStop(0, `rgba(255, 152, 0, ${0.4 * predictionPhase})`);
                    sideGradient.addColorStop(1, 'rgba(255, 107, 0, 0)');
                    
                    this.ctx.strokeStyle = sideGradient;
                    this.ctx.lineWidth = 1.5;
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = 'rgba(255, 107, 0, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(sideX, sideY);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
                
                this.ctx.restore();
                
                // Time distortion effect (subtle wave around bullet)
                const distortionPhase = Math.sin(time * 6) * 0.5 + 0.5;
                this.ctx.strokeStyle = `rgba(255, 193, 7, ${0.3 * distortionPhase})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([2, 8]);
                this.ctx.shadowBlur = 8;
                this.ctx.shadowColor = 'rgba(255, 107, 0, 0.4)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize + 15, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                this.ctx.shadowBlur = 0;
            } else if (weaponName === 'deterministicEngine') {
                // Enhanced Deterministic Engine Bullets - complete individual system description
                const bulletSize = bullet.size || 7;
                const angle = Math.atan2(bullet.vy, bullet.vx);
                
                // Outer complete system field glow - deep purple/violet
                const outerGlow = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 4.2);
                outerGlow.addColorStop(0, 'rgba(139, 0, 255, 0.6)');
                outerGlow.addColorStop(0.3, 'rgba(156, 39, 176, 0.4)');
                outerGlow.addColorStop(0.6, 'rgba(123, 31, 162, 0.3)');
                outerGlow.addColorStop(1, 'rgba(139, 0, 255, 0)');
                this.ctx.fillStyle = outerGlow;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 4.2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Complete system rings - showing definite, complete description
                const systemPhase = Math.sin(time * 3.5) * 0.3 + 0.7;
                for (let i = 0; i < 4; i++) {
                    const ringSize = bulletSize + 5 + i * 4;
                    const ringAlpha = (0.7 - i * 0.15) * systemPhase;
                    
                    this.ctx.strokeStyle = `rgba(139, 0, 255, ${ringAlpha})`;
                    this.ctx.lineWidth = 2.5 - i * 0.3;
                    this.ctx.setLineDash([5 + i, 2]);
                    this.ctx.shadowBlur = 12 - i * 2;
                    this.ctx.shadowColor = 'rgba(139, 0, 255, 0.7)';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, ringSize, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
                this.ctx.setLineDash([]);
                
                // Main bullet body with deep purple gradient
                const bulletGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize);
                bulletGradient.addColorStop(0, '#ba68c8'); // Bright purple center
                bulletGradient.addColorStop(0.3, '#9c27b0'); // Standard purple
                bulletGradient.addColorStop(0.6, '#8b00ff'); // Deep purple
                bulletGradient.addColorStop(1, '#6a1b9a'); // Very dark purple edge
                this.ctx.fillStyle = bulletGradient;
                // OPTIMIZED: Reduced shadow blur
                this.ctx.shadowBlur = 13;
                this.ctx.shadowColor = 'rgba(139, 0, 255, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Inner bright core - white to purple (complete system energy)
                const coreGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 0.7);
                coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.98)');
                coreGradient.addColorStop(0.3, 'rgba(233, 30, 99, 0.8)'); // Pink-purple
                coreGradient.addColorStop(0.6, 'rgba(186, 104, 200, 0.6)');
                coreGradient.addColorStop(1, 'rgba(139, 0, 255, 0)');
                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 0.7, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Devastating spread trail - wide and powerful
                const trailLength = 32;
                const trailGradient = this.ctx.createLinearGradient(
                    bullet.x, bullet.y,
                    bullet.x - Math.cos(angle) * trailLength,
                    bullet.y - Math.sin(angle) * trailLength
                );
                trailGradient.addColorStop(0, 'rgba(139, 0, 255, 0.98)');
                trailGradient.addColorStop(0.2, 'rgba(156, 39, 176, 0.85)');
                trailGradient.addColorStop(0.5, 'rgba(186, 104, 200, 0.7)');
                trailGradient.addColorStop(0.8, 'rgba(233, 30, 99, 0.5)');
                trailGradient.addColorStop(1, 'rgba(139, 0, 255, 0)');
                
                this.ctx.strokeStyle = trailGradient;
                this.ctx.lineWidth = 6;
                this.ctx.lineCap = 'round';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = 'rgba(139, 0, 255, 0.9)';
                this.ctx.beginPath();
                this.ctx.moveTo(bullet.x, bullet.y);
                this.ctx.lineTo(bullet.x - Math.cos(angle) * trailLength, 
                              bullet.y - Math.sin(angle) * trailLength);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Spread damage particles (10 particles - devastating spread)
                // OPTIMIZED: Reduce particles when many bullets active
                const deterministicTrailCount = Math.max(3, Math.floor(10 * particleMultiplier));
                for (let i = 0; i < deterministicTrailCount; i++) {
                    const particlePos = (i + 1) / (deterministicTrailCount + 1);
                    const particleX = bullet.x - Math.cos(angle) * trailLength * particlePos;
                    const particleY = bullet.y - Math.sin(angle) * trailLength * particlePos;
                    const particleSize = 3 + Math.sin(time * 5.5 + i) * 1;
                    
                    // Alternating purple shades for spread effect
                    const particleColor = i % 2 === 0 ? '139, 0, 255' : '186, 104, 200';
                    this.ctx.fillStyle = `rgba(${particleColor}, ${0.9 - i * 0.08})`;
                    // OPTIMIZED: Reduced shadow blur
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowColor = `rgba(${particleColor}, 0.8)`;
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // Complete system orbiting particles (10 particles - complete description)
                for (let i = 0; i < 10; i++) {
                    const particleAngle = time * 4 + (i / 10) * Math.PI * 2;
                    const particleX = bullet.x + Math.cos(particleAngle) * (bulletSize + 8);
                    const particleY = bullet.y + Math.sin(particleAngle) * (bulletSize + 8);
                    const particleSize = 3 + Math.sin(time * 6 + i) * 0.8;
                    
                    // Alternating colors for complete system
                    const particleColor = i % 2 === 0 ? '139, 0, 255' : '233, 30, 99';
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.95})`;
                    this.ctx.shadowBlur = 16;
                    this.ctx.shadowColor = `rgba(${particleColor}, 0.95)`;
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // Deterministic system rings (5 rotating rings - complete description)
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(time * 3.5);
                
                // Ring 1 - complete system indicator
                this.ctx.strokeStyle = `rgba(139, 0, 255, ${0.6 * systemPhase})`;
                this.ctx.lineWidth = 2.5;
                this.ctx.setLineDash([6, 2]);
                this.ctx.shadowBlur = 14;
                this.ctx.shadowColor = 'rgba(139, 0, 255, 0.8)';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 9, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Ring 2 - individual system (counter-rotating)
                this.ctx.rotate(-time * 2.5);
                this.ctx.strokeStyle = `rgba(156, 39, 176, ${0.5 * systemPhase})`;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 3]);
                this.ctx.shadowBlur = 12;
                this.ctx.shadowColor = 'rgba(156, 39, 176, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 11, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Ring 3 - deterministic description
                this.ctx.rotate(time * 4);
                this.ctx.strokeStyle = `rgba(186, 104, 200, ${0.4 * systemPhase})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([4, 4]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 13, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Ring 4 - definite properties
                this.ctx.rotate(-time * 3);
                this.ctx.strokeStyle = `rgba(233, 30, 99, ${0.35 * systemPhase})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([3, 5]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 15, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Ring 5 - complete description (outermost)
                this.ctx.rotate(time * 2);
                const ring5Gradient = this.ctx.createLinearGradient(-bulletSize - 17, 0, bulletSize + 17, 0);
                ring5Gradient.addColorStop(0, `rgba(139, 0, 255, ${0.3 * systemPhase})`);
                ring5Gradient.addColorStop(0.5, `rgba(186, 104, 200, ${0.3 * systemPhase})`);
                ring5Gradient.addColorStop(1, `rgba(139, 0, 255, ${0.3 * systemPhase})`);
                this.ctx.strokeStyle = ring5Gradient;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([2, 6]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 17, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
                this.ctx.restore();
                
                // Devastating spread pattern lines (8 lines - wide spread damage)
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(angle);
                
                for (let i = 0; i < 8; i++) {
                    const lineAngle = (i / 8) * Math.PI * 2;
                    const lineLength = bulletSize + 10;
                    const lineX = Math.cos(lineAngle) * lineLength;
                    const lineY = Math.sin(lineAngle) * lineLength;
                    
                    const lineGradient = this.ctx.createLinearGradient(0, 0, lineX, lineY);
                    const lineColor = i % 2 === 0 ? '139, 0, 255' : '186, 104, 200';
                    lineGradient.addColorStop(0, `rgba(${lineColor}, ${0.7 * systemPhase})`);
                    lineGradient.addColorStop(1, `rgba(${lineColor}, 0)`);
                    
                    this.ctx.strokeStyle = lineGradient;
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowBlur = 12;
                    this.ctx.shadowColor = `rgba(${lineColor}, 0.7)`;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(lineX, lineY);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
                
                this.ctx.restore();
                
                // Complete system field effect (outermost wave)
                const fieldPhase = Math.sin(time * 4) * 0.5 + 0.5;
                this.ctx.strokeStyle = `rgba(139, 0, 255, ${0.25 * fieldPhase})`;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([3, 10]);
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(139, 0, 255, 0.5)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize + 20, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                this.ctx.shadowBlur = 0;
            } else if (weaponName === 'individualSystemCore') {
                // OPTIMIZED: Enhanced Individual System Core Bullets - reduced complexity for performance
                // REDUCED SIZE: Scale down from base size by 25% (8 -> 6, maintaining proportions)
                const baseBulletSize = bullet.size || 8;
                const bulletSize = baseBulletSize * 0.75; // Reduce size by 25%
                const angle = Math.atan2(bullet.vy, bullet.vx);
                
                // OPTIMIZED: Cache bypassPhase calculation (calculate once, not per bullet)
                // Use a simpler, smoother pulse calculation
                const bypassPhase = Math.sin(time * 2) * 0.2 + 0.8; // Slower, smoother pulse (2x instead of 4x)
                
                // OPTIMIZED: Simplified outer glow - single fill instead of gradient
                this.ctx.fillStyle = `rgba(0, 255, 255, ${0.4 * bypassPhase})`;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 3.5, 0, Math.PI * 2); // Reduced from 4.5
                this.ctx.fill();
                
                // OPTIMIZED: Reduced from 5 rings to 3 rings for better performance
                for (let i = 0; i < 3; i++) {
                    const ringSize = bulletSize + 4.5 + i * 5; // Simplified spacing
                    const ringAlpha = (0.7 - i * 0.15) * bypassPhase;
                    
                    this.ctx.strokeStyle = `rgba(0, 255, 255, ${ringAlpha})`;
                    this.ctx.lineWidth = 2 - i * 0.3;
                    this.ctx.setLineDash([5, 2]); // Simplified dash pattern
                    // OPTIMIZED: Reduced shadow blur operations
                    if (i === 0) {
                        this.ctx.shadowBlur = 8; // Only first ring has shadow
                        this.ctx.shadowColor = 'rgba(0, 255, 255, 0.6)';
                    } else {
                        this.ctx.shadowBlur = 0;
                    }
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, ringSize, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
                this.ctx.setLineDash([]);
                
                // Main bullet body with intense cyan gradient (scaled proportionally)
                const bulletGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize);
                bulletGradient.addColorStop(0, '#b2ebf2'); // Bright cyan center
                bulletGradient.addColorStop(0.3, '#4dd0e1'); // Medium cyan
                bulletGradient.addColorStop(0.6, '#00ffff'); // Pure cyan
                bulletGradient.addColorStop(1, '#0097a7'); // Dark cyan edge
                this.ctx.fillStyle = bulletGradient;
                // OPTIMIZED: Reduced shadow blur (scaled proportionally)
                this.ctx.shadowBlur = 10.5; // Scaled: 14->10.5
                this.ctx.shadowColor = 'rgba(0, 255, 255, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // Inner bright core - white to cyan (individual system energy)
                const coreGradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletSize * 0.75);
                coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                coreGradient.addColorStop(0.2, 'rgba(178, 235, 242, 0.9)');
                coreGradient.addColorStop(0.5, 'rgba(77, 208, 225, 0.7)');
                coreGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize * 0.75, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Massive damage trail - longest and most intense (scaled proportionally)
                const trailLength = 26.25; // Scaled: 35->26.25 (75%)
                const trailGradient = this.ctx.createLinearGradient(
                    bullet.x, bullet.y,
                    bullet.x - Math.cos(angle) * trailLength,
                    bullet.y - Math.sin(angle) * trailLength
                );
                trailGradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
                trailGradient.addColorStop(0.15, 'rgba(77, 208, 225, 0.9)');
                trailGradient.addColorStop(0.4, 'rgba(0, 188, 212, 0.8)');
                trailGradient.addColorStop(0.7, 'rgba(0, 151, 167, 0.6)');
                trailGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                
                this.ctx.strokeStyle = trailGradient;
                this.ctx.lineWidth = 5.25; // Scaled: 7->5.25 (75%)
                this.ctx.lineCap = 'round';
                this.ctx.shadowBlur = 16.5; // Scaled: 22->16.5 (75%)
                this.ctx.shadowColor = 'rgba(0, 255, 255, 0.95)';
                this.ctx.beginPath();
                this.ctx.moveTo(bullet.x, bullet.y);
                this.ctx.lineTo(bullet.x - Math.cos(angle) * trailLength, 
                              bullet.y - Math.sin(angle) * trailLength);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // OPTIMIZED: Reduced from 12 to 6 trail particles for better performance
                const individualTrailCount = Math.max(2, Math.floor(6 * particleMultiplier));
                for (let i = 0; i < individualTrailCount; i++) {
                    const particlePos = (i + 1) / (individualTrailCount + 1);
                    const particleX = bullet.x - Math.cos(angle) * trailLength * particlePos;
                    const particleY = bullet.y - Math.sin(angle) * trailLength * particlePos;
                    // OPTIMIZED: Fixed size - no sin calculation for better performance
                    const particleSize = 2.5;
                    
                    // Alternating cyan shades for massive damage
                    const particleColor = i % 2 === 0 ? '0, 255, 255' : '77, 208, 225'; // Simplified to 2 colors
                    this.ctx.fillStyle = `rgba(${particleColor}, ${0.9 - i * 0.1})`;
                    // OPTIMIZED: Reduced shadow blur
                    this.ctx.shadowBlur = 4; // Reduced from 6.75
                    this.ctx.shadowColor = `rgba(${particleColor}, 0.7)`;
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // OPTIMIZED: Reduced from 12 to 6 orbiting particles for better performance
                for (let i = 0; i < 6; i++) {
                    const particleAngle = time * 3 + (i / 6) * Math.PI * 2; // Slower rotation (3x instead of 5x)
                    const particleX = bullet.x + Math.cos(particleAngle) * (bulletSize + 7.5);
                    const particleY = bullet.y + Math.sin(particleAngle) * (bulletSize + 7.5);
                    const particleSize = 2.5; // Fixed size - no sin calculation for performance
                    
                    // Alternating cyan shades for omnidirectional effect
                    const particleColor = i % 2 === 0 ? '0, 255, 255' : '77, 208, 225'; // Simplified to 2 colors
                    this.ctx.fillStyle = `rgba(${particleColor}, 0.9)`;
                    // OPTIMIZED: Reduced shadow blur
                    this.ctx.shadowBlur = 6;
                    this.ctx.shadowColor = `rgba(${particleColor}, 0.7)`;
                    this.ctx.beginPath();
                    this.ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                // OPTIMIZED: Reduced from 6 rotating rings to 3 for better performance
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(time * 2); // Slower rotation (2x instead of 4x)
                
                // Ring 1 - individual system indicator
                this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.6 * bypassPhase})`;
                this.ctx.lineWidth = 2.5;
                this.ctx.setLineDash([6, 2]);
                this.ctx.shadowBlur = 8; // Reduced shadow
                this.ctx.shadowColor = 'rgba(0, 255, 255, 0.7)';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 8, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
                
                // Ring 2 - system bypass (counter-rotating)
                this.ctx.rotate(-time * 1.5); // Slower counter-rotation
                this.ctx.strokeStyle = `rgba(77, 208, 225, ${0.5 * bypassPhase})`;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 3]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 12, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Ring 3 - complete bypass (simplified, no gradient)
                this.ctx.rotate(time * 2);
                this.ctx.strokeStyle = `rgba(0, 188, 212, ${0.4 * bypassPhase})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([4, 4]);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, bulletSize + 16, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
                this.ctx.restore();
                
                // OPTIMIZED: Reduced from 12 to 8 spread lines for better performance
                this.ctx.save();
                this.ctx.translate(bullet.x, bullet.y);
                this.ctx.rotate(angle);
                
                for (let i = 0; i < 8; i++) {
                    const lineAngle = (i / 8) * Math.PI * 2;
                    const lineLength = bulletSize + 10; // Slightly shorter
                    const lineX = Math.cos(lineAngle) * lineLength;
                    const lineY = Math.sin(lineAngle) * lineLength;
                    
                    // OPTIMIZED: Simplified - solid color instead of gradient
                    const lineColor = i % 2 === 0 ? '0, 255, 255' : '77, 208, 225'; // Simplified to 2 colors
                    this.ctx.strokeStyle = `rgba(${lineColor}, ${0.7 * bypassPhase})`;
                    this.ctx.lineWidth = 2.5; // Reduced from 3.5
                    // OPTIMIZED: Only first line has shadow for performance
                    if (i === 0) {
                        this.ctx.shadowBlur = 6; // Reduced from 14
                        this.ctx.shadowColor = `rgba(${lineColor}, 0.6)`;
                    } else {
                        this.ctx.shadowBlur = 0;
                    }
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, 0);
                    this.ctx.lineTo(lineX, lineY);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
                
                this.ctx.restore();
                
                // OPTIMIZED: Simplified bypass field - slower pulse, less shadow
                const bypassFieldPhase = Math.sin(time * 2) * 0.3 + 0.7; // Slower pulse (2x instead of 5x)
                this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.25 * bypassFieldPhase})`;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([4, 8]); // Simplified dash
                this.ctx.shadowBlur = 6; // Reduced from 12
                this.ctx.shadowColor = 'rgba(0, 255, 255, 0.5)';
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bulletSize + 20, 0, Math.PI * 2); // Reduced from 25
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                this.ctx.shadowBlur = 0;
            } else {
                // Other weapons - use existing enhanced visuals
                // Photon glow effect based on energy
                const glowSize = bullet.size * 2;
                const gradient = this.ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, glowSize);
                gradient.addColorStop(0, bullet.color);
                gradient.addColorStop(0.5, bullet.color + '80'); // 50% opacity
                gradient.addColorStop(1, bullet.color + '00'); // Transparent
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, glowSize, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Core photon
                this.ctx.fillStyle = bullet.color;
                this.ctx.beginPath();
                this.ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Energy trail
                this.ctx.strokeStyle = bullet.color + '60';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                const trailLength = 15;
                const angle = Math.atan2(bullet.vy, bullet.vx);
                this.ctx.moveTo(bullet.x, bullet.y);
                this.ctx.lineTo(bullet.x - Math.cos(angle) * trailLength, 
                              bullet.y - Math.sin(angle) * trailLength);
                this.ctx.stroke();
            }
        } // End of for loop for player bullets
        
        // Draw enemy bullets
        // OPTIMIZATION: Use for loop and add culling for off-screen bullets
        const bulletCullMargin = 50;
        for (let i = 0; i < this.enemyBullets.length; i++) {
            const bullet = this.enemyBullets[i];
            
            // CULLING: Skip bullets that are far off-screen
            if (bullet.x < -bulletCullMargin || bullet.x > this.canvas.width + bulletCullMargin ||
                bullet.y < -bulletCullMargin || bullet.y > this.canvas.height + bulletCullMargin) {
                continue;
            }
            
            this.ctx.fillStyle = bullet.color;
            // OPTIMIZATION: Reduce shadow effects during boss battles
            if (!this.bossMode) {
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = bullet.color;
            }
            this.ctx.beginPath();
            this.ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
            this.ctx.fill();
            if (!this.bossMode) {
                this.ctx.shadowBlur = 0;
            }
        }
    }
    
    drawEnemyShips() {
        this.enemyShips.forEach(enemy => {
            // Calculate angle to face player
            const dx = this.player.x - enemy.x;
            const dy = this.player.y - enemy.y;
            // atan2(dy, dx) gives angle from positive X axis (pointing right)
            // Ship will be drawn pointing right (positive X), so we can use the angle directly
            const angle = Math.atan2(dy, dx);
            
            this.ctx.save();
            this.ctx.translate(enemy.x, enemy.y);
            this.ctx.rotate(angle);
            
            const enemySize = enemy.size;
            
            // Redesigned enemy ship - menacing, angular predator design
            // Red/dark red color scheme for enemy theme
            
            // Main body gradient (bright red to dark red)
            const bodyGradient = this.ctx.createLinearGradient(enemySize * 1.2, 0, -enemySize * 0.9, 0);
            bodyGradient.addColorStop(0, '#ff5252'); // Bright red at front
            bodyGradient.addColorStop(0.2, '#f44336'); // Medium bright red
            bodyGradient.addColorStop(0.5, '#d32f2f'); // Medium red
            bodyGradient.addColorStop(0.8, '#c62828'); // Dark red
            bodyGradient.addColorStop(1, '#b71c1c'); // Very dark red at back
            this.ctx.fillStyle = bodyGradient;
            
            // New aggressive enemy ship shape - angular predator design
            // Ship is drawn pointing right (positive X), will be rotated to face player
            this.ctx.beginPath();
            // Sharp angular front - like a predator's head
            this.ctx.moveTo(enemySize * 1.2, 0); // Right front point (pointing right)
            
            // Top side - aggressive angular design
            this.ctx.lineTo(enemySize * 0.9, -enemySize * 0.3); // Front top edge
            this.ctx.lineTo(enemySize * 0.6, -enemySize * 0.6); // Top wing
            this.ctx.lineTo(enemySize * 0.2, -enemySize * 0.8); // Top wing tip
            this.ctx.lineTo(-enemySize * 0.2, -enemySize * 0.7); // Top mid wing
            this.ctx.lineTo(-enemySize * 0.6, -enemySize * 0.5); // Top lower wing
            this.ctx.lineTo(-enemySize * 0.8, -enemySize * 0.2); // Top tail
            this.ctx.lineTo(-enemySize * 0.9, 0); // Back center
            
            // Bottom side (mirror)
            this.ctx.lineTo(-enemySize * 0.8, enemySize * 0.2);
            this.ctx.lineTo(-enemySize * 0.6, enemySize * 0.5);
            this.ctx.lineTo(-enemySize * 0.2, enemySize * 0.7);
            this.ctx.lineTo(enemySize * 0.2, enemySize * 0.8);
            this.ctx.lineTo(enemySize * 0.6, enemySize * 0.6);
            this.ctx.lineTo(enemySize * 0.9, enemySize * 0.3);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Wing details - angular predator design
            this.ctx.strokeStyle = 'rgba(211, 47, 47, 0.7)';
            this.ctx.lineWidth = 2;
            // Wing edge highlights
            this.ctx.beginPath();
            // Top wing leading edge
            this.ctx.moveTo(enemySize * 0.9, -enemySize * 0.3);
            this.ctx.lineTo(enemySize * 0.2, -enemySize * 0.8);
            // Bottom wing leading edge
            this.ctx.moveTo(enemySize * 0.9, enemySize * 0.3);
            this.ctx.lineTo(enemySize * 0.2, enemySize * 0.8);
            this.ctx.stroke();
            
            // Angular panel lines
            this.ctx.strokeStyle = 'rgba(198, 40, 40, 0.6)';
            this.ctx.lineWidth = 1.5;
            this.ctx.beginPath();
            // Vertical line across body
            this.ctx.moveTo(enemySize * 0.3, -enemySize * 0.4);
            this.ctx.lineTo(enemySize * 0.3, enemySize * 0.4);
            // Diagonal lines on wings
            this.ctx.moveTo(enemySize * 0.1, -enemySize * 0.6);
            this.ctx.lineTo(-enemySize * 0.3, -enemySize * 0.5);
            this.ctx.moveTo(enemySize * 0.1, enemySize * 0.6);
            this.ctx.lineTo(-enemySize * 0.3, enemySize * 0.5);
            this.ctx.stroke();
            
            // Central body accent - dark core
            this.ctx.fillStyle = 'rgba(183, 28, 28, 0.8)';
            this.ctx.beginPath();
            this.ctx.moveTo(enemySize * 0.8, 0);
            this.ctx.lineTo(enemySize * 0.4, -enemySize * 0.25);
            this.ctx.lineTo(-enemySize * 0.3, 0);
            this.ctx.lineTo(enemySize * 0.4, enemySize * 0.25);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Predator "eye" sensor - menacing triangular design (at front)
            const eyeGradient = this.ctx.createRadialGradient(enemySize * 0.6, 0, 0, enemySize * 0.6, 0, enemySize * 0.25);
            eyeGradient.addColorStop(0, 'rgba(255, 50, 50, 0.95)');
            eyeGradient.addColorStop(0.4, 'rgba(244, 67, 54, 0.8)');
            eyeGradient.addColorStop(0.7, 'rgba(211, 47, 47, 0.5)');
            eyeGradient.addColorStop(1, 'rgba(183, 28, 28, 0.2)');
            this.ctx.fillStyle = eyeGradient;
            this.ctx.beginPath();
            // Triangular eye shape (pointing right)
            this.ctx.moveTo(enemySize * 0.75, 0);
            this.ctx.lineTo(enemySize * 0.5, -enemySize * 0.18);
            this.ctx.lineTo(enemySize * 0.5, enemySize * 0.18);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Eye frame - dark angular
            this.ctx.strokeStyle = 'rgba(183, 28, 28, 0.95)';
            this.ctx.lineWidth = 2.5;
            this.ctx.stroke();
            
            // Inner eye - bright red core
            this.ctx.fillStyle = 'rgba(255, 0, 0, 0.95)';
            this.ctx.beginPath();
            this.ctx.moveTo(enemySize * 0.7, 0);
            this.ctx.lineTo(enemySize * 0.55, -enemySize * 0.1);
            this.ctx.lineTo(enemySize * 0.55, enemySize * 0.1);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Front angular spikes - aggressive weapons (at front, pointing right)
            this.ctx.fillStyle = 'rgba(198, 40, 40, 0.9)';
            // Top front spike
            this.ctx.beginPath();
            this.ctx.moveTo(enemySize * 0.9, -enemySize * 0.3);
            this.ctx.lineTo(enemySize * 1.0, -enemySize * 0.25);
            this.ctx.lineTo(enemySize * 0.95, -enemySize * 0.2);
            this.ctx.closePath();
            this.ctx.fill();
            // Bottom front spike
            this.ctx.beginPath();
            this.ctx.moveTo(enemySize * 0.9, enemySize * 0.3);
            this.ctx.lineTo(enemySize * 1.0, enemySize * 0.25);
            this.ctx.lineTo(enemySize * 0.95, enemySize * 0.2);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Side weapon ports - angular design (on wings)
            this.ctx.fillStyle = 'rgba(100, 0, 0, 0.8)';
            // Top weapon port
            this.ctx.beginPath();
            this.ctx.moveTo(enemySize * 0.2, -enemySize * 0.7);
            this.ctx.lineTo(enemySize * 0.3, -enemySize * 0.65);
            this.ctx.lineTo(enemySize * 0.3, -enemySize * 0.75);
            this.ctx.closePath();
            this.ctx.fill();
            // Bottom weapon port
            this.ctx.beginPath();
            this.ctx.moveTo(enemySize * 0.2, enemySize * 0.7);
            this.ctx.lineTo(enemySize * 0.3, enemySize * 0.65);
            this.ctx.lineTo(enemySize * 0.3, enemySize * 0.75);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Engine flames - aggressive, menacing
            // Ship front points right (positive X), so thrusters point left (negative X) - opposite direction
            const time = Date.now() * 0.011;
            const flameIntensity = 0.75 + Math.sin(time) * 0.2;
            
            // Main engine - single large exhaust pointing away from front
            // Front is at enemySize * 1.2 (right), so back is at -enemySize * 0.9 (left)
            // Flames extend further left (negative X) - opposite of front direction
            const flameGradient1 = this.ctx.createLinearGradient(-enemySize * 0.9, 0, -enemySize * 1.6, 0);
            flameGradient1.addColorStop(0, `rgba(255, 100, 50, ${0.9 * flameIntensity})`);
            flameGradient1.addColorStop(0.2, `rgba(255, 50, 0, ${0.85 * flameIntensity})`);
            flameGradient1.addColorStop(0.5, `rgba(200, 0, 0, ${0.7 * flameIntensity})`);
            flameGradient1.addColorStop(0.8, `rgba(150, 0, 0, ${0.5 * flameIntensity})`);
            flameGradient1.addColorStop(1, `rgba(100, 0, 0, ${0.3 * flameIntensity})`);
            
            this.ctx.fillStyle = flameGradient1;
            this.ctx.beginPath();
            const flame1Width = enemySize * 0.25 * (1 + Math.sin(time * 2.2) * 0.2);
            const flame1Length = enemySize * 0.7 * flameIntensity;
            // Flames extend in negative X direction (left) - opposite of front (right)
            this.ctx.moveTo(-enemySize * 0.9, -flame1Width);
            this.ctx.lineTo(-enemySize * 0.9 - flame1Length, 0); // Extending left
            this.ctx.lineTo(-enemySize * 0.9, flame1Width);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Secondary exhaust - inner flame
            this.ctx.fillStyle = flameGradient1;
            this.ctx.beginPath();
            const flame2Width = enemySize * 0.18 * (1 + Math.cos(time * 2.2) * 0.15);
            const flame2Length = enemySize * 0.5 * flameIntensity;
            // Also extending left (negative X)
            this.ctx.moveTo(-enemySize * 0.9, -flame2Width * 0.7);
            this.ctx.lineTo(-enemySize * 0.9 - flame2Length, 0); // Extending left
            this.ctx.lineTo(-enemySize * 0.9, flame2Width * 0.7);
            this.ctx.closePath();
            this.ctx.fill();
            
            // Engine core - bright red (at the back, opposite of front)
            this.ctx.fillStyle = `rgba(255, 50, 50, ${0.95 * flameIntensity})`;
            this.ctx.beginPath();
            this.ctx.ellipse(-enemySize * 0.9, 0, enemySize * 0.08, enemySize * 0.1, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Threat indicators (pulsing red) - angular design
            const threatIntensity = 0.7 + Math.sin(time * 2.5) * 0.3;
            this.ctx.fillStyle = `rgba(255, 0, 0, ${threatIntensity})`;
            // Front threat lights (angular, near front spikes)
            // Top front
            this.ctx.beginPath();
            this.ctx.moveTo(enemySize * 0.85, -enemySize * 0.25);
            this.ctx.lineTo(enemySize * 0.8, -enemySize * 0.22);
            this.ctx.lineTo(enemySize * 0.8, -enemySize * 0.28);
            this.ctx.closePath();
            this.ctx.fill();
            // Bottom front
            this.ctx.beginPath();
            this.ctx.moveTo(enemySize * 0.85, enemySize * 0.25);
            this.ctx.lineTo(enemySize * 0.8, enemySize * 0.22);
            this.ctx.lineTo(enemySize * 0.8, enemySize * 0.28);
            this.ctx.closePath();
            this.ctx.fill();
            // Side threat lights (on wings)
            this.ctx.beginPath();
            this.ctx.arc(enemySize * 0.4, -enemySize * 0.6, enemySize * 0.045, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(enemySize * 0.4, enemySize * 0.6, enemySize * 0.045, 0, Math.PI * 2);
            this.ctx.fill();
            
            this.ctx.restore();
            
            // Enemy health bar
            const barWidth = enemySize * 2;
            const barHeight = 4;
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            this.ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemySize - 10, barWidth, barHeight);
            const healthPercent = enemy.health / enemy.maxHealth;
            this.ctx.fillStyle = '#f44336';
            this.ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemySize - 10, barWidth * healthPercent, barHeight);
        });
    }
    
    updateBossEnemies(deltaTime) {
        const now = Date.now();
        
        // Update boss enemies - move with different patterns and shoot
        // OPTIMIZATION: Use for loop with reverse iteration for better performance when removing enemies
        for (let i = this.bossEnemies.length - 1; i >= 0; i--) {
            const enemy = this.bossEnemies[i];
            
            // Remove dead enemies immediately
            if (enemy.health <= 0) {
                this.bossEnemies.splice(i, 1);
                continue;
            }
            
            // Calculate distance to player (squared for most checks, only sqrt when needed)
            const dx = this.player.x - enemy.x;
            const dy = this.player.y - enemy.y;
            const distSq = dx * dx + dy * dy;
            const dist = Math.sqrt(distSq); // Only calculate sqrt once, reuse for all calculations
            
            // Initialize path pattern if not set
            if (!enemy.pathPattern) {
                enemy.pathPattern = Math.floor(Math.random() * 4); // 0-3 different patterns
                enemy.pathAngle = Math.random() * Math.PI * 2; // Random starting angle for orbiting
                enemy.pathTime = 0; // Time accumulator for path patterns
            }
            
            enemy.pathTime += deltaTime;
            
            // Different movement patterns to prevent overlapping
            let moveX = 0, moveY = 0;
            
            if (enemy.pathPattern === 0) {
                // Pattern 0: Direct approach but with slight offset
                const approachAngle = Math.atan2(dy, dx) + (enemy.pathPattern * 0.3); // Slight angle offset
                moveX = Math.cos(approachAngle) * enemy.speed * deltaTime;
                moveY = Math.sin(approachAngle) * enemy.speed * deltaTime;
            } else if (enemy.pathPattern === 1) {
                // Pattern 1: Orbit around player
                const orbitRadius = 200 + (enemy.pathPattern * 50);
                const orbitSpeed = 1.5;
                enemy.pathAngle += orbitSpeed * deltaTime;
                const orbitX = this.player.x + Math.cos(enemy.pathAngle) * orbitRadius;
                const orbitY = this.player.y + Math.sin(enemy.pathAngle) * orbitRadius;
                const orbitDx = orbitX - enemy.x;
                const orbitDy = orbitY - enemy.y;
                // OPTIMIZATION: Use squared distance check, only normalize if needed
                const orbitDistSq = orbitDx * orbitDx + orbitDy * orbitDy;
                if (orbitDistSq > 0.01) { // Avoid division by zero
                    const orbitDist = Math.sqrt(orbitDistSq);
                    moveX = (orbitDx / orbitDist) * enemy.speed * deltaTime;
                    moveY = (orbitDy / orbitDist) * enemy.speed * deltaTime;
                }
            } else if (enemy.pathPattern === 2) {
                // Pattern 2: Zigzag approach
                const zigzagOffset = Math.sin(enemy.pathTime * 2) * 100; // Side-to-side movement
                const approachAngle = Math.atan2(dy, dx);
                const perpendicularAngle = approachAngle + Math.PI / 2;
                moveX = Math.cos(approachAngle) * enemy.speed * deltaTime * 0.8 + 
                        Math.cos(perpendicularAngle) * zigzagOffset * deltaTime * 0.3;
                moveY = Math.sin(approachAngle) * enemy.speed * deltaTime * 0.8 + 
                        Math.sin(perpendicularAngle) * zigzagOffset * deltaTime * 0.3;
            } else {
                // Pattern 3: Maintain distance, strafe around
                const maintainDist = 250;
                if (dist < maintainDist) {
                    // Too close, move away
                    moveX = -(dx / dist) * enemy.speed * deltaTime * 0.6;
                    moveY = -(dy / dist) * enemy.speed * deltaTime * 0.6;
                } else {
                    // Strafe perpendicular to player
                    const strafeAngle = Math.atan2(dy, dx) + Math.PI / 2;
                    moveX = Math.cos(strafeAngle) * enemy.speed * deltaTime * 0.7;
                    moveY = Math.sin(strafeAngle) * enemy.speed * deltaTime * 0.7;
                }
            }
            
            // OPTIMIZED: Apply separation force to keep enemies well-spaced
            // Performance optimizations:
            // 1. Use squared distances to avoid expensive sqrt
            // 2. Early exit for enemies that are too far away
            // 3. Only check every other frame for performance (staggered updates)
            let separationX = 0, separationY = 0;
            let neighborCount = 0;
            const minSeparationDistance = 180; // Keeps them much further apart
            const minSeparationDistanceSq = minSeparationDistance * minSeparationDistance; // Squared for comparison
            const separationForce = 400; // Stronger push away
            const maxCheckDistanceSq = minSeparationDistanceSq * 1.5; // Only check enemies within this range
            
            // OPTIMIZATION: Only check separation every other frame to reduce CPU load
            // Use loop index (i) to stagger updates across frames - avoids expensive indexOf call
            const shouldCheckSeparation = (i % 2 === 0) || (enemy.pathTime % 0.1 < deltaTime);
            
            if (shouldCheckSeparation) {
                // OPTIMIZATION: Use for loop instead of for...of for better performance
                for (let j = 0; j < this.bossEnemies.length; j++) {
                    const other = this.bossEnemies[j];
                    if (other === enemy || other.health <= 0) continue;
                    
                    // OPTIMIZATION: Use squared distance for early exit (no sqrt needed)
                    const otherDx = enemy.x - other.x;
                    const otherDy = enemy.y - other.y;
                    const otherDistSq = otherDx * otherDx + otherDy * otherDy;
                    
                    // Early exit: Skip if too far away
                    if (otherDistSq > maxCheckDistanceSq) continue;
                    
                    // Only calculate sqrt if enemy is within separation distance
                    if (otherDistSq > 0 && otherDistSq < minSeparationDistanceSq) {
                        const otherDist = Math.sqrt(otherDistSq);
                        // Calculate separation force - stronger when closer
                        const forceStrength = (minSeparationDistance - otherDist) / minSeparationDistance;
                        separationX += (otherDx / otherDist) * forceStrength;
                        separationY += (otherDy / otherDist) * forceStrength;
                        neighborCount++;
                    }
                }
            }
            
            if (neighborCount > 0) {
                // Apply separation force - stronger and more consistent
                separationX = (separationX / neighborCount) * separationForce * deltaTime;
                separationY = (separationY / neighborCount) * separationForce * deltaTime;
            }
            
            // Apply movement with separation
            enemy.x += moveX + separationX;
            enemy.y += moveY + separationY;
            
            // Keep enemy on screen - boss mode enemies must stay in the scene
            // Use enemy size as margin to keep them fully visible
            const margin = enemy.size || 20;
            enemy.x = Math.max(margin, Math.min(this.canvas.width - margin, enemy.x));
            enemy.y = Math.max(margin, Math.min(this.canvas.height - margin, enemy.y));
            
            // Shoot at player - FIXED: No cooldown reduction, prevent continuous streams
            if (now - enemy.lastShot >= enemy.shotCooldown) {
                const angle = Math.atan2(dy, dx);
                const bulletSpeed = 350 + this.level * 5;
                // REDUCED: Boss enemy bullets do less damage to prevent overwhelming the player
                // Base damage reduced from 20 to 10, and level scaling reduced from *2 to *1
                const bulletDamage = 10 + this.level * 1;
                this.enemyBullets.push({
                    x: enemy.x,
                    y: enemy.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    color: enemy.color,
                    size: 5,
                    damage: bulletDamage,
                    lifetime: 4
                });
                enemy.lastShot = now;
                // FIXED: Reset to base cooldown instead of reducing (prevents continuous streams)
                // Don't modify shotCooldown - keep it constant
            }
        }
    }
    
    drawBossEnemies() {
        // OPTIMIZATION: Use for loop instead of forEach for better performance
        // OPTIMIZATION: Add culling to skip off-screen enemies
        const cullMargin = 100; // Draw enemies slightly off-screen for smooth entry/exit
        
        for (let i = 0; i < this.bossEnemies.length; i++) {
            const enemy = this.bossEnemies[i];
            
            // CULLING: Skip enemies that are far off-screen
            if (enemy.x < -cullMargin || enemy.x > this.canvas.width + cullMargin ||
                enemy.y < -cullMargin || enemy.y > this.canvas.height + cullMargin) {
                continue;
            }
            
            const dx = this.player.x - enemy.x;
            const dy = this.player.y - enemy.y;
            const angle = Math.atan2(dy, dx);
            
            this.ctx.save();
            this.ctx.translate(enemy.x, enemy.y);
            this.ctx.rotate(angle);
            
            // OPTIMIZATION: Simplified rendering for boss battles - reduce visual complexity
            // Draw different shapes based on enemy type
                const healthPercent = Math.max(0, enemy.health / enemy.maxHealth);
            const enemySize = enemy.size;
            
            if (enemy.type === 'neuralDrone') {
                // SIMPLIFIED Neural Drone - Reduced layers for performance
                // Simple outer glow (single layer instead of multiple)
                this.ctx.fillStyle = `rgba(156, 39, 176, ${0.2 * healthPercent})`;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * 1.3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Main hexagon body (single color, no gradient)
                this.ctx.fillStyle = `rgba(156, 39, 176, ${healthPercent})`;
                this.ctx.beginPath();
                for (let j = 0; j < 6; j++) {
                    const a = (j * Math.PI) / 3;
                    const x = Math.cos(a) * enemySize;
                    const y = Math.sin(a) * enemySize;
                    if (j === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                // Inner core (simple circle)
                this.ctx.fillStyle = `rgba(33, 150, 243, ${healthPercent})`;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
            } else if (enemy.type === 'geneticSentinel') {
                // SIMPLIFIED Genetic Sentinel - Reduced complexity
                // Simple outer glow
                this.ctx.fillStyle = `rgba(0, 255, 136, ${0.2 * healthPercent})`;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * 1.3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Simple double helix (2 circles)
                this.ctx.fillStyle = `rgba(0, 255, 136, ${healthPercent})`;
                this.ctx.beginPath();
                this.ctx.arc(-enemySize * 0.3, 0, enemySize * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
                        this.ctx.beginPath();
                this.ctx.arc(enemySize * 0.3, 0, enemySize * 0.4, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                // Center core
                this.ctx.fillStyle = `rgba(0, 204, 255, ${healthPercent})`;
                        this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * 0.3, 0, Math.PI * 2);
                        this.ctx.fill();
            } else if (enemy.type === 'molecularDefender') {
                // SIMPLIFIED Molecular Defender - Reduced complexity
                this.ctx.fillStyle = enemy.color;
                this.ctx.beginPath();
                for (let j = 0; j < 8; j++) {
                    const a = (j * Math.PI) / 4;
                    const r = (j % 2 === 0) ? enemySize : enemySize * 0.5;
                    const x = Math.cos(a) * r;
                    const y = Math.sin(a) * r;
                    if (j === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                this.ctx.fill();
                // Inner shape
                this.ctx.fillStyle = enemy.secondaryColor;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
            } else if (enemy.type === 'cellularGuardian') {
                // SIMPLIFIED Cellular Guardian - Reduced complexity
                this.ctx.fillStyle = enemy.color;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * 0.7, 0, Math.PI * 2);
                this.ctx.fill();
                // Spikes
                this.ctx.strokeStyle = enemy.secondaryColor;
                this.ctx.lineWidth = 3;
                for (let j = 0; j < 8; j++) {
                    const a = (j * Math.PI) / 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(Math.cos(a) * enemySize * 0.7, Math.sin(a) * enemySize * 0.7);
                    this.ctx.lineTo(Math.cos(a) * enemySize, Math.sin(a) * enemySize);
                    this.ctx.stroke();
                }
                // Center
                this.ctx.fillStyle = enemy.secondaryColor;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * 0.3, 0, Math.PI * 2);
                this.ctx.fill();
            } else if (enemy.type === 'quantumDisruptor') {
                // SIMPLIFIED Quantum Disruptor - Reduced complexity
                const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;
                this.ctx.fillStyle = enemy.color;
                this.ctx.globalAlpha = 0.7;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * pulse, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.globalAlpha = 1;
                this.ctx.strokeStyle = enemy.secondaryColor;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * 0.6, 0, Math.PI * 2);
                this.ctx.stroke();
                // Inner energy core
                this.ctx.fillStyle = enemy.secondaryColor;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, enemySize * 0.3, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            this.ctx.restore();
            
            // Health bar (simplified)
            const barWidth = enemySize * 2;
            const barHeight = 4;
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            this.ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemySize - 10, barWidth, barHeight);
            this.ctx.fillStyle = enemy.color;
            this.ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemySize - 10, barWidth * healthPercent, barHeight);
        }
    }

    drawParticles() {
        // Check if particles are enabled
        if (!this.settings.showParticles) return;
        
        // OPTIMIZATION: Progressive particle limits based on game state
        const level = this.level || 1;
        const bulletCount = this.bullets.length;
        const obstacleCount = this.obstacles.length;
        
        // Reduce particles when many bullets, obstacles, or high level
        let maxParticles = this.bossMode ? 50 : 200;
        if (bulletCount > 30 || obstacleCount > 20 || level >= 50) {
            maxParticles = Math.floor(maxParticles * 0.5); // 50% reduction
        } else if (bulletCount > 15 || obstacleCount > 15 || level >= 30) {
            maxParticles = Math.floor(maxParticles * 0.7); // 30% reduction
        }
        
        const particlesToDraw = this.particles.slice(0, maxParticles);
        
        // OPTIMIZATION: Use for loop instead of forEach for better performance
        const cullMargin = 50; // Cull particles far off-screen
        
        for (let i = 0; i < particlesToDraw.length; i++) {
            const p = particlesToDraw[i];
            
            // CULLING: Skip particles that are far off-screen
            if (p.x < -cullMargin || p.x > this.canvas.width + cullMargin ||
                p.y < -cullMargin || p.y > this.canvas.height + cullMargin) {
                continue;
            }
            
            try {
                this.ctx.save();
                this.ctx.globalAlpha = p.alpha || 1;
                
                // Determine particle type based on color (for different effects)
                // Check if it's a fire/explosion particle (orange/red/yellow colors)
                const colorStr = String(p.color || '#ffffff');
                let isFireParticle = false;
                
                // Check for specific fire colors - simplified and safe
                if (colorStr === '#ffeb3b') {
                    isFireParticle = true;
                } else if (colorStr.startsWith('hsl(')) {
                    // Extract hue from HSL color safely
                    try {
                        const hueMatch = colorStr.match(/hsl\((\d+)/);
                        if (hueMatch && hueMatch[1] !== undefined) {
                            const hue = parseInt(hueMatch[1], 10);
                            // Fire colors are typically in the 0-60 range (red to yellow)
                            if (!isNaN(hue) && hue >= 0 && hue <= 60) {
                                isFireParticle = true;
                            }
                        }
                    } catch (e) {
                        // If parsing fails, treat as generic particle
                    }
                } else if (colorStr.startsWith('#ff') || colorStr.startsWith('#f44')) {
                    // Hex colors starting with #ff or #f44 are likely fire colors
                    isFireParticle = true;
                }
                
                if (isFireParticle) {
                    // Fire/explosion particles - orange to red gradient
                    const gradient = this.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size || 5);
                    gradient.addColorStop(0, '#ffeb3b'); // Bright yellow center
                    gradient.addColorStop(0.3, '#ff9800'); // Orange
                    gradient.addColorStop(0.7, '#f44336'); // Red
                    gradient.addColorStop(1, '#c62828'); // Dark red edge
                    
                    this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size || 5, 0, Math.PI * 2);
                    
                    // Add glow effect
                    this.ctx.shadowBlur = (p.size || 5) * 2;
                    this.ctx.shadowColor = p.color || '#ff9800';
            this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                    
                    // Inner bright core for fire particles
                    this.ctx.fillStyle = `rgba(255, 255, 200, ${(p.alpha || 1) * 0.8})`;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, (p.size || 5) * 0.4, 0, Math.PI * 2);
                    this.ctx.fill();
                } else {
                    // Generic particles - simple rendering with glow
                    this.ctx.fillStyle = p.color || '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size || 5, 0, Math.PI * 2);
                    
                    // Add glow effect
                    this.ctx.shadowBlur = (p.size || 5) * 1.5;
                    this.ctx.shadowColor = p.color || '#ffffff';
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
                
                this.ctx.restore();
            } catch (error) {
                // If there's an error drawing a particle, restore context and continue
                this.ctx.restore();
                console.error('Error drawing particle:', error, p);
            }
        }
    }

    drawCursor() {
        // Draw custom cursor (the + symbol) at mouse position
        // This replaces the browser cursor so gamepad can control it
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        // Draw + symbol
        this.ctx.moveTo(this.mouse.x - 10, this.mouse.y);
        this.ctx.lineTo(this.mouse.x + 10, this.mouse.y);
        this.ctx.moveTo(this.mouse.x, this.mouse.y - 10);
        this.ctx.lineTo(this.mouse.x, this.mouse.y + 10);
        this.ctx.stroke();
        
        // Add a small circle in the center for better visibility
        this.ctx.fillStyle = '#ffffff';
        this.ctx.beginPath();
        this.ctx.arc(this.mouse.x, this.mouse.y, 2, 0, Math.PI * 2);
        this.ctx.fill();
    }

    drawCrosshair() {
        // Only draw crosshair if targeting computer is equipped
        if (!this.currentUpgrades.includes('targetingComputer')) {
            return; // No crosshair without targeting computer
        }
        
        const time = this.time || 0;
        
        // Use the current mouse position (updated by gamepad or mouse)
        const dx = this.mouse.x - this.player.x;
        const dy = this.mouse.y - this.player.y;
        const angle = Math.atan2(dy, dx);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Determine colors based on mode
        const primaryColor = this.mode === 'ensemble' ? '#ffc107' : '#4caf50';
        const primaryColorRGB = this.mode === 'ensemble' ? '255, 193, 7' : '76, 175, 80';
        const secondaryColor = this.mode === 'ensemble' ? '#ff9800' : '#66bb6a';
        const secondaryColorRGB = this.mode === 'ensemble' ? '255, 152, 0' : '102, 187, 106';
        
        // Pulsing effect for targeting computer
        const pulsePhase = Math.sin(time * 3) * 0.2 + 0.8;
        
        // Enhanced targeting line from player to mouse
        const lineGradient = this.ctx.createLinearGradient(this.player.x, this.player.y, this.mouse.x, this.mouse.y);
        lineGradient.addColorStop(0, `rgba(${primaryColorRGB}, ${0.6 * pulsePhase})`);
        lineGradient.addColorStop(0.5, `rgba(${secondaryColorRGB}, ${0.7 * pulsePhase})`);
        lineGradient.addColorStop(1, `rgba(${primaryColorRGB}, ${0.8 * pulsePhase})`);
        
        this.ctx.strokeStyle = lineGradient;
        this.ctx.lineWidth = 2.5;
        this.ctx.setLineDash([8, 4]);
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = `rgba(${primaryColorRGB}, 0.6)`;
        this.ctx.beginPath();
        this.ctx.moveTo(this.player.x, this.player.y);
        this.ctx.lineTo(this.mouse.x, this.mouse.y);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        this.ctx.setLineDash([]);

        // Range indicator dots along the line
        const dotCount = Math.floor(distance / 50);
        for (let i = 1; i <= dotCount && i <= 10; i++) {
            const dotProgress = i / (dotCount + 1);
            const dotX = this.player.x + dx * dotProgress;
            const dotY = this.player.y + dy * dotProgress;
            const dotSize = 2 + Math.sin(time * 4 + i) * 0.5;
            
            this.ctx.fillStyle = `rgba(${primaryColorRGB}, ${0.7 * pulsePhase})`;
            this.ctx.shadowBlur = 6;
            this.ctx.shadowColor = `rgba(${primaryColorRGB}, 0.5)`;
            this.ctx.beginPath();
            this.ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
        }
        
        // Ensemble mode spread indicators
        if (this.mode === 'ensemble') {
            const spreadAngle = 0.15;
            const spreadLength = Math.min(200, distance * 0.8);
            
            // Left spread line
            const leftGradient = this.ctx.createLinearGradient(
                this.player.x, this.player.y,
                this.player.x + Math.cos(angle - spreadAngle) * spreadLength,
                this.player.y + Math.sin(angle - spreadAngle) * spreadLength
            );
            leftGradient.addColorStop(0, `rgba(255, 193, 7, ${0.4 * pulsePhase})`);
            leftGradient.addColorStop(1, `rgba(255, 152, 0, ${0.2 * pulsePhase})`);
            
            this.ctx.strokeStyle = leftGradient;
            this.ctx.lineWidth = 1.5;
            this.ctx.setLineDash([6, 6]);
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = 'rgba(255, 193, 7, 0.4)';
            this.ctx.beginPath();
            this.ctx.moveTo(this.player.x, this.player.y);
            this.ctx.lineTo(this.player.x + Math.cos(angle - spreadAngle) * spreadLength, 
                          this.player.y + Math.sin(angle - spreadAngle) * spreadLength);
            this.ctx.stroke();
            this.ctx.shadowBlur = 0;
            
            // Right spread line
            const rightGradient = this.ctx.createLinearGradient(
                this.player.x, this.player.y,
                this.player.x + Math.cos(angle + spreadAngle) * spreadLength,
                this.player.y + Math.sin(angle + spreadAngle) * spreadLength
            );
            rightGradient.addColorStop(0, `rgba(255, 193, 7, ${0.4 * pulsePhase})`);
            rightGradient.addColorStop(1, `rgba(255, 152, 0, ${0.2 * pulsePhase})`);
            
            this.ctx.strokeStyle = rightGradient;
            this.ctx.beginPath();
            this.ctx.moveTo(this.player.x, this.player.y);
            this.ctx.lineTo(this.player.x + Math.cos(angle + spreadAngle) * spreadLength, 
                          this.player.y + Math.sin(angle + spreadAngle) * spreadLength);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }
        
        // Enhanced crosshair at mouse position
        const crosshairSize = 15;
        const crosshairPulse = Math.sin(time * 4) * 2 + crosshairSize;
        
        // Outer glow ring
        const glowGradient = this.ctx.createRadialGradient(this.mouse.x, this.mouse.y, 0, this.mouse.x, this.mouse.y, crosshairPulse * 1.5);
        glowGradient.addColorStop(0, `rgba(${primaryColorRGB}, ${0.3 * pulsePhase})`);
        glowGradient.addColorStop(0.5, `rgba(${secondaryColorRGB}, ${0.2 * pulsePhase})`);
        glowGradient.addColorStop(1, `rgba(${primaryColorRGB}, 0)`);
        this.ctx.fillStyle = glowGradient;
        this.ctx.beginPath();
        this.ctx.arc(this.mouse.x, this.mouse.y, crosshairPulse * 1.5, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Pulsing outer ring
        this.ctx.strokeStyle = `rgba(${primaryColorRGB}, ${0.5 * pulsePhase})`;
        this.ctx.lineWidth = 2;
        this.ctx.shadowBlur = 12;
        this.ctx.shadowColor = `rgba(${primaryColorRGB}, 0.6)`;
        this.ctx.beginPath();
        this.ctx.arc(this.mouse.x, this.mouse.y, crosshairPulse, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Main crosshair lines (horizontal and vertical)
        this.ctx.strokeStyle = primaryColor;
        this.ctx.lineWidth = 2.5;
        this.ctx.lineCap = 'round';
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = `rgba(${primaryColorRGB}, 0.8)`;
        
        // Horizontal line
        this.ctx.beginPath();
        this.ctx.moveTo(this.mouse.x - crosshairSize, this.mouse.y);
        this.ctx.lineTo(this.mouse.x - crosshairSize * 0.3, this.mouse.y);
        this.ctx.moveTo(this.mouse.x + crosshairSize * 0.3, this.mouse.y);
        this.ctx.lineTo(this.mouse.x + crosshairSize, this.mouse.y);
        this.ctx.stroke();
        
        // Vertical line
        this.ctx.beginPath();
        this.ctx.moveTo(this.mouse.x, this.mouse.y - crosshairSize);
        this.ctx.lineTo(this.mouse.x, this.mouse.y - crosshairSize * 0.3);
        this.ctx.moveTo(this.mouse.x, this.mouse.y + crosshairSize * 0.3);
        this.ctx.lineTo(this.mouse.x, this.mouse.y + crosshairSize);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Inner crosshair (diagonal lines)
        const innerSize = crosshairSize * 0.5;
        this.ctx.strokeStyle = `rgba(${secondaryColorRGB}, ${0.8 * pulsePhase})`;
        this.ctx.lineWidth = 1.5;
        this.ctx.shadowBlur = 8;
        this.ctx.shadowColor = `rgba(${secondaryColorRGB}, 0.6)`;
        
        // Top-left to bottom-right
        this.ctx.beginPath();
        this.ctx.moveTo(this.mouse.x - innerSize * 0.7, this.mouse.y - innerSize * 0.7);
        this.ctx.lineTo(this.mouse.x - innerSize * 0.2, this.mouse.y - innerSize * 0.2);
        this.ctx.moveTo(this.mouse.x + innerSize * 0.2, this.mouse.y + innerSize * 0.2);
        this.ctx.lineTo(this.mouse.x + innerSize * 0.7, this.mouse.y + innerSize * 0.7);
        this.ctx.stroke();
        
        // Top-right to bottom-left
        this.ctx.beginPath();
        this.ctx.moveTo(this.mouse.x + innerSize * 0.7, this.mouse.y - innerSize * 0.7);
        this.ctx.lineTo(this.mouse.x + innerSize * 0.2, this.mouse.y - innerSize * 0.2);
        this.ctx.moveTo(this.mouse.x - innerSize * 0.2, this.mouse.y + innerSize * 0.2);
        this.ctx.lineTo(this.mouse.x - innerSize * 0.7, this.mouse.y + innerSize * 0.7);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Center targeting dot
        const centerSize = 3 + Math.sin(time * 5) * 0.5;
        const centerGradient = this.ctx.createRadialGradient(this.mouse.x, this.mouse.y, 0, this.mouse.x, this.mouse.y, centerSize);
        centerGradient.addColorStop(0, `rgba(255, 255, 255, ${0.95 * pulsePhase})`);
        centerGradient.addColorStop(0.5, `rgba(${primaryColorRGB}, ${0.8 * pulsePhase})`);
        centerGradient.addColorStop(1, `rgba(${secondaryColorRGB}, 0)`);
        this.ctx.fillStyle = centerGradient;
        this.ctx.shadowBlur = 12;
        this.ctx.shadowColor = `rgba(${primaryColorRGB}, 0.9)`;
        this.ctx.beginPath();
        this.ctx.arc(this.mouse.x, this.mouse.y, centerSize, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Rotating targeting rings
        this.ctx.save();
        this.ctx.translate(this.mouse.x, this.mouse.y);
        this.ctx.rotate(time * 2);
        
        // Ring 1
        this.ctx.strokeStyle = `rgba(${primaryColorRGB}, ${0.3 * pulsePhase})`;
        this.ctx.lineWidth = 1.5;
        this.ctx.setLineDash([4, 4]);
        this.ctx.shadowBlur = 8;
        this.ctx.shadowColor = `rgba(${primaryColorRGB}, 0.4)`;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, crosshairSize * 0.8, 0, Math.PI * 2);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
        
        // Ring 2 (counter-rotating)
        this.ctx.rotate(-time * 3);
        this.ctx.strokeStyle = `rgba(${secondaryColorRGB}, ${0.25 * pulsePhase})`;
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([3, 5]);
        this.ctx.beginPath();
        this.ctx.arc(0, 0, crosshairSize * 1.1, 0, Math.PI * 2);
        this.ctx.stroke();
        
        this.ctx.setLineDash([]);
        this.ctx.restore();
    }

    drawEnsembleOverlay() {
        this.ctx.fillStyle = 'rgba(255, 193, 7, 0.2)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Removed text overlay - it was appearing behind the score panel
    }
    
    drawRepairableItemsIndicator() {
        // Update repairable items list
        this.updateRepairableItems();
        
        if (this.repairableItems.length === 0) {
            // Show message that nothing needs repair
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(10, this.canvas.height - 60, 300, 50);
            this.ctx.fillStyle = '#4caf50';
            this.ctx.font = 'bold 14px Arial';
            this.ctx.textAlign = 'left';
            this.ctx.fillText('🔨 Hammer Equipped', 20, this.canvas.height - 40);
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '12px Arial';
            this.ctx.fillText('All items at full durability', 20, this.canvas.height - 20);
            return;
        }
        
        // Show repairable items indicator
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(10, this.canvas.height - 80 - (this.repairableItems.length * 25), 350, 80 + (this.repairableItems.length * 25));
        
        this.ctx.fillStyle = '#ff9800';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'left';
        this.ctx.fillText('🔨 Hammer Equipped - Press Q to Repair', 20, this.canvas.height - 60 - (this.repairableItems.length * 25));
        
        // Show list of repairable items
        this.repairableItems.forEach((item, index) => {
            const y = this.canvas.height - 40 - (this.repairableItems.length * 25) + (index * 25);
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '12px Arial';
            const itemName = item.name.charAt(0).toUpperCase() + item.name.slice(1);
            this.ctx.fillText(`${itemName}: ${Math.round(item.durability)}% → 100%`, 20, y);
        });
    }

    drawGameOver() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.fillStyle = '#f44336';
        this.ctx.font = 'bold 48px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 150);
        
        // Display death reason
        let deathMessage = '';
        let deathIcon = '';
        if (this.deathReason === 'hunger') {
            deathMessage = 'You starved to death!';
            deathIcon = '🍽️';
        } else if (this.deathReason === 'health') {
            deathMessage = 'You were destroyed in combat!';
            deathIcon = '💥';
        } else {
            deathMessage = 'You were defeated!';
            deathIcon = '💀';
        }
        
        this.ctx.fillStyle = '#ff9800';
        this.ctx.font = 'bold 28px Arial';
        this.ctx.fillText(`${deathIcon} ${deathMessage}`, this.canvas.width / 2, this.canvas.height / 2 - 90);
        
        // Display stats
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '24px Arial';
        const finalScore = Math.floor(this.score || 0); // Ensure score is a number
        this.ctx.fillText(`Final Score: ${finalScore.toLocaleString()}`, this.canvas.width / 2, this.canvas.height / 2 - 40);
        this.ctx.fillText(`Level Reached: ${this.level || 1}`, this.canvas.width / 2, this.canvas.height / 2 - 5);
        
        // Display additional stats if survival system is active
        if (this.survivalUnlocked) {
            this.ctx.fillStyle = '#aaa';
            this.ctx.font = '18px Arial';
            this.ctx.fillText(`Time Survived: ${Math.floor(this.time || 0)}s`, this.canvas.width / 2, this.canvas.height / 2 + 30);
        }
        
        // Check if this is a new high score
        const isNewHighScore = this.checkNewHighScore();
        if (isNewHighScore) {
            this.ctx.fillStyle = '#4fc3f7';
            this.ctx.font = 'bold 20px Arial';
            this.ctx.fillText('NEW HIGH SCORE!', this.canvas.width / 2, this.canvas.height / 2 + 65);
        }
        
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '18px Arial';
        this.ctx.fillText('Press R to Restart', this.canvas.width / 2, this.canvas.height / 2 + 100);
        this.ctx.fillText('Press L to View Leaderboard', this.canvas.width / 2, this.canvas.height / 2 + 130);
    }
    
    checkNewHighScore() {
        if (!this.playerName) {
            this.showNameInput();
            return false;
        }
        
        const currentBest = this.leaderboard.find(entry => entry.name === this.playerName);
        if (!currentBest) {
            this.submitScore();
            return true;
        }
        
        if (this.score > currentBest.score || this.level > currentBest.level) {
            this.submitScore();
            return true;
        }
        
        return false;
    }
    
    showNameInput() {
        const name = prompt('Enter your name for the leaderboard:', this.playerName || 'Player');
        if (name && name.trim()) {
            this.playerName = name.trim();
            this.savePlayerName();
            this.submitScore();
        }
    }
    
    showSaveUnlockNotification() {
        // Create a notification overlay
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 10000;
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            animation: fadeIn 0.5s ease-in;
            border: 3px solid #ffd700;
        `;
        
        notification.innerHTML = `
            <div style="font-size: 2em; margin-bottom: 15px;">🎉</div>
            <div style="margin-bottom: 10px;">HIDDEN SEQUENCE COMPLETE!</div>
            <div style="font-size: 0.9em; font-weight: normal; margin-top: 15px; opacity: 0.95;">
                Save Feature Unlocked!<br>
                Press <span style="background: rgba(255,255,255,0.2); padding: 3px 8px; border-radius: 5px;">V</span> to revert to 2 levels back
            </div>
        `;
        
        // Add fade-in animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove notification after 5 seconds
        setTimeout(() => {
            notification.style.animation = 'fadeIn 0.5s ease-in reverse';
            setTimeout(() => {
                document.body.removeChild(notification);
                document.head.removeChild(style);
            }, 500);
        }, 5000);
    }
    
    async submitScore() {
        if (!this.playerName) return;
        
        // If no API URL is set, use local storage only
        if (!this.apiUrl) {
            this.submitScoreLocal();
            return;
        }
        
        try {
            const response = await fetch(`${this.apiUrl}/leaderboard`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: this.playerName,
                    score: this.score,
                    level: this.level
                }),
                signal: AbortSignal.timeout(2000) // 2 second timeout
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            if (data.success) {
                console.log('Score submitted successfully! Rank:', data.rank);
                // Reload leaderboard to get updated list
                await this.loadLeaderboardFromServer();
            } else {
                // Fallback to local storage
                this.submitScoreLocal();
            }
        } catch (error) {
            // Silently fallback to localStorage - server connection failures are expected
            // Don't log connection refused errors
            const isConnectionError = error.name === 'TypeError' || 
                                     error.name === 'AbortError' ||
                                     error.message?.includes('fetch') ||
                                     error.message?.includes('Failed to fetch') ||
                                     error.message?.includes('network');
            
            if (!isConnectionError) {
                console.warn('Error submitting score to server:', error);
            }
            // Fallback to local storage
            this.submitScoreLocal();
        }
    }
    
    submitScoreLocal() {
        const existingIndex = this.leaderboard.findIndex(entry => entry.name === this.playerName);
        const entry = {
            name: this.playerName,
            score: Math.max(this.score, existingIndex >= 0 ? this.leaderboard[existingIndex].score : 0),
            level: Math.max(this.level, existingIndex >= 0 ? this.leaderboard[existingIndex].level : 0),
            date: new Date().toISOString()
        };
        
        if (existingIndex >= 0) {
            this.leaderboard[existingIndex] = entry;
        } else {
            this.leaderboard.push(entry);
        }
        
        this.leaderboard.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            return b.level - a.level;
        });
        
        this.leaderboard = this.leaderboard.slice(0, 10);
        this.saveLeaderboardLocal();
    }
    
    loadPlayerName() {
        try {
            return localStorage.getItem('bellGamePlayerName') || '';
        } catch (e) {
            return '';
        }
    }
    
    savePlayerName() {
        try {
            localStorage.setItem('bellGamePlayerName', this.playerName);
        } catch (e) {
            console.error('Failed to save player name:', e);
        }
    }
    
    async loadLeaderboardFromServer() {
        // Only try to connect if API URL is set
        if (!this.apiUrl) {
            this.leaderboard = this.loadLeaderboardLocal();
            return;
        }
        
        try {
            const response = await fetch(`${this.apiUrl}/leaderboard`, {
                signal: AbortSignal.timeout(2000) // 2 second timeout
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();
            if (data.success) {
                this.leaderboard = data.leaderboard || [];
                this.updateStats();
            }
        } catch (error) {
            // Silently fallback to localStorage - server connection failures are expected
            // Don't log connection refused errors (ERR_CONNECTION_REFUSED, ERR_FAILED)
            const isConnectionError = error.name === 'TypeError' || 
                                     error.name === 'AbortError' ||
                                     error.message?.includes('fetch') ||
                                     error.message?.includes('Failed to fetch') ||
                                     error.message?.includes('network');
            
            if (!isConnectionError) {
                console.warn('Failed to load leaderboard from server:', error);
            }
            // Fallback to localStorage
            this.leaderboard = this.loadLeaderboardLocal();
        }
    }
    
    async loadTopScores() {
        // Only try to connect if API URL is set
        if (!this.apiUrl) {
            // Use local storage for top scores
            const localLeaderboard = this.loadLeaderboardLocal();
            if (localLeaderboard.length > 0) {
                const topEntry = localLeaderboard.reduce((top, entry) => 
                    entry.score > top.score ? entry : top, localLeaderboard[0]);
                return { topScore: topEntry.score || 0, topLevel: topEntry.level || 1 };
            }
            return { topScore: 0, topLevel: 1 };
        }
        
        try {
            const response = await fetch(`${this.apiUrl}/leaderboard/top`, {
                signal: AbortSignal.timeout(2000) // 2 second timeout
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();
            if (data.success) {
                return { topScore: data.topScore, topLevel: data.topLevel };
            }
        } catch (error) {
            // Silently fallback to localStorage - server connection failures are expected
            // Don't log connection refused errors
            const isConnectionError = error.name === 'TypeError' || 
                                     error.name === 'AbortError' ||
                                     error.message?.includes('fetch') ||
                                     error.message?.includes('Failed to fetch') ||
                                     error.message?.includes('network');
            
            if (!isConnectionError) {
                console.warn('Failed to load top scores:', error);
            }
            // Fallback to local storage
            const localLeaderboard = this.loadLeaderboardLocal();
            if (localLeaderboard.length > 0) {
                const topEntry = localLeaderboard.reduce((top, entry) => 
                    entry.score > top.score ? entry : top, localLeaderboard[0]);
                return { topScore: topEntry.score || 0, topLevel: topEntry.level || 1 };
            }
        }
        return { topScore: 0, topLevel: 1 };
    }
    
    loadLeaderboardLocal() {
        try {
            const stored = localStorage.getItem('bellGameLeaderboard');
            return stored ? JSON.parse(stored) : [];
        } catch (e) {
            return [];
        }
    }
    
    saveLeaderboardLocal() {
        try {
            localStorage.setItem('bellGameLeaderboard', JSON.stringify(this.leaderboard));
        } catch (e) {
            console.error('Failed to save leaderboard:', e);
        }
    }

    startCutscene() {
        if (!this.cutsceneOverlay || !this.cutsceneCanvas) {
            console.error('[Cutscene] Missing cutscene overlay or canvas!', {
                overlay: !!this.cutsceneOverlay,
                canvas: !!this.cutsceneCanvas,
                overlayElement: document.getElementById('cutsceneOverlay'),
                canvasElement: document.getElementById('cutsceneCanvas')
            });
            return;
        }
        
        // Ensure cutsceneId is set (default to opening if not set)
        if (!this.cutsceneId) {
            this.cutsceneId = 'opening';
        }
        
        console.log(`[Cutscene] Starting cutscene: ${this.cutsceneId}, phase: ${this.cutscenePhase}`);
        
        // Ensure overlay and canvas elements exist
        if (!this.cutsceneOverlay) {
            console.error('[Cutscene] cutsceneOverlay element not found!');
            return;
        }
        
        if (!this.cutsceneCanvas) {
            console.error('[Cutscene] cutsceneCanvas element not found!');
            return;
        }
        
        // Ensure context is initialized
        if (!this.cutsceneCtx && this.cutsceneCanvas) {
            this.cutsceneCtx = this.cutsceneCanvas.getContext('2d');
            console.log('[Cutscene] Initialized cutscene context');
        }
        
        if (!this.cutsceneCtx) {
            console.error('[Cutscene] Cannot get cutscene context!');
            return;
        }
        
        // Reset debug flags
        this._cutsceneDrawLogged = false;
        this._cutsceneDrawCallLogged = false;
        
        // Show overlay
        this.cutsceneOverlay.classList.add('active');
        console.log('[Cutscene] Overlay active class added');
        
        // Resize canvas
        this.cutsceneCanvas.width = window.innerWidth;
        this.cutsceneCanvas.height = window.innerHeight;
        console.log(`[Cutscene] Canvas resized to ${window.innerWidth}x${window.innerHeight}`);
        
        // Re-initialize context after resize (canvas resize clears context)
        this.cutsceneCtx = this.cutsceneCanvas.getContext('2d');
        if (!this.cutsceneCtx) {
            console.error('[Cutscene] Failed to get context after resize!');
            return;
        }
        
        this.cutsceneTime = 0;
        // Don't reset phase here - it should be set by startLevelCutscene or opening cutscene
        
        // Setup skip button (double-click to skip)
        const skipBtn = document.getElementById('cutsceneSkip');
        if (skipBtn) {
            skipBtn.ondblclick = () => this.skipCutscene();
        }
        
        // Setup keyboard/mouse skip
        // Store handler reference so we can remove it later
        this._cutsceneSkipHandler = (e) => {
            // Only skip on keyboard (Space/Enter) - single press is fine for keyboard
            if (e.key === ' ' || e.key === 'Enter') {
                this.skipCutscene();
                this.removeCutsceneSkipHandlers();
            } else if (e.type === 'dblclick') {
                // Only skip on double-click directly on overlay/canvas, not on buttons or other UI
                const target = e.target;
                // Don't skip if double-clicking on skip button, text, or other interactive elements
                if (target.id === 'cutsceneSkip' || 
                    target === this.cutsceneText ||
                    (target.closest && target.closest('#cutsceneSkip'))) {
                    return; // Don't skip if double-clicking on skip button or text
                }
                // Only skip if double-clicking on overlay/canvas itself
                if (target === this.cutsceneOverlay || 
                    target === this.cutsceneCanvas ||
                    (this.cutsceneOverlay && this.cutsceneOverlay.contains(target))) {
                    this.skipCutscene();
                    this.removeCutsceneSkipHandlers();
                }
            }
        };
        document.addEventListener('keydown', this._cutsceneSkipHandler);
        // Only listen for double-clicks on the overlay itself, not the whole document
        if (this.cutsceneOverlay) {
            this.cutsceneOverlay.addEventListener('dblclick', this._cutsceneSkipHandler);
        }
    }
    
    removeCutsceneSkipHandlers() {
        if (this._cutsceneSkipHandler) {
            document.removeEventListener('keydown', this._cutsceneSkipHandler);
            if (this.cutsceneOverlay) {
                this.cutsceneOverlay.removeEventListener('dblclick', this._cutsceneSkipHandler);
            }
            this._cutsceneSkipHandler = null;
        }
    }
    
    skipCutscene() {
        // Don't save skip preference - cutscene will show again next time
        console.log('[Cutscene] Skipping cutscene');
        this.removeCutsceneSkipHandlers();
        // Mark as skipped so it won't be saved as "shown"
        this._cutsceneWasSkipped = true;
        this.endCutscene();
    }
    
    endCutscene() {
        console.log(`[Cutscene] Ending cutscene: ${this.cutsceneId}, phase: ${this.cutscenePhase}`);
        
        // Reset debug flag
        this._cutsceneDrawLogged = false;
        
        // Clear canvas immediately to prevent drawing after cutscene ends
        if (this.cutsceneCtx && this.cutsceneCanvas) {
            this.cutsceneCtx.fillStyle = '#000';
            this.cutsceneCtx.fillRect(0, 0, this.cutsceneCanvas.width, this.cutsceneCanvas.height);
        }
        
        // Hide overlay
        if (this.cutsceneOverlay) {
            this.cutsceneOverlay.classList.remove('active');
        }
        
        // Clear text
        if (this.cutsceneText) {
            this.cutsceneText.textContent = '';
            this.cutsceneText.classList.remove('visible');
        }
        
        // Don't mark cutscenes as shown - they will always appear when reaching the level
        // Players can skip with double-click if they want, but cutscenes will show again next time
        // Reset skip flag
        this._cutsceneWasSkipped = false;
        
        const wasManual = this.cutsceneIsManual;
        const currentCutsceneId = this.cutsceneId;
        
        // Remove skip handlers
        this.removeCutsceneSkipHandlers();
        
        // Reset cutscene state
        this.cutsceneIsManual = false;
        this.cutsceneId = null; // Clear cutscene ID to prevent drawing
        this.cutscenePhase = 0;
        this.cutsceneTime = 0;
        
        // If this was a level cutscene triggered automatically, proceed to level-up menu
        if (!wasManual && currentCutsceneId && currentCutsceneId.startsWith('level')) {
            this.gameState = 'levelup';
            this.levelUpState = true;
            try {
                this.audio.playSFX('levelUp', 1.0);
                this.showLevelUpMenu();
            } catch (e) {
                console.warn('[Game] Could not show level-up menu:', e);
                this.gameState = 'playing';
                this.levelUpState = false;
            }
        } else {
            // Manual cutscene or opening cutscene - return to game
            this.gameState = 'playing';
            this.levelUpState = false;
            // Start main music if not already playing
            if (!wasManual) {
                console.log('[Game] Cutscene ended, starting main music');
                this.audio.playMusic('main', true, true);
                this.showNameInputDelayed();
            }
        }
    }
    
    showNameInputDelayed() {
        // Show name input on first play if no name set
        if (!this.playerName) {
            setTimeout(() => {
                const name = prompt('Enter your name for the leaderboard (you can change this later):', 'Player');
                if (name && name.trim()) {
                    this.playerName = name.trim();
                    this.savePlayerName();
                }
            }, 1000);
        }
    }
    
    updateCutscene(deltaTime) {
        if (this.gameState !== 'cutscene') {
            console.warn(`[Cutscene] updateCutscene called but gameState is ${this.gameState}, not 'cutscene'`);
            return;
        }
        
        this.cutsceneTime += deltaTime;
        
        // Handle different cutscenes based on ID
        if (this.cutsceneId === 'opening') {
            // Opening cutscene - optimized timing based on reading speed research
            // Research: Average reading speed 200-250 WPM = 4-5 words/second
            // Allow 4-5 words/second + 2 seconds for image viewing + 1 second fade = optimal timing
            
            // Phase 0: "1964 - Bell Labs: John Bell struggles with Einstein's 1949 paper. Using Quantum Mechanics, he builds a time travel device..."
            // Word count: ~20 words = 5 seconds reading + 2s image viewing + 1s fade = 8 seconds
            if (this.cutscenePhase === 0 && this.cutsceneTime > 8) {
                this.cutscenePhase = 1;
                this.cutsceneTime = 0;
                console.log('[Cutscene] Opening cutscene: Phase 0 -> 1');
            } 
            // Phase 1: "The device activates! Bell travels back to 1949 to meet Einstein..."
            // Word count: ~10 words = 3 seconds reading + 2s image viewing + 1s fade = 6 seconds
            else if (this.cutscenePhase === 1 && this.cutsceneTime > 6) {
                this.cutscenePhase = 2;
                this.cutsceneTime = 0;
                console.log('[Cutscene] Opening cutscene: Phase 1 -> 2');
            } 
            // Phase 2: Two messages - "Returning to 1964..." (~10 words) + "CRITICAL ERROR!..." (~10 words)
            // Total: ~20 words = 5 seconds reading + 2s image viewing + 1s fade = 8 seconds per message = 16 seconds total
            else if (this.cutscenePhase === 2 && this.cutsceneTime > 16) {
                this.cutscenePhase = 3;
                this.cutsceneTime = 0;
                console.log('[Cutscene] Opening cutscene: Phase 2 -> 3');
            } 
            // Phase 3: "Einstein shrinks to atomic scale... Entering Bell's brain..."
            // Extended timing: 3s image viewing + 1.5s fade in + 2.5s reading + 0.5s fade out + 1s gap + 1s fade in + 2s reading + 1s fade out = 12 seconds
            else if (this.cutscenePhase === 3 && this.cutsceneTime > 12) {
                this.cutscenePhase = 4;
                this.cutsceneTime = 0;
                console.log('[Cutscene] Opening cutscene: Phase 3 -> 4');
            } else if (this.cutscenePhase === 4 && this.cutsceneTime > 3) {
                console.log('[Cutscene] Opening cutscene: Ending');
                this.endCutscene();
            }
        } else if (this.cutsceneId && this.cutsceneId.startsWith('level')) {
            // Level-based cutscenes - 4 phases for enhanced cutscenes (Level 5+), 3 for others
            // Increased durations to give more time to read text
            if (this.cutscenePhase === 0 && this.cutsceneTime > 12) {
                this.cutscenePhase = 1;
                this.cutsceneTime = 0;
                console.log(`[Cutscene] ${this.cutsceneId}: Phase 0 -> 1 (time: ${this.cutsceneTime.toFixed(2)})`);
            } else if (this.cutscenePhase === 1 && this.cutsceneTime > 12) {
                this.cutscenePhase = 2;
                this.cutsceneTime = 0;
                console.log(`[Cutscene] ${this.cutsceneId}: Phase 1 -> 2 (time: ${this.cutsceneTime.toFixed(2)})`);
            } else if (this.cutscenePhase === 2 && this.cutsceneTime > 10) {
                // Check if this cutscene has a Phase 3 (building technology)
                // cutsceneId is a string like "level5", so we need to extract the level number
                const level = parseInt(this.cutsceneId.replace('level', ''));
                if (level === 5 || level === 10 || level === 25 || level === 35 || 
                    level === 40 || level === 50 || level === 65 || 
                    level === 70 || level === 80) {
                    this.cutscenePhase = 3;
                    this.cutsceneTime = 0;
                    console.log(`[Cutscene] ${this.cutsceneId}: Phase 2 -> 3 (time: ${this.cutsceneTime.toFixed(2)})`);
                } else {
                    console.log(`[Cutscene] ${this.cutsceneId}: Ending (phase 2 complete)`);
                    this.endCutscene();
                }
            } else if (this.cutscenePhase === 3 && this.cutsceneTime > 14) {
                console.log(`[Cutscene] ${this.cutsceneId}: Ending (phase 3 complete)`);
                this.endCutscene();
            }
        } else {
            console.warn(`[Cutscene] Unknown cutscene ID: ${this.cutsceneId}`);
        }
    }
    
    // Helper function to draw glow effect
    drawGlow(ctx, x, y, radius, color, intensity = 1) {
        // Parse color string to extract RGB and alpha values
        let r = 79, g = 195, b = 247, a = 0.6; // Default cyan
        
        if (color.startsWith('rgba')) {
            // Extract rgba values
            const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (match) {
                r = parseInt(match[1]);
                g = parseInt(match[2]);
                b = parseInt(match[3]);
                a = match[4] ? parseFloat(match[4]) : 1;
            }
        } else if (color.startsWith('#')) {
            // Hex color
            const hex = color.replace('#', '');
            r = parseInt(hex.substr(0, 2), 16);
            g = parseInt(hex.substr(2, 2), 16);
            b = parseInt(hex.substr(4, 2), 16);
            a = hex.length > 6 ? parseInt(hex.substr(6, 2), 16) / 255 : 1;
        }
        
        // Apply intensity
        a *= intensity;
        
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${a})`);
        gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${a * 0.5})`);
        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Helper function to draw shadow
    drawShadow(ctx, x, y, width, height, blur = 10, opacity = 0.3) {
        ctx.shadowColor = 'rgba(0, 0, 0, ' + opacity + ')';
        ctx.shadowBlur = blur;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        ctx.fillRect(x, y, width, height);
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    // Helper function to draw detailed Bell character
    drawBellCharacter(ctx, x, y, scale = 1, alpha = 1, time = 0) {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(x, y);
        
        // Breathing animation - subtle vertical movement
        const breathOffset = Math.sin((time || 0) * 1.2) * 2;
        ctx.translate(0, breathOffset);
        
        ctx.scale(scale, scale);
        
        // Enhanced shadow with glow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
        ctx.shadowBlur = 25;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        
        // ========== BODY (Lab Coat) ==========
        // Lab coat body with enhanced gradient and depth
        const coatGradient = ctx.createLinearGradient(-25, -60, -25, 40);
        coatGradient.addColorStop(0, '#f5f5f5'); // Top highlight
        coatGradient.addColorStop(0.2, '#f0f0f0');
        coatGradient.addColorStop(0.5, '#e8e8e8');
        coatGradient.addColorStop(0.8, '#d8d8d8');
        coatGradient.addColorStop(1, '#c8c8c8'); // Bottom shadow
        ctx.fillStyle = coatGradient;
        ctx.beginPath();
        ctx.moveTo(-25, -60);
        ctx.lineTo(-30, 40);
        ctx.lineTo(30, 40);
        ctx.lineTo(25, -60);
        ctx.closePath();
        ctx.fill();
        
        // Lab coat side shadows for depth
        ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
        ctx.beginPath();
        ctx.moveTo(-25, -60);
        ctx.lineTo(-30, 40);
        ctx.lineTo(-28, 40);
        ctx.lineTo(-23, -60);
        ctx.closePath();
        ctx.fill();
        
        // Lab coat buttons
        ctx.fillStyle = '#888';
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.arc(0, -40 + i * 20, 2.5, 0, Math.PI * 2);
            ctx.fill();
            // Button highlight
            ctx.fillStyle = '#aaa';
            ctx.beginPath();
            ctx.arc(0.5, -40.5 + i * 20, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#888';
        }
        
        // Lab coat collar with enhanced detail
        const collarGradient = ctx.createLinearGradient(-20, -70, 20, -60);
        collarGradient.addColorStop(0, '#d8d8d8');
        collarGradient.addColorStop(0.5, '#e0e0e0');
        collarGradient.addColorStop(1, '#d0d0d0');
        ctx.fillStyle = collarGradient;
        ctx.beginPath();
        ctx.moveTo(-20, -60);
        ctx.lineTo(-15, -70);
        ctx.lineTo(15, -70);
        ctx.lineTo(20, -60);
        ctx.closePath();
        ctx.fill();
        // Collar highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.moveTo(-15, -70);
        ctx.lineTo(0, -65);
        ctx.lineTo(15, -70);
        ctx.lineTo(0, -60);
        ctx.closePath();
        ctx.fill();
        
        // ========== HEAD ==========
        // Head base with enhanced skin tone gradient
        const headGradient = ctx.createRadialGradient(-5, -80, 0, 0, -75, 24);
        headGradient.addColorStop(0, '#fae8c8'); // Center highlight
        headGradient.addColorStop(0.4, '#f8e0b8');
        headGradient.addColorStop(0.7, '#f4d3a1');
        headGradient.addColorStop(1, '#e8c890'); // Edge shadow
        ctx.fillStyle = headGradient;
        ctx.beginPath();
        ctx.arc(0, -75, 24, 0, Math.PI * 2);
        ctx.fill();
        
        // Head shadow (chin area)
        ctx.fillStyle = 'rgba(200, 180, 150, 0.3)';
        ctx.beginPath();
        ctx.ellipse(0, -55, 18, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ========== HAIR ==========
        // Hair base with texture
        const hairGradient = ctx.createRadialGradient(0, -90, 0, 0, -85, 28);
        hairGradient.addColorStop(0, '#4a3a2a');
        hairGradient.addColorStop(0.6, '#3a2a1a');
        hairGradient.addColorStop(1, '#2a1a0a');
        ctx.fillStyle = hairGradient;
        ctx.beginPath();
        ctx.arc(0, -85, 28, 0, Math.PI, true);
        ctx.fill();
        
        // Hair texture - individual strands
        ctx.fillStyle = '#5a4a3a';
        for (let i = 0; i < 12; i++) {
            const strandX = -12 + (i * 2);
            const strandY = -88 + Math.sin(i * 0.5) * 2;
            ctx.beginPath();
            ctx.arc(strandX, strandY, 2.5, 0, Math.PI * 2);
            ctx.fill();
        }
        // Hair highlights
        ctx.fillStyle = '#6a5a4a';
        for (let i = 0; i < 8; i++) {
            const highlightX = -10 + (i * 2.5);
            const highlightY = -90 + Math.sin(i * 0.7) * 1;
            ctx.beginPath();
            ctx.arc(highlightX, highlightY, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ========== FACE FEATURES ==========
        // Eyebrows
        ctx.fillStyle = '#2a1a0a';
        ctx.beginPath();
        ctx.ellipse(-10, -82, 6, 2, -0.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(10, -82, 6, 2, 0.1, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes (under glasses, visible)
        ctx.fillStyle = '#333';
        // Left eye
        ctx.beginPath();
        ctx.arc(-12, -75, 3, 0, Math.PI * 2);
        ctx.fill();
        // Right eye
        ctx.beginPath();
        ctx.arc(12, -75, 3, 0, Math.PI * 2);
        ctx.fill();
        // Eye highlights
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-11.5, -75.5, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(12.5, -75.5, 1, 0, Math.PI * 2);
        ctx.fill();
        
        // Nose with shading
        ctx.strokeStyle = 'rgba(200, 180, 150, 0.4)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, -70);
        ctx.lineTo(0, -62);
        ctx.stroke();
        // Nostrils
        ctx.fillStyle = 'rgba(180, 160, 130, 0.5)';
        ctx.beginPath();
        ctx.arc(-2, -62, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(2, -62, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Mouth
        ctx.strokeStyle = 'rgba(150, 120, 100, 0.6)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, -58, 4, 0, Math.PI);
        ctx.stroke();
        
        // ========== GLASSES ==========
        // Enhanced glasses with animated reflection and glow
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 3;
        const glassGlow = 0.3 + Math.sin((time || 0) * 2) * 0.1;
        ctx.fillStyle = `rgba(200, 220, 255, ${0.3 + glassGlow * 0.2})`;
        
        // Left lens with glow and frame
        this.drawGlow(ctx, -12, -75, 14, `rgba(79, 195, 247, ${glassGlow * 0.3})`);
        ctx.beginPath();
        ctx.arc(-12, -75, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Frame detail
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(-12, -75, 10, 0, Math.PI * 2);
        ctx.stroke();
        
        // Right lens with glow and frame
        this.drawGlow(ctx, 12, -75, 14, `rgba(79, 195, 247, ${glassGlow * 0.3})`);
        ctx.beginPath();
        ctx.arc(12, -75, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        // Frame detail
        ctx.beginPath();
        ctx.arc(12, -75, 10, 0, Math.PI * 2);
        ctx.stroke();
        
        // Bridge with detail
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-2, -75);
        ctx.lineTo(2, -75);
        ctx.stroke();
        // Bridge highlight
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-1.5, -75);
        ctx.lineTo(1.5, -75);
        ctx.stroke();
        
        // Temple pieces (sides of glasses)
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(-22, -75);
        ctx.lineTo(-25, -70);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(22, -75);
        ctx.lineTo(25, -70);
        ctx.stroke();
        
        // Animated reflection on glasses (moves with time)
        const reflectionOffset = (time || 0) * 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + glassGlow * 0.3})`;
        ctx.beginPath();
        ctx.arc(-8 - reflectionOffset * 0.5, -78, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(8 + reflectionOffset * 0.5, -78, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // ========== ARMS ==========
        // Enhanced arms with subtle animation (working gesture)
        // Left arm (raised, working) - animated movement
        ctx.save();
        ctx.translate(-20, -20);
        const armSway = Math.sin((time || 0) * 1.5) * 0.1;
        ctx.rotate(-0.3 + armSway);
        
        // Left arm with gradient
        const leftArmGradient = ctx.createLinearGradient(-8, -15, -8, 20);
        leftArmGradient.addColorStop(0, '#e0c090');
        leftArmGradient.addColorStop(0.5, '#f4d3a1');
        leftArmGradient.addColorStop(1, '#e8c890');
        ctx.fillStyle = leftArmGradient;
        ctx.fillRect(-8, -15, 16, 35);
        // Arm highlight
        ctx.fillStyle = 'rgba(255, 240, 220, 0.4)';
        ctx.fillRect(-6, -15, 8, 35);
        // Arm shadow
        ctx.fillStyle = 'rgba(180, 150, 120, 0.3)';
        ctx.fillRect(-2, -15, 4, 35);
        ctx.restore();
        
        // Right arm with subtle movement
        const rightArmOffset = Math.sin((time || 0) * 1.2) * 1;
        const rightArmGradient = ctx.createLinearGradient(15, -10, 15, 30);
        rightArmGradient.addColorStop(0, '#e0c090');
        rightArmGradient.addColorStop(0.5, '#f4d3a1');
        rightArmGradient.addColorStop(1, '#e8c890');
        ctx.fillStyle = rightArmGradient;
        ctx.fillRect(15, -10 + rightArmOffset, 16, 40);
        // Arm highlight
        ctx.fillStyle = 'rgba(255, 240, 220, 0.4)';
        ctx.fillRect(17, -10 + rightArmOffset, 8, 40);
        // Arm shadow
        ctx.fillStyle = 'rgba(180, 150, 120, 0.3)';
        ctx.fillRect(21, -10 + rightArmOffset, 4, 40);
        
        // ========== HANDS ==========
        // Enhanced hands with fingers
        ctx.fillStyle = '#f4d3a1';
        // Left hand (working position)
        ctx.beginPath();
        ctx.arc(-25, -5, 10, 0, Math.PI * 2);
        ctx.fill();
        // Left hand shadow
        ctx.fillStyle = 'rgba(200, 180, 150, 0.4)';
        ctx.beginPath();
        ctx.arc(-25, -3, 10, 0, Math.PI * 2);
        ctx.fill();
        // Left hand fingers
        ctx.fillStyle = '#f4d3a1';
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.arc(-25 + (i - 1.5) * 3, -8, 2.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Right hand
        ctx.beginPath();
        ctx.arc(23, 30, 10, 0, Math.PI * 2);
        ctx.fill();
        // Right hand shadow
        ctx.fillStyle = 'rgba(200, 180, 150, 0.4)';
        ctx.beginPath();
        ctx.arc(23, 32, 10, 0, Math.PI * 2);
        ctx.fill();
        // Right hand fingers
        ctx.fillStyle = '#f4d3a1';
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.arc(23 + (i - 1.5) * 3, 27, 2.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ========== LEGS ==========
        // Enhanced legs with pants
        const pantsGradient = ctx.createLinearGradient(-12, 40, -12, 90);
        pantsGradient.addColorStop(0, '#2a2a4a');
        pantsGradient.addColorStop(0.5, '#1a1a3a');
        pantsGradient.addColorStop(1, '#0a0a2a');
        ctx.fillStyle = pantsGradient;
        // Left leg
        ctx.fillRect(-12, 40, 18, 50);
        // Right leg
        ctx.fillRect(-6, 40, 18, 50);
        
        // Pants creases and details
        ctx.strokeStyle = '#0a0a2a';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-3, 40);
        ctx.lineTo(-3, 90);
        ctx.stroke();
        // Side creases
        ctx.strokeStyle = 'rgba(10, 10, 42, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-6, 50);
        ctx.lineTo(-6, 90);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, 50);
        ctx.lineTo(0, 90);
        ctx.stroke();
        
        // ========== SHOES ==========
        // Enhanced shoes with shine
        const shoeGradient = ctx.createLinearGradient(-15, 90, -15, 98);
        shoeGradient.addColorStop(0, '#1a1a1a');
        shoeGradient.addColorStop(0.5, '#0a0a0a');
        shoeGradient.addColorStop(1, '#000000');
        ctx.fillStyle = shoeGradient;
        ctx.fillRect(-15, 90, 20, 8);
        ctx.fillRect(-9, 90, 20, 8);
        
        // Shoe shine with gradient
        const shineGradient = ctx.createLinearGradient(-13, 90, -13, 93);
        shineGradient.addColorStop(0, 'rgba(150, 150, 150, 0.6)');
        shineGradient.addColorStop(1, 'rgba(100, 100, 100, 0.3)');
        ctx.fillStyle = shineGradient;
        ctx.fillRect(-13, 90, 12, 3);
        ctx.fillRect(-7, 90, 12, 3);
        // Shoe laces
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-10, 92);
        ctx.lineTo(-10, 95);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-4, 92);
        ctx.lineTo(-4, 95);
        ctx.stroke();
        
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.restore();
    }
    
    // Helper function to draw detailed Einstein character
    drawEinsteinCharacter(ctx, x, y, scale = 1, alpha = 1, time = 0) {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(x, y);
        
        // Breathing animation - subtle vertical movement
        const breathOffset = Math.sin((time || 0) * 1.0) * 2;
        ctx.translate(0, breathOffset);
        
        ctx.scale(scale, scale);
        
        // Enhanced shadow with glow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
        ctx.shadowBlur = 25;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        
        // ========== HEAD ==========
        // Head base with enhanced skin tone gradient (warmer, more aged)
        const headGradient = ctx.createRadialGradient(-3, -12, 0, 0, -10, 20);
        headGradient.addColorStop(0, '#ffe8c8'); // Center highlight
        headGradient.addColorStop(0.3, '#ffe0b8');
        headGradient.addColorStop(0.6, '#ffc088');
        headGradient.addColorStop(0.9, '#ffaa44');
        headGradient.addColorStop(1, '#ff8844'); // Edge shadow (warmer)
        ctx.fillStyle = headGradient;
        ctx.beginPath();
        ctx.arc(0, -10, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Head shadow (chin and jaw area)
        ctx.fillStyle = 'rgba(200, 150, 100, 0.4)';
        ctx.beginPath();
        ctx.ellipse(0, 2, 16, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Forehead wrinkles (characteristic of Einstein - more detailed)
        ctx.strokeStyle = 'rgba(200, 150, 100, 0.5)';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 5; i++) {
            const wrinkleY = -22 - i * 1.5;
            ctx.beginPath();
            ctx.moveTo(-10 + i * 2, wrinkleY);
            ctx.lineTo(-8 + i * 2, wrinkleY + 1);
            ctx.stroke();
        }
        // Side wrinkles
        ctx.strokeStyle = 'rgba(200, 150, 100, 0.4)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(-14, -18 + i * 2);
            ctx.lineTo(-12, -17 + i * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(14, -18 + i * 2);
            ctx.lineTo(12, -17 + i * 2);
            ctx.stroke();
        }
        
        // ========== HAIR ==========
        // Enhanced wild white hair with subtle animation (Einstein's signature)
        // Base hair layer
        const hairBaseGradient = ctx.createRadialGradient(0, -12, 0, 0, -12, 25);
        hairBaseGradient.addColorStop(0, '#fffef8');
        hairBaseGradient.addColorStop(0.5, '#fff8e0');
        hairBaseGradient.addColorStop(1, '#ffe8c0');
        ctx.fillStyle = hairBaseGradient;
        ctx.beginPath();
        ctx.arc(0, -12, 25, 0, Math.PI * 2);
        ctx.fill();
        
        // Main hair mass with animated movement and individual strands
        ctx.fillStyle = '#fff8e0';
        for (let i = 0; i < 20; i++) {
            const hairAngle = (i / 20) * Math.PI * 2;
            const hairDist = 20 + Math.sin(i * 0.7) * 8;
            const hairAnim = Math.sin((time || 0) * 0.8 + i * 0.3) * 2; // Subtle hair movement
            const hairX = Math.cos(hairAngle) * (hairDist + hairAnim);
            const hairY = -12 + Math.sin(hairAngle) * 12;
            const hairSize = 7 + Math.sin(i * 0.5) * 4;
            ctx.beginPath();
            ctx.arc(hairX, hairY, hairSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Additional hair texture and volume (highlights)
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 15; i++) {
            const hairAngle = (i / 15) * Math.PI * 2;
            const hairDist = 22 + Math.sin(i) * 4;
            const hairX = Math.cos(hairAngle) * hairDist;
            const hairY = -12 + Math.sin(hairAngle) * 10;
            const hairSize = 5 + Math.sin(i * 0.7) * 2;
            ctx.beginPath();
            ctx.arc(hairX, hairY, hairSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Top hair spike (characteristic Einstein look) - enhanced
        ctx.fillStyle = '#fffef8';
        ctx.beginPath();
        ctx.arc(0, -30, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(-6, -32, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(6, -32, 8, 0, Math.PI * 2);
        ctx.fill();
        // Additional spikes
        ctx.beginPath();
        ctx.arc(-3, -34, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(3, -34, 6, 0, Math.PI * 2);
        ctx.fill();
        
        // ========== EYEBROWS ==========
        // Bushy eyebrows (more detailed)
        ctx.fillStyle = '#fff8e0';
        // Left eyebrow
        ctx.beginPath();
        ctx.ellipse(-7, -12, 6, 2.5, -0.2, 0, Math.PI * 2);
        ctx.fill();
        // Right eyebrow
        ctx.beginPath();
        ctx.ellipse(7, -12, 6, 2.5, 0.2, 0, Math.PI * 2);
        ctx.fill();
        // Eyebrow texture (individual hairs)
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.arc(-7 + i * 0.5, -12, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(7 - i * 0.5, -12, 1, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ========== EYES ==========
        // Eyes - more expressive and characteristic
        ctx.fillStyle = '#1a1a1a';
        // Left eye
        ctx.beginPath();
        ctx.arc(-7, -8, 3, 0, Math.PI * 2);
        ctx.fill();
        // Right eye
        ctx.beginPath();
        ctx.arc(7, -8, 3, 0, Math.PI * 2);
        ctx.fill();
        // Eye highlights (more detailed)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-6.5, -8.5, 1.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(7.5, -8.5, 1.2, 0, Math.PI * 2);
        ctx.fill();
        // Secondary highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(-6.2, -8.3, 0.6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(7.8, -8.3, 0.6, 0, Math.PI * 2);
        ctx.fill();
        // Eye wrinkles (crow's feet)
        ctx.strokeStyle = 'rgba(200, 150, 100, 0.3)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(-12 - i, -8);
            ctx.lineTo(-10 - i * 0.5, -7 - i * 0.5);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(12 + i, -8);
            ctx.lineTo(10 + i * 0.5, -7 - i * 0.5);
            ctx.stroke();
        }
        
        // ========== NOSE ==========
        // Nose - more prominent with shading
        ctx.strokeStyle = 'rgba(200, 150, 100, 0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -6);
        ctx.lineTo(0, 2);
        ctx.stroke();
        // Nose shadow
        ctx.fillStyle = 'rgba(200, 150, 100, 0.3)';
        ctx.beginPath();
        ctx.ellipse(-1, 0, 2, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        // Nostrils (more detailed)
        ctx.fillStyle = 'rgba(180, 130, 90, 0.5)';
        ctx.beginPath();
        ctx.arc(-2.5, 1, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(2.5, 1, 2, 0, Math.PI * 2);
        ctx.fill();
        // Nostril highlights
        ctx.fillStyle = 'rgba(200, 150, 100, 0.3)';
        ctx.beginPath();
        ctx.arc(-2.2, 0.8, 0.8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(2.8, 0.8, 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // ========== MUSTACHE ==========
        // Prominent bushy mustache (Einstein's most recognizable feature) - enhanced
        // Base mustache
        const mustacheGradient = ctx.createLinearGradient(-14, 0, 14, 0);
        mustacheGradient.addColorStop(0, '#fffef8');
        mustacheGradient.addColorStop(0.5, '#fff8e0');
        mustacheGradient.addColorStop(1, '#fffef8');
        ctx.fillStyle = mustacheGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 16, 7, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Mustache texture - individual hairs (more detailed)
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 12; i++) {
            const mustacheX = -12 + (i * 2);
            const mustacheY = -1 + Math.sin(i * 0.5) * 1.5;
            const hairSize = 2.5 + Math.sin(i) * 0.5;
            ctx.beginPath();
            ctx.arc(mustacheX, mustacheY, hairSize, 0, Math.PI * 2);
            ctx.fill();
        }
        // Additional mustache volume
        ctx.fillStyle = '#fff8e0';
        for (let i = 0; i < 8; i++) {
            const mustacheX = -10 + (i * 2.5);
            const mustacheY = 0.5 + Math.sin(i * 0.7) * 1;
            ctx.beginPath();
            ctx.arc(mustacheX, mustacheY, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Mustache extends down (more detailed)
        ctx.fillStyle = '#fff8e0';
        ctx.beginPath();
        ctx.ellipse(-7, 3, 5, 4, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(7, 3, 5, 4, 0.3, 0, Math.PI * 2);
        ctx.fill();
        // Mustache side texture
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.arc(-8 + i * 0.5, 4, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(8 - i * 0.5, 4, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ========== MOUTH ==========
        // Mouth (visible under mustache)
        ctx.strokeStyle = 'rgba(150, 100, 80, 0.5)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 1, 3, 0, Math.PI);
        ctx.stroke();
        
        // ========== BODY (SWEATER) ==========
        // Enhanced sweater with texture (Einstein's typical casual wear)
        const bodyGradient = ctx.createLinearGradient(-12, 2, -12, 28);
        bodyGradient.addColorStop(0, '#a59575');
        bodyGradient.addColorStop(0.3, '#9b8565');
        bodyGradient.addColorStop(0.6, '#8b7355');
        bodyGradient.addColorStop(1, '#6b5a45');
        ctx.fillStyle = bodyGradient;
        ctx.fillRect(-12, 2, 24, 28);
        
        // Sweater texture/pattern (knit pattern)
        ctx.strokeStyle = 'rgba(107, 90, 69, 0.4)';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(-12, 6 + i * 6);
            ctx.lineTo(12, 6 + i * 6);
            ctx.stroke();
        }
        // Vertical knit lines
        ctx.strokeStyle = 'rgba(107, 90, 69, 0.2)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.moveTo(-10 + i * 4, 2);
            ctx.lineTo(-10 + i * 4, 28);
            ctx.stroke();
        }
        // Sweater shadow
        ctx.fillStyle = 'rgba(50, 40, 30, 0.2)';
        ctx.fillRect(-12, 2, 24, 5);
        
        // ========== ARMS ==========
        // Enhanced arms with sleeves
        const armGradient = ctx.createLinearGradient(-14, 5, -14, 25);
        armGradient.addColorStop(0, '#ffcc66');
        armGradient.addColorStop(0.5, '#ffaa44');
        armGradient.addColorStop(1, '#ff8844');
        ctx.fillStyle = armGradient;
        // Left arm
        ctx.fillRect(-14, 5, 10, 20);
        // Right arm
        ctx.fillRect(4, 5, 10, 20);
        // Arm highlights
        ctx.fillStyle = 'rgba(255, 200, 150, 0.3)';
        ctx.fillRect(-12, 5, 6, 20);
        ctx.fillRect(6, 5, 6, 20);
        // Arm shadows
        ctx.fillStyle = 'rgba(200, 120, 60, 0.3)';
        ctx.fillRect(-10, 5, 4, 20);
        ctx.fillRect(8, 5, 4, 20);
        
        // Sleeve cuffs (more detailed)
        const cuffGradient = ctx.createLinearGradient(-14, 23, -14, 25);
        cuffGradient.addColorStop(0, '#8b7355');
        cuffGradient.addColorStop(1, '#6b5a45');
        ctx.fillStyle = cuffGradient;
        ctx.fillRect(-14, 23, 10, 3);
        ctx.fillRect(4, 23, 10, 3);
        // Cuff detail
        ctx.strokeStyle = '#5a4a35';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-14, 24);
        ctx.lineTo(-4, 24);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(4, 24);
        ctx.lineTo(14, 24);
        ctx.stroke();
        
        // ========== HANDS ==========
        // Enhanced hands with detailed fingers
        const handGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
        handGradient.addColorStop(0, '#ffcc66');
        handGradient.addColorStop(1, '#ffaa44');
        ctx.fillStyle = handGradient;
        
        // Left hand
        ctx.save();
        ctx.translate(-12, 25);
        ctx.beginPath();
        ctx.arc(0, 0, 7, 0, Math.PI * 2);
        ctx.fill();
        // Left hand shadow
        ctx.fillStyle = 'rgba(200, 120, 60, 0.4)';
        ctx.beginPath();
        ctx.arc(1, 1, 7, 0, Math.PI * 2);
        ctx.fill();
        // Left hand fingers (more detailed)
        ctx.fillStyle = handGradient;
        for (let i = 0; i < 4; i++) {
            const fingerX = -4 + i * 2.5;
            const fingerY = -2;
            ctx.beginPath();
            ctx.arc(fingerX, fingerY, 2.5, 0, Math.PI * 2);
            ctx.fill();
            // Finger shadow
            ctx.fillStyle = 'rgba(200, 120, 60, 0.3)';
            ctx.beginPath();
            ctx.arc(fingerX + 0.5, fingerY + 0.5, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = handGradient;
        }
        ctx.restore();
        
        // Right hand
        ctx.save();
        ctx.translate(12, 25);
        ctx.beginPath();
        ctx.arc(0, 0, 7, 0, Math.PI * 2);
        ctx.fill();
        // Right hand shadow
        ctx.fillStyle = 'rgba(200, 120, 60, 0.4)';
        ctx.beginPath();
        ctx.arc(1, 1, 7, 0, Math.PI * 2);
        ctx.fill();
        // Right hand fingers (more detailed)
        ctx.fillStyle = handGradient;
        for (let i = 0; i < 4; i++) {
            const fingerX = -4 + i * 2.5;
            const fingerY = -2;
            ctx.beginPath();
            ctx.arc(fingerX, fingerY, 2.5, 0, Math.PI * 2);
            ctx.fill();
            // Finger shadow
            ctx.fillStyle = 'rgba(200, 120, 60, 0.3)';
            ctx.beginPath();
            ctx.arc(fingerX + 0.5, fingerY + 0.5, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = handGradient;
        }
        ctx.restore();
        
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.restore();
    }
    
    // Helper function to draw Einstein's ship (spacecraft he uses to navigate Bell's mind)
    drawEinsteinShip(ctx, x, y, scale = 1, alpha = 1, time = 0) {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        
        const shipWidth = 120;
        const shipHeight = 80;
        
        // Ship shadow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 20;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        
        // Main ship body (futuristic but with Einstein's style - slightly retro)
        const shipGradient = ctx.createLinearGradient(-shipWidth/2, -shipHeight/2, -shipWidth/2, shipHeight/2);
        shipGradient.addColorStop(0, '#4a6b8a');
        shipGradient.addColorStop(0.3, '#3a5a7a');
        shipGradient.addColorStop(0.7, '#2a4a6a');
        shipGradient.addColorStop(1, '#1a3a5a');
        ctx.fillStyle = shipGradient;
        
        // Ship body shape (rounded, aerodynamic)
        ctx.beginPath();
        ctx.ellipse(0, 0, shipWidth/2, shipHeight/2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Ship cockpit (transparent, showing Einstein inside)
        ctx.fillStyle = 'rgba(79, 195, 247, 0.3)';
        ctx.strokeStyle = 'rgba(79, 195, 247, 0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(0, -10, shipWidth/3, shipHeight/3, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Ship details - control panels and lights
        for (let i = 0; i < 6; i++) {
            const lightX = -shipWidth/3 + (i * shipWidth/7.5);
            const lightY = shipHeight/4;
            const glow = 0.4 + Math.sin(time * 2 + i) * 0.3;
            this.drawGlow(ctx, lightX, lightY, 4, `rgba(79, 195, 247, ${glow})`);
        }
        
        // Ship engines/thrusters (glowing)
        const thrusterY = shipHeight/2 + 5;
        for (let i = 0; i < 2; i++) {
            const thrusterX = -shipWidth/4 + i * (shipWidth/2);
            const thrusterGlow = 0.6 + Math.sin(time * 3 + i * Math.PI) * 0.4;
            ctx.fillStyle = `rgba(255, 170, 68, ${thrusterGlow})`;
            ctx.beginPath();
            ctx.arc(thrusterX, thrusterY, 8, 0, Math.PI * 2);
            ctx.fill();
            // Thruster flame
            ctx.fillStyle = `rgba(255, 100, 0, ${thrusterGlow * 0.7})`;
            ctx.beginPath();
            ctx.arc(thrusterX, thrusterY + 12, 12, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Ship wings/fins
        ctx.fillStyle = '#2a4a6a';
        // Left wing
        ctx.beginPath();
        ctx.moveTo(-shipWidth/2, 0);
        ctx.lineTo(-shipWidth/2 - 15, shipHeight/3);
        ctx.lineTo(-shipWidth/3, shipHeight/4);
        ctx.closePath();
        ctx.fill();
        // Right wing
        ctx.beginPath();
        ctx.moveTo(shipWidth/2, 0);
        ctx.lineTo(shipWidth/2 + 15, shipHeight/3);
        ctx.lineTo(shipWidth/3, shipHeight/4);
        ctx.closePath();
        ctx.fill();
        
        // Einstein inside the cockpit (smaller scale) with animation
        ctx.save();
        ctx.translate(0, -10);
        ctx.scale(0.4, 0.4);
        this.drawEinsteinCharacter(ctx, 0, 0, 1, 0.9, time);
        ctx.restore();
        
        // Ship glow effect
        this.drawGlow(ctx, 0, 0, shipWidth/2, 'rgba(79, 195, 247, 0.2)');
        
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.restore();
    }
    
    // Helper function to draw mad scientist time machine
    drawTimeMachine(ctx, x, y, width, height, time, phase) {
        ctx.save();
        ctx.translate(x, y);
        
        // Main machine body (steampunk style)
        const machineGradient = ctx.createLinearGradient(-width/2, -height/2, -width/2, height/2);
        machineGradient.addColorStop(0, '#8b7355');
        machineGradient.addColorStop(0.3, '#6b5a45');
        machineGradient.addColorStop(0.7, '#4a3a2a');
        machineGradient.addColorStop(1, '#2a1a1a');
        ctx.fillStyle = machineGradient;
        ctx.fillRect(-width/2, -height/2, width, height);
        
        // Metal panels with rivets
        ctx.fillStyle = '#5a4a3a';
        ctx.fillRect(-width/2 + 10, -height/2 + 10, width - 20, 40);
        // Rivets
        ctx.fillStyle = '#3a2a1a';
        for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.arc(-width/2 + 20 + i * 30, -height/2 + 30, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Gears on sides (rotating)
        ctx.fillStyle = '#8b7355';
        for (let side = -1; side <= 1; side += 2) {
            ctx.save();
            ctx.translate(side * (width/2 - 20), 0);
            ctx.rotate(time * 0.5);
            // Large gear
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#3a2a1a';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Gear teeth
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * 25, Math.sin(angle) * 25);
                ctx.lineTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        // Enhanced central control panel with animated glowing buttons
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(-40, -30, 80, 60);
        // Panel glow
        this.drawGlow(ctx, 0, 0, 50, 'rgba(79, 195, 247, 0.1)');
        // Enhanced glowing buttons with pulsing
        for (let i = 0; i < 8; i++) {
            const btnX = -30 + (i % 4) * 20;
            const btnY = -20 + Math.floor(i / 4) * 20;
            const glow = 0.5 + Math.sin(time * 2 + i) * 0.5;
            const pulse = phase >= 1 ? (0.7 + Math.sin(time * 3 + i) * 0.3) : glow;
            ctx.fillStyle = `rgba(79, 195, 247, ${pulse})`;
            ctx.beginPath();
            ctx.arc(btnX, btnY, 4, 0, Math.PI * 2);
            ctx.fill();
            // Enhanced glow effect with multiple layers
            this.drawGlow(ctx, btnX, btnY, 10, `rgba(79, 195, 247, ${pulse * 0.6})`);
            this.drawGlow(ctx, btnX, btnY, 6, `rgba(79, 195, 247, ${pulse * 0.8})`);
        }
        
        // Dials and gauges
        ctx.strokeStyle = '#4fc3f7';
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            const dialX = -50 + i * 50;
            const dialY = 40;
            ctx.beginPath();
            ctx.arc(dialX, dialY, 15, 0, Math.PI * 2);
            ctx.stroke();
            // Needle
            const needleAngle = time * 0.3 + i;
            ctx.beginPath();
            ctx.moveTo(dialX, dialY);
            ctx.lineTo(dialX + Math.cos(needleAngle) * 12, dialY + Math.sin(needleAngle) * 12);
            ctx.stroke();
        }
        
        // Enhanced Tesla coils on top (if phase 1 or 2)
        if (phase >= 1) {
            for (let i = -1; i <= 1; i += 2) {
                const coilX = i * 30;
                const coilY = -height/2 - 10;
                // Coil base with glow
                ctx.fillStyle = '#6b5a45';
                ctx.fillRect(coilX - 5, coilY, 10, 20);
                this.drawGlow(ctx, coilX, coilY + 10, 15, 'rgba(79, 195, 247, 0.2)');
                // Enhanced coil with animated radius
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let j = 0; j < 5; j++) {
                    const y = coilY + 5 + j * 3;
                    const radius = 3 + Math.sin(time * 3 + j) * 1.5;
                    ctx.arc(coilX, y, radius, 0, Math.PI * 2);
                }
                ctx.stroke();
                // Enhanced electric arcs with multiple branches
                if (phase === 1 || phase === 2) {
                    const arcIntensity = 0.7 + Math.sin(time * 5) * 0.3;
                    ctx.strokeStyle = `rgba(79, 195, 247, ${arcIntensity})`;
                    ctx.lineWidth = 2;
                    // Main arc
                    ctx.beginPath();
                    ctx.moveTo(coilX, coilY);
                    const arcDist = 30 + Math.sin(time * 4) * 10;
                    const arcAngle = (i * Math.PI / 3) + Math.sin(time * 2) * 0.3;
                    ctx.lineTo(coilX + Math.cos(arcAngle) * arcDist, coilY + Math.sin(arcAngle) * arcDist);
                    ctx.stroke();
                    // Secondary arc branches
                    for (let branch = 0; branch < 2; branch++) {
                        const branchAngle = arcAngle + (branch - 0.5) * 0.4;
                        const branchDist = arcDist * 0.6;
                        ctx.beginPath();
                        ctx.moveTo(coilX, coilY);
                        ctx.lineTo(coilX + Math.cos(branchAngle) * branchDist, coilY + Math.sin(branchAngle) * branchDist);
                        ctx.stroke();
                        // Glow at arc end
                        this.drawGlow(ctx, 
                            coilX + Math.cos(branchAngle) * branchDist, 
                            coilY + Math.sin(branchAngle) * branchDist, 
                            8, 
                            `rgba(79, 195, 247, ${arcIntensity * 0.5})`
                        );
                    }
                }
            }
        }
        
        // Steam vents
        if (phase >= 1) {
            ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
            for (let i = 0; i < 4; i++) {
                const ventX = -width/2 + 20 + i * 40;
                const ventY = height/2 - 5;
                const steamHeight = Math.sin(time * 2 + i) * 15 + 20;
                ctx.beginPath();
                ctx.arc(ventX, ventY, 5, 0, Math.PI * 2);
                ctx.fill();
                // Steam cloud
                ctx.beginPath();
                ctx.arc(ventX, ventY - steamHeight, 8 + Math.sin(time * 3 + i) * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.restore();
    }
    
    drawCutscene() {
        // Debug: Log every call to drawCutscene
        if (this.gameState !== 'cutscene') {
            return;
        }
        
        // Don't draw if cutsceneId is null or undefined (cutscene was ended/cleared)
        if (!this.cutsceneId) {
            console.warn('[Cutscene] drawCutscene called but cutsceneId is null/undefined, gameState:', this.gameState);
            return;
        }
        
        // Debug log on first draw attempt
        if (!this._cutsceneDrawLogged) {
            console.log(`[Cutscene] drawCutscene called for cutsceneId: ${this.cutsceneId}, phase: ${this.cutscenePhase}`);
            this._cutsceneDrawLogged = true;
        }
        
        // Re-initialize elements if missing (in case DOM wasn't ready during constructor)
        if (!this.cutsceneCanvas) {
            this.cutsceneCanvas = document.getElementById('cutsceneCanvas');
            if (this.cutsceneCanvas) {
                console.log('[Cutscene] Re-initialized cutsceneCanvas in drawCutscene');
            }
        }
        if (!this.cutsceneOverlay) {
            this.cutsceneOverlay = document.getElementById('cutsceneOverlay');
            if (this.cutsceneOverlay) {
                console.log('[Cutscene] Re-initialized cutsceneOverlay in drawCutscene');
            }
        }
        if (!this.cutsceneText) {
            this.cutsceneText = document.getElementById('cutsceneText');
            if (this.cutsceneText) {
                console.log('[Cutscene] Re-initialized cutsceneText in drawCutscene');
            }
        }
        
        // Check if elements exist
        if (!this.cutsceneCanvas || !this.cutsceneOverlay) {
            console.error('[Cutscene] Missing required elements!', {
                canvas: !!this.cutsceneCanvas,
                overlay: !!this.cutsceneOverlay,
                text: !!this.cutsceneText
            });
            return;
        }
        
        // Ensure overlay is visible
        if (!this.cutsceneOverlay.classList.contains('active')) {
            this.cutsceneOverlay.classList.add('active');
            console.log('[Cutscene] Overlay activated in drawCutscene');
        }
        
        // Ensure canvas is visible and positioned correctly
        const canvasStyle = window.getComputedStyle(this.cutsceneCanvas);
        if (canvasStyle.display === 'none') {
            this.cutsceneCanvas.style.display = 'block';
            console.log('[Cutscene] Canvas was hidden, made visible');
        }
        // Ensure canvas is positioned correctly
        if (canvasStyle.position !== 'fixed') {
            this.cutsceneCanvas.style.position = 'fixed';
            this.cutsceneCanvas.style.top = '0';
            this.cutsceneCanvas.style.left = '0';
            this.cutsceneCanvas.style.zIndex = '20000';
        }
        
        // Ensure text element is positioned correctly
        if (this.cutsceneText) {
            const textStyle = window.getComputedStyle(this.cutsceneText);
            if (textStyle.position !== 'fixed') {
                this.cutsceneText.style.position = 'fixed';
                this.cutsceneText.style.bottom = '100px';
                this.cutsceneText.style.left = '50%';
                this.cutsceneText.style.transform = 'translateX(-50%)';
                this.cutsceneText.style.zIndex = '20001';
            }
        }
        
        // Ensure context exists
        if (!this.cutsceneCtx) {
            this.cutsceneCtx = this.cutsceneCanvas.getContext('2d');
            if (!this.cutsceneCtx) {
                console.error('[Cutscene] No context available for drawing!');
                return;
            }
        }
        
        let ctx = this.cutsceneCtx;
        let w = this.cutsceneCanvas.width;
        let h = this.cutsceneCanvas.height;
        
        if (w === 0 || h === 0) {
            console.warn('[Cutscene] Canvas has zero dimensions, resizing...');
            this.cutsceneCanvas.width = window.innerWidth;
            this.cutsceneCanvas.height = window.innerHeight;
            w = this.cutsceneCanvas.width;
            h = this.cutsceneCanvas.height;
            // Re-get context after resize
            this.cutsceneCtx = this.cutsceneCanvas.getContext('2d');
            if (!this.cutsceneCtx) {
                console.error('[Cutscene] Failed to get context after resize!');
                return;
            }
            ctx = this.cutsceneCtx;
        }
        
        // Clear canvas with black background
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);
        
        // Route to appropriate cutscene based on ID
        if (this.cutsceneId === 'opening') {
            this.drawOpeningCutscene(ctx, w, h);
        } else if (this.cutsceneId && this.cutsceneId.startsWith('level')) {
            this.drawLevelCutscene(ctx, w, h);
        } else {
            // Fallback
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Cutscene: ${this.cutsceneId || 'unknown'}`, w * 0.5, h * 0.5);
        }
    }
    
    // Draw opening cutscene (original)
    drawOpeningCutscene(ctx, w, h) {
        // Phase 0: Bell studying Einstein's 1949 paper, building time travel device
        if (this.cutscenePhase === 0) {
            // Enhanced lab background with deep atmospheric lighting and depth
            const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
            bgGradient.addColorStop(0, '#030308'); // Darker top
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#0a0a1a');
            bgGradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Multiple atmospheric light sources for depth
            // Main light source (left side - window/equipment)
            const lightGradient1 = ctx.createRadialGradient(w * 0.15, h * 0.25, 0, w * 0.15, h * 0.25, 400);
            lightGradient1.addColorStop(0, 'rgba(79, 195, 247, 0.15)');
            lightGradient1.addColorStop(0.5, 'rgba(79, 195, 247, 0.08)');
            lightGradient1.addColorStop(1, 'rgba(79, 195, 247, 0)');
            ctx.fillStyle = lightGradient1;
            ctx.fillRect(0, 0, w, h);
            
            // Secondary light source (right side - desk lamp)
            const lightGradient2 = ctx.createRadialGradient(w * 0.75, h * 0.2, 0, w * 0.75, h * 0.2, 300);
            lightGradient2.addColorStop(0, 'rgba(255, 228, 161, 0.12)'); // Warm paper light
            lightGradient2.addColorStop(0.6, 'rgba(255, 228, 161, 0.05)');
            lightGradient2.addColorStop(1, 'rgba(255, 228, 161, 0)');
            ctx.fillStyle = lightGradient2;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced ambient particles for atmosphere (more layers)
            for (let layer = 0; layer < 3; layer++) {
                const layerCount = 20 + layer * 10;
                const layerSpeed = 0.3 + layer * 0.2;
                for (let i = 0; i < layerCount; i++) {
                    const x = ((i * 37) % w) + Math.sin(this.cutsceneTime * layerSpeed + i) * 5;
                    const y = ((i * 23) % h) + Math.cos(this.cutsceneTime * layerSpeed + i) * 5;
                    const alpha = (0.02 + layer * 0.01) + Math.sin(this.cutsceneTime * layerSpeed + i) * (0.01 + layer * 0.005);
                    const size = 1 + layer * 0.5;
                    ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                    ctx.fillRect(x, y, size, size);
                }
            }
            
            // Lab equipment shadows on walls
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            for (let i = 0; i < 5; i++) {
                const shadowX = w * 0.1 + i * 150;
                const shadowY = h * 0.3;
                ctx.beginPath();
                ctx.ellipse(shadowX, shadowY, 40, 60, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Window/light source on left wall
            const windowGradient = ctx.createRadialGradient(w * 0.1, h * 0.3, 0, w * 0.1, h * 0.3, 200);
            windowGradient.addColorStop(0, 'rgba(79, 195, 247, 0.2)');
            windowGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.1)');
            windowGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
            ctx.fillStyle = windowGradient;
            ctx.fillRect(0, 0, w * 0.3, h * 0.6);
            
            // Lab wall texture (brick/panel pattern)
            ctx.strokeStyle = 'rgba(50, 50, 70, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 6; j++) {
                    const brickX = (w / 8) * i;
                    const brickY = (h / 6) * j;
                    ctx.strokeRect(brickX, brickY, w / 8, h / 6);
                }
            }
            
            // Lab floor with texture and shadows
            ctx.fillStyle = '#0f0f1f';
            ctx.fillRect(0, h * 0.75, w, h * 0.25);
            // Floor tiles
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.moveTo((w / 10) * i, h * 0.75);
                ctx.lineTo((w / 10) * i, h);
                ctx.stroke();
            }
            
            // Shelves with equipment in background
            ctx.fillStyle = '#2a1a1a';
            ctx.fillRect(0, h * 0.1, w, 40);
            // Equipment on shelves
            for (let i = 0; i < 8; i++) {
                const eqX = (w / 8) * i + 30;
                const eqY = h * 0.12;
                ctx.fillStyle = '#3a2a2a';
                ctx.fillRect(eqX, eqY, 40, 30);
                // Glowing elements
                const glow = 0.3 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                this.drawGlow(ctx, eqX + 20, eqY + 15, 15, `rgba(79, 195, 247, ${glow})`);
            }
            
            // Time travel machine (left side) - ENHANCED MAD SCIENTIST STYLE
            const machineX = w * 0.15;
            const machineY = h * 0.5;
            const machinePulse = Math.sin(this.cutsceneTime * 1.5) * 2; // Subtle pulsing
            this.drawTimeMachine(ctx, machineX, machineY + machinePulse, 200, 400, this.cutsceneTime, 0);
            
            // Enhanced machine glow and energy field
            const machineGlow = 0.4 + Math.sin(this.cutsceneTime * 2) * 0.3;
            this.drawGlow(ctx, machineX, machineY, 150, `rgba(79, 195, 247, ${machineGlow * 0.2})`);
            
            // Energy field around machine (quantum fluctuations)
            for (let ring = 0; ring < 3; ring++) {
                const ringRadius = 120 + ring * 30 + Math.sin(this.cutsceneTime * 1.5 + ring) * 15;
                const ringAlpha = (0.3 - ring * 0.1) * (0.5 + Math.sin(this.cutsceneTime * 2) * 0.5);
                ctx.strokeStyle = `rgba(79, 195, 247, ${ringAlpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(machineX, machineY, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Enhanced desk with Einstein's paper (right side) - brown backdrop with lighting
            const deskX = w * 0.65;
            const deskY = h * 0.2;
            const deskWidth = 200;
            const deskHeight = 300;
            
            // Desk with gradient for depth
            const deskGradient = ctx.createLinearGradient(deskX, deskY, deskX, deskY + deskHeight);
            deskGradient.addColorStop(0, '#3a2a2a');
            deskGradient.addColorStop(0.5, '#2a1a1a');
            deskGradient.addColorStop(1, '#1a0a0a');
            ctx.fillStyle = deskGradient;
            ctx.fillRect(deskX, deskY, deskWidth, deskHeight);
            
            // Desk highlight (light from lamp)
            const deskHighlight = ctx.createLinearGradient(deskX, deskY, deskX + deskWidth, deskY);
            deskHighlight.addColorStop(0, 'rgba(255, 228, 161, 0.1)');
            deskHighlight.addColorStop(1, 'rgba(255, 228, 161, 0)');
            ctx.fillStyle = deskHighlight;
            ctx.fillRect(deskX, deskY, deskWidth, deskHeight * 0.3);
            
            // Enhanced desk shadow
            this.drawShadow(ctx, deskX, deskY, deskWidth, deskHeight, 25, 0.6);
            
            // Desk wood grain texture
            ctx.strokeStyle = 'rgba(100, 80, 60, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const grainY = deskY + i * 60;
                ctx.beginPath();
                ctx.moveTo(deskX, grainY);
                ctx.lineTo(deskX + deskWidth, grainY);
                ctx.stroke();
            }
            
            // Enhanced paper centered on desk with equal margins and animated glow
            const paperMargin = 20; // Equal margin on all sides
            const paperX = deskX + paperMargin;
            const paperY = deskY + paperMargin;
            const paperWidth = deskWidth - (paperMargin * 2);
            const paperHeight = deskHeight - (paperMargin * 2);
            
            // Paper glow (warm light from desk lamp)
            const paperGlow = 0.3 + Math.sin(this.cutsceneTime * 1.5) * 0.1;
            this.drawGlow(ctx, paperX + paperWidth / 2, paperY + paperHeight / 2, paperWidth, `rgba(255, 228, 161, ${paperGlow * 0.2})`);
            
            // Paper with enhanced glow and shadow
            const paperGradient = ctx.createLinearGradient(paperX, paperY, paperX, paperY + paperHeight);
            paperGradient.addColorStop(0, '#f8e8b8'); // Top highlight
            paperGradient.addColorStop(0.5, '#f4e4a1');
            paperGradient.addColorStop(1, '#e8d890'); // Bottom shadow
            ctx.fillStyle = paperGradient;
            // Enhanced paper shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
            ctx.fillRect(paperX, paperY, paperWidth, paperHeight);
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Paper texture (subtle lines - ruled paper effect)
            ctx.strokeStyle = 'rgba(200, 180, 140, 0.25)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < 12; i++) {
                const lineY = paperY + 20 + i * 18;
                ctx.beginPath();
                ctx.moveTo(paperX + 8, lineY);
                ctx.lineTo(paperX + paperWidth - 8, lineY);
                ctx.stroke();
            }
            
            // Paper margin line (left side)
            ctx.strokeStyle = 'rgba(150, 120, 100, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(paperX + 15, paperY + 10);
            ctx.lineTo(paperX + 15, paperY + paperHeight - 10);
            ctx.stroke();
            
            // Paper crease/fold (subtle vertical line)
            ctx.strokeStyle = 'rgba(200, 180, 140, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(paperX + paperWidth / 2, paperY);
            ctx.lineTo(paperX + paperWidth / 2, paperY + paperHeight);
            ctx.stroke();
            
            // Paper corner fold (top right) - aged look
            ctx.fillStyle = 'rgba(200, 180, 140, 0.2)';
            ctx.beginPath();
            ctx.moveTo(paperX + paperWidth - 10, paperY);
            ctx.lineTo(paperX + paperWidth, paperY);
            ctx.lineTo(paperX + paperWidth, paperY + 10);
            ctx.closePath();
            ctx.fill();
            
            // Additional paper details: ink spots and wear (aged document)
            ctx.fillStyle = 'rgba(100, 80, 60, 0.15)';
            ctx.beginPath();
            ctx.arc(paperX + 30, paperY + 180, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(paperX + paperWidth - 40, paperY + 220, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Paper aging/yellowing overlay (subtle vintage effect)
            ctx.fillStyle = 'rgba(200, 180, 120, 0.08)';
            ctx.fillRect(paperX, paperY, paperWidth, paperHeight);
            
            // Text on paper (Einstein's paper) with EPR reference - CENTERED
            ctx.fillStyle = '#2a1a1a';
            ctx.textAlign = 'center';
            const textCenterX = paperX + paperWidth / 2;
            let textY = paperY + 25;
            
            // Title - larger font
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Reply to Criticisms', textCenterX, textY);
            textY += 22;
            
            // Author and year - larger font
            ctx.font = '13px Arial';
            ctx.fillText('Albert Einstein, 1949', textCenterX, textY);
            textY += 25;
            
            // EPR reference quote - centered with word wrap - larger font
            ctx.font = '11px Arial';
            const quoteWidth = paperWidth - 30; // Margin inside paper
            const quoteText = "Within the framework of statistical quantum theory there is no such thing as a complete description of the individual system.";
            // Word wrap the quote
            const words = quoteText.split(' ');
            let line = '';
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > quoteWidth && i > 0) {
                    ctx.fillText(line.trim(), textCenterX, textY);
                    line = words[i] + ' ';
                    textY += 15;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line.trim(), textCenterX, textY);
            ctx.textAlign = 'left'; // Reset alignment
            
            // Bell character (enhanced with animation)
            const bellX = w * 0.5;
            const bellY = h * 0.68;
            const bellFloat = Math.sin(this.cutsceneTime * 0.8) * 3; // Gentle floating
            this.drawBellCharacter(ctx, bellX, bellY + bellFloat, 1, 1, this.cutsceneTime);
            
            // Enhanced character glow (working energy)
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, bellX, bellY, 60, `rgba(79, 195, 247, ${workGlow * 0.15})`);
            
            // Enhanced particle effects around time machine (quantum fluctuations)
            // Multiple layers of particles for depth
            for (let layer = 0; layer < 3; layer++) {
                const layerSpeed = 0.5 + layer * 0.3;
                const layerDist = 40 + layer * 30;
                const layerCount = 15 + layer * 5;
                for (let i = 0; i < layerCount; i++) {
                    const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed;
                    const dist = layerDist + Math.sin(this.cutsceneTime * 2 + i + layer) * 15;
                    const px = machineX + Math.cos(angle) * dist;
                    const py = machineY - 100 + Math.sin(angle) * dist;
                    const size = (1.5 + layer * 0.5) + Math.sin(this.cutsceneTime * 3 + i) * (0.8 + layer * 0.2);
                    const alpha = (0.3 + layer * 0.1) + Math.sin(this.cutsceneTime * 2 + i) * (0.3 + layer * 0.1);
                    this.drawGlow(ctx, px, py, size * 4, `rgba(79, 195, 247, ${alpha})`);
                    
                    // Particle trail
                    ctx.strokeStyle = `rgba(79, 195, 247, ${alpha * 0.3})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(px - Math.cos(angle) * 8, py - Math.sin(angle) * 8);
                    ctx.stroke();
                }
            }
            
            // Update text with fade-in animation (research-based: 1 second fade, 2 seconds image viewing before text)
            if (this.cutsceneText) {
                const textFadeIn = Math.min(1, Math.max(0, (this.cutsceneTime - 2) / 1)); // Fade in after 2s, over 1s
                const textFadeOut = Math.min(1, Math.max(0, (this.cutsceneTime - 7) / 1)); // Fade out at 7s, over 1s
                const textAlpha = textFadeIn * (1 - textFadeOut);
                
                this.cutsceneText.textContent = "1964 - Bell Labs: John Bell struggles with Einstein's 1949 paper. Using Quantum Mechanics, he builds a time travel device...";
                this.cutsceneText.style.opacity = textAlpha;
                this.cutsceneText.style.color = '#ffffff';
                this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                this.cutsceneText.style.fontSize = '24px';
                this.cutsceneText.style.fontWeight = '500';
                this.cutsceneText.classList.add('visible');
            }
        }
        
        // Phase 1: Time travel to 1949 - Bell activates device, travels back
        else if (this.cutscenePhase === 1) {
            // Enhanced time travel effect with dynamic vortex and energy
            const centerX = w * 0.5;
            const centerY = h * 0.5;
            const maxRadius = Math.max(w, h) * 1.2;
            
            // Deep space background with stars
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
            bgGradient.addColorStop(0, '#1a0a3a');
            bgGradient.addColorStop(0.3, '#0f0515');
            bgGradient.addColorStop(0.6, '#0a0a1a');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Animated stars in background
            for (let i = 0; i < 50; i++) {
                const starX = (i * 137) % w;
                const starY = (i * 211) % h;
                const starTwinkle = 0.3 + Math.sin(this.cutsceneTime * 2 + i) * 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${starTwinkle * 0.6})`;
                ctx.fillRect(starX, starY, 1, 1);
            }
            
            // Time travel device (center) - FULLY ACTIVATED with enhanced effects
            const machineX = w * 0.5;
            const machineY = h * 0.5;
            const machinePulse = Math.sin(this.cutsceneTime * 2) * 3;
            this.drawTimeMachine(ctx, machineX, machineY + machinePulse, 250, 450, this.cutsceneTime, 1);
            
            // Enhanced temporal vortex/portal effect with multiple layers
            for (let ring = 0; ring < 6; ring++) {
                const ringRadius = 150 + ring * 35 + Math.sin(this.cutsceneTime * 2 + ring) * 25;
                const ringAlpha = (0.7 - ring * 0.1) * (0.6 + Math.sin(this.cutsceneTime * 3) * 0.4);
                const ringHue = 200 + ring * 8;
                ctx.strokeStyle = `hsla(${ringHue}, 100%, 60%, ${ringAlpha})`;
                ctx.lineWidth = 3 + ring * 0.5;
                ctx.beginPath();
                ctx.arc(machineX, machineY, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
                // Glow around rings
                this.drawGlow(ctx, machineX, machineY, ringRadius, `hsla(${ringHue}, 100%, 70%, ${ringAlpha * 0.3})`);
            }
            
            // Enhanced temporal energy waves with trails
            for (let i = 0; i < 60; i++) {
                const angle = (this.cutsceneTime * 4 + i) * 0.2;
                const dist = 120 + Math.sin(this.cutsceneTime * 5 + i) * 50;
                const waveAlpha = 0.5 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                const waveHue = 180 + i * 2;
                ctx.strokeStyle = `hsla(${waveHue}, 100%, 70%, ${waveAlpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(machineX, machineY);
                const endX = machineX + Math.cos(angle) * dist;
                const endY = machineY + Math.sin(angle) * dist;
                ctx.lineTo(endX, endY);
                ctx.stroke();
                // Enhanced glow at end of wave
                this.drawGlow(ctx, endX, endY, 10, `hsla(${waveHue}, 100%, 70%, ${waveAlpha * 0.6})`);
                // Wave trail
                ctx.strokeStyle = `hsla(${waveHue}, 100%, 70%, ${waveAlpha * 0.3})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - Math.cos(angle) * 15, endY - Math.sin(angle) * 15);
                ctx.stroke();
            }
            
            // Central energy core (portal opening)
            const corePulse = 0.6 + Math.sin(this.cutsceneTime * 4) * 0.4;
            this.drawGlow(ctx, machineX, machineY, 100, `hsla(200, 100%, 70%, ${corePulse * 0.5})`);
            this.drawGlow(ctx, machineX, machineY, 60, `hsla(200, 100%, 80%, ${corePulse * 0.7})`);
            this.drawGlow(ctx, machineX, machineY, 30, `hsla(200, 100%, 90%, ${corePulse * 0.9})`);
            
            // Bell character (fading out as he travels) - ENHANCED with travel effects
            const bellX = machineX;
            const bellY = machineY - 80;
            const fade = 1 - Math.min(1, this.cutsceneTime / 2.5);
            const travelDist = this.cutsceneTime * 30;
            const bellFloat = Math.sin(this.cutsceneTime * 1.2) * 2;
            this.drawBellCharacter(ctx, bellX, bellY - travelDist + bellFloat, 1, fade, this.cutsceneTime);
            
            // Travel trail effect (following Bell)
            if (fade > 0.2) {
                for (let trail = 0; trail < 5; trail++) {
                    const trailDist = travelDist - trail * 8;
                    const trailAlpha = (fade - 0.2) * (0.3 - trail * 0.05);
                    if (trailAlpha > 0) {
                        this.drawGlow(ctx, bellX, bellY - trailDist, 30 - trail * 5, `rgba(79, 195, 247, ${trailAlpha})`);
                    }
                }
            }
            
            // Enhanced time distortion particles with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerSpeed = 2 + layer * 1;
                const layerDist = 180 + layer * 40;
                const layerCount = 30 + layer * 20;
                for (let i = 0; i < layerCount; i++) {
                    const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed;
                    const dist = layerDist + Math.sin(this.cutsceneTime * 3 + i + layer) * 80;
                    const x = machineX + Math.cos(angle) * dist;
                    const y = machineY + Math.sin(angle) * dist;
                    const size = (1 + layer * 0.3) + Math.sin(this.cutsceneTime * 4 + i) * (0.5 + layer * 0.2);
                    const alpha = (0.3 + layer * 0.1) + Math.sin(this.cutsceneTime * 2 + i) * (0.2 + layer * 0.1);
                    this.drawGlow(ctx, x, y, size * 3, `rgba(79, 195, 247, ${alpha})`);
                    // Particle connection lines (temporal field)
                    if (i % 5 === 0 && layer === 1) {
                        const nextI = (i + 5) % layerCount;
                        const nextAngle = (nextI / layerCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed;
                        const nextDist = layerDist + Math.sin(this.cutsceneTime * 3 + nextI + layer) * 80;
                        const nextX = machineX + Math.cos(nextAngle) * nextDist;
                        const nextY = machineY + Math.sin(nextAngle) * nextDist;
                        ctx.strokeStyle = `rgba(79, 195, 247, ${alpha * 0.2})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(nextX, nextY);
                        ctx.stroke();
                    }
                }
            }
            
            // Year indicator with glow
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            const yearFade = Math.min(1, this.cutsceneTime / 1.5);
            ctx.globalAlpha = yearFade;
            this.drawGlow(ctx, machineX, h * 0.2, 100, 'rgba(255, 255, 255, 0.5)');
            ctx.fillText('1949', machineX, h * 0.2);
            ctx.globalAlpha = 1;
            
            // Update text with fade-in animation
            if (this.cutsceneText) {
                const textFadeIn = Math.min(1, Math.max(0, (this.cutsceneTime - 2) / 1)); // Fade in after 2s
                const textFadeOut = Math.min(1, Math.max(0, (this.cutsceneTime - 5) / 1)); // Fade out at 5s
                const textAlpha = textFadeIn * (1 - textFadeOut);
                
                this.cutsceneText.textContent = "The device activates! Bell travels back to 1949 to meet Einstein...";
                this.cutsceneText.style.opacity = textAlpha;
                this.cutsceneText.style.color = '#4fc3f7';
                this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                this.cutsceneText.style.fontSize = '24px';
                this.cutsceneText.style.fontWeight = '500';
            }
        }
        
        // Phase 2: Return to 1964 with Einstein - physics incomplete, Einstein starts shrinking
        else if (this.cutscenePhase === 2) {
            // Enhanced return scene with dramatic error effects and warning atmosphere
            const centerX = w * 0.5;
            const centerY = h * 0.5;
            const maxRadius = Math.max(w, h) * 1.2;
            
            // Darker, more ominous background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
            bgGradient.addColorStop(0, '#2a1a1a'); // Warmer, more ominous
            bgGradient.addColorStop(0.3, '#1a0a0a');
            bgGradient.addColorStop(0.6, '#0a0505');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Warning glow that pulses
            const warningPulse = 0.3 + Math.sin(this.cutsceneTime * 3) * 0.2;
            const warningGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 400);
            warningGradient.addColorStop(0, `rgba(255, 68, 68, ${warningPulse * 0.15})`);
            warningGradient.addColorStop(0.5, `rgba(255, 100, 50, ${warningPulse * 0.08})`);
            warningGradient.addColorStop(1, 'rgba(255, 68, 68, 0)');
            ctx.fillStyle = warningGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Time travel device (center) - MALFUNCTIONING with enhanced error effects
            const machineX = w * 0.5;
            const machineY = h * 0.5;
            const machineShake = Math.sin(this.cutsceneTime * 8) * 2; // Malfunction shake
            this.drawTimeMachine(ctx, machineX + machineShake, machineY, 250, 450, this.cutsceneTime, 2);
            
            // Enhanced error glow around malfunctioning machine
            const errorGlow = 0.4 + Math.sin(this.cutsceneTime * 4) * 0.3;
            this.drawGlow(ctx, machineX, machineY, 200, `rgba(255, 68, 68, ${errorGlow * 0.2})`);
            
            // Enhanced error sparks and glitches with multiple layers
            for (let layer = 0; layer < 2; layer++) {
                const layerCount = 20 + layer * 15;
                for (let i = 0; i < layerCount; i++) {
                    const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * (3 + layer);
                    const dist = 120 + layer * 50 + Math.sin(this.cutsceneTime * 4 + i) * 40;
                    const x = machineX + Math.cos(angle) * dist;
                    const y = machineY + Math.sin(angle) * dist;
                    const sparkAlpha = 0.5 + Math.sin(this.cutsceneTime * 5 + i) * 0.5;
                    ctx.strokeStyle = `rgba(255, 68, 68, ${sparkAlpha})`;
                    ctx.lineWidth = 2 + layer;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    const sparkLength = 15 + layer * 10;
                    ctx.lineTo(x + (Math.random() - 0.5) * sparkLength, y + (Math.random() - 0.5) * sparkLength);
                    ctx.stroke();
                    // Spark glow
                    this.drawGlow(ctx, x, y, 4, `rgba(255, 68, 68, ${sparkAlpha * 0.6})`);
                }
            }
            
            // Bell returning (fading in) - ENHANCED with animation
            const bellX = machineX - 100;
            const bellY = machineY - 50;
            const bellFade = Math.min(1, this.cutsceneTime / 1.2);
            const bellTravel = (1 - bellFade) * 50;
            const bellFloat = Math.sin(this.cutsceneTime * 0.8) * 3;
            this.drawBellCharacter(ctx, bellX + bellTravel, bellY + bellFloat, 1, bellFade, this.cutsceneTime);
            
            // Return glow effect
            if (bellFade > 0.3) {
                const returnGlow = (bellFade - 0.3) * 0.5;
                this.drawGlow(ctx, bellX + bellTravel, bellY, 50, `rgba(79, 195, 247, ${returnGlow * 0.2})`);
            }
            
            // Einstein (appearing, then starting to shrink) - ENHANCED with effects
            // Einstein should shrink down, then grow back to largest size before Phase 3
            const einsteinX = machineX + 100;
            const einsteinY = machineY - 50;
            const einsteinFade = Math.min(1, (this.cutsceneTime - 0.8) / 1.2);
            
            // Shrink then grow: starts at 1.0, shrinks to small point, then grows back to 1.2 (largest)
            // Phase 2 duration is 16 seconds, so we have time for this animation
            let shrinkFactor;
            if (this.cutsceneTime < 2.5) {
                // Before shrinking: normal size
                shrinkFactor = 1.0;
            } else if (this.cutsceneTime < 6.0) {
                // Shrinking phase: from 1.0 down to 0.1 (small point)
                const shrinkProgress = (this.cutsceneTime - 2.5) / 3.5;
                shrinkFactor = 1.0 - (shrinkProgress * 0.9); // 1.0 -> 0.1
            } else {
                // Growing phase: from 0.1 back up to 1.2 (largest)
                const growProgress = (this.cutsceneTime - 6.0) / 10.0; // Remaining time in phase
                shrinkFactor = 0.1 + (growProgress * 1.1); // 0.1 -> 1.2
                shrinkFactor = Math.min(1.2, shrinkFactor); // Cap at 1.2
            }
            
            // Ensure scale is always positive to prevent body parts from flipping to head
            shrinkFactor = Math.max(0.1, Math.abs(shrinkFactor));
            const einsteinTravel = (1 - einsteinFade) * 50;
            const einsteinFloat = Math.sin(this.cutsceneTime * 0.7) * 2;
            this.drawEinsteinCharacter(ctx, einsteinX - einsteinTravel, einsteinY + einsteinFloat, shrinkFactor, einsteinFade, this.cutsceneTime);
            
            // Warning glow around Einstein when shrinking (physics incomplete)
            if (this.cutsceneTime > 2.5 && shrinkFactor < 0.5) {
                const warningGlow = (0.5 - shrinkFactor) * 2; // Stronger as he shrinks
                this.drawGlow(ctx, einsteinX - einsteinTravel, einsteinY, 40 * shrinkFactor, `rgba(255, 170, 68, ${warningGlow * 0.4})`);
            }
            
            // Warning particles around Einstein (physics incomplete) - ENHANCED
            if (this.cutsceneTime > 2.5) {
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2 + this.cutsceneTime * 3;
                    const dist = 40 + (this.cutsceneTime - 2.5) * 30;
                    const x = einsteinX + Math.cos(angle) * dist;
                    const y = einsteinY + Math.sin(angle) * dist;
                    const size = 2 + Math.sin(this.cutsceneTime * 4 + i) * 1;
                    const alpha = 0.6 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                    this.drawGlow(ctx, x, y, size * 3, `rgba(255, 170, 68, ${alpha})`);
                }
            }
            
            // Year indicator with error glow
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            this.drawGlow(ctx, machineX, h * 0.2, 100, 'rgba(255, 255, 255, 0.3)');
            ctx.fillText('1964', machineX, h * 0.2);
            
            // Error message particles
            if (this.cutsceneTime > 2.5) {
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const alpha = 0.2 + Math.sin(this.cutsceneTime * 2 + i) * 0.1;
                    ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                    ctx.fillRect(x, y, 2, 2);
                }
            }
            
            // Update text with fade animations for two messages
            if (this.cutsceneText) {
                if (this.cutsceneTime < 8) {
                    // First message: "Returning to 1964..."
                    const textFadeIn = Math.min(1, Math.max(0, (this.cutsceneTime - 2) / 1));
                    const textFadeOut = Math.min(1, Math.max(0, (this.cutsceneTime - 7) / 1));
                    const textAlpha = textFadeIn * (1 - textFadeOut);
                    
                    this.cutsceneText.textContent = "Returning to 1964... Bell brings Einstein back to Bell Labs...";
                    this.cutsceneText.style.opacity = textAlpha;
                    this.cutsceneText.style.color = '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                } else {
                    // Second message: "CRITICAL ERROR!"
                    const textFadeIn = Math.min(1, Math.max(0, (this.cutsceneTime - 8) / 1));
                    const textFadeOut = Math.min(1, Math.max(0, (this.cutsceneTime - 15) / 1));
                    const textAlpha = textFadeIn * (1 - textFadeOut);
                    
                    this.cutsceneText.textContent = "CRITICAL ERROR! The physics is incomplete! Einstein begins to shrink...";
                    this.cutsceneText.style.opacity = textAlpha;
                    this.cutsceneText.style.color = '#ff4444';
                    this.cutsceneText.style.textShadow = '0 0 15px rgba(255, 68, 68, 0.9), 0 0 30px rgba(255, 68, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                }
                this.cutsceneText.style.fontSize = '24px';
                this.cutsceneText.style.fontWeight = '500';
            }
        }
        
        // Phase 3: Einstein shrinks to atomic scale, enters Bell's brain
        else if (this.cutscenePhase === 3) {
            // Enhanced shrinking effect - dramatic zoom into Bell's head with enhanced depth
            const zoom = 1 + this.cutsceneTime * 0.5;
            const bellHeadX = w * 0.5;
            const bellHeadY = h * 0.45;
            
            // Background with enhanced depth effect and color transitions
            const bgGradient = ctx.createRadialGradient(bellHeadX, bellHeadY, 0, bellHeadX, bellHeadY, Math.max(w, h) * zoom);
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.2, '#0f0505');
            bgGradient.addColorStop(0.4, '#0a0a0a');
            bgGradient.addColorStop(0.7, '#050505');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Subtle warm glow around head area (biological warmth)
            const headGlow = ctx.createRadialGradient(bellHeadX, bellHeadY, 0, bellHeadX, bellHeadY, 200);
            headGlow.addColorStop(0, 'rgba(255, 170, 100, 0.1)');
            headGlow.addColorStop(0.5, 'rgba(255, 150, 80, 0.05)');
            headGlow.addColorStop(1, 'rgba(255, 130, 60, 0)');
            ctx.fillStyle = headGlow;
            ctx.fillRect(0, 0, w, h);
            
            ctx.save();
            ctx.translate(bellHeadX, bellHeadY);
            ctx.scale(zoom, zoom);
            ctx.translate(-bellHeadX, -bellHeadY);
            
            // Draw Bell's head with enhanced detail (getting larger as we zoom in)
            const headGradient = ctx.createRadialGradient(bellHeadX, bellHeadY, 0, bellHeadX, bellHeadY, 80 / zoom);
            headGradient.addColorStop(0, '#f8e0b8');
            headGradient.addColorStop(1, '#f4d3a1');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(bellHeadX, bellHeadY, 90 / zoom, 0, Math.PI * 2);
            ctx.fill();
            
            // Head shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20 / zoom;
            ctx.shadowOffsetX = 5 / zoom;
            ctx.shadowOffsetY = 5 / zoom;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Draw detailed brain structure (becoming visible)
            if (this.cutsceneTime > 0.8) {
                const brainAlpha = Math.min(1, (this.cutsceneTime - 0.8) / 0.5);
                // Brain outer layer
                const brainGradient = ctx.createRadialGradient(bellHeadX, bellHeadY, 0, bellHeadX, bellHeadY, 70 / zoom);
                brainGradient.addColorStop(0, '#ffaaaa');
                brainGradient.addColorStop(0.5, '#ff8888');
                brainGradient.addColorStop(1, '#cc6666');
                ctx.fillStyle = brainGradient;
                ctx.globalAlpha = brainAlpha;
                ctx.beginPath();
                ctx.arc(bellHeadX, bellHeadY, 70 / zoom, 0, Math.PI * 2);
                ctx.fill();
                
                // Brain inner structure
                ctx.fillStyle = '#ff6666';
                ctx.beginPath();
                ctx.arc(bellHeadX, bellHeadY, 50 / zoom, 0, Math.PI * 2);
                ctx.fill();
                
                // Enhanced neural pathways with glow
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2 / zoom;
                ctx.shadowColor = 'rgba(255, 68, 68, 0.8)';
                ctx.shadowBlur = 5 / zoom;
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2 + this.cutsceneTime * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(bellHeadX, bellHeadY);
                    const pathLength = 45 / zoom;
                    ctx.lineTo(
                        bellHeadX + Math.cos(angle) * pathLength,
                        bellHeadY + Math.sin(angle) * pathLength
                    );
                    ctx.stroke();
                    // Neural nodes
                    const nodeX = bellHeadX + Math.cos(angle) * pathLength;
                    const nodeY = bellHeadY + Math.sin(angle) * pathLength;
                    this.drawGlow(ctx, nodeX, nodeY, 4 / zoom, 'rgba(255, 68, 68, 0.6)');
                }
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            ctx.restore();
            
            // Draw Einstein (shrinking, entering brain) - ENHANCED
            // Draw Einstein OUTSIDE the zoom transform to avoid coordinate system conflicts
            // At largest scale (1.0), Einstein should be right-side up: head at top, body at bottom
            // He should smoothly shrink from normal size to atomic size without flipping
            ctx.save();
            
            // Reset to canvas's natural coordinate system (Y increases downward)
            // Use resetTransform if available, otherwise use setTransform with identity matrix
            if (ctx.resetTransform) {
                ctx.resetTransform();
            } else {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            
            // Einstein starts at scale 1.0 (normal size) and shrinks to 0.1 (atomic size)
            // Smoothly decrease scale over 3.5 seconds - ensure it's always positive
            const einsteinScale = Math.max(0.1, 1 - Math.min(1, this.cutsceneTime / 3.5));
            const einsteinX = bellHeadX;
            // Move Einstein upward as he shrinks (entering the brain)
            const einsteinY = bellHeadY - (this.cutsceneTime * 30);
            const einsteinAlpha = Math.max(0.3, einsteinScale);
            
            // Shrinking distortion effect (warping space around Einstein)
            if (einsteinScale < 0.8) {
                const distortionIntensity = (0.8 - einsteinScale) / 0.7; // 0 to 1 as he shrinks
                for (let ring = 0; ring < 5; ring++) {
                    const ringRadius = 30 + ring * 15;
                    const ringAlpha = distortionIntensity * (0.4 - ring * 0.08);
                    ctx.strokeStyle = `rgba(255, 170, 68, ${ringAlpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(einsteinX, einsteinY, ringRadius * einsteinScale, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Only draw if scale is large enough to be visible
            // Ensure scale is always positive to prevent flipping
            if (einsteinScale > 0.1 && einsteinScale > 0) {
                // Draw Einstein with consistent coordinate system and animation
                // Head is at y=-10 (top), body is at y=2-28 (bottom) in drawEinsteinCharacter
                // With normal canvas coords (Y down = positive), this renders correctly
                // Use absolute value to ensure positive scale
                this.drawEinsteinCharacter(ctx, einsteinX, einsteinY, Math.abs(einsteinScale), einsteinAlpha, this.cutsceneTime);
                
                // Shrinking energy field around Einstein
                const shrinkGlow = (1 - einsteinScale) * 0.6;
                this.drawGlow(ctx, einsteinX, einsteinY, 40 * einsteinScale, `rgba(255, 170, 68, ${shrinkGlow})`);
            }
            
            ctx.restore();
            
            // Enhanced atomic particles (Einstein at atomic scale) with multi-layer effects
            // Multiple particle layers for depth
            for (let layer = 0; layer < 3; layer++) {
                const layerSpeed = 1.5 + layer * 0.5;
                const layerDist = 100 + layer * 30;
                const layerCount = 25 + layer * 15;
                for (let i = 0; i < layerCount; i++) {
                    const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed;
                    const dist = layerDist + Math.sin(i * 0.3 + layer) * 40;
                    const x = bellHeadX + Math.cos(angle) * dist;
                    const y = bellHeadY + Math.sin(angle) * dist;
                    const size = (1.5 + layer * 0.3) + Math.sin(this.cutsceneTime * 4 + i) * (0.5 + layer * 0.2);
                    const alpha = (0.5 + layer * 0.1) + Math.sin(this.cutsceneTime * 3 + i) * (0.3 + layer * 0.1);
                    this.drawGlow(ctx, x, y, size * 5, `rgba(255, 170, 68, ${alpha})`);
                    // Enhanced particle trail
                    ctx.strokeStyle = `rgba(255, 170, 68, ${alpha * 0.4})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - Math.cos(angle) * (12 + layer * 3), y - Math.sin(angle) * (12 + layer * 3));
                    ctx.stroke();
                    // Trail glow
                    this.drawGlow(ctx, x - Math.cos(angle) * 8, y - Math.sin(angle) * 8, size * 2, `rgba(255, 170, 68, ${alpha * 0.2})`);
                }
            }
            
            // Enhanced molecules forming (obstacles in the game) with animated glow
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + this.cutsceneTime * 0.5;
                const dist = 220;
                const x = bellHeadX + Math.cos(angle) * dist;
                const y = bellHeadY + Math.sin(angle) * dist;
                const pulse = 0.6 + Math.sin(this.cutsceneTime * 2 + i) * 0.4;
                const size = 10 + Math.sin(this.cutsceneTime * 2 + i) * 3;
                // Multi-layer glow
                this.drawGlow(ctx, x, y, size * 3, `rgba(255, 68, 68, ${pulse * 0.4})`);
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 100, 100, ${pulse * 0.6})`);
                // Molecule core
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                // Molecule highlight
                ctx.fillStyle = 'rgba(255, 150, 150, 0.6)';
                ctx.beginPath();
                ctx.arc(x - size * 0.3, y - size * 0.3, size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                // Connection lines between molecules (molecular bonds)
                if (i > 0) {
                    const prevAngle = ((i - 1) / 8) * Math.PI * 2 + this.cutsceneTime * 0.5;
                    const prevX = bellHeadX + Math.cos(prevAngle) * dist;
                    const prevY = bellHeadY + Math.sin(prevAngle) * dist;
                    ctx.strokeStyle = `rgba(255, 68, 68, ${pulse * 0.3})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(prevX, prevY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field effects
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 150 + Math.random() * 100;
                const x = bellHeadX + Math.cos(angle) * dist;
                const y = bellHeadY + Math.sin(angle) * dist;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 2 + i) * 0.1;
                ctx.strokeStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x - 5, y);
                ctx.lineTo(x + 5, y);
                ctx.moveTo(x, y - 5);
                ctx.lineTo(x, y + 5);
                ctx.stroke();
            }
            
            // Update text with improved fade animation - longer display time for readability
            if (this.cutsceneText) {
                // First message: "Einstein shrinks to atomic scale..." - appears after 3s, stays for 4s, fades over 1s
                // Second message: "You are now inside..." - appears after 1s gap, stays for 3s, fades over 1s
                let textAlpha = 0;
                let currentText = "";
                
                if (this.cutsceneTime < 3) {
                    // Wait 3 seconds before showing first text (let image be viewed first)
                    textAlpha = 0;
                    currentText = "Einstein shrinks to atomic scale... Entering Bell's brain...";
                } else if (this.cutsceneTime < 7) {
                    // First message: fade in over 1.5s, stay visible for 2.5s
                    const fadeIn = Math.min(1, (this.cutsceneTime - 3) / 1.5);
                    const fadeOut = Math.min(1, Math.max(0, (this.cutsceneTime - 6.5) / 0.5));
                    textAlpha = fadeIn * (1 - fadeOut);
                    currentText = "Einstein shrinks to atomic scale... Entering Bell's brain...";
                } else if (this.cutsceneTime < 8) {
                    // Brief gap between messages
                    textAlpha = 0;
                    currentText = "You are now inside Bell's brain at atomic scale! Break free and escape!";
                } else {
                    // Second message: fade in over 1s, stay visible for 2s, fade out over 1s
                    const fadeIn = Math.min(1, (this.cutsceneTime - 8) / 1);
                    const fadeOut = Math.min(1, Math.max(0, (this.cutsceneTime - 10) / 1));
                    textAlpha = fadeIn * (1 - fadeOut);
                    currentText = "You are now inside Bell's brain at atomic scale! Break free and escape!";
                }
                
                this.cutsceneText.textContent = currentText;
                this.cutsceneText.style.opacity = textAlpha;
                this.cutsceneText.style.color = '#ffaa44';
                this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                this.cutsceneText.style.fontSize = '24px';
                this.cutsceneText.style.fontWeight = '500';
            }
        }
        
        // Phase 4: Transition to game
        else if (this.cutscenePhase === 4) {
            // Fade to black
            const fade = Math.min(1, this.cutsceneTime / 2);
            ctx.fillStyle = `rgba(0, 0, 0, ${fade})`;
            ctx.fillRect(0, 0, w, h);
            
            if (this.cutsceneText) {
                this.cutsceneText.textContent = "Break free from Bell's mind! Your journey to escape begins now...";
                this.cutsceneText.style.opacity = 1 - fade;
            }
        }
    }
    
    // Draw level-based cutscenes
    drawLevelCutscene(ctx, w, h) {
        if (!ctx) {
            console.error('[Cutscene] No context in drawLevelCutscene');
            return;
        }
        
        const level = parseInt(this.cutsceneId.replace('level', ''));
        
        // Get cutscene content based on level
        const cutsceneData = this.getCutsceneData(level);
        if (!cutsceneData) {
            // Fallback - just show text
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Level ${level} - Progressing through Bell's mind...`, w * 0.5, h * 0.5);
            if (this.cutsceneText) {
                this.cutsceneText.textContent = `Level ${level} - Progressing through Bell's mind...`;
                this.cutsceneText.classList.add('visible');
            }
            return;
        }
        
        // Draw background
        const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
        bgGradient.addColorStop(0, cutsceneData.bgColor1 || '#050510');
        bgGradient.addColorStop(0.5, cutsceneData.bgColor2 || '#0a0a1a');
        bgGradient.addColorStop(1, cutsceneData.bgColor3 || '#1a1a2e');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, w, h);
        
        // Atmospheric lighting
        const lightGradient = ctx.createRadialGradient(w * 0.5, h * 0.3, 0, w * 0.5, h * 0.3, 400);
        lightGradient.addColorStop(0, 'rgba(79, 195, 247, 0.15)');
        lightGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
        ctx.fillStyle = lightGradient;
        ctx.fillRect(0, 0, w, h);
        
        // Draw unique visuals for each cutscene based on level
        this.drawUniqueCutscene(ctx, w, h, level, cutsceneData);
        
        // Update text with enhanced styling
        if (this.cutsceneText && cutsceneData.texts && cutsceneData.texts[this.cutscenePhase] !== undefined) {
            // Remove "Level X:" prefix from text
            let text = cutsceneData.texts[this.cutscenePhase];
            text = text.replace(/^Level \d+:\s*/i, ''); // Remove "Level X: " prefix
            this.cutsceneText.textContent = text;
            const textColor = cutsceneData.textColor || '#4fc3f7';
            this.cutsceneText.style.color = textColor;
            
            // Enhanced text shadow with glow effect based on color
            if (textColor === '#ff4444' || textColor === '#f44336') {
                // Red text for critical errors
                this.cutsceneText.style.textShadow = '0 0 15px rgba(255, 68, 68, 0.9), 0 0 30px rgba(255, 68, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
            } else if (textColor === '#ffaa44' || textColor === '#ff8800') {
                // Orange/yellow text
                this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
            } else {
                // Blue/cyan text (default)
                this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
            }
            
            this.cutsceneText.style.fontSize = '24px';
            this.cutsceneText.style.fontWeight = '500';
            this.cutsceneText.style.opacity = '1';
            this.cutsceneText.classList.add('visible');
        } else if (this.cutsceneText) {
            // Fallback text with enhanced styling
            this.cutsceneText.textContent = `Phase ${this.cutscenePhase}`;
            this.cutsceneText.style.color = '#4fc3f7';
            this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
            this.cutsceneText.style.fontSize = '24px';
            this.cutsceneText.style.fontWeight = '500';
            this.cutsceneText.style.opacity = '1';
            this.cutsceneText.classList.add('visible');
        }
    }
    
    // Get cutscene data for a specific level
    getCutsceneData(level) {
        const cutscenes = {
            5: {
                bgColor1: '#050510',
                bgColor2: '#0a0a1a',
                bgColor3: '#1a1a2e',
                textColor: '#4fc3f7',
                texts: [
                    "Level 5: Inside Bell's mind, you begin to understand...",
                    "The Psi-function is not ontological - it's just a tool for predictions on ensembles. Quantum mechanics deals with statistics, not individual systems.",
                    "Einstein's argument becomes clearer: there is no complete description of the individual system in statistical quantum theory.",
                    "Applying this understanding, Einstein begins constructing a weapon that channels probability distributions - the Spread Weapon."
                ]
            },
            10: {
                bgColor1: '#0a0510',
                bgColor2: '#1a0a1a',
                bgColor3: '#2a1a2e',
                textColor: '#ffaa44',
                texts: [
                    "Level 10: The radioactive atom example...",
                    "A single atom has a definite decay time, but the Psi-function cannot show this exact transformation time. It only gives probabilities for ensembles.",
                    "This is the key: individual systems need complete descriptions, but statistical QM only provides ensemble predictions.",
                    "Applying this realization, Einstein begins constructing a weapon that channels definite transformation times - the Laser Weapon."
                ]
            },
            20: {
                bgColor1: '#050510',
                bgColor2: '#0a0a1a',
                bgColor3: '#1a1a2e',
                textColor: '#4fc3f7',
                texts: [
                    "Level 20: The distinction becomes clear...",
                    "Ensemble QM: Statistical predictions for groups of systems. Individual System Model: Complete description of single systems with definite properties.",
                    "You realize: to escape Bell's mind, you must understand individual systems, not just ensembles."
                ]
            },
            25: {
                bgColor1: '#0a0510',
                bgColor2: '#1a0a1a',
                bgColor3: '#2a1a2e',
                textColor: '#ffaa44',
                texts: [
                    "Level 25: The complete description problem...",
                    "Statistical quantum theory cannot provide a complete description of individual systems. The Psi-function describes ensembles, not singular systems.",
                    "Einstein's programmatic aim: complete description of any individual real situation. This is what's missing from QM.",
                    "Applying this understanding, Einstein begins developing technology that provides complete descriptions of individual systems - the foundation for future breakthroughs."
                ]
            },
            35: {
                bgColor1: '#050510',
                bgColor2: '#0a0a1a',
                bgColor3: '#1a1a2e',
                textColor: '#4fc3f7',
                texts: [
                    "Level 35: But what about Bell's theorem?",
                    "Everyone says: 'BUT BELL!' Bell's theorem shows that local hidden variables are impossible... but only for correlated pairs!",
                    "Bell focused on correlated pairs (A and B). His logic requires measurements on both systems to test correlations.",
                    "Understanding Bell's focus, Einstein begins constructing technologies to complete descriptions and stabilize individual systems."
                ]
            },
            40: {
                bgColor1: '#0a0510',
                bgColor2: '#1a0a1a',
                bgColor3: '#2a1a2e',
                textColor: '#ffaa44',
                texts: [
                    "Level 40: The sidestep becomes clear...",
                    "If you only have A or B (individual systems), not correlated pairs, Bell's theorem doesn't apply!",
                    "Einstein's later argument is different from EPR. It's about individual systems, not correlations. This sidesteps Bell entirely.",
                    "Applying the sidestep realization, Einstein begins constructing technologies to protect individual systems and scan transformation times."
                ]
            },
            50: {
                bgColor1: '#050510',
                bgColor2: '#0a0a1a',
                bgColor3: '#1a1a2e',
                textColor: '#4fc3f7',
                texts: [
                    "Level 50: Building the individual system model...",
                    "The future physics Einstein suspects: complete the program by modeling individual systems. This model won't deal with correlations.",
                    "Because it models only individual systems (A or B), not pairs, it sidesteps Bell. The path to escape is becoming clear!",
                    "Applying the complete individual system model, Einstein begins constructing a weapon that channels deterministic descriptions - the Deterministic Engine."
                ]
            },
            55: {
                bgColor1: '#0a0510',
                bgColor2: '#1a0a1a',
                bgColor3: '#2a1a2e',
                textColor: '#ffaa44',
                texts: [
                    "Level 55: Progress in escaping...",
                    "You're making progress! The molecules you destroy represent breaking free from Bell's statistical thinking.",
                    "Each level brings you closer to understanding: individual systems have definite properties, complete descriptions are possible."
                ]
            },
            65: {
                bgColor1: '#050510',
                bgColor2: '#0a0a1a',
                bgColor3: '#1a1a2e',
                textColor: '#4fc3f7',
                texts: [
                    "Level 65: The transformation time problem...",
                    "The radioactive atom has a definite transformation time. The Psi-function cannot show this - it's incomplete for individual systems.",
                    "But a complete individual system model would show the exact transformation time. This is what Einstein argued for.",
                    "Applying this understanding, Einstein begins constructing a circuit that bypasses ensemble limitations - the Ensemble Bypass."
                ]
            },
            70: {
                bgColor1: '#0a0510',
                bgColor2: '#1a0a1a',
                bgColor3: '#2a1a2e',
                textColor: '#ffaa44',
                texts: [
                    "Level 70: Completing the description...",
                    "A complete description of individual systems would provide definite properties: exact decay times, precise positions, definite states.",
                    "This complete description has no room in statistical quantum theory, but it's what's needed to escape Bell's mind!",
                    "Applying the complete description, Einstein begins constructing layered barriers to protect individual systems - the Individual System Barrier."
                ]
            },
            80: {
                bgColor1: '#050510',
                bgColor2: '#0a0a1a',
                bgColor3: '#1a1a2e',
                textColor: '#4fc3f7',
                texts: [
                    "Level 80: Near escape - understanding the solution...",
                    "You're almost there! The solution: model individual systems with complete descriptions. Don't deal with correlations - sidestep Bell!",
                    "If A and B are correlated pairs and that's Bell's logic, how does that apply if you only have A or B? It doesn't!",
                    "Applying the near-escape realization, Einstein begins constructing an amplifier to boost individual system properties - the Individual System Amplifier."
                ]
            },
            85: {
                bgColor1: '#0a0510',
                bgColor2: '#1a0a1a',
                bgColor3: '#2a1a2e',
                textColor: '#ffaa44',
                texts: [
                    "Level 85: The final realization...",
                    "Einstein's argument in 'Reply to Criticisms' 1949: Psi deals with ensembles, not individual systems. Complete descriptions are needed.",
                    "The individual system model sidesteps Bell because it doesn't deal with correlated pairs. You're ready to escape!"
                ]
            },
            90: {
                bgColor1: '#050510',
                bgColor2: '#0a0a1a',
                bgColor3: '#1a1a2e',
                textColor: '#4fc3f7',
                texts: [
                    "Level 90: The escape path is clear...",
                    "Jammer pointed out: Bell misattributed Hidden Variables to Einstein. Bell focused on correlated pairs after becoming obsessed with EPR.",
                    "Einstein's later writings reflect a different argument - about individual systems, not correlations. This has no semblance to EPR."
                ]
            },
            95: {
                bgColor1: '#0a0510',
                bgColor2: '#1a0a1a',
                bgColor3: '#2a1a2e',
                textColor: '#ffaa44',
                texts: [
                    "Level 95: Almost free...",
                    "The type of model Einstein suspects: completing the program by modeling the individual system. Because it won't deal with correlations, it sidesteps Bell.",
                    "If A and B are correlated pairs and that's Bell's logic, how does that apply if you only have A or B? It doesn't! You're breaking free!"
                ]
            },
            100: {
                bgColor1: '#050510',
                bgColor2: '#0a0a1a',
                bgColor3: '#1a1a2e',
                textColor: '#4fc3f7',
                texts: [
                    "Level 100: ESCAPE!",
                    "You've understood: The wave function is epistemological, not ontological. It's a tool for predictions on ensembles.",
                    "Individual systems need complete descriptions. By modeling only A or B (not pairs), you've sidestepped Bell entirely. You're free!"
                ]
            }
        };
        
        return cutscenes[level] || null;
    }
    
    // Draw unique visuals for each cutscene based on level and phase
    drawUniqueCutscene(ctx, w, h, level, data) {
        // Route to level-specific drawing functions
        switch(level) {
            case 5:
                this.drawCutsceneLevel5(ctx, w, h, data);
                break;
            case 10:
                this.drawCutsceneLevel10(ctx, w, h, data);
                break;
            case 20:
                this.drawCutsceneLevel20(ctx, w, h, data);
                break;
            case 25:
                this.drawCutsceneLevel25(ctx, w, h, data);
                break;
            case 35:
                this.drawCutsceneLevel35(ctx, w, h, data);
                break;
            case 40:
                this.drawCutsceneLevel40(ctx, w, h, data);
                break;
            case 50:
                this.drawCutsceneLevel50(ctx, w, h, data);
                break;
            case 55:
                this.drawCutsceneLevel55(ctx, w, h, data);
                break;
            case 65:
                this.drawCutsceneLevel65(ctx, w, h, data);
                break;
            case 70:
                this.drawCutsceneLevel70(ctx, w, h, data);
                break;
            case 80:
                this.drawCutsceneLevel80(ctx, w, h, data);
                break;
            case 85:
                this.drawCutsceneLevel85(ctx, w, h, data);
                break;
            case 90:
                this.drawCutsceneLevel90(ctx, w, h, data);
                break;
            case 95:
                this.drawCutsceneLevel95(ctx, w, h, data);
                break;
            case 100:
                this.drawCutsceneLevel100(ctx, w, h, data);
                break;
            default:
                // Fallback to generic cutscene
                this.drawGenericCutscene(ctx, w, h, data);
        }
    }
    
    // Generic fallback cutscene (old code)
    drawGenericCutscene(ctx, w, h, data) {
        if (this.cutscenePhase === 0) {
            this.drawCutscenePhase0(ctx, w, h, data);
        } else if (this.cutscenePhase === 1) {
            this.drawCutscenePhase1(ctx, w, h, data);
        } else if (this.cutscenePhase === 2) {
            this.drawCutscenePhase2(ctx, w, h, data);
        }
    }
    
    // Draw phase 0 of level cutscenes (generic - kept for fallback)
    drawCutscenePhase0(ctx, w, h, data) {
        // Draw Bell's brain environment
        const brainX = w * 0.5;
        const brainY = h * 0.5;
        
        // Brain structure with neural pathways
        const brainGradient = ctx.createRadialGradient(brainX, brainY, 0, brainX, brainY, 200);
        brainGradient.addColorStop(0, 'rgba(255, 170, 170, 0.3)');
        brainGradient.addColorStop(1, 'rgba(255, 100, 100, 0.1)');
        ctx.fillStyle = brainGradient;
        ctx.beginPath();
        ctx.arc(brainX, brainY, 200, 0, Math.PI * 2);
        ctx.fill();
        
        // Neural pathways
        ctx.strokeStyle = 'rgba(255, 68, 68, 0.4)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 20; i++) {
            const angle = (i / 20) * Math.PI * 2 + this.cutsceneTime * 0.3;
            ctx.beginPath();
            ctx.moveTo(brainX, brainY);
            ctx.lineTo(
                brainX + Math.cos(angle) * 180,
                brainY + Math.sin(angle) * 180
            );
            ctx.stroke();
        }
        
        // Quantum particles (you in the brain)
        for (let i = 0; i < 30; i++) {
            const angle = (i / 30) * Math.PI * 2 + this.cutsceneTime * 1.5;
            const dist = 100 + Math.sin(i * 0.3) * 50;
            const x = brainX + Math.cos(angle) * dist;
            const y = brainY + Math.sin(angle) * dist;
            const size = 2 + Math.sin(this.cutsceneTime * 3 + i) * 1;
            const alpha = 0.6 + Math.sin(this.cutsceneTime * 2 + i) * 0.3;
            this.drawGlow(ctx, x, y, size * 3, `rgba(79, 195, 247, ${alpha})`);
        }
    }
    
    // Draw phase 1 of level cutscenes
    drawCutscenePhase1(ctx, w, h, data) {
        // Draw Einstein in his ship (appearing to guide you through Bell's mind)
        const shipX = w * 0.5;
        const shipY = h * 0.6;
        const shipFade = Math.min(1, this.cutsceneTime / 2);
        const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10; // Gentle floating animation
        
        // Draw Einstein's ship with Einstein inside
        this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.2, shipFade, this.cutsceneTime);
        
        // Draw Bell's brain environment in background
        const brainX = w * 0.5;
        const brainY = h * 0.3;
        const brainGradient = ctx.createRadialGradient(brainX, brainY, 0, brainX, brainY, 250);
        brainGradient.addColorStop(0, 'rgba(255, 170, 170, 0.2)');
        brainGradient.addColorStop(1, 'rgba(255, 100, 100, 0.05)');
        ctx.fillStyle = brainGradient;
        ctx.beginPath();
        ctx.arc(brainX, brainY, 250, 0, Math.PI * 2);
        ctx.fill();
        
        // Neural pathways around the ship
        ctx.strokeStyle = 'rgba(255, 68, 68, 0.3)';
        ctx.lineWidth = 2;
        for (let i = 0; i < 15; i++) {
            const angle = (i / 15) * Math.PI * 2 + this.cutsceneTime * 0.2;
            ctx.beginPath();
            ctx.moveTo(brainX, brainY);
            ctx.lineTo(
                brainX + Math.cos(angle) * 200,
                brainY + Math.sin(angle) * 200
            );
            ctx.stroke();
        }
        
        // Draw paper/document floating near ship (Einstein's notes)
        if (this.cutsceneTime > 1) {
            const paperX = shipX - 150;
            const paperY = shipY - 80;
            const paperFade = Math.min(1, (this.cutsceneTime - 1) / 1);
            const paperFloat = Math.sin(this.cutsceneTime * 2 + 1) * 5;
            
            ctx.globalAlpha = paperFade;
            ctx.fillStyle = '#f4e4a1';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 10;
            ctx.fillRect(paperX - 80, paperY + paperFloat - 50, 160, 100);
            ctx.shadowBlur = 0;
            
            // Text on paper
            ctx.fillStyle = '#2a1a1a';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Reply to Criticisms', paperX, paperY + paperFloat - 30);
            ctx.fillText('1949', paperX, paperY + paperFloat - 10);
            ctx.fillText('Individual Systems', paperX, paperY + paperFloat + 10);
            ctx.fillText('vs Ensembles', paperX, paperY + paperFloat + 30);
            ctx.textAlign = 'left';
            ctx.globalAlpha = 1;
        }
        
        // Quantum field effects around ship
        for (let i = 0; i < 40; i++) {
            const angle = (i / 40) * Math.PI * 2 + this.cutsceneTime;
            const dist = 100 + Math.sin(i * 0.3) * 50;
            const x = shipX + Math.cos(angle) * dist;
            const y = shipY + Math.sin(angle) * dist;
            const alpha = 0.3 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
            ctx.strokeStyle = `rgba(79, 195, 247, ${alpha})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 5, y);
            ctx.lineTo(x + 5, y);
            ctx.moveTo(x, y - 5);
            ctx.lineTo(x, y + 5);
            ctx.stroke();
        }
    }
    
    // Draw phase 2 of level cutscenes
    drawCutscenePhase2(ctx, w, h, data) {
        // Transition effect - particles moving outward (progress)
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        // Expanding rings
        for (let ring = 0; ring < 3; ring++) {
            const ringRadius = 50 + ring * 80 + this.cutsceneTime * 100;
            const ringAlpha = 0.6 - ring * 0.2 - this.cutsceneTime * 0.2;
            if (ringAlpha > 0) {
                ctx.strokeStyle = `rgba(79, 195, 247, ${ringAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Particles moving outward (escape progress)
        for (let i = 0; i < 50; i++) {
            const angle = (i / 50) * Math.PI * 2;
            const dist = 100 + this.cutsceneTime * 150;
            const x = centerX + Math.cos(angle) * dist;
            const y = centerY + Math.sin(angle) * dist;
            const size = 3 + Math.sin(this.cutsceneTime * 4 + i) * 1;
            const alpha = 0.8 - this.cutsceneTime * 0.3;
            if (alpha > 0) {
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
        }
        
        // Fade to next level
        const fade = Math.min(1, this.cutsceneTime / 2);
        ctx.fillStyle = `rgba(0, 0, 0, ${fade * 0.5})`;
        ctx.fillRect(0, 0, w, h);
    }
    
    // ========== UNIQUE CUTSCENE DRAWING FUNCTIONS ==========
    // Each cutscene has unique visuals matching its story
    
    // Level 5: Psi-function & Ensembles - Enhanced Version
    drawCutsceneLevel5(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Einstein in ship observing animated Psi-function equation with wave visualization
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            const shipFade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid (quantum field) with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(79, 195, 247, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            // Draw Einstein's ship with enhanced glow
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, shipFade, this.cutsceneTime);
            
            // Ship observation glow (Einstein studying)
            if (shipFade > 0.5) {
                const studyGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
                this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(79, 195, 247, ${studyGlow * shipFade * 0.2})`);
            }
            
            // Enhanced animated wave function visualization (center-right)
            const waveX = centerX + 150;
            const waveY = centerY;
            const waveWidth = 300;
            const waveHeight = 150;
            const fade = Math.min(1, this.cutsceneTime / 2);
            ctx.globalAlpha = fade;
            
            // Background panel for wave visualization
            const panelGradient = ctx.createLinearGradient(waveX - waveWidth/2 - 20, waveY - waveHeight/2 - 60, waveX - waveWidth/2 - 20, waveY + waveHeight/2 + 80);
            panelGradient.addColorStop(0, 'rgba(79, 195, 247, 0.1)');
            panelGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.05)');
            panelGradient.addColorStop(1, 'rgba(79, 195, 247, 0.02)');
            ctx.fillStyle = panelGradient;
            ctx.fillRect(waveX - waveWidth/2 - 20, waveY - waveHeight/2 - 60, waveWidth + 40, waveHeight + 140);
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(waveX - waveWidth/2 - 20, waveY - waveHeight/2 - 60, waveWidth + 40, waveHeight + 140);
            
            // Enhanced probability wave (sine wave with probability density) - multiple harmonics
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let x = 0; x < waveWidth; x += 2) {
                const t = (x / waveWidth) * Math.PI * 4 + this.cutsceneTime * 2;
                const y = Math.sin(t) * (waveHeight * 0.3) + Math.sin(t * 2) * (waveHeight * 0.1);
                const px = waveX - waveWidth/2 + x;
                const py = waveY + y;
                if (x === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            
            // Wave glow trail
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.4)';
            ctx.lineWidth = 5;
            ctx.beginPath();
            for (let x = 0; x < waveWidth; x += 2) {
                const t = (x / waveWidth) * Math.PI * 4 + this.cutsceneTime * 2;
                const y = Math.sin(t) * (waveHeight * 0.3) + Math.sin(t * 2) * (waveHeight * 0.1);
                const px = waveX - waveWidth/2 + x;
                const py = waveY + y;
                if (x === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            
            // Enhanced probability density (filled area under wave) with gradient
            const densityGradient = ctx.createLinearGradient(waveX - waveWidth/2, waveY - waveHeight/2, waveX - waveWidth/2, waveY + waveHeight/2);
            densityGradient.addColorStop(0, 'rgba(79, 195, 247, 0.3)');
            densityGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.2)');
            densityGradient.addColorStop(1, 'rgba(79, 195, 247, 0.05)');
            ctx.fillStyle = densityGradient;
            ctx.beginPath();
            ctx.moveTo(waveX - waveWidth/2, waveY + waveHeight/2);
            for (let x = 0; x < waveWidth; x += 2) {
                const t = (x / waveWidth) * Math.PI * 4 + this.cutsceneTime * 2;
                const y = Math.sin(t) * (waveHeight * 0.3) + Math.sin(t * 2) * (waveHeight * 0.1);
                const px = waveX - waveWidth/2 + x;
                const py = waveY + y;
                ctx.lineTo(px, py);
            }
            ctx.lineTo(waveX + waveWidth/2, waveY + waveHeight/2);
            ctx.closePath();
            ctx.fill();
            
            // Enhanced Psi-function equation with multi-layer glow effect
            const equationGlow = 0.6 + Math.sin(this.cutsceneTime * 3) * 0.4;
            this.drawGlow(ctx, waveX, waveY - waveHeight/2 - 40, 100, `rgba(79, 195, 247, ${equationGlow * 0.3})`);
            this.drawGlow(ctx, waveX, waveY - waveHeight/2 - 40, 60, `rgba(79, 195, 247, ${equationGlow * 0.5})`);
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 56px "Times New Roman", serif';
            ctx.textAlign = 'center';
            ctx.fillText('Ψ(x,t)', waveX, waveY - waveHeight/2 - 40);
            ctx.shadowBlur = 0;
            
            // Enhanced subscript and description with fade
            const textFade = Math.min(1, (this.cutsceneTime - 1) / 1);
            ctx.globalAlpha = fade * textFade;
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#4fc3f7';
            ctx.fillText('Wave Function', waveX, waveY - waveHeight/2 - 10);
            ctx.font = '18px Arial';
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
            ctx.fillText('Probability Amplitude', waveX, waveY + waveHeight/2 + 30);
            ctx.fillText('for Ensembles', waveX, waveY + waveHeight/2 + 55);
            
            // Enhanced animated particles representing ensemble (orbiting around equation) - multiple layers
            const particleCount = 40;
            for (let layer = 0; layer < 2; layer++) {
                const layerDist = 150 + layer * 50;
                const layerSpeed = 0.8 + layer * 0.3;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed;
                    const dist = layerDist + Math.sin(i * 0.7 + this.cutsceneTime) * (30 + layer * 20);
                    const x = waveX + Math.cos(angle) * dist;
                    const y = waveY + Math.sin(angle) * dist * 0.6;
                    const alpha = (0.4 + layer * 0.1) + Math.sin(this.cutsceneTime * 3 + i * 0.5) * (0.3 + layer * 0.1);
                    const size = (4 + layer * 1) + Math.sin(this.cutsceneTime * 2 + i) * (2 + layer);
                    this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                    // Particle trail
                    ctx.strokeStyle = `rgba(79, 195, 247, ${alpha * 0.3})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - Math.cos(angle) * 8, y - Math.sin(angle) * 8);
                    ctx.stroke();
                }
            }
            
            // Enhanced connecting lines from particles to wave (showing statistical connection)
            if (this.cutsceneTime > 1) {
                const lineFade = Math.min(1, (this.cutsceneTime - 1) / 1);
                ctx.strokeStyle = `rgba(79, 195, 247, ${0.2 * lineFade})`;
                ctx.lineWidth = 1.5;
                for (let i = 0; i < particleCount; i += 2) {
                    const angle = (i / particleCount) * Math.PI * 2 + this.cutsceneTime * 0.8;
                    const dist = 180 + Math.sin(i * 0.7 + this.cutsceneTime) * 40;
                    const px = waveX + Math.cos(angle) * dist;
                    const py = waveY + Math.sin(angle) * dist * 0.6;
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(waveX, waveY);
                    ctx.stroke();
                    // Connection point glow
                    this.drawGlow(ctx, px, py, 3, `rgba(79, 195, 247, ${0.3 * lineFade})`);
                }
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(5);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Split screen comparison - Ensemble (statistical) vs Individual (deterministic)
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.5, '#050510');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            const shipX = w * 0.15;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 0.9, 1, this.cutsceneTime);
            
            // Ship observation glow
            const observationGlow = 0.2 + Math.sin(this.cutsceneTime * 2) * 0.1;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 70, `rgba(79, 195, 247, ${observationGlow})`);
            
            // Enhanced divider line with glow
            const dividerPulse = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            ctx.strokeStyle = `rgba(255, 255, 255, ${dividerPulse})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, h);
            ctx.stroke();
            // Divider glow
            this.drawGlow(ctx, centerX, centerY, 5, `rgba(255, 255, 255, ${dividerPulse * 0.3})`);
            
            // Divider particles
            for (let i = 0; i < 20; i++) {
                const y = (h / 20) * i + Math.sin(this.cutsceneTime * 2 + i) * 5;
                this.drawGlow(ctx, centerX, y, 3, `rgba(255, 255, 255, ${dividerPulse * 0.4})`);
            }
            
            // LEFT SIDE: Ensemble (Statistical QM) - Enhanced
            const ensembleX = w * 0.35;
            const ensembleY = centerY;
            
            // Enhanced background panel with gradient
            const ensemblePanelGradient = ctx.createLinearGradient(w * 0.25, h * 0.1, w * 0.25, h * 0.9);
            ensemblePanelGradient.addColorStop(0, 'rgba(79, 195, 247, 0.2)');
            ensemblePanelGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.15)');
            ensemblePanelGradient.addColorStop(1, 'rgba(79, 195, 247, 0.1)');
            ctx.fillStyle = ensemblePanelGradient;
            ctx.fillRect(w * 0.25, h * 0.1, w * 0.25, h * 0.8);
            
            // Panel border with glow
            const ensembleGlow = 0.5 + Math.sin(this.cutsceneTime * 2) * 0.3;
            ctx.strokeStyle = `rgba(79, 195, 247, ${ensembleGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(w * 0.25, h * 0.1, w * 0.25, h * 0.8);
            // Corner glows
            this.drawGlow(ctx, w * 0.25, h * 0.1, 20, `rgba(79, 195, 247, ${ensembleGlow * 0.4})`);
            this.drawGlow(ctx, w * 0.5, h * 0.1, 20, `rgba(79, 195, 247, ${ensembleGlow * 0.4})`);
            this.drawGlow(ctx, w * 0.25, h * 0.9, 20, `rgba(79, 195, 247, ${ensembleGlow * 0.4})`);
            this.drawGlow(ctx, w * 0.5, h * 0.9, 20, `rgba(79, 195, 247, ${ensembleGlow * 0.4})`);
            
            // Title
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ENSEMBLE', ensembleX, h * 0.2);
            ctx.font = '20px Arial';
            ctx.fillText('Statistical Quantum Mechanics', ensembleX, h * 0.25);
            
            // Enhanced particles in probability cloud (fuzzy distribution) - multiple layers
            const particleCount = 60;
            for (let layer = 0; layer < 2; layer++) {
                const layerRadius = 50 + layer * 30;
                const layerSpeed = 0.5 + layer * 0.3;
                for (let i = 0; i < particleCount; i++) {
                    // Random positions with Gaussian-like distribution
                    const angle = (i / particleCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed;
                    const radius = layerRadius + Math.random() * (30 + layer * 20) + Math.sin(this.cutsceneTime + i) * (15 + layer * 10);
                    const x = ensembleX + Math.cos(angle) * radius;
                    const y = ensembleY + Math.sin(angle) * radius * 0.7;
                    const alpha = (0.5 + layer * 0.1) + Math.random() * (0.2 + layer * 0.1);
                    const size = (3 + layer) + Math.random() * (2 + layer);
                    this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                    // Particle connection lines (showing statistical relationships)
                    if (i % 5 === 0 && layer === 0) {
                        const nextI = (i + 5) % particleCount;
                        const nextAngle = (nextI / particleCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed;
                        const nextRadius = layerRadius + Math.random() * 30 + Math.sin(this.cutsceneTime + nextI) * 15;
                        const nextX = ensembleX + Math.cos(nextAngle) * nextRadius;
                        const nextY = ensembleY + Math.sin(nextAngle) * nextRadius * 0.7;
                        ctx.strokeStyle = `rgba(79, 195, 247, ${alpha * 0.2})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(nextX, nextY);
                        ctx.stroke();
                    }
                }
            }
            
            // Enhanced probability density cloud (fuzzy background) - multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerDist = 40 + layer * 20;
                const layerSize = 30 + layer * 15;
                for (let i = 0; i < 12 + layer * 3; i++) {
                    const angle = (i / (12 + layer * 3)) * Math.PI * 2;
                    const dist = layerDist + Math.sin(this.cutsceneTime * 2 + i + layer) * (20 + layer * 10);
                    const x = ensembleX + Math.cos(angle) * dist;
                    const y = ensembleY + Math.sin(angle) * dist * 0.7;
                    const alpha = (0.1 + layer * 0.02) + Math.sin(this.cutsceneTime + i) * (0.03 + layer * 0.02);
                    this.drawGlow(ctx, x, y, layerSize, `rgba(79, 195, 247, ${alpha})`);
                }
            }
            
            // Show statistical text
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
            ctx.font = '16px Arial';
            ctx.fillText('Many systems', ensembleX, h * 0.65);
            ctx.fillText('Probabilistic', ensembleX, h * 0.7);
            ctx.fillText('Statistical predictions', ensembleX, h * 0.75);
            ctx.fillText('|Ψ|² = probability', ensembleX, h * 0.82);
            
            // RIGHT SIDE: Individual System - Enhanced
            const individualX = w * 0.75;
            const individualY = centerY;
            
            // Enhanced background panel with gradient
            const individualPanelGradient = ctx.createLinearGradient(w * 0.65, h * 0.1, w * 0.65, h * 0.9);
            individualPanelGradient.addColorStop(0, 'rgba(255, 170, 68, 0.2)');
            individualPanelGradient.addColorStop(0.5, 'rgba(255, 170, 68, 0.15)');
            individualPanelGradient.addColorStop(1, 'rgba(255, 170, 68, 0.1)');
            ctx.fillStyle = individualPanelGradient;
            ctx.fillRect(w * 0.65, h * 0.1, w * 0.25, h * 0.8);
            
            // Panel border with glow
            const individualGlow = 0.5 + Math.sin(this.cutsceneTime * 2 + Math.PI) * 0.3;
            ctx.strokeStyle = `rgba(255, 170, 68, ${individualGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(w * 0.65, h * 0.1, w * 0.25, h * 0.8);
            // Corner glows
            this.drawGlow(ctx, w * 0.65, h * 0.1, 20, `rgba(255, 170, 68, ${individualGlow * 0.4})`);
            this.drawGlow(ctx, w * 0.9, h * 0.1, 20, `rgba(255, 170, 68, ${individualGlow * 0.4})`);
            this.drawGlow(ctx, w * 0.65, h * 0.9, 20, `rgba(255, 170, 68, ${individualGlow * 0.4})`);
            this.drawGlow(ctx, w * 0.9, h * 0.9, 20, `rgba(255, 170, 68, ${individualGlow * 0.4})`);
            
            // Title
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 32px Arial';
            ctx.fillText('INDIVIDUAL', individualX, h * 0.2);
            ctx.font = '20px Arial';
            ctx.fillText('Complete Description?', individualX, h * 0.25);
            
            // Draw single, well-defined particle
            const particleX = individualX;
            const particleY = individualY;
            const pulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
            
            // Outer glow
            this.drawGlow(ctx, particleX, particleY, 35 * pulse, 'rgba(255, 170, 68, 0.4)');
            // Middle glow
            this.drawGlow(ctx, particleX, particleY, 25 * pulse, 'rgba(255, 170, 68, 0.6)');
            // Core
            this.drawGlow(ctx, particleX, particleY, 15 * pulse, 'rgba(255, 170, 68, 0.9)');
            
            // Draw definite position indicator (crosshair)
            ctx.strokeStyle = '#ffaa44';
            ctx.lineWidth = 2;
            const crossSize = 20;
            ctx.beginPath();
            ctx.moveTo(particleX - crossSize, particleY);
            ctx.lineTo(particleX + crossSize, particleY);
            ctx.moveTo(particleX, particleY - crossSize);
            ctx.lineTo(particleX, particleY + crossSize);
            ctx.stroke();
            
            // Show individual system text
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.font = '16px Arial';
            ctx.fillText('Single system', individualX, h * 0.65);
            ctx.fillText('Definite properties', individualX, h * 0.7);
            ctx.fillText('Complete description?', individualX, h * 0.75);
            ctx.fillText('Exact values needed', individualX, h * 0.82);
            
            // Draw question mark between them (Einstein's question)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('?', centerX, centerY);
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(5);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Realization - Understanding the distinction - Enhanced
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            const shipX = w * 0.2 + Math.min(this.cutsceneTime * 30, w * 0.3);
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship realization glow
            const realizationGlow = 0.4 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 100, `rgba(79, 195, 247, ${realizationGlow * 0.3})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat, 60, `rgba(255, 170, 68, ${realizationGlow * 0.2})`);
            
            // Draw enhanced realization particles (understanding flowing from ensemble to individual)
            const realizationX = centerX + 100;
            const realizationY = centerY;
            
            // Enhanced ensemble particles (left) flowing toward individual (right) - multiple layers
            for (let layer = 0; layer < 2; layer++) {
                const layerCount = 25 + layer * 15;
                const layerSpeed = 0.3 + layer * 0.2;
                for (let i = 0; i < layerCount; i++) {
                    const progress = ((this.cutsceneTime * layerSpeed) + (i / layerCount) * 0.5) % 1;
                    const startX = w * 0.4;
                    const endX = w * 0.7;
                    const x = startX + (endX - startX) * progress;
                    const y = centerY + Math.sin(i * 0.5 + this.cutsceneTime * 2) * (60 + layer * 20);
                    const alpha = (0.6 + layer * 0.1) - progress * (0.4 + layer * 0.1);
                    const size = (4 + layer) - progress * (2 + layer);
                    
                    // Color transition from cyan (ensemble) to orange (individual)
                    const r = Math.floor(79 + (255 - 79) * progress);
                    const g = Math.floor(195 + (170 - 195) * progress);
                    const b = Math.floor(247 + (68 - 247) * progress);
                    
                    if (alpha > 0 && size > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(${r}, ${g}, ${b}, ${alpha})`);
                        // Particle trail
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.3})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x - (endX - startX) * 0.05, y);
                        ctx.stroke();
                    }
                }
            }
            
            // Connection lines showing transformation
            if (this.cutsceneTime > 0.5) {
                const lineFade = Math.min(1, (this.cutsceneTime - 0.5) / 1);
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 * lineFade})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(w * 0.4, centerY);
                ctx.lineTo(w * 0.7, centerY);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Enhanced key insight text (fading in with glow)
            const textFade = Math.min(1, (this.cutsceneTime - 1) / 2);
            ctx.globalAlpha = textFade;
            
            // Text glow effects
            const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, centerX, h * 0.3, 150, `rgba(255, 255, 255, ${textGlow * textFade * 0.2})`);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 15;
            ctx.fillText('The Psi-function describes', centerX, h * 0.3);
            ctx.fillText('ENSEMBLES, not individual systems', centerX, h * 0.35);
            ctx.shadowBlur = 0;
            
            ctx.font = '24px Arial';
            ctx.fillStyle = '#4fc3f7';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 10;
            ctx.fillText('Statistical QM is incomplete', centerX, h * 0.45);
            ctx.fillText('for individual descriptions', centerX, h * 0.5);
            ctx.shadowBlur = 0;
            
            // Enhanced equation showing the distinction
            if (this.cutsceneTime > 2) {
                const eqFade = Math.min(1, (this.cutsceneTime - 2) / 1);
                ctx.globalAlpha = textFade * eqFade;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 22px "Times New Roman", serif';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 8;
                ctx.fillText('Ψ(x,t) → |Ψ|² = probability (ensemble)', centerX, h * 0.62);
                ctx.fillText('Individual system → needs complete description', centerX, h * 0.68);
                ctx.shadowBlur = 0;
                
                // Equation glow
                this.drawGlow(ctx, centerX, h * 0.65, 200, `rgba(79, 195, 247, ${eqFade * 0.15})`);
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(5);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 3) {
            // Phase 3: Einstein building the Spread Weapon technology - Enhanced
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship working glow
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(156, 39, 176, ${workGlow * 0.2})`);
            
            // Workbench/construction area (center-right) - Enhanced
            const workbenchX = centerX + 100;
            const workbenchY = centerY;
            const workbenchFade = Math.min(1, this.cutsceneTime / 1.5);
            
            // Enhanced background workbench panel with gradient
            ctx.globalAlpha = workbenchFade;
            const workbenchGradient = ctx.createLinearGradient(workbenchX - 200, workbenchY - 150, workbenchX - 200, workbenchY + 150);
            workbenchGradient.addColorStop(0, 'rgba(156, 39, 176, 0.25)');
            workbenchGradient.addColorStop(0.5, 'rgba(156, 39, 176, 0.2)');
            workbenchGradient.addColorStop(1, 'rgba(156, 39, 176, 0.15)');
            ctx.fillStyle = workbenchGradient;
            ctx.fillRect(workbenchX - 200, workbenchY - 150, 400, 300);
            
            // Enhanced panel border with pulsing glow
            const panelGlow = 0.5 + Math.sin(this.cutsceneTime * 3) * 0.3;
            ctx.strokeStyle = `rgba(156, 39, 176, ${panelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchX - 200, workbenchY - 150, 400, 300);
            // Corner glows
            this.drawGlow(ctx, workbenchX - 200, workbenchY - 150, 25, `rgba(156, 39, 176, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY - 150, 25, `rgba(156, 39, 176, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX - 200, workbenchY + 150, 25, `rgba(156, 39, 176, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY + 150, 25, `rgba(156, 39, 176, ${panelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(156, 39, 176, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const x = workbenchX - 200 + (i * 100);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 150);
                ctx.lineTo(x, workbenchY + 150);
                ctx.stroke();
            }
            for (let i = 0; i < 4; i++) {
                const y = workbenchY - 150 + (i * 100);
                ctx.beginPath();
                ctx.moveTo(workbenchX - 200, y);
                ctx.lineTo(workbenchX + 200, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Construction progress (0-1 over time)
            // Phase 3 starts with cutsceneTime = 0, so we need to account for initial delay
            // Total phase duration is 8 seconds, so we spread the build over ~7 seconds
            const buildProgress = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 7));
            
            // Phase 1: Gathering materials (probability particles flowing in)
            if (buildProgress < 0.3) {
                const gatherProgress = buildProgress / 0.3;
                const particleCount = 20;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const startDist = 250;
                    const endDist = 100;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 * (1 - gatherProgress);
                    const size = 5 - gatherProgress * 2;
                    this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                }
                
                // Text
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Gathering probability data...', workbenchX, workbenchY + 120);
            }
            
            // Phase 2: Assembling weapon core
            if (buildProgress >= 0.3 && buildProgress < 0.6) {
                const assembleProgress = (buildProgress - 0.3) / 0.3;
                
                // Weapon core (central barrel) assembling
                const coreLength = 80 * assembleProgress;
                ctx.strokeStyle = `rgba(156, 39, 176, ${0.5 + assembleProgress * 0.5})`;
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(workbenchX - coreLength/2, workbenchY);
                ctx.lineTo(workbenchX + coreLength/2, workbenchY);
                ctx.stroke();
                
                // Glow effect
                this.drawGlow(ctx, workbenchX, workbenchY, coreLength/2, `rgba(156, 39, 176, ${assembleProgress * 0.6})`);
                
                // Assembly particles
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const dist = 60 + Math.sin(this.cutsceneTime * 3 + i) * 20;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.4 * (1 - assembleProgress);
                    this.drawGlow(ctx, x, y, 4, `rgba(156, 39, 176, ${alpha})`);
                }
                
                // Text
                ctx.fillStyle = '#9c27b0';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Assembling weapon core...', workbenchX, workbenchY + 120);
            }
            
            // Phase 3: Adding spread mechanism
            if (buildProgress >= 0.6 && buildProgress < 0.85) {
                const spreadProgress = (buildProgress - 0.6) / 0.25;
                
                // Draw main barrel (complete)
                ctx.strokeStyle = 'rgba(156, 39, 176, 1)';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 40, workbenchY);
                ctx.lineTo(workbenchX + 40, workbenchY);
                ctx.stroke();
                this.drawGlow(ctx, workbenchX, workbenchY, 40, 'rgba(156, 39, 176, 0.6)');
                
                // Spread mechanism (3 barrels) appearing
                const spreadAngle = 0.4; // radians
                for (let i = -1; i <= 1; i++) {
                    const angle = i * spreadAngle * spreadProgress;
                    const length = 50 * spreadProgress;
                    const endX = workbenchX + Math.cos(angle) * length;
                    const endY = workbenchY - Math.sin(angle) * length;
                    
                    ctx.strokeStyle = `rgba(156, 39, 176, ${0.5 + spreadProgress * 0.5})`;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(workbenchX, workbenchY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    
                    // Projectile tip
                    if (spreadProgress > 0.5) {
                        this.drawGlow(ctx, endX, endY, 8, `rgba(156, 39, 176, ${spreadProgress})`);
                    }
                }
                
                // Energy flowing into spread mechanism
                for (let i = 0; i < 10; i++) {
                    const progress = (this.cutsceneTime * 0.5 + i * 0.1) % 1;
                    const x = workbenchX + progress * 40;
                    const y = workbenchY;
                    this.drawGlow(ctx, x, y, 4, `rgba(156, 39, 176, ${0.8 - progress * 0.5})`);
                }
                
                // Text
                ctx.fillStyle = '#9c27b0';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Installing spread mechanism...', workbenchX, workbenchY + 120);
            }
            
            // Phase 4: Finalizing and testing
            if (buildProgress >= 0.85) {
                const finalizeProgress = (buildProgress - 0.85) / 0.15;
                
                // Complete weapon
                ctx.strokeStyle = 'rgba(156, 39, 176, 1)';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 40, workbenchY);
                ctx.lineTo(workbenchX + 40, workbenchY);
                ctx.stroke();
                
                // 3 spread barrels
                const spreadAngle = 0.4;
                for (let i = -1; i <= 1; i++) {
                    const angle = i * spreadAngle;
                    ctx.strokeStyle = 'rgba(156, 39, 176, 1)';
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.moveTo(workbenchX, workbenchY);
                    ctx.lineTo(workbenchX + Math.cos(angle) * 50, workbenchY - Math.sin(angle) * 50);
                    ctx.stroke();
                    
                    // Projectile tips
                    const tipX = workbenchX + Math.cos(angle) * 50;
                    const tipY = workbenchY - Math.sin(angle) * 50;
                    this.drawGlow(ctx, tipX, tipY, 8, 'rgba(156, 39, 176, 1)');
                }
                
                // Complete glow
                this.drawGlow(ctx, workbenchX, workbenchY, 50, 'rgba(156, 39, 176, 0.8)');
                
                // Test firing animation
                if (finalizeProgress > 0.3) {
                    const fireProgress = (finalizeProgress - 0.3) / 0.7;
                    for (let i = -1; i <= 1; i++) {
                        const angle = i * spreadAngle;
                        const projectileX = workbenchX + Math.cos(angle) * (50 + fireProgress * 100);
                        const projectileY = workbenchY - Math.sin(angle) * (50 + fireProgress * 100);
                        const alpha = 1 - fireProgress;
                        this.drawGlow(ctx, projectileX, projectileY, 10, `rgba(156, 39, 176, ${alpha})`);
                    }
                }
                
                // Success particles
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2 + this.cutsceneTime * 2;
                    const dist = 80 + Math.sin(this.cutsceneTime * 3 + i) * 30;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 + Math.sin(this.cutsceneTime * 4 + i) * 0.4;
                    this.drawGlow(ctx, x, y, 5, `rgba(156, 39, 176, ${alpha})`);
                }
                
                // Text
                ctx.fillStyle = '#9c27b0';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SPREAD WEAPON COMPLETE!', workbenchX, workbenchY + 120);
                ctx.font = '18px Arial';
                ctx.fillStyle = 'rgba(156, 39, 176, 0.9)';
                ctx.fillText('Probability distribution weapon ready', workbenchX, workbenchY + 150);
            }
            
            // Connection line from ship to workbench (Einstein working)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(shipX + 30, shipY);
            ctx.lineTo(workbenchX - 200, workbenchY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Set foreground text for phase 3 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(5);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[3]) {
                    let text = cutsceneData.texts[3].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        }
    }
    
    // Level 10: Radioactive Atom Example
    // Level 10: Radioactive Atom Example - Enhanced
    drawCutsceneLevel10(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced radioactive atom with potential barrier and electron cloud
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0f0510');
            bgGradient.addColorStop(0.6, '#0a0505');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid (quantum field) with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(255, 170, 68, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced atom nucleus (radioactive core) with pulsing effect
            const nucleusPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.1;
            const nucleusGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 35 * nucleusPulse);
            nucleusGradient.addColorStop(0, '#ff6666');
            nucleusGradient.addColorStop(0.5, '#ff4444');
            nucleusGradient.addColorStop(1, '#cc0000');
            ctx.fillStyle = nucleusGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 35 * nucleusPulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Enhanced nucleus glow with multiple layers
            this.drawGlow(ctx, centerX, centerY, 35 * nucleusPulse, 'rgba(255, 68, 68, 0.9)');
            this.drawGlow(ctx, centerX, centerY, 50 * nucleusPulse, 'rgba(255, 68, 68, 0.6)');
            this.drawGlow(ctx, centerX, centerY, 70 * nucleusPulse, 'rgba(255, 68, 68, 0.3)');
            
            // Enhanced electron shells (orbiting electrons) with trails
            for (let shell = 0; shell < 3; shell++) {
                const shellRadius = 60 + shell * 25;
                const electronCount = 2 + shell * 2;
                for (let i = 0; i < electronCount; i++) {
                    const angle = (i / electronCount) * Math.PI * 2 + this.cutsceneTime * (1 + shell * 0.5);
                    const x = centerX + Math.cos(angle) * shellRadius;
                    const y = centerY + Math.sin(angle) * shellRadius;
                    const alpha = 0.7 - shell * 0.2;
                    
                    // Electron trail
                    const trailAngle = angle - 0.2;
                    const trailX = centerX + Math.cos(trailAngle) * shellRadius;
                    const trailY = centerY + Math.sin(trailAngle) * shellRadius;
                    this.drawGlow(ctx, trailX, trailY, 3, `rgba(79, 195, 247, ${alpha * 0.3})`);
                    
                    // Main electron
                    this.drawGlow(ctx, x, y, 5, `rgba(79, 195, 247, ${alpha})`);
                    this.drawGlow(ctx, x, y, 8, `rgba(79, 195, 247, ${alpha * 0.5})`);
                }
            }
            
            // Enhanced potential barrier (energy barrier preventing decay) with pulsing effect
            const barrierPulse = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.2;
            ctx.strokeStyle = `rgba(255, 255, 0, ${barrierPulse})`;
            ctx.lineWidth = 4;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, 90, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Barrier glow
            this.drawGlow(ctx, centerX, centerY, 90, `rgba(255, 255, 0, ${barrierPulse * 0.3})`);
            
            // Enhanced alpha particle trying to escape (orbiting inside barrier) with energy trail
            const escapeAngle = this.cutsceneTime * 1.5;
            const escapeDist = 70 + Math.sin(this.cutsceneTime * 4) * 15;
            const particleX = centerX + Math.cos(escapeAngle) * escapeDist;
            const particleY = centerY + Math.sin(escapeAngle) * escapeDist;
            
            // Energy trail
            for (let i = 0; i < 5; i++) {
                const trailAngle = escapeAngle - i * 0.15;
                const trailDist = escapeDist - i * 3;
                const trailX = centerX + Math.cos(trailAngle) * trailDist;
                const trailY = centerY + Math.sin(trailAngle) * trailDist;
                this.drawGlow(ctx, trailX, trailY, 6 - i, `rgba(79, 195, 247, ${0.5 - i * 0.1})`);
            }
            
            // Main alpha particle
            this.drawGlow(ctx, particleX, particleY, 12, 'rgba(79, 195, 247, 0.9)');
            this.drawGlow(ctx, particleX, particleY, 18, 'rgba(79, 195, 247, 0.6)');
            this.drawGlow(ctx, particleX, particleY, 25, 'rgba(79, 195, 247, 0.3)');
            
            // Enhanced time label with question mark (unknown decay time) with glow
            const textGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
            this.drawGlow(ctx, centerX, centerY - 120, 80, `rgba(255, 170, 68, ${textGlow * 0.3})`);
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 20;
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('t = ?', centerX, centerY - 120);
            ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            ctx.fillText('Exact transformation time unknown', centerX, centerY - 90);
            ctx.shadowBlur = 0;
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(10);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced Psi-function probability distribution (ensemble prediction)
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            ctx.globalAlpha = fade;
            
            // Enhanced probability wave function expanding outward with multiple layers
            for (let layer = 0; layer < 2; layer++) {
                for (let ring = 0; ring < 10 + layer * 5; ring++) {
                    const radius = 50 + ring * 25 + this.cutsceneTime * 50 + layer * 10;
                    const alpha = (0.5 - ring * 0.05 - this.cutsceneTime * 0.15) * (1 - layer * 0.3);
                    if (alpha > 0) {
                        ctx.strokeStyle = `rgba(79, 195, 247, ${alpha})`;
                        ctx.lineWidth = 2 + layer;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        // Ring glow
                        this.drawGlow(ctx, centerX, centerY, radius, `rgba(79, 195, 247, ${alpha * 0.3})`);
                    }
                }
            }
            
            // Enhanced probability density cloud (filled area) with multiple layers
            for (let layer = 0; layer < 2; layer++) {
                const cloudGradient = ctx.createRadialGradient(centerX, centerY, 50 + layer * 20, centerX, centerY, 200 + layer * 50);
                cloudGradient.addColorStop(0, `rgba(79, 195, 247, ${0.3 - layer * 0.1})`);
                cloudGradient.addColorStop(0.5, `rgba(79, 195, 247, ${0.15 - layer * 0.05})`);
                cloudGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
                ctx.fillStyle = cloudGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 200 + layer * 50, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Enhanced multiple atoms (ensemble) with probability distribution and connections
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const dist = 150 + Math.sin(this.cutsceneTime + i) * 30;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                // Each atom has different probability of decay
                const prob = 0.3 + Math.sin(i + this.cutsceneTime) * 0.3;
                const size = 6 + prob * 4;
                this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${prob})`);
                this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${prob * 0.5})`);
                
                // Connection lines to center (showing statistical relationship)
                if (i % 3 === 0) {
                    ctx.strokeStyle = `rgba(79, 195, 247, ${prob * 0.2})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(centerX, centerY);
                    ctx.stroke();
                }
            }
            
            // Enhanced text explaining probability with glow effects
            const textFade = Math.min(1, (this.cutsceneTime - 1) / 1);
            ctx.globalAlpha = fade * textFade;
            
            // Text glow
            const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, centerX, h * 0.25, 150, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
            
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 15;
            ctx.fillText('Ψ gives probability distribution', centerX, h * 0.25);
            ctx.shadowBlur = 0;
            ctx.font = '22px Arial';
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 10;
            ctx.fillText('"50% of atoms decay by time t"', centerX, h * 0.3);
            ctx.fillText('But which specific atoms?', centerX, h * 0.35);
            ctx.shadowBlur = 0;
            
            // Warning text with orange glow
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 24px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 12;
            ctx.fillText('Cannot show exact transformation time!', centerX, h * 0.75);
            ctx.shadowBlur = 0;
            this.drawGlow(ctx, centerX, h * 0.75, 200, `rgba(255, 170, 68, ${textFade * 0.2})`);
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(10);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced individual atom with definite transformation time
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0f0510');
            bgGradient.addColorStop(0.6, '#0a0505');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Quantum field particles (orange theme)
            for (let i = 0; i < 40; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced single atom (individual system) with pulsing
            const atomPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.1;
            const nucleusGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 35 * atomPulse);
            nucleusGradient.addColorStop(0, '#ffaa44');
            nucleusGradient.addColorStop(0.5, '#ff8800');
            nucleusGradient.addColorStop(1, '#cc6600');
            ctx.fillStyle = nucleusGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 35 * atomPulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Enhanced glow with multiple layers
            this.drawGlow(ctx, centerX, centerY, 35 * atomPulse, 'rgba(255, 170, 68, 0.9)');
            this.drawGlow(ctx, centerX, centerY, 50 * atomPulse, 'rgba(255, 170, 68, 0.6)');
            this.drawGlow(ctx, centerX, centerY, 70 * atomPulse, 'rgba(255, 170, 68, 0.3)');
            
            // Enhanced countdown timer showing definite time with pulsing glow
            const timeValue = (5.3 - this.cutsceneTime * 0.5).toFixed(1);
            const timerGlow = 0.8 + Math.sin(this.cutsceneTime * 4) * 0.2;
            this.drawGlow(ctx, centerX, centerY - 40, 100, `rgba(255, 170, 68, ${timerGlow * 0.4})`);
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 52px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 25;
            ctx.fillText(`t = ${timeValue} seconds`, centerX, centerY - 40);
            ctx.shadowBlur = 0;
            
            // Enhanced decay happening at exact time with energy burst
            if (this.cutsceneTime > 2) {
                // Alpha particle escaping with enhanced trail
                const escapeProgress = Math.min(1, (this.cutsceneTime - 2) / 1.5);
                const escapeX = centerX + (escapeProgress * 150);
                const escapeY = centerY;
                
                // Enhanced trail with multiple layers
                for (let i = 0; i < 8; i++) {
                    const trailX = centerX + (escapeProgress * 150) - i * 15;
                    const trailAlpha = (0.6 - i * 0.08) * (1 - escapeProgress * 0.3);
                    const trailSize = 8 - i;
                    this.drawGlow(ctx, trailX, escapeY, trailSize, `rgba(79, 195, 247, ${trailAlpha})`);
                }
                
                // Main alpha particle with multiple glow layers
                this.drawGlow(ctx, escapeX, escapeY, 15, 'rgba(79, 195, 247, 0.9)');
                this.drawGlow(ctx, escapeX, escapeY, 22, 'rgba(79, 195, 247, 0.6)');
                this.drawGlow(ctx, escapeX, escapeY, 30, 'rgba(79, 195, 247, 0.3)');
                
                // Energy burst at escape point
                if (escapeProgress > 0.3) {
                    const burstSize = (escapeProgress - 0.3) * 50;
                    this.drawGlow(ctx, escapeX, escapeY, burstSize, `rgba(79, 195, 247, ${(1 - escapeProgress) * 0.5})`);
                }
            }
            
            // Enhanced text: Complete description with glow
            const textFade = Math.min(1, (this.cutsceneTime - 1) / 1);
            ctx.globalAlpha = fade * textFade;
            const textGlow2 = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, centerX, h * 0.625, 200, `rgba(255, 170, 68, ${textGlow2 * textFade * 0.2})`);
            
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.fillText('Individual system has', centerX, h * 0.6);
            ctx.fillText('DEFINITE transformation time', centerX, h * 0.65);
            ctx.shadowBlur = 0;
            ctx.font = '22px Arial';
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            ctx.fillText('Complete description is possible!', centerX, h * 0.72);
            ctx.shadowBlur = 0;
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(10);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 3) {
            // Phase 3: Enhanced Einstein building the Laser Weapon technology
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship working glow
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(244, 67, 54, ${workGlow * 0.2})`);
            
            // Workbench/construction area (center-right) - Enhanced
            const workbenchX = centerX + 100;
            const workbenchY = centerY;
            const workbenchFade = Math.min(1, this.cutsceneTime / 1.5);
            
            // Enhanced background workbench panel with gradient
            ctx.globalAlpha = workbenchFade;
            const workbenchGradient = ctx.createLinearGradient(workbenchX - 200, workbenchY - 150, workbenchX - 200, workbenchY + 150);
            workbenchGradient.addColorStop(0, 'rgba(244, 67, 54, 0.25)');
            workbenchGradient.addColorStop(0.5, 'rgba(244, 67, 54, 0.2)');
            workbenchGradient.addColorStop(1, 'rgba(244, 67, 54, 0.15)');
            ctx.fillStyle = workbenchGradient;
            ctx.fillRect(workbenchX - 200, workbenchY - 150, 400, 300);
            
            // Enhanced panel border with pulsing glow
            const panelGlow = 0.5 + Math.sin(this.cutsceneTime * 3) * 0.3;
            ctx.strokeStyle = `rgba(244, 67, 54, ${panelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchX - 200, workbenchY - 150, 400, 300);
            // Corner glows
            this.drawGlow(ctx, workbenchX - 200, workbenchY - 150, 25, `rgba(244, 67, 54, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY - 150, 25, `rgba(244, 67, 54, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX - 200, workbenchY + 150, 25, `rgba(244, 67, 54, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY + 150, 25, `rgba(244, 67, 54, ${panelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(244, 67, 54, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const x = workbenchX - 200 + (i * 100);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 150);
                ctx.lineTo(x, workbenchY + 150);
                ctx.stroke();
            }
            for (let i = 0; i < 4; i++) {
                const y = workbenchY - 150 + (i * 100);
                ctx.beginPath();
                ctx.moveTo(workbenchX - 200, y);
                ctx.lineTo(workbenchX + 200, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Construction progress (0-1 over time)
            const buildProgress = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 7));
            
            // Phase 1: Enhanced gathering transformation time data (radioactive particles flowing in)
            if (buildProgress < 0.3) {
                const gatherProgress = buildProgress / 0.3;
                const particleCount = 30;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const startDist = 250;
                    const endDist = 100;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 * (1 - gatherProgress);
                    const size = 6 - gatherProgress * 2;
                    // Red/orange particles for radioactive decay with trails
                    this.drawGlow(ctx, x, y, size, `rgba(255, 107, 0, ${alpha})`);
                    this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 107, 0, ${alpha * 0.5})`);
                    
                    // Particle trail
                    const trailAngle = angle - 0.1;
                    const trailDist = dist + 5;
                    const trailX = workbenchX + Math.cos(trailAngle) * trailDist;
                    const trailY = workbenchY + Math.sin(trailAngle) * trailDist * 0.7;
                    this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(255, 107, 0, ${alpha * 0.3})`);
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#ff6b00';
                ctx.font = '22px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ff6b00';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering transformation time data...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 2: Enhanced assembling laser core (focusing mechanism)
            if (buildProgress >= 0.3 && buildProgress < 0.6) {
                const assembleProgress = (buildProgress - 0.3) / 0.3;
                
                // Enhanced laser core (central focusing barrel) assembling
                const coreLength = 100 * assembleProgress;
                ctx.strokeStyle = `rgba(244, 67, 54, ${0.5 + assembleProgress * 0.5})`;
                ctx.lineWidth = 12;
                ctx.beginPath();
                ctx.moveTo(workbenchX - coreLength/2, workbenchY);
                ctx.lineTo(workbenchX + coreLength/2, workbenchY);
                ctx.stroke();
                
                // Enhanced glow effect (laser intensity) with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, coreLength/2, `rgba(244, 67, 54, ${assembleProgress * 0.8})`);
                this.drawGlow(ctx, workbenchX, workbenchY, coreLength/2 * 1.5, `rgba(244, 67, 54, ${assembleProgress * 0.4})`);
                
                // Enhanced energy particles converging (laser focusing) with trails
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    const dist = 80 - assembleProgress * 40;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.5 * (1 - assembleProgress);
                    const size = 5 + Math.sin(this.cutsceneTime * 3 + i) * 2;
                    this.drawGlow(ctx, x, y, size, `rgba(244, 67, 54, ${alpha})`);
                    
                    // Connection line to core
                    if (i % 5 === 0) {
                        ctx.strokeStyle = `rgba(244, 67, 54, ${alpha * 0.3})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(workbenchX, workbenchY);
                        ctx.stroke();
                    }
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#f44336';
                ctx.font = '22px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#f44336';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling laser focusing core...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 3: Enhanced adding continuous beam mechanism
            if (buildProgress >= 0.6 && buildProgress < 0.85) {
                const beamProgress = (buildProgress - 0.6) / 0.25;
                
                // Enhanced main barrel (complete) with glow
                ctx.strokeStyle = 'rgba(244, 67, 54, 1)';
                ctx.lineWidth = 12;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 50, workbenchY);
                ctx.lineTo(workbenchX + 50, workbenchY);
                ctx.stroke();
                this.drawGlow(ctx, workbenchX, workbenchY, 50, 'rgba(244, 67, 54, 0.8)');
                this.drawGlow(ctx, workbenchX, workbenchY, 70, 'rgba(244, 67, 54, 0.4)');
                
                // Enhanced continuous beam extending with multiple layers
                const beamLength = 80 * beamProgress;
                ctx.strokeStyle = `rgba(244, 67, 54, ${0.7 + beamProgress * 0.3})`;
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(workbenchX + 50, workbenchY);
                ctx.lineTo(workbenchX + 50 + beamLength, workbenchY);
                ctx.stroke();
                
                // Enhanced beam glow (intense laser light) with multiple layers
                this.drawGlow(ctx, workbenchX + 50 + beamLength/2, workbenchY, beamLength/2, `rgba(244, 67, 54, ${beamProgress * 0.9})`);
                this.drawGlow(ctx, workbenchX + 50 + beamLength/2, workbenchY, beamLength, `rgba(244, 67, 54, ${beamProgress * 0.4})`);
                
                // Enhanced energy flowing into beam (continuous stream) with more particles
                for (let i = 0; i < 20; i++) {
                    const progress = (this.cutsceneTime * 0.8 + i * 0.1) % 1;
                    const x = workbenchX - 50 + progress * (100 + beamLength);
                    const y = workbenchY;
                    const alpha = 0.9 - progress * 0.3;
                    const size = 6 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                    this.drawGlow(ctx, x, y, size, `rgba(244, 67, 54, ${alpha})`);
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#f44336';
                ctx.font = '22px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#f44336';
                ctx.shadowBlur = 10;
                ctx.fillText('Installing continuous beam mechanism...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 4: Finalizing and testing
            if (buildProgress >= 0.85) {
                const finalizeProgress = (buildProgress - 0.85) / 0.15;
                
                // Complete laser weapon
                ctx.strokeStyle = 'rgba(244, 67, 54, 1)';
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 50, workbenchY);
                ctx.lineTo(workbenchX + 50, workbenchY);
                ctx.stroke();
                
                // Continuous beam (complete)
                ctx.strokeStyle = 'rgba(244, 67, 54, 1)';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(workbenchX + 50, workbenchY);
                ctx.lineTo(workbenchX + 130, workbenchY);
                ctx.stroke();
                
                // Complete glow
                this.drawGlow(ctx, workbenchX, workbenchY, 50, 'rgba(244, 67, 54, 0.8)');
                this.drawGlow(ctx, workbenchX + 90, workbenchY, 40, 'rgba(244, 67, 54, 0.9)');
                
                // Test firing animation (continuous beam extending)
                if (finalizeProgress > 0.3) {
                    const fireProgress = (finalizeProgress - 0.3) / 0.7;
                    const beamExtend = fireProgress * 150;
                    ctx.strokeStyle = 'rgba(244, 67, 54, 1)';
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.moveTo(workbenchX + 130, workbenchY);
                    ctx.lineTo(workbenchX + 130 + beamExtend, workbenchY);
                    ctx.stroke();
                    
                    // Beam tip glow
                    this.drawGlow(ctx, workbenchX + 130 + beamExtend, workbenchY, 20, `rgba(244, 67, 54, ${1 - fireProgress * 0.5})`);
                    
                    // Energy particles along beam
                    for (let i = 0; i < 10; i++) {
                        const progress = (this.cutsceneTime * 1.5 + i * 0.1) % 1;
                        const x = workbenchX + 50 + progress * (80 + beamExtend);
                        const y = workbenchY;
                        this.drawGlow(ctx, x, y, 4, `rgba(244, 67, 54, ${0.8 - progress * 0.4})`);
                    }
                }
                
                // Enhanced success particles (red/orange) with more layers
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2 + this.cutsceneTime * 2;
                    const dist = 80 + Math.sin(this.cutsceneTime * 3 + i) * 30;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 + Math.sin(this.cutsceneTime * 4 + i) * 0.4;
                    const size = 6 + Math.sin(this.cutsceneTime * 2 + i) * 3;
                    this.drawGlow(ctx, x, y, size, `rgba(244, 67, 54, ${alpha})`);
                    this.drawGlow(ctx, x, y, size * 1.5, `rgba(244, 67, 54, ${alpha * 0.5})`);
                }
                
                // Enhanced text with glow effects
                ctx.fillStyle = '#f44336';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#f44336';
                ctx.shadowBlur = 20;
                ctx.fillText('LASER WEAPON COMPLETE!', workbenchX, workbenchY + 120);
                this.drawGlow(ctx, workbenchX, workbenchY + 120, 150, 'rgba(244, 67, 54, 0.4)');
                ctx.shadowBlur = 0;
                ctx.font = '20px Arial';
                ctx.fillStyle = 'rgba(244, 67, 54, 0.9)';
                ctx.shadowColor = '#f44336';
                ctx.shadowBlur = 10;
                ctx.fillText('Definite transformation time weapon ready', workbenchX, workbenchY + 150);
                ctx.shadowBlur = 0;
            }
            
            // Enhanced connection line from ship to workbench (Einstein working)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(shipX + 30, shipY);
            ctx.lineTo(workbenchX - 200, workbenchY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Connection glow
            const midX = (shipX + 30 + workbenchX - 200) / 2;
            const midY = (shipY + workbenchY) / 2;
            this.drawGlow(ctx, midX, midY, 5, 'rgba(255, 255, 255, 0.2)');
            
            // Set foreground text for phase 3 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(10);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[3]) {
                    let text = cutsceneData.texts[3].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        }
    }
    
    // Level 20: Individual vs Ensemble distinction - Enhanced
    drawCutsceneLevel20(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced two paths diverging from a central point (Einstein's realization)
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(79, 195, 247, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            const startX = w * 0.5;
            const startY = h * 0.3;
            const leftX = w * 0.25;
            const rightX = w * 0.75;
            const endY = h * 0.7;
            
            // Enhanced central point (Einstein's ship/understanding) with glow
            const shipX = startX;
            const shipY = startY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 8;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 0.8, 1, this.cutsceneTime);
            
            // Ship realization glow
            const realizationGlow = 0.4 + Math.sin(this.cutsceneTime * 2) * 0.3;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 100, `rgba(79, 195, 247, ${realizationGlow * 0.2})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat, 60, `rgba(255, 170, 68, ${realizationGlow * 0.15})`);
            
            // Enhanced left path: Ensemble QM (curved path) with glow
            const leftPathPulse = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.2;
            ctx.strokeStyle = `rgba(79, 195, 247, ${leftPathPulse})`;
            ctx.lineWidth = 6;
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.quadraticCurveTo(startX - 50, (startY + endY) / 2, leftX, endY);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Path glow
            const midLeftX = (startX + leftX) / 2;
            const midLeftY = (startY + endY) / 2;
            this.drawGlow(ctx, midLeftX, midLeftY, 30, `rgba(79, 195, 247, ${leftPathPulse * 0.3})`);
            
            // Enhanced right path: Individual System (curved path) with glow
            const rightPathPulse = 0.7 + Math.sin(this.cutsceneTime * 2 + Math.PI) * 0.2;
            ctx.strokeStyle = `rgba(255, 170, 68, ${rightPathPulse})`;
            ctx.lineWidth = 6;
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.quadraticCurveTo(startX + 50, (startY + endY) / 2, rightX, endY);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Path glow
            const midRightX = (startX + rightX) / 2;
            const midRightY = (startY + endY) / 2;
            this.drawGlow(ctx, midRightX, midRightY, 30, `rgba(255, 170, 68, ${rightPathPulse * 0.3})`);
            
            // Enhanced particles flowing along paths with trails
            for (let i = 0; i < 15; i++) {
                const progress = (this.cutsceneTime * 0.3 + i * 0.1) % 1;
                // Left path particles
                const leftT = progress;
                const leftPathX = startX + (leftX - startX) * leftT;
                const leftPathY = startY + (endY - startY) * leftT;
                const leftAlpha = 0.8 - progress * 0.4;
                const leftSize = 6 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                this.drawGlow(ctx, leftPathX, leftPathY, leftSize, `rgba(79, 195, 247, ${leftAlpha})`);
                this.drawGlow(ctx, leftPathX, leftPathY, leftSize * 1.5, `rgba(79, 195, 247, ${leftAlpha * 0.5})`);
                
                // Right path particles
                const rightPathX = startX + (rightX - startX) * progress;
                const rightPathY = startY + (endY - startY) * progress;
                const rightAlpha = 0.8 - progress * 0.4;
                const rightSize = 6 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                this.drawGlow(ctx, rightPathX, rightPathY, rightSize, `rgba(255, 170, 68, ${rightAlpha})`);
                this.drawGlow(ctx, rightPathX, rightPathY, rightSize * 1.5, `rgba(255, 170, 68, ${rightAlpha * 0.5})`);
            }
            
            // Enhanced labels with icons and glow effects
            const labelGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, leftX, endY - 20, 100, `rgba(79, 195, 247, ${labelGlow * 0.2})`);
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 15;
            ctx.fillText('ENSEMBLE QM', leftX, endY - 20);
            ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
            ctx.fillText('Statistical', leftX, endY + 5);
            
            this.drawGlow(ctx, rightX, endY - 20, 120, `rgba(255, 170, 68, ${labelGlow * 0.2})`);
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 36px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.fillText('INDIVIDUAL SYSTEM', rightX, endY - 20);
            ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.fillText('Complete Description', rightX, endY + 5);
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(20);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced detailed side-by-side comparison
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            const dividerX = w * 0.5;
            
            // Enhanced ENSEMBLE SIDE (Left) with gradient panel
            const ensemblePanelGradient = ctx.createLinearGradient(0, h * 0.1, 0, h * 0.9);
            ensemblePanelGradient.addColorStop(0, 'rgba(79, 195, 247, 0.2)');
            ensemblePanelGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.15)');
            ensemblePanelGradient.addColorStop(1, 'rgba(79, 195, 247, 0.1)');
            ctx.fillStyle = ensemblePanelGradient;
            ctx.fillRect(0, 0, dividerX, h);
            
            // Enhanced panel border with pulsing glow
            const ensembleGlow = 0.5 + Math.sin(this.cutsceneTime * 2) * 0.3;
            ctx.strokeStyle = `rgba(79, 195, 247, ${ensembleGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, dividerX, h);
            // Corner glows
            this.drawGlow(ctx, 0, 0, 20, `rgba(79, 195, 247, ${ensembleGlow * 0.4})`);
            this.drawGlow(ctx, dividerX, 0, 20, `rgba(79, 195, 247, ${ensembleGlow * 0.4})`);
            this.drawGlow(ctx, 0, h, 20, `rgba(79, 195, 247, ${ensembleGlow * 0.4})`);
            this.drawGlow(ctx, dividerX, h, 20, `rgba(79, 195, 247, ${ensembleGlow * 0.4})`);
            
            // Enhanced ensemble title with glow
            const ensembleTitleGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, dividerX * 0.5, h * 0.15, 120, `rgba(79, 195, 247, ${ensembleTitleGlow * 0.2})`);
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 15;
            ctx.fillText('ENSEMBLE QM', dividerX * 0.5, h * 0.15);
            ctx.shadowBlur = 0;
            
            // Enhanced many particles (statistical distribution) with connections
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % (dividerX * 0.8) + dividerX * 0.1;
                const y = h * 0.25 + ((i * 23) % (h * 0.4));
                const alpha = 0.4 + Math.sin(i + this.cutsceneTime) * 0.3;
                const size = 4 + Math.sin(this.cutsceneTime * 2 + i) * 3;
                this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
                
                // Connection lines (showing statistical relationships)
                if (i % 7 === 0) {
                    const nextI = (i + 7) % 50;
                    const nextX = (nextI * 37) % (dividerX * 0.8) + dividerX * 0.1;
                    const nextY = h * 0.25 + ((nextI * 23) % (h * 0.4));
                    ctx.strokeStyle = `rgba(79, 195, 247, ${alpha * 0.2})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(nextX, nextY);
                    ctx.stroke();
                }
            }
            
            // Enhanced properties list with glow
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
            ctx.font = '22px Arial';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 8;
            ctx.fillText('• Statistical predictions', dividerX * 0.5, h * 0.55);
            ctx.fillText('• Probabilities |Ψ|²', dividerX * 0.5, h * 0.6);
            ctx.fillText('• Groups of systems', dividerX * 0.5, h * 0.65);
            ctx.fillText('• Epistemological tool', dividerX * 0.5, h * 0.7);
            ctx.shadowBlur = 0;
            
            // Enhanced INDIVIDUAL SIDE (Right) with gradient panel
            const individualPanelGradient = ctx.createLinearGradient(dividerX, h * 0.1, dividerX, h * 0.9);
            individualPanelGradient.addColorStop(0, 'rgba(255, 170, 68, 0.2)');
            individualPanelGradient.addColorStop(0.5, 'rgba(255, 170, 68, 0.15)');
            individualPanelGradient.addColorStop(1, 'rgba(255, 170, 68, 0.1)');
            ctx.fillStyle = individualPanelGradient;
            ctx.fillRect(dividerX, 0, dividerX, h);
            
            // Enhanced panel border with pulsing glow
            const individualGlow = 0.5 + Math.sin(this.cutsceneTime * 2 + Math.PI) * 0.3;
            ctx.strokeStyle = `rgba(255, 170, 68, ${individualGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(dividerX, 0, dividerX, h);
            // Corner glows
            this.drawGlow(ctx, dividerX, 0, 20, `rgba(255, 170, 68, ${individualGlow * 0.4})`);
            this.drawGlow(ctx, w, 0, 20, `rgba(255, 170, 68, ${individualGlow * 0.4})`);
            this.drawGlow(ctx, dividerX, h, 20, `rgba(255, 170, 68, ${individualGlow * 0.4})`);
            this.drawGlow(ctx, w, h, 20, `rgba(255, 170, 68, ${individualGlow * 0.4})`);
            
            // Enhanced individual title with glow
            const individualTitleGlow = 0.6 + Math.sin(this.cutsceneTime * 2 + Math.PI) * 0.4;
            this.drawGlow(ctx, dividerX * 1.5, h * 0.15, 140, `rgba(255, 170, 68, ${individualTitleGlow * 0.2})`);
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 40px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.fillText('INDIVIDUAL SYSTEM', dividerX * 1.5, h * 0.15);
            ctx.shadowBlur = 0;
            
            // Enhanced single, well-defined particle with multiple glow layers
            const particleX = dividerX * 1.5;
            const particleY = h * 0.45;
            const pulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
            this.drawGlow(ctx, particleX, particleY, 40 * pulse, 'rgba(255, 170, 68, 0.5)');
            this.drawGlow(ctx, particleX, particleY, 30 * pulse, 'rgba(255, 170, 68, 0.7)');
            this.drawGlow(ctx, particleX, particleY, 20 * pulse, 'rgba(255, 170, 68, 0.9)');
            this.drawGlow(ctx, particleX, particleY, 12 * pulse, 'rgba(255, 170, 68, 1)');
            
            // Enhanced definite position crosshair with glow
            ctx.strokeStyle = '#ffaa44';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            const crossSize = 30;
            ctx.beginPath();
            ctx.moveTo(particleX - crossSize, particleY);
            ctx.lineTo(particleX + crossSize, particleY);
            ctx.moveTo(particleX, particleY - crossSize);
            ctx.lineTo(particleX, particleY + crossSize);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Enhanced properties list with glow
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.font = '22px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 8;
            ctx.fillText('• Definite properties', dividerX * 1.5, h * 0.55);
            ctx.fillText('• Exact values', dividerX * 1.5, h * 0.6);
            ctx.fillText('• Single system', dividerX * 1.5, h * 0.65);
            ctx.fillText('• Complete description', dividerX * 1.5, h * 0.7);
            ctx.shadowBlur = 0;
            
            // Enhanced divider line with pulsing glow
            const dividerPulse = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            ctx.strokeStyle = `rgba(255, 255, 255, ${dividerPulse})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(dividerX, 0);
            ctx.lineTo(dividerX, h);
            ctx.stroke();
            // Divider glow
            this.drawGlow(ctx, dividerX, centerY, 5, `rgba(255, 255, 255, ${dividerPulse * 0.3})`);
            
            // Divider particles
            for (let i = 0; i < 20; i++) {
                const y = (h / 20) * i + Math.sin(this.cutsceneTime * 2 + i) * 5;
                this.drawGlow(ctx, dividerX, y, 3, `rgba(255, 255, 255, ${dividerPulse * 0.4})`);
            }
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(20);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced you choosing the individual path (realization)
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0f0510');
            bgGradient.addColorStop(0.6, '#0a0505');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Quantum field particles (orange theme)
            for (let i = 0; i < 40; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha})`);
            }
            
            // Enhanced Einstein's ship moving toward individual path with glow
            const shipX = centerX - 150 + Math.min(this.cutsceneTime * 40, 200);
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Ship movement glow
            const movementGlow = 0.4 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 100, `rgba(255, 170, 68, ${movementGlow * 0.3})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat, 60, `rgba(255, 170, 68, ${movementGlow * 0.2})`);
            
            // Enhanced large arrow pointing right (individual path) with glow
            const arrowStartX = centerX - 100;
            const arrowEndX = centerX + 150;
            const arrowPulse = 0.8 + Math.sin(this.cutsceneTime * 2) * 0.2;
            ctx.strokeStyle = `rgba(255, 170, 68, ${arrowPulse})`;
            ctx.lineWidth = 10;
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(arrowStartX, centerY);
            ctx.lineTo(arrowEndX, centerY);
            ctx.lineTo(arrowEndX - 30, centerY - 25);
            ctx.moveTo(arrowEndX, centerY);
            ctx.lineTo(arrowEndX - 30, centerY + 25);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Arrow glow
            this.drawGlow(ctx, arrowEndX - 15, centerY, 40, `rgba(255, 170, 68, ${arrowPulse * 0.4})`);
            
            // Enhanced particles/understanding flowing along the path with trails
            for (let i = 0; i < 25; i++) {
                const progress = (this.cutsceneTime * 0.4 + i * 0.06) % 1;
                const x = arrowStartX + progress * (arrowEndX - arrowStartX);
                const y = centerY + Math.sin(progress * Math.PI * 2) * 30;
                const alpha = 0.9 - progress * 0.5;
                const size = 7 + Math.sin(progress * Math.PI * 4) * 3;
                if (alpha > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha})`);
                    this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 170, 68, ${alpha * 0.5})`);
                    
                    // Particle trail
                    const trailX = x - (arrowEndX - arrowStartX) * 0.05;
                    this.drawGlow(ctx, trailX, y, size * 0.5, `rgba(255, 170, 68, ${alpha * 0.3})`);
                }
            }
            
            // Enhanced realization text with glow effects
            const textFade = Math.min(1, (this.cutsceneTime - 1) / 2);
            ctx.globalAlpha = textFade;
            
            // Text glow
            const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, centerX, h * 0.325, 200, `rgba(255, 170, 68, ${textGlow * textFade * 0.2})`);
            this.drawGlow(ctx, centerX, h * 0.65, 180, `rgba(255, 170, 68, ${textGlow * textFade * 0.2})`);
            
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.fillText('To escape, understand', centerX, h * 0.3);
            ctx.fillText('INDIVIDUAL SYSTEMS', centerX, h * 0.35);
            ctx.shadowBlur = 0;
            ctx.font = '24px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            ctx.fillText('not just ensembles!', centerX, h * 0.65);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(20);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        }
    }
    
    // Level 25: Complete Description Problem - Enhanced
    drawCutsceneLevel25(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced incomplete description puzzle - missing pieces visualization
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(79, 195, 247, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced central incomplete puzzle structure
            const puzzleRadius = 120;
            const pieceCount = 12;
            
            // Enhanced puzzle pieces forming an incomplete circle with animations
            for (let i = 0; i < pieceCount; i++) {
                const angle = (i / pieceCount) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * puzzleRadius;
                const y = centerY + Math.sin(angle) * puzzleRadius;
                
                // Skip missing pieces for now
                if (i === 3 || i === 7 || i === 10) continue;
                
                // Enhanced puzzle piece with jigsaw shape and pulsing
                const piecePulse = 1 + Math.sin(this.cutsceneTime * 2 + i) * 0.1;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle + Math.PI / 2);
                
                // Enhanced piece gradient
                const pieceGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25 * piecePulse);
                pieceGradient.addColorStop(0, 'rgba(79, 195, 247, 0.9)');
                pieceGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.6)');
                pieceGradient.addColorStop(1, 'rgba(79, 195, 247, 0.3)');
                ctx.fillStyle = pieceGradient;
                
                // Enhanced jigsaw piece shape
                ctx.beginPath();
                ctx.arc(0, 0, 25 * piecePulse, 0, Math.PI * 2);
                // Add jigsaw tab
                ctx.arc(0, -30 * piecePulse, 8 * piecePulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Enhanced piece glow with multiple layers
                this.drawGlow(ctx, 0, 0, 25 * piecePulse, 'rgba(79, 195, 247, 0.7)');
                this.drawGlow(ctx, 0, 0, 35 * piecePulse, 'rgba(79, 195, 247, 0.4)');
                
                ctx.restore();
            }
            
            // Enhanced missing pieces (gaps) - show as empty spaces with red indicators
            for (let gapIndex = 0; gapIndex < 3; gapIndex++) {
                const gapNum = [3, 7, 10][gapIndex];
                const angle = (gapNum / pieceCount) * Math.PI * 2;
                const gapX = centerX + Math.cos(angle) * puzzleRadius;
                const gapY = centerY + Math.sin(angle) * puzzleRadius;
                
                // Enhanced red warning indicator with pulsing
                const pulse = 1 + Math.sin(this.cutsceneTime * 3 + gapIndex) * 0.4;
                ctx.strokeStyle = `rgba(255, 68, 68, ${0.8 * pulse})`;
                ctx.lineWidth = 4;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(gapX, gapY, 35 * pulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Enhanced pulsing red glow with multiple layers
                this.drawGlow(ctx, gapX, gapY, 35 * pulse, `rgba(255, 68, 68, ${0.6 * pulse})`);
                this.drawGlow(ctx, gapX, gapY, 50 * pulse, `rgba(255, 68, 68, ${0.3 * pulse})`);
                this.drawGlow(ctx, gapX, gapY, 70 * pulse, `rgba(255, 68, 68, ${0.15 * pulse})`);
                
                // Enhanced question mark in gap with glow
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('?', gapX, gapY + 10);
                ctx.shadowBlur = 0;
            }
            
            // Enhanced connecting lines between pieces (showing incomplete structure) with glow
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.4)';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 10;
            for (let i = 0; i < pieceCount; i++) {
                if (i === 3 || i === 7 || i === 10) continue; // Skip missing pieces
                const angle1 = (i / pieceCount) * Math.PI * 2;
                const angle2 = ((i + 1) % pieceCount / pieceCount) * Math.PI * 2;
                if ((i + 1) % pieceCount === 3 || (i + 1) % pieceCount === 7 || (i + 1) % pieceCount === 10) continue;
                
                const x1 = centerX + Math.cos(angle1) * puzzleRadius;
                const y1 = centerY + Math.sin(angle1) * puzzleRadius;
                const x2 = centerX + Math.cos(angle2) * puzzleRadius;
                const y2 = centerY + Math.sin(angle2) * puzzleRadius;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // Connection point glows
                this.drawGlow(ctx, (x1 + x2) / 2, (y1 + y2) / 2, 5, 'rgba(79, 195, 247, 0.3)');
            }
            ctx.shadowBlur = 0;
            
            // Enhanced title with glow effects
            const titleGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, centerX, h * 0.2, 200, `rgba(255, 170, 68, ${titleGlow * 0.2})`);
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 20;
            ctx.fillText('INCOMPLETE DESCRIPTION', centerX, h * 0.2);
            ctx.shadowBlur = 0;
            ctx.font = '22px Arial';
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            ctx.fillText('Missing pieces in the puzzle', centerX, h * 0.25);
            ctx.shadowBlur = 0;
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(25);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced split view - Psi-function (incomplete) vs Individual System (complete)
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            const dividerX = w * 0.5;
            const fade = Math.min(1, this.cutsceneTime / 2);
            ctx.globalAlpha = fade;
            
            // Enhanced LEFT SIDE: Psi-function (Ensemble - Incomplete) with gradient panel
            const psiPanelGradient = ctx.createLinearGradient(0, h * 0.1, 0, h * 0.9);
            psiPanelGradient.addColorStop(0, 'rgba(79, 195, 247, 0.2)');
            psiPanelGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.15)');
            psiPanelGradient.addColorStop(1, 'rgba(79, 195, 247, 0.1)');
            ctx.fillStyle = psiPanelGradient;
            ctx.fillRect(0, 0, dividerX, h);
            
            // Enhanced panel border with pulsing glow
            const psiGlow = 0.5 + Math.sin(this.cutsceneTime * 2) * 0.3;
            ctx.strokeStyle = `rgba(79, 195, 247, ${psiGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, dividerX, h);
            // Corner glows
            this.drawGlow(ctx, 0, 0, 20, `rgba(79, 195, 247, ${psiGlow * 0.4})`);
            this.drawGlow(ctx, dividerX, 0, 20, `rgba(79, 195, 247, ${psiGlow * 0.4})`);
            this.drawGlow(ctx, 0, h, 20, `rgba(79, 195, 247, ${psiGlow * 0.4})`);
            this.drawGlow(ctx, dividerX, h, 20, `rgba(79, 195, 247, ${psiGlow * 0.4})`);
            
            // Enhanced Psi-function equation with incomplete indicator
            const psiX = dividerX * 0.5;
            const psiY = h * 0.4;
            
            // Enhanced Psi-function with multi-layer glow
            const psiEquationGlow = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, psiX, psiY, 100, `rgba(79, 195, 247, ${psiEquationGlow * 0.3})`);
            this.drawGlow(ctx, psiX, psiY, 60, `rgba(79, 195, 247, ${psiEquationGlow * 0.5})`);
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 25;
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 72px "Times New Roman", serif';
            ctx.textAlign = 'center';
            ctx.fillText('Ψ(x,t)', psiX, psiY);
            ctx.shadowBlur = 0;
            
            // Enhanced incomplete indicator (red X) with pulsing glow
            const xPulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.2;
            ctx.strokeStyle = `rgba(255, 68, 68, ${0.9 * xPulse})`;
            ctx.lineWidth = 5;
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(psiX - 45, psiY - 45);
            ctx.lineTo(psiX + 45, psiY + 45);
            ctx.moveTo(psiX + 45, psiY - 45);
            ctx.lineTo(psiX - 45, psiY + 45);
            ctx.stroke();
            ctx.shadowBlur = 0;
            this.drawGlow(ctx, psiX, psiY, 50, `rgba(255, 68, 68, ${xPulse * 0.3})`);
            
            // Enhanced text labels with glow
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 26px Arial';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 10;
            ctx.fillText('Statistical QM', psiX, psiY + 60);
            ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 8;
            ctx.fillText('Ensemble only', psiX, psiY + 85);
            ctx.fillText('Incomplete for', psiX, psiY + 105);
            ctx.fillText('individual systems', psiX, psiY + 125);
            ctx.shadowBlur = 0;
            
            // Enhanced probability cloud (fuzzy, incomplete) with more particles
            for (let i = 0; i < 35; i++) {
                const x = psiX - 100 + (i * 37) % 200;
                const y = psiY - 120 + ((i * 23) % 100);
                const alpha = 0.3 + Math.sin(i + this.cutsceneTime) * 0.3;
                const size = 5 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
            }
            
            // Enhanced RIGHT SIDE: Individual System (Complete Description) with gradient panel
            const completePanelGradient = ctx.createLinearGradient(dividerX, h * 0.1, dividerX, h * 0.9);
            completePanelGradient.addColorStop(0, 'rgba(255, 170, 68, 0.2)');
            completePanelGradient.addColorStop(0.5, 'rgba(255, 170, 68, 0.15)');
            completePanelGradient.addColorStop(1, 'rgba(255, 170, 68, 0.1)');
            ctx.fillStyle = completePanelGradient;
            ctx.fillRect(dividerX, 0, dividerX, h);
            
            // Enhanced panel border with pulsing glow
            const completeGlow = 0.5 + Math.sin(this.cutsceneTime * 2 + Math.PI) * 0.3;
            ctx.strokeStyle = `rgba(255, 170, 68, ${completeGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(dividerX, 0, dividerX, h);
            // Corner glows
            this.drawGlow(ctx, dividerX, 0, 20, `rgba(255, 170, 68, ${completeGlow * 0.4})`);
            this.drawGlow(ctx, w, 0, 20, `rgba(255, 170, 68, ${completeGlow * 0.4})`);
            this.drawGlow(ctx, dividerX, h, 20, `rgba(255, 170, 68, ${completeGlow * 0.4})`);
            this.drawGlow(ctx, w, h, 20, `rgba(255, 170, 68, ${completeGlow * 0.4})`);
            
            // Enhanced complete description visualization
            const completeX = dividerX * 1.5;
            const completeY = h * 0.4;
            
            // Enhanced complete puzzle/circle with pulsing
            const completePulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            const completeRadius = 60 * completePulse;
            const completeGradient = ctx.createRadialGradient(completeX, completeY, 0, completeX, completeY, completeRadius);
            completeGradient.addColorStop(0, '#ffaa44');
            completeGradient.addColorStop(0.5, '#ff8800');
            completeGradient.addColorStop(1, '#cc6600');
            ctx.fillStyle = completeGradient;
            ctx.beginPath();
            ctx.arc(completeX, completeY, completeRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Enhanced complete indicator (checkmark) with glow
            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 8;
            ctx.shadowColor = '#4caf50';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(completeX - 30, completeY);
            ctx.lineTo(completeX - 8, completeY + 22);
            ctx.lineTo(completeX + 30, completeY - 18);
            ctx.stroke();
            ctx.shadowBlur = 0;
            this.drawGlow(ctx, completeX, completeY, 30, 'rgba(76, 175, 80, 0.4)');
            
            // Enhanced glow effect with multiple layers
            this.drawGlow(ctx, completeX, completeY, completeRadius, 'rgba(255, 170, 68, 0.9)');
            this.drawGlow(ctx, completeX, completeY, completeRadius + 30, 'rgba(255, 170, 68, 0.6)');
            this.drawGlow(ctx, completeX, completeY, completeRadius + 50, 'rgba(255, 170, 68, 0.3)');
            
            // Enhanced text labels with glow
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 26px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            ctx.fillText('Individual System', completeX, completeY + 60);
            ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 8;
            ctx.fillText('Complete description', completeX, completeY + 85);
            ctx.fillText('All properties known', completeX, completeY + 105);
            ctx.fillText('Definite values', completeX, completeY + 125);
            ctx.shadowBlur = 0;
            
            // Enhanced definite properties (clear, well-defined) with connections
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const dist = 40;
                const x = completeX + Math.cos(angle) * dist;
                const y = completeY + Math.sin(angle) * dist;
                const size = 7 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                this.drawGlow(ctx, x, y, size, 'rgba(255, 170, 68, 0.9)');
                this.drawGlow(ctx, x, y, size * 1.5, 'rgba(255, 170, 68, 0.5)');
                
                // Connection lines to center
                if (i % 3 === 0) {
                    ctx.strokeStyle = 'rgba(255, 170, 68, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(completeX, completeY);
                    ctx.stroke();
                }
            }
            
            // Enhanced divider line with pulsing glow
            const dividerPulse = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            ctx.strokeStyle = `rgba(255, 255, 255, ${dividerPulse})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(dividerX, 0);
            ctx.lineTo(dividerX, h);
            ctx.stroke();
            // Divider glow
            this.drawGlow(ctx, dividerX, centerY, 5, `rgba(255, 255, 255, ${dividerPulse * 0.3})`);
            
            // Divider particles
            for (let i = 0; i < 20; i++) {
                const y = (h / 20) * i + Math.sin(this.cutsceneTime * 2 + i) * 5;
                this.drawGlow(ctx, dividerX, y, 3, `rgba(255, 255, 255, ${dividerPulse * 0.4})`);
            }
            
            // Enhanced center question mark (what's the problem?) with glow
            const questionGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, dividerX, h * 0.15, 80, `rgba(255, 255, 255, ${questionGlow * 0.2})`);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = 'bold 56px Arial';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            ctx.fillText('?', dividerX, h * 0.15);
            ctx.shadowBlur = 0;
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(25);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced Einstein's programmatic aim - complete description vision
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0f0510');
            bgGradient.addColorStop(0.6, '#0a0505');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Quantum field particles (orange theme)
            for (let i = 0; i < 40; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha})`);
            }
            
            // Enhanced Einstein's ship with glow
            const shipX = centerX - 150;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Ship vision glow
            const visionGlow = 0.4 + Math.sin(this.cutsceneTime * 2) * 0.3;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(255, 170, 68, ${visionGlow * 0.2})`);
            
            // Enhanced vision of complete description (appearing from ship)
            const visionX = centerX + 100;
            const visionY = centerY;
            const visionFade = Math.min(1, this.cutsceneTime / 2);
            ctx.globalAlpha = visionFade;
            
            // Enhanced complete description circle (pulsing, glowing) with multiple layers
            const visionPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.15;
            const visionRadius = 80 * visionPulse;
            const visionGradient = ctx.createRadialGradient(visionX, visionY, 0, visionX, visionY, visionRadius);
            visionGradient.addColorStop(0, 'rgba(255, 170, 68, 1)');
            visionGradient.addColorStop(0.3, 'rgba(255, 170, 68, 0.8)');
            visionGradient.addColorStop(0.6, 'rgba(255, 170, 68, 0.5)');
            visionGradient.addColorStop(1, 'rgba(255, 170, 68, 0)');
            ctx.fillStyle = visionGradient;
            ctx.beginPath();
            ctx.arc(visionX, visionY, visionRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Enhanced outer glow rings with more layers
            for (let ring = 0; ring < 5; ring++) {
                const ringRadius = visionRadius + 30 + ring * 25;
                const ringAlpha = (0.4 - ring * 0.08) * visionFade;
                ctx.strokeStyle = `rgba(255, 170, 68, ${ringAlpha})`;
                ctx.lineWidth = 2 + ring;
                ctx.beginPath();
                ctx.arc(visionX, visionY, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
                // Ring glow
                this.drawGlow(ctx, visionX, visionY, ringRadius, `rgba(255, 170, 68, ${ringAlpha * 0.3})`);
            }
            
            // Enhanced complete puzzle pieces (all connected) with pulsing
            const pieceCount = 12;
            for (let i = 0; i < pieceCount; i++) {
                const angle = (i / pieceCount) * Math.PI * 2;
                const dist = visionRadius - 20;
                const x = visionX + Math.cos(angle) * dist;
                const y = visionY + Math.sin(angle) * dist;
                const piecePulse = 1 + Math.sin(this.cutsceneTime * 3 + i * 0.5) * 0.1;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                
                // Enhanced complete piece with gradient
                const pieceGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 14 * piecePulse);
                pieceGradient.addColorStop(0, '#ffaa44');
                pieceGradient.addColorStop(0.5, '#ff8800');
                pieceGradient.addColorStop(1, '#cc6600');
                ctx.fillStyle = pieceGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 14 * piecePulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Piece glow
                this.drawGlow(ctx, 0, 0, 14 * piecePulse, 'rgba(255, 170, 68, 0.8)');
                
                ctx.restore();
            }
            
            // Enhanced connecting lines (complete structure) with glow
            ctx.strokeStyle = 'rgba(255, 170, 68, 0.7)';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            for (let i = 0; i < pieceCount; i++) {
                const angle1 = (i / pieceCount) * Math.PI * 2;
                const angle2 = ((i + 1) / pieceCount) * Math.PI * 2;
                const x1 = visionX + Math.cos(angle1) * (visionRadius - 20);
                const y1 = visionY + Math.sin(angle1) * (visionRadius - 20);
                const x2 = visionX + Math.cos(angle2) * (visionRadius - 20);
                const y2 = visionY + Math.sin(angle2) * (visionRadius - 20);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
            
            // Enhanced checkmark in center with glow
            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 8;
            ctx.shadowColor = '#4caf50';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(visionX - 35, visionY);
            ctx.lineTo(visionX - 12, visionY + 25);
            ctx.lineTo(visionX + 35, visionY - 25);
            ctx.stroke();
            ctx.shadowBlur = 0;
            this.drawGlow(ctx, visionX, visionY, 40, 'rgba(76, 175, 80, 0.5)');
            
            // Enhanced energy/light rays from ship to vision with trails
            for (let i = 0; i < 15; i++) {
                const progress = (this.cutsceneTime * 0.5 + i * 0.08) % 1;
                const startX = shipX + 50;
                const endX = visionX - visionRadius;
                const x = startX + (endX - startX) * progress;
                const y = centerY + Math.sin(progress * Math.PI * 3) * 30;
                const alpha = 0.8 - progress * 0.6;
                const size = 6 - progress * 2;
                
                if (alpha > 0 && size > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha})`);
                    this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 170, 68, ${alpha * 0.5})`);
                    
                    // Energy trail
                    const trailX = x - (endX - startX) * 0.05;
                    this.drawGlow(ctx, trailX, y, size * 0.5, `rgba(255, 170, 68, ${alpha * 0.3})`);
                }
            }
            
            // Enhanced text: Einstein's programmatic aim with glow effects
            const textFade = Math.min(1, (this.cutsceneTime - 1) / 2);
            ctx.globalAlpha = visionFade * textFade;
            
            const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, centerX, h * 0.25, 250, `rgba(255, 170, 68, ${textGlow * textFade * 0.2})`);
            this.drawGlow(ctx, centerX, h * 0.675, 220, `rgba(255, 170, 68, ${textGlow * textFade * 0.2})`);
            
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.fillText('Einstein\'s Programmatic Aim:', centerX, h * 0.25);
            ctx.shadowBlur = 0;
            ctx.font = '26px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 12;
            ctx.fillText('Complete description', centerX, h * 0.65);
            ctx.fillText('of any individual real situation', centerX, h * 0.7);
            ctx.shadowBlur = 0;
            ctx.font = '22px Arial';
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            ctx.fillText('This is what\'s missing from QM', centerX, h * 0.75);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(25);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 3) {
            // Phase 3: Enhanced Einstein building complete description technology foundation
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship working glow
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(255, 170, 68, ${workGlow * 0.2})`);
            
            // Workbench/construction area (center-right) - Enhanced
            const workbenchX = centerX + 100;
            const workbenchY = centerY;
            const workbenchFade = Math.min(1, this.cutsceneTime / 1.5);
            
            // Enhanced background workbench panel with gradient
            ctx.globalAlpha = workbenchFade;
            const workbenchGradient = ctx.createLinearGradient(workbenchX - 200, workbenchY - 150, workbenchX - 200, workbenchY + 150);
            workbenchGradient.addColorStop(0, 'rgba(255, 170, 68, 0.25)');
            workbenchGradient.addColorStop(0.5, 'rgba(255, 170, 68, 0.2)');
            workbenchGradient.addColorStop(1, 'rgba(255, 170, 68, 0.15)');
            ctx.fillStyle = workbenchGradient;
            ctx.fillRect(workbenchX - 200, workbenchY - 150, 400, 300);
            
            // Enhanced panel border with pulsing glow
            const panelGlow = 0.5 + Math.sin(this.cutsceneTime * 3) * 0.3;
            ctx.strokeStyle = `rgba(255, 170, 68, ${panelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchX - 200, workbenchY - 150, 400, 300);
            // Corner glows
            this.drawGlow(ctx, workbenchX - 200, workbenchY - 150, 25, `rgba(255, 170, 68, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY - 150, 25, `rgba(255, 170, 68, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX - 200, workbenchY + 150, 25, `rgba(255, 170, 68, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY + 150, 25, `rgba(255, 170, 68, ${panelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(255, 170, 68, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const x = workbenchX - 200 + (i * 100);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 150);
                ctx.lineTo(x, workbenchY + 150);
                ctx.stroke();
            }
            for (let i = 0; i < 4; i++) {
                const y = workbenchY - 150 + (i * 100);
                ctx.beginPath();
                ctx.moveTo(workbenchX - 200, y);
                ctx.lineTo(workbenchX + 200, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Construction progress (0-1 over time)
            const buildProgress = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 7));
            
            // Phase 1: Enhanced gathering complete description data (particles flowing in)
            if (buildProgress < 0.3) {
                const gatherProgress = buildProgress / 0.3;
                const particleCount = 30;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const startDist = 250;
                    const endDist = 100;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 * (1 - gatherProgress);
                    const size = 6 - gatherProgress * 2;
                    // Orange particles for complete description data with trails
                    this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha})`);
                    this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 170, 68, ${alpha * 0.5})`);
                    
                    // Particle trail
                    const trailAngle = angle - 0.1;
                    const trailDist = dist + 5;
                    const trailX = workbenchX + Math.cos(trailAngle) * trailDist;
                    const trailY = workbenchY + Math.sin(trailAngle) * trailDist * 0.7;
                    this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(255, 170, 68, ${alpha * 0.3})`);
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#ffaa44';
                ctx.font = '22px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering complete description data...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 2: Enhanced assembling description matrix core
            if (buildProgress >= 0.3 && buildProgress < 0.6) {
                const assembleProgress = (buildProgress - 0.3) / 0.3;
                
                // Enhanced matrix core (central structure) assembling
                const coreSize = 80 * assembleProgress;
                const corePulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.1;
                
                // Core gradient
                const coreGradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, coreSize * corePulse);
                coreGradient.addColorStop(0, 'rgba(255, 170, 68, 1)');
                coreGradient.addColorStop(0.5, 'rgba(255, 170, 68, 0.7)');
                coreGradient.addColorStop(1, 'rgba(255, 170, 68, 0.3)');
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, coreSize * corePulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Core glow with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, coreSize * corePulse, 'rgba(255, 170, 68, 0.8)');
                this.drawGlow(ctx, workbenchX, workbenchY, coreSize * corePulse + 20, 'rgba(255, 170, 68, 0.5)');
                this.drawGlow(ctx, workbenchX, workbenchY, coreSize * corePulse + 40, 'rgba(255, 170, 68, 0.3)');
                
                // Matrix grid pattern (appearing as it assembles)
                ctx.strokeStyle = `rgba(255, 170, 68, ${0.6 * assembleProgress})`;
                ctx.lineWidth = 2;
                const gridLines = Math.floor(assembleProgress * 8);
                for (let i = 0; i < gridLines; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x1 = workbenchX + Math.cos(angle) * (coreSize * 0.3);
                    const y1 = workbenchY + Math.sin(angle) * (coreSize * 0.3);
                    const x2 = workbenchX + Math.cos(angle) * (coreSize * 0.8);
                    const y2 = workbenchY + Math.sin(angle) * (coreSize * 0.8);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#ffaa44';
                ctx.font = '22px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling description matrix core...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 3: Enhanced completing the matrix structure
            if (buildProgress >= 0.6 && buildProgress < 0.9) {
                const completeProgress = (buildProgress - 0.6) / 0.3;
                
                // Enhanced complete matrix structure
                const matrixSize = 80;
                const matrixPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
                
                // Matrix core (complete)
                const matrixGradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, matrixSize * matrixPulse);
                matrixGradient.addColorStop(0, 'rgba(255, 170, 68, 1)');
                matrixGradient.addColorStop(0.3, 'rgba(255, 170, 68, 0.8)');
                matrixGradient.addColorStop(0.6, 'rgba(255, 170, 68, 0.5)');
                matrixGradient.addColorStop(1, 'rgba(255, 170, 68, 0.2)');
                ctx.fillStyle = matrixGradient;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, matrixSize * matrixPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Enhanced matrix grid (complete pattern)
                ctx.strokeStyle = `rgba(255, 170, 68, ${0.7 + completeProgress * 0.3})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const x1 = workbenchX + Math.cos(angle) * (matrixSize * 0.3);
                    const y1 = workbenchY + Math.sin(angle) * (matrixSize * 0.3);
                    const x2 = workbenchX + Math.cos(angle) * (matrixSize * 0.9);
                    const y2 = workbenchY + Math.sin(angle) * (matrixSize * 0.9);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                
                // Enhanced connecting rings (showing complete structure)
                for (let ring = 0; ring < 3; ring++) {
                    const ringRadius = matrixSize * (0.4 + ring * 0.2);
                    const ringAlpha = (0.5 - ring * 0.1) * (0.5 + completeProgress * 0.5);
                    ctx.strokeStyle = `rgba(255, 170, 68, ${ringAlpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(workbenchX, workbenchY, ringRadius * matrixPulse, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Enhanced matrix glow with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, matrixSize * matrixPulse, 'rgba(255, 170, 68, 0.9)');
                this.drawGlow(ctx, workbenchX, workbenchY, matrixSize * matrixPulse + 30, 'rgba(255, 170, 68, 0.6)');
                this.drawGlow(ctx, workbenchX, workbenchY, matrixSize * matrixPulse + 50, 'rgba(255, 170, 68, 0.3)');
                
                // Enhanced text with glow
                ctx.fillStyle = '#ffaa44';
                ctx.font = '22px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.fillText('Completing matrix structure...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 4: Enhanced final activation (complete description technology ready)
            if (buildProgress >= 0.9) {
                const activateProgress = (buildProgress - 0.9) / 0.1;
                
                // Enhanced complete matrix (fully active)
                const matrixSize = 80;
                const matrixPulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.2;
                
                // Matrix core with enhanced pulsing
                const matrixGradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, matrixSize * matrixPulse);
                matrixGradient.addColorStop(0, 'rgba(255, 170, 68, 1)');
                matrixGradient.addColorStop(0.2, 'rgba(255, 170, 68, 0.9)');
                matrixGradient.addColorStop(0.5, 'rgba(255, 170, 68, 0.7)');
                matrixGradient.addColorStop(1, 'rgba(255, 170, 68, 0.3)');
                ctx.fillStyle = matrixGradient;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, matrixSize * matrixPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Enhanced active matrix grid with pulsing
                ctx.strokeStyle = `rgba(255, 170, 68, ${0.9 + Math.sin(this.cutsceneTime * 5) * 0.1})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 15;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + this.cutsceneTime * 0.5;
                    const x1 = workbenchX + Math.cos(angle) * (matrixSize * 0.3);
                    const y1 = workbenchY + Math.sin(angle) * (matrixSize * 0.3);
                    const x2 = workbenchX + Math.cos(angle) * (matrixSize * 0.9);
                    const y2 = workbenchY + Math.sin(angle) * (matrixSize * 0.9);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
                
                // Enhanced active rings with pulsing
                for (let ring = 0; ring < 5; ring++) {
                    const ringRadius = matrixSize * (0.3 + ring * 0.15);
                    const ringAlpha = (0.6 - ring * 0.1) + Math.sin(this.cutsceneTime * 3 + ring) * 0.2;
                    ctx.strokeStyle = `rgba(255, 170, 68, ${ringAlpha})`;
                    ctx.lineWidth = 2 + ring;
                    ctx.beginPath();
                    ctx.arc(workbenchX, workbenchY, ringRadius * matrixPulse, 0, Math.PI * 2);
                    ctx.stroke();
                    // Ring glow
                    this.drawGlow(ctx, workbenchX, workbenchY, ringRadius * matrixPulse, `rgba(255, 170, 68, ${ringAlpha * 0.3})`);
                }
                
                // Enhanced energy particles (active state)
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2 + this.cutsceneTime * 2;
                    const dist = matrixSize * (0.5 + Math.sin(this.cutsceneTime + i) * 0.3);
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist;
                    const alpha = 0.7 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                    const size = 4 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                    this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha})`);
                }
                
                // Enhanced matrix glow with multiple pulsing layers
                this.drawGlow(ctx, workbenchX, workbenchY, matrixSize * matrixPulse, 'rgba(255, 170, 68, 1)');
                this.drawGlow(ctx, workbenchX, workbenchY, matrixSize * matrixPulse + 40, 'rgba(255, 170, 68, 0.7)');
                this.drawGlow(ctx, workbenchX, workbenchY, matrixSize * matrixPulse + 70, 'rgba(255, 170, 68, 0.4)');
                this.drawGlow(ctx, workbenchX, workbenchY, matrixSize * matrixPulse + 100, 'rgba(255, 170, 68, 0.2)');
                
                // Enhanced success text with glow
                const textFade = Math.min(1, activateProgress * 2);
                ctx.globalAlpha = textFade;
                const textGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
                this.drawGlow(ctx, workbenchX, workbenchY + 100, 200, `rgba(255, 170, 68, ${textGlow * textFade * 0.2})`);
                
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 26px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 15;
                ctx.fillText('Complete Description Technology', workbenchX, workbenchY + 100);
                ctx.fillText('Foundation Ready!', workbenchX, workbenchY + 130);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 3 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(25);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[3]) {
                    let text = cutsceneData.texts[3].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        }
    }
    
    // Level 35: Bell's Theorem
    // Level 35: Bell's Theorem - Enhanced
    drawCutsceneLevel35(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced dramatic "BUT BELL!" with particles representing the "choir"
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a0a');
            bgGradient.addColorStop(0.3, '#0f0505');
            bgGradient.addColorStop(0.6, '#0a0303');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid (warning field) with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(255, 68, 68, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced warning theme)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 68, 68, ${alpha})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced warning/alert pattern with multiple layers
            for (let layer = 0; layer < 2; layer++) {
                const layerDist = 100 + layer * 50;
                const layerSpeed = 0.5 + layer * 0.3;
                for (let i = 0; i < 10 + layer * 5; i++) {
                    const angle = (i / (10 + layer * 5)) * Math.PI * 2 + this.cutsceneTime * layerSpeed;
                    const x = centerX + Math.cos(angle) * layerDist;
                    const y = centerY + Math.sin(angle) * layerDist;
                    const alpha = (0.2 + layer * 0.1) + Math.sin(this.cutsceneTime * 2 + i) * (0.1 + layer * 0.05);
                    const size = 30 + layer * 10;
                    this.drawGlow(ctx, x, y, size, `rgba(255, 68, 68, ${alpha * fade})`);
                }
            }
            
            // Enhanced "BUT BELL!" text with dramatic effects and multi-layer glow
            const scale = 1 + Math.sin(this.cutsceneTime * 4) * 0.15;
            const rotation = Math.sin(this.cutsceneTime * 2) * 0.05;
            
            // Enhanced multi-layer text glow
            const textGlow = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, centerX, h * 0.4, 200, `rgba(255, 68, 68, ${textGlow * fade * 0.3})`);
            this.drawGlow(ctx, centerX, h * 0.4, 150, `rgba(255, 68, 68, ${textGlow * fade * 0.5})`);
            this.drawGlow(ctx, centerX, h * 0.4, 100, `rgba(255, 68, 68, ${textGlow * fade * 0.7})`);
            
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 40;
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 72px Arial';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(centerX, h * 0.4);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            ctx.fillText('BUT BELL!', 0, 0);
            ctx.restore();
            ctx.shadowBlur = 0;
            
            // Enhanced subtitle with glow
            const subtitleFade = Math.min(1, (this.cutsceneTime - 0.5) / 1);
            ctx.globalAlpha = fade * subtitleFade;
            this.drawGlow(ctx, centerX, h * 0.5, 150, `rgba(255, 68, 68, ${subtitleFade * 0.2})`);
            ctx.fillStyle = 'rgba(255, 68, 68, 0.9)';
            ctx.font = 'bold 24px Arial';
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 15;
            ctx.fillText('"Bell\'s theorem proves', centerX, h * 0.5);
            ctx.fillText('local hidden variables impossible!"', centerX, h * 0.55);
            ctx.shadowBlur = 0;
            
            // Enhanced particles representing the "choir" (many voices saying this) with trails
            for (let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 2 + this.cutsceneTime * 0.5;
                const dist = 180 + Math.sin(i * 0.5 + this.cutsceneTime) * 40;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const alpha = (0.5 + Math.sin(this.cutsceneTime * 3 + i) * 0.3) * fade;
                const size = 5 + Math.sin(this.cutsceneTime * 2 + i) * 3;
                this.drawGlow(ctx, x, y, size, `rgba(255, 68, 68, ${alpha})`);
                this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 68, 68, ${alpha * 0.5})`);
                
                // Particle trail
                const trailAngle = angle - 0.1;
                const trailDist = dist - 5;
                const trailX = centerX + Math.cos(trailAngle) * trailDist;
                const trailY = centerY + Math.sin(trailAngle) * trailDist;
                this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(255, 68, 68, ${alpha * 0.3})`);
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(35);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced correlated pairs (A and B) with entanglement visualization
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(79, 195, 247, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            const leftX = w * 0.3;
            const rightX = w * 0.7;
            
            // Enhanced title with glow
            const titleGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, centerX, h * 0.2, 150, `rgba(79, 195, 247, ${titleGlow * 0.2})`);
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 15;
            ctx.fillText('Bell\'s Theorem Focus:', centerX, h * 0.2);
            ctx.shadowBlur = 0;
            ctx.font = 'bold 24px Arial';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 10;
            ctx.fillText('CORRELATED PAIRS', centerX, h * 0.25);
            ctx.shadowBlur = 0;
            
            // Enhanced System A (left) with multiple glow layers
            const aPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            const aGradient = ctx.createRadialGradient(leftX, centerY, 0, leftX, centerY, 45 * aPulse);
            aGradient.addColorStop(0, '#66d4ff');
            aGradient.addColorStop(0.5, '#4fc3f7');
            aGradient.addColorStop(1, '#29b6f6');
            ctx.fillStyle = aGradient;
            ctx.beginPath();
            ctx.arc(leftX, centerY, 45 * aPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, leftX, centerY, 45 * aPulse, 'rgba(79, 195, 247, 0.8)');
            this.drawGlow(ctx, leftX, centerY, 60 * aPulse, 'rgba(79, 195, 247, 0.5)');
            this.drawGlow(ctx, leftX, centerY, 80 * aPulse, 'rgba(79, 195, 247, 0.3)');
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 10;
            ctx.fillText('A', leftX, centerY + 12);
            ctx.shadowBlur = 0;
            
            // Enhanced System B (right) with multiple glow layers
            const bPulse = 1 + Math.sin(this.cutsceneTime * 2 + Math.PI) * 0.1;
            const bGradient = ctx.createRadialGradient(rightX, centerY, 0, rightX, centerY, 45 * bPulse);
            bGradient.addColorStop(0, '#66d4ff');
            bGradient.addColorStop(0.5, '#4fc3f7');
            bGradient.addColorStop(1, '#29b6f6');
            ctx.fillStyle = bGradient;
            ctx.beginPath();
            ctx.arc(rightX, centerY, 45 * bPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, rightX, centerY, 45 * bPulse, 'rgba(79, 195, 247, 0.8)');
            this.drawGlow(ctx, rightX, centerY, 60 * bPulse, 'rgba(79, 195, 247, 0.5)');
            this.drawGlow(ctx, rightX, centerY, 80 * bPulse, 'rgba(79, 195, 247, 0.3)');
            
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 10;
            ctx.fillText('B', rightX, centerY + 12);
            ctx.shadowBlur = 0;
            
            // Enhanced entanglement connection (animated wave/particles) with trails
            const connectionWidth = rightX - leftX - 90;
            for (let layer = 0; layer < 2; layer++) {
                const layerCount = 8 + layer * 4;
                const layerSpeed = 0.3 + layer * 0.2;
                for (let i = 0; i < layerCount; i++) {
                    const progress = (i / layerCount) + (this.cutsceneTime * layerSpeed) % 1;
                const x = leftX + 45 + progress * connectionWidth;
                    const y = centerY + Math.sin(progress * Math.PI * 4 + this.cutsceneTime * 2) * (15 + layer * 5);
                    const alpha = (0.6 + layer * 0.1) + Math.sin(progress * Math.PI * 2) * (0.3 - layer * 0.1);
                    const size = (6 + layer * 2) + Math.sin(progress * Math.PI * 3) * 2;
                    this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha})`);
                    this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 170, 68, ${alpha * 0.5})`);
                    
                    // Particle trail
                    const trailX = x - (connectionWidth / layerCount) * 0.3;
                    this.drawGlow(ctx, trailX, y, size * 0.5, `rgba(255, 170, 68, ${alpha * 0.3})`);
                }
            }
            
            // Enhanced connection line (correlation) with pulsing glow
            const connectionPulse = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.3;
            ctx.strokeStyle = `rgba(255, 170, 68, ${connectionPulse})`;
            ctx.lineWidth = 5;
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(leftX + 45, centerY);
            ctx.lineTo(rightX - 45, centerY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;
            
            // Connection glow
            this.drawGlow(ctx, centerX, centerY, 5, `rgba(255, 170, 68, ${connectionPulse * 0.4})`);
            
            // Enhanced label with glow (fade in after 1 second)
            const labelFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (labelFade > 0) {
                ctx.globalAlpha = labelFade;
                this.drawGlow(ctx, centerX, centerY - 80, 120, `rgba(255, 170, 68, ${labelFade * 0.2})`);
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 22px Arial';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
            ctx.fillText('Correlated Pair (A and B)', centerX, centerY - 80);
                ctx.shadowBlur = 0;
            ctx.font = '18px Arial';
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 8;
            ctx.fillText('Measurements on BOTH systems', centerX, centerY - 50);
                ctx.shadowBlur = 0;
            }
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(35);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced Bell's logic requires both - show the requirement
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(79, 195, 247, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            const leftX = w * 0.3;
            const rightX = w * 0.7;
            
            // Enhanced System A with pulsing and multiple glow layers
            const aPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            const aGradient = ctx.createRadialGradient(leftX, centerY, 0, leftX, centerY, 35 * aPulse);
            aGradient.addColorStop(0, '#66d4ff');
            aGradient.addColorStop(0.5, '#4fc3f7');
            aGradient.addColorStop(1, '#29b6f6');
            ctx.fillStyle = aGradient;
            ctx.beginPath();
            ctx.arc(leftX, centerY, 35 * aPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, leftX, centerY, 35 * aPulse, 'rgba(79, 195, 247, 0.8)');
            this.drawGlow(ctx, leftX, centerY, 50 * aPulse, 'rgba(79, 195, 247, 0.5)');
            this.drawGlow(ctx, leftX, centerY, 70 * aPulse, 'rgba(79, 195, 247, 0.3)');
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 10;
            ctx.fillText('A', leftX, centerY + 10);
            ctx.shadowBlur = 0;
            
            // Enhanced System B with pulsing and multiple glow layers
            const bPulse = 1 + Math.sin(this.cutsceneTime * 2 + Math.PI) * 0.1;
            const bGradient = ctx.createRadialGradient(rightX, centerY, 0, rightX, centerY, 35 * bPulse);
            bGradient.addColorStop(0, '#66d4ff');
            bGradient.addColorStop(0.5, '#4fc3f7');
            bGradient.addColorStop(1, '#29b6f6');
            ctx.fillStyle = bGradient;
            ctx.beginPath();
            ctx.arc(rightX, centerY, 35 * bPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, rightX, centerY, 35 * bPulse, 'rgba(79, 195, 247, 0.8)');
            this.drawGlow(ctx, rightX, centerY, 50 * bPulse, 'rgba(79, 195, 247, 0.5)');
            this.drawGlow(ctx, rightX, centerY, 70 * bPulse, 'rgba(79, 195, 247, 0.3)');
            
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 10;
            ctx.fillText('B', rightX, centerY + 10);
            ctx.shadowBlur = 0;
            
            // Enhanced arrows pointing to both with pulsing glow
            const arrowPulse = 0.8 + Math.sin(this.cutsceneTime * 3) * 0.2;
            ctx.strokeStyle = `rgba(255, 68, 68, ${arrowPulse})`;
            ctx.lineWidth = 5;
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            // Arrow to A
            ctx.moveTo(centerX - 50, centerY - 60);
            ctx.lineTo(leftX, centerY - 35);
            ctx.lineTo(leftX - 10, centerY - 45);
            ctx.moveTo(leftX, centerY - 35);
            ctx.lineTo(leftX + 10, centerY - 45);
            // Arrow to B
            ctx.moveTo(centerX + 50, centerY - 60);
            ctx.lineTo(rightX, centerY - 35);
            ctx.lineTo(rightX - 10, centerY - 45);
            ctx.moveTo(rightX, centerY - 35);
            ctx.lineTo(rightX + 10, centerY - 45);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Arrow glows
            this.drawGlow(ctx, leftX, centerY - 35, 15, `rgba(255, 68, 68, ${arrowPulse * 0.4})`);
            this.drawGlow(ctx, rightX, centerY - 35, 15, `rgba(255, 68, 68, ${arrowPulse * 0.4})`);
            
            // Enhanced main text with glow (fade in after 1 second)
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                
                const titleGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, centerY - 80, 150, `rgba(255, 255, 255, ${titleGlow * textFade * 0.2})`);
                this.drawGlow(ctx, centerX, centerY + 50, 180, `rgba(255, 170, 68, ${textFade * 0.2})`);
                
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 15;
            ctx.fillText('Bell\'s Theorem:', centerX, centerY - 80);
                ctx.shadowBlur = 0;
                ctx.font = 'bold 22px Arial';
            ctx.fillStyle = '#ffaa44';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 12;
            ctx.fillText('Requires measurements', centerX, centerY + 50);
            ctx.fillText('on BOTH A and B', centerX, centerY + 80);
                ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
            ctx.fillText('(Correlated pairs only!)', centerX, centerY + 110);
                ctx.shadowBlur = 0;
            }
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(35);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 3) {
            // Phase 3: Enhanced Einstein building Complete Description Matrix & Individual Stabilizer
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(79, 195, 247, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship working glow
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(79, 195, 247, ${workGlow * 0.2})`);
            
            // Two workbenches side by side
            const workbenchLeftX = centerX - 50;
            const workbenchRightX = centerX + 150;
            const workbenchY = centerY;
            const workbenchFade = Math.min(1, this.cutsceneTime / 1.5);
            
            // Construction progress (0-1 over time)
            const buildProgress = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 7));
            
            // Enhanced LEFT WORKBENCH: Complete Description Matrix with gradient panel
            ctx.globalAlpha = workbenchFade;
            const leftPanelGradient = ctx.createLinearGradient(workbenchLeftX - 150, workbenchY - 120, workbenchLeftX - 150, workbenchY + 120);
            leftPanelGradient.addColorStop(0, 'rgba(79, 195, 247, 0.25)');
            leftPanelGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.2)');
            leftPanelGradient.addColorStop(1, 'rgba(79, 195, 247, 0.15)');
            ctx.fillStyle = leftPanelGradient;
            ctx.fillRect(workbenchLeftX - 150, workbenchY - 120, 300, 240);
            
            // Enhanced panel border with pulsing glow
            const leftPanelGlow = 0.5 + Math.sin(this.cutsceneTime * 3) * 0.3;
            ctx.strokeStyle = `rgba(79, 195, 247, ${leftPanelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchLeftX - 150, workbenchY - 120, 300, 240);
            // Corner glows
            this.drawGlow(ctx, workbenchLeftX - 150, workbenchY - 120, 25, `rgba(79, 195, 247, ${leftPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchLeftX + 150, workbenchY - 120, 25, `rgba(79, 195, 247, ${leftPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchLeftX - 150, workbenchY + 120, 25, `rgba(79, 195, 247, ${leftPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchLeftX + 150, workbenchY + 120, 25, `rgba(79, 195, 247, ${leftPanelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const x = workbenchLeftX - 150 + (i * 75);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 120);
                ctx.lineTo(x, workbenchY + 120);
                ctx.stroke();
            }
            for (let i = 0; i < 4; i++) {
                const y = workbenchY - 120 + (i * 80);
                ctx.beginPath();
                ctx.moveTo(workbenchLeftX - 150, y);
                ctx.lineTo(workbenchLeftX + 150, y);
                ctx.stroke();
            }
            
            // Enhanced RIGHT WORKBENCH: Individual Stabilizer with gradient panel
            const rightPanelGradient = ctx.createLinearGradient(workbenchRightX - 150, workbenchY - 120, workbenchRightX - 150, workbenchY + 120);
            rightPanelGradient.addColorStop(0, 'rgba(255, 170, 68, 0.25)');
            rightPanelGradient.addColorStop(0.5, 'rgba(255, 170, 68, 0.2)');
            rightPanelGradient.addColorStop(1, 'rgba(255, 170, 68, 0.15)');
            ctx.fillStyle = rightPanelGradient;
            ctx.fillRect(workbenchRightX - 150, workbenchY - 120, 300, 240);
            
            // Enhanced panel border with pulsing glow
            const rightPanelGlow = 0.5 + Math.sin(this.cutsceneTime * 3 + Math.PI) * 0.3;
            ctx.strokeStyle = `rgba(255, 170, 68, ${rightPanelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchRightX - 150, workbenchY - 120, 300, 240);
            // Corner glows
            this.drawGlow(ctx, workbenchRightX - 150, workbenchY - 120, 25, `rgba(255, 170, 68, ${rightPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchRightX + 150, workbenchY - 120, 25, `rgba(255, 170, 68, ${rightPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchRightX - 150, workbenchY + 120, 25, `rgba(255, 170, 68, ${rightPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchRightX + 150, workbenchY + 120, 25, `rgba(255, 170, 68, ${rightPanelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(255, 170, 68, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const x = workbenchRightX - 150 + (i * 75);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 120);
                ctx.lineTo(x, workbenchY + 120);
                ctx.stroke();
            }
            for (let i = 0; i < 4; i++) {
                const y = workbenchY - 120 + (i * 80);
                ctx.beginPath();
                ctx.moveTo(workbenchRightX - 150, y);
                ctx.lineTo(workbenchRightX + 150, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Phase 1: Gathering materials (0-30%)
            if (buildProgress < 0.3) {
                const gatherProgress = buildProgress / 0.3;
                
                // Left: Matrix data particles (cyan)
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const startDist = 200;
                    const endDist = 80;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchLeftX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 * (1 - gatherProgress);
                    this.drawGlow(ctx, x, y, 4, `rgba(79, 195, 247, ${alpha})`);
                }
                
                // Right: Stabilizer particles (orange)
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const startDist = 200;
                    const endDist = 80;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchRightX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 * (1 - gatherProgress);
                    this.drawGlow(ctx, x, y, 4, `rgba(255, 170, 68, ${alpha})`);
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering description data...', workbenchLeftX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffaa44';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering stabilization data...', workbenchRightX, workbenchY + 100);
                ctx.shadowBlur = 0;
            }
            
            // Phase 2: Assembling cores (30-60%)
            if (buildProgress >= 0.3 && buildProgress < 0.6) {
                const assembleProgress = (buildProgress - 0.3) / 0.3;
                
                // Left: Matrix grid assembling
                const gridSize = 60 * assembleProgress;
                ctx.strokeStyle = `rgba(79, 195, 247, ${0.5 + assembleProgress * 0.5})`;
                ctx.lineWidth = 2;
                const gridCells = Math.floor(4 * assembleProgress);
                for (let i = 0; i <= gridCells; i++) {
                    for (let j = 0; j <= gridCells; j++) {
                        const x = workbenchLeftX - gridSize/2 + (i / 4) * gridSize;
                        const y = workbenchY - gridSize/2 + (j / 4) * gridSize;
                        ctx.strokeRect(x, y, gridSize/4, gridSize/4);
                    }
                }
                this.drawGlow(ctx, workbenchLeftX, workbenchY, gridSize/2, `rgba(79, 195, 247, ${assembleProgress * 0.5})`);
                
                // Right: Ship core assembling
                const shipSize = 30 * assembleProgress;
                ctx.fillStyle = `rgba(255, 170, 68, ${0.5 + assembleProgress * 0.5})`;
                ctx.beginPath();
                ctx.moveTo(workbenchRightX, workbenchY - shipSize);
                ctx.lineTo(workbenchRightX - shipSize * 0.75, workbenchY + shipSize * 0.5);
                ctx.lineTo(workbenchRightX, workbenchY + shipSize * 0.25);
                ctx.lineTo(workbenchRightX + shipSize * 0.75, workbenchY + shipSize * 0.5);
                ctx.closePath();
                ctx.fill();
                this.drawGlow(ctx, workbenchRightX, workbenchY, shipSize, `rgba(255, 170, 68, ${assembleProgress * 0.5})`);
                
                // Enhanced text with glow
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling matrix core...', workbenchLeftX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffaa44';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling stabilizer core...', workbenchRightX, workbenchY + 100);
                ctx.shadowBlur = 0;
            }
            
            // Phase 3: Completing structures (60-85%)
            if (buildProgress >= 0.6 && buildProgress < 0.85) {
                const completeProgress = (buildProgress - 0.6) / 0.25;
                
                // Left: Complete Matrix (full grid)
                ctx.strokeStyle = 'rgba(79, 195, 247, 1)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        const x = workbenchLeftX - 30 + i * 20;
                        const y = workbenchY - 30 + j * 20;
                        ctx.strokeRect(x, y, 15, 15);
                    }
                }
                this.drawGlow(ctx, workbenchLeftX, workbenchY, 40, 'rgba(79, 195, 247, 0.6)');
                
                // Matrix activation (cells lighting up)
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        if (completeProgress > (i + j) / 8) {
                            const x = workbenchLeftX - 30 + i * 20 + 7.5;
                            const y = workbenchY - 30 + j * 20 + 7.5;
                            this.drawGlow(ctx, x, y, 5, 'rgba(79, 195, 247, 0.8)');
                        }
                    }
                }
                
                // Right: Complete Ship
                ctx.fillStyle = 'rgba(255, 170, 68, 1)';
                ctx.beginPath();
                ctx.moveTo(workbenchRightX, workbenchY - 20);
                ctx.lineTo(workbenchRightX - 15, workbenchY + 10);
                ctx.lineTo(workbenchRightX, workbenchY + 5);
                ctx.lineTo(workbenchRightX + 15, workbenchY + 10);
                ctx.closePath();
                ctx.fill();
                this.drawGlow(ctx, workbenchRightX, workbenchY, 25, 'rgba(255, 170, 68, 0.6)');
                
                // Stabilizer field (pulsing rings)
                const pulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
                for (let ring = 0; ring < 3; ring++) {
                    const radius = (20 + ring * 10) * pulse * completeProgress;
                    ctx.strokeStyle = `rgba(255, 170, 68, ${0.6 - ring * 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(workbenchRightX, workbenchY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.fillText('Activating matrix...', workbenchLeftX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffaa44';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.fillText('Energizing stabilizer...', workbenchRightX, workbenchY + 100);
                ctx.shadowBlur = 0;
            }
            
            // Phase 4: Finalizing and testing (85-100%)
            if (buildProgress >= 0.85) {
                const finalizeProgress = (buildProgress - 0.85) / 0.15;
                
                // Left: Complete Matrix (fully lit)
                ctx.strokeStyle = 'rgba(79, 195, 247, 1)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        const x = workbenchLeftX - 30 + i * 20;
                        const y = workbenchY - 30 + j * 20;
                        ctx.strokeRect(x, y, 15, 15);
                        const cellX = x + 7.5;
                        const cellY = y + 7.5;
                        this.drawGlow(ctx, cellX, cellY, 5, 'rgba(79, 195, 247, 0.9)');
                    }
                }
                this.drawGlow(ctx, workbenchLeftX, workbenchY, 50, 'rgba(79, 195, 247, 0.7)');
                
                // Right: Complete Ship with active stabilizer
                ctx.fillStyle = 'rgba(255, 170, 68, 1)';
                ctx.beginPath();
                ctx.moveTo(workbenchRightX, workbenchY - 20);
                ctx.lineTo(workbenchRightX - 15, workbenchY + 10);
                ctx.lineTo(workbenchRightX, workbenchY + 5);
                ctx.lineTo(workbenchRightX + 15, workbenchY + 10);
                ctx.closePath();
                ctx.fill();
                this.drawGlow(ctx, workbenchRightX, workbenchY, 25, 'rgba(255, 170, 68, 0.8)');
                
                // Active stabilizer field
                const pulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
                for (let ring = 0; ring < 3; ring++) {
                    const radius = (20 + ring * 10) * pulse;
                    ctx.strokeStyle = `rgba(255, 170, 68, ${0.7 - ring * 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(workbenchRightX, workbenchY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Success particles
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2 + this.cutsceneTime * 2;
                    const dist = 60 + Math.sin(this.cutsceneTime * 3 + i) * 20;
                    // Left particles (cyan)
                    const leftX = workbenchLeftX + Math.cos(angle) * dist;
                    const leftY = workbenchY + Math.sin(angle) * dist * 0.7;
                    this.drawGlow(ctx, leftX, leftY, 4, `rgba(79, 195, 247, ${0.6 + Math.sin(this.cutsceneTime * 4 + i) * 0.4})`);
                    // Right particles (orange)
                    const rightX = workbenchRightX + Math.cos(angle) * dist;
                    const rightY = workbenchY + Math.sin(angle) * dist * 0.7;
                    this.drawGlow(ctx, rightX, rightY, 4, `rgba(255, 170, 68, ${0.6 + Math.sin(this.cutsceneTime * 4 + i) * 0.4})`);
                }
                
                // Enhanced text with glow
                const textFade = Math.min(1, finalizeProgress * 2);
                ctx.globalAlpha = textFade;
                const leftTextGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
                const rightTextGlow = 0.7 + Math.sin(this.cutsceneTime * 2 + Math.PI) * 0.3;
                this.drawGlow(ctx, workbenchLeftX, workbenchY + 100, 150, `rgba(79, 195, 247, ${leftTextGlow * textFade * 0.2})`);
                this.drawGlow(ctx, workbenchRightX, workbenchY + 100, 150, `rgba(255, 170, 68, ${rightTextGlow * textFade * 0.2})`);
                
                ctx.fillStyle = '#4fc3f7';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
                ctx.fillText('MATRIX COMPLETE!', workbenchLeftX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffaa44';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 15;
                ctx.fillText('STABILIZER COMPLETE!', workbenchRightX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Enhanced connection lines from ship to workbenches with glow
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(shipX + 30, shipY);
            ctx.lineTo(workbenchLeftX - 150, workbenchY);
            ctx.moveTo(shipX + 30, shipY);
            ctx.lineTo(workbenchRightX - 150, workbenchY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;
            
            // Set foreground text for phase 3 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(35);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[3]) {
                    let text = cutsceneData.texts[3].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 10px rgba(79, 195, 247, 0.8), 0 0 20px rgba(79, 195, 247, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        }
    }
    
    // Level 40: The Sidestep - Enhanced
    // Level 40: The Sidestep - Enhanced
    drawCutsceneLevel40(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced show A or B (not both) - the key insight
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0f0510');
            bgGradient.addColorStop(0.6, '#0a0505');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(255, 170, 68, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced orange theme)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced title with multi-layer glow
            const titleGlow = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, centerX, h * 0.15, 200, `rgba(255, 170, 68, ${titleGlow * fade * 0.3})`);
            this.drawGlow(ctx, centerX, h * 0.15, 150, `rgba(255, 170, 68, ${titleGlow * fade * 0.5})`);
            this.drawGlow(ctx, centerX, h * 0.15, 100, `rgba(255, 170, 68, ${titleGlow * fade * 0.7})`);
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('THE SIDESTEP', centerX, h * 0.15);
            ctx.shadowBlur = 0;
            
            // Enhanced subtitle with glow
            const subtitleFade = Math.min(1, (this.cutsceneTime - 0.5) / 1);
            ctx.globalAlpha = fade * subtitleFade;
            this.drawGlow(ctx, centerX, h * 0.22, 150, `rgba(255, 170, 68, ${subtitleFade * 0.2})`);
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.font = 'bold 22px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 12;
            ctx.fillText('If you only have A or B (not correlated pairs)', centerX, h * 0.22);
            ctx.shadowBlur = 0;
            
            ctx.globalAlpha = fade;
            
            // Show A OR B (not correlated) - enhanced alternating/split display
            const leftX = w * 0.35;
            const rightX = w * 0.65;
            
            // Enhanced System A (left side) with pulsing and multiple glow layers
            const aAlpha = 0.5 + Math.sin(this.cutsceneTime * 2) * 0.5;
            const aPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            const aGradient = ctx.createRadialGradient(leftX, centerY, 0, leftX, centerY, 55 * aPulse);
            aGradient.addColorStop(0, `rgba(79, 195, 247, ${aAlpha})`);
            aGradient.addColorStop(0.5, `rgba(79, 195, 247, ${aAlpha * 0.8})`);
            aGradient.addColorStop(1, `rgba(79, 195, 247, ${aAlpha * 0.4})`);
            ctx.fillStyle = aGradient;
            ctx.beginPath();
            ctx.arc(leftX, centerY, 55 * aPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, leftX, centerY, 55 * aPulse, `rgba(79, 195, 247, ${aAlpha * 0.9})`);
            this.drawGlow(ctx, leftX, centerY, 75 * aPulse, `rgba(79, 195, 247, ${aAlpha * 0.5})`);
            this.drawGlow(ctx, leftX, centerY, 95 * aPulse, `rgba(79, 195, 247, ${aAlpha * 0.3})`);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 15;
            ctx.fillText('A', leftX, centerY + 18);
            ctx.shadowBlur = 0;
            
            // Enhanced "OR" text in center with glow
            const orGlow = 0.6 + Math.sin(this.cutsceneTime * 4) * 0.4;
            this.drawGlow(ctx, centerX, centerY, 80, `rgba(255, 255, 255, ${orGlow * fade * 0.3})`);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 40px Arial';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.fillText('OR', centerX, centerY);
            ctx.shadowBlur = 0;
            
            // Enhanced System B (right side) with pulsing and multiple glow layers
            const bAlpha = 0.5 + Math.cos(this.cutsceneTime * 2) * 0.5;
            const bPulse = 1 + Math.cos(this.cutsceneTime * 2) * 0.1;
            const bGradient = ctx.createRadialGradient(rightX, centerY, 0, rightX, centerY, 55 * bPulse);
            bGradient.addColorStop(0, `rgba(255, 170, 68, ${bAlpha})`);
            bGradient.addColorStop(0.5, `rgba(255, 170, 68, ${bAlpha * 0.8})`);
            bGradient.addColorStop(1, `rgba(255, 170, 68, ${bAlpha * 0.4})`);
            ctx.fillStyle = bGradient;
            ctx.beginPath();
            ctx.arc(rightX, centerY, 55 * bPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, rightX, centerY, 55 * bPulse, `rgba(255, 170, 68, ${bAlpha * 0.9})`);
            this.drawGlow(ctx, rightX, centerY, 75 * bPulse, `rgba(255, 170, 68, ${bAlpha * 0.5})`);
            this.drawGlow(ctx, rightX, centerY, 95 * bPulse, `rgba(255, 170, 68, ${bAlpha * 0.3})`);
            
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.fillText('B', rightX, centerY + 18);
            ctx.shadowBlur = 0;
            
            // Enhanced key text with glow
            const keyTextFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            ctx.globalAlpha = fade * keyTextFade;
            this.drawGlow(ctx, centerX, h * 0.75, 150, `rgba(255, 170, 68, ${keyTextFade * 0.2})`);
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.font = 'bold 20px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            ctx.fillText('Not correlated pairs!', centerX, h * 0.75);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(40);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced show sidestep - Bell's theorem doesn't apply
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(255, 170, 68, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced Bell's theorem text (faded/crossed out) with glow
            const bellTextGlow = 0.4 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, centerX, centerY - 80, 150, `rgba(255, 68, 68, ${bellTextGlow * 0.2})`);
            ctx.fillStyle = 'rgba(255, 68, 68, 0.4)';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 15;
            ctx.fillText('Bell\'s Theorem', centerX, centerY - 80);
            ctx.shadowBlur = 0;
            
            // Enhanced cross-out line with pulsing glow
            const crossPulse = 0.8 + Math.sin(this.cutsceneTime * 3) * 0.2;
            ctx.strokeStyle = `rgba(255, 68, 68, ${crossPulse})`;
            ctx.lineWidth = 8;
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(centerX - 120, centerY - 100);
            ctx.lineTo(centerX + 120, centerY - 60);
            ctx.stroke();
            ctx.shadowBlur = 0;
            // Cross-out glow
            this.drawGlow(ctx, centerX, centerY - 80, 5, `rgba(255, 68, 68, ${crossPulse * 0.4})`);
            
            // Enhanced "Doesn't Apply!" text with glow
            const doesntApplyGlow = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, centerX, centerY - 40, 120, `rgba(255, 68, 68, ${doesntApplyGlow * 0.3})`);
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 28px Arial';
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 20;
            ctx.fillText('Doesn\'t Apply!', centerX, centerY - 40);
            ctx.shadowBlur = 0;
            
            // Enhanced individual system (highlighted) - A or B alone with multiple glow layers
            const systemX = centerX;
            const systemY = centerY + 40;
            const pulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
            
            const systemGradient = ctx.createRadialGradient(systemX, systemY, 0, systemX, systemY, 60 * pulse);
            systemGradient.addColorStop(0, '#ffaa44');
            systemGradient.addColorStop(0.3, '#ff8800');
            systemGradient.addColorStop(0.6, '#ff6600');
            systemGradient.addColorStop(1, '#cc5500');
            ctx.fillStyle = systemGradient;
            ctx.beginPath();
            ctx.arc(systemX, systemY, 60 * pulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, systemX, systemY, 60 * pulse, 'rgba(255, 170, 68, 0.9)');
            this.drawGlow(ctx, systemX, systemY, 80 * pulse, 'rgba(255, 170, 68, 0.6)');
            this.drawGlow(ctx, systemX, systemY, 100 * pulse, 'rgba(255, 170, 68, 0.3)');
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 40px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.fillText('A or B', systemX, systemY + 15);
            ctx.shadowBlur = 0;
            
            // Enhanced explanation text with glow
            const explanationFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            ctx.globalAlpha = explanationFade;
            this.drawGlow(ctx, centerX, h * 0.75, 150, `rgba(255, 170, 68, ${explanationFade * 0.2})`);
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 24px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 12;
            ctx.fillText('Individual systems', centerX, h * 0.75);
            ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 10;
            ctx.fillText('(Not correlated pairs)', centerX, h * 0.8);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(40);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced the realization - sidestepping Bell entirely
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0f0510');
            bgGradient.addColorStop(0.6, '#0a0505');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(255, 170, 68, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced orange theme)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced Einstein's ship with glow
            const shipX = centerX - 100;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship realization glow
            const realizationGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(255, 170, 68, ${realizationGlow * 0.2})`);
            
            // Enhanced path showing the sidestep (curved arrow) with pulsing glow
            const arrowPulse = 0.8 + Math.sin(this.cutsceneTime * 2) * 0.2;
            ctx.strokeStyle = `rgba(255, 170, 68, ${arrowPulse})`;
            ctx.lineWidth = 8;
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(centerX - 50, centerY);
            ctx.quadraticCurveTo(centerX, centerY - 80, centerX + 150, centerY);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Path glow
            this.drawGlow(ctx, centerX + 50, centerY - 40, 30, `rgba(255, 170, 68, ${arrowPulse * 0.4})`);
            
            // Enhanced arrowhead with glow
            ctx.beginPath();
            ctx.moveTo(centerX + 150, centerY);
            ctx.lineTo(centerX + 130, centerY - 20);
            ctx.moveTo(centerX + 150, centerY);
            ctx.lineTo(centerX + 130, centerY + 20);
            ctx.stroke();
            this.drawGlow(ctx, centerX + 150, centerY, 20, `rgba(255, 170, 68, ${arrowPulse * 0.5})`);
            
            // Enhanced particles following the sidestep path with trails
            for (let layer = 0; layer < 2; layer++) {
                const layerCount = 12 + layer * 6;
                const layerSpeed = 0.3 + layer * 0.2;
                for (let i = 0; i < layerCount; i++) {
                    const progress = (this.cutsceneTime * layerSpeed + i * 0.1) % 1;
                const t = progress;
                const x = centerX - 50 + t * 200;
                const y = centerY - 80 * (4 * t * (1 - t)); // Quadratic curve
                    const alpha = (0.9 - layer * 0.1) - progress * (0.5 - layer * 0.1);
                    const size = (6 + layer * 2) + Math.sin(progress * Math.PI * 4) * (3 + layer);
                    if (alpha > 0 && size > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 170, 68, ${alpha * 0.5})`);
                        
                        // Particle trail
                        const trailProgress = Math.max(0, progress - 0.1);
                        const trailT = trailProgress;
                        const trailX = centerX - 50 + trailT * 200;
                        const trailY = centerY - 80 * (4 * trailT * (1 - trailT));
                        this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(255, 170, 68, ${alpha * 0.3})`);
                    }
                }
            }
            
            // Enhanced realization text with glow effects
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 2));
            ctx.globalAlpha = textFade;
            
            const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
            this.drawGlow(ctx, centerX, h * 0.25, 200, `rgba(255, 170, 68, ${textGlow * textFade * 0.2})`);
            this.drawGlow(ctx, centerX, h * 0.65, 220, `rgba(255, 170, 68, ${textFade * 0.2})`);
            
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.fillText('Einstein\'s later argument:', centerX, h * 0.25);
            ctx.fillText('About individual systems', centerX, h * 0.3);
            ctx.shadowBlur = 0;
            ctx.font = 'bold 24px Arial';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 12;
            ctx.fillText('NOT correlations', centerX, h * 0.65);
            ctx.fillText('This sidesteps Bell entirely!', centerX, h * 0.7);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(40);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 3) {
            // Phase 3: Enhanced Einstein building Ontological Reality Shield & Transformation Time Scanner
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(255, 170, 68, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (enhanced)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha})`);
            }
            
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship working glow
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(255, 170, 68, ${workGlow * 0.2})`);
            
            // Two workbenches side by side
            const workbenchLeftX = centerX - 50;
            const workbenchRightX = centerX + 150;
            const workbenchY = centerY;
            const workbenchFade = Math.min(1, this.cutsceneTime / 1.5);
            
            // Construction progress (0-1 over time)
            const buildProgress = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 7));
            
            // Enhanced LEFT WORKBENCH: Ontological Reality Shield with gradient panel
            ctx.globalAlpha = workbenchFade;
            const leftPanelGradient = ctx.createLinearGradient(workbenchLeftX - 150, workbenchY - 120, workbenchLeftX - 150, workbenchY + 120);
            leftPanelGradient.addColorStop(0, 'rgba(255, 170, 68, 0.25)');
            leftPanelGradient.addColorStop(0.5, 'rgba(255, 170, 68, 0.2)');
            leftPanelGradient.addColorStop(1, 'rgba(255, 170, 68, 0.15)');
            ctx.fillStyle = leftPanelGradient;
            ctx.fillRect(workbenchLeftX - 150, workbenchY - 120, 300, 240);
            
            // Enhanced panel border with pulsing glow
            const leftPanelGlow = 0.5 + Math.sin(this.cutsceneTime * 3) * 0.3;
            ctx.strokeStyle = `rgba(255, 170, 68, ${leftPanelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchLeftX - 150, workbenchY - 120, 300, 240);
            // Corner glows
            this.drawGlow(ctx, workbenchLeftX - 150, workbenchY - 120, 25, `rgba(255, 170, 68, ${leftPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchLeftX + 150, workbenchY - 120, 25, `rgba(255, 170, 68, ${leftPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchLeftX - 150, workbenchY + 120, 25, `rgba(255, 170, 68, ${leftPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchLeftX + 150, workbenchY + 120, 25, `rgba(255, 170, 68, ${leftPanelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(255, 170, 68, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const x = workbenchLeftX - 150 + (i * 75);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 120);
                ctx.lineTo(x, workbenchY + 120);
                ctx.stroke();
            }
            for (let i = 0; i < 4; i++) {
                const y = workbenchY - 120 + (i * 80);
                ctx.beginPath();
                ctx.moveTo(workbenchLeftX - 150, y);
                ctx.lineTo(workbenchLeftX + 150, y);
                ctx.stroke();
            }
            
            // Enhanced RIGHT WORKBENCH: Transformation Time Scanner with gradient panel
            const rightPanelGradient = ctx.createLinearGradient(workbenchRightX - 150, workbenchY - 120, workbenchRightX - 150, workbenchY + 120);
            rightPanelGradient.addColorStop(0, 'rgba(255, 107, 0, 0.25)');
            rightPanelGradient.addColorStop(0.5, 'rgba(255, 107, 0, 0.2)');
            rightPanelGradient.addColorStop(1, 'rgba(255, 107, 0, 0.15)');
            ctx.fillStyle = rightPanelGradient;
            ctx.fillRect(workbenchRightX - 150, workbenchY - 120, 300, 240);
            
            // Enhanced panel border with pulsing glow
            const rightPanelGlow = 0.5 + Math.sin(this.cutsceneTime * 3 + Math.PI) * 0.3;
            ctx.strokeStyle = `rgba(255, 107, 0, ${rightPanelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchRightX - 150, workbenchY - 120, 300, 240);
            // Corner glows
            this.drawGlow(ctx, workbenchRightX - 150, workbenchY - 120, 25, `rgba(255, 107, 0, ${rightPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchRightX + 150, workbenchY - 120, 25, `rgba(255, 107, 0, ${rightPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchRightX - 150, workbenchY + 120, 25, `rgba(255, 107, 0, ${rightPanelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchRightX + 150, workbenchY + 120, 25, `rgba(255, 107, 0, ${rightPanelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(255, 107, 0, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const x = workbenchRightX - 150 + (i * 75);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 120);
                ctx.lineTo(x, workbenchY + 120);
                ctx.stroke();
            }
            for (let i = 0; i < 4; i++) {
                const y = workbenchY - 120 + (i * 80);
                ctx.beginPath();
                ctx.moveTo(workbenchRightX - 150, y);
                ctx.lineTo(workbenchRightX + 150, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Phase 1: Gathering materials (0-30%)
            if (buildProgress < 0.3) {
                const gatherProgress = buildProgress / 0.3;
                
                // Left: Shield energy particles (orange/yellow)
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const startDist = 200;
                    const endDist = 80;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchLeftX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 * (1 - gatherProgress);
                    this.drawGlow(ctx, x, y, 4, `rgba(255, 170, 68, ${alpha})`);
                }
                
                // Right: Scanner time data particles (orange/red)
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const startDist = 200;
                    const endDist = 80;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchRightX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 * (1 - gatherProgress);
                    this.drawGlow(ctx, x, y, 4, `rgba(255, 107, 0, ${alpha})`);
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#ffaa44';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering ontological data...', workbenchLeftX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff6b00';
                ctx.shadowColor = '#ff6b00';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering time data...', workbenchRightX, workbenchY + 100);
                ctx.shadowBlur = 0;
            }
            
            // Phase 2: Assembling cores (30-60%)
            if (buildProgress >= 0.3 && buildProgress < 0.6) {
                const assembleProgress = (buildProgress - 0.3) / 0.3;
                
                // Left: Shield core (circular barrier forming)
                const shieldRadius = 40 * assembleProgress;
                ctx.strokeStyle = `rgba(255, 170, 68, ${0.5 + assembleProgress * 0.5})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(workbenchLeftX, workbenchY, shieldRadius, 0, Math.PI * 2);
                ctx.stroke();
                this.drawGlow(ctx, workbenchLeftX, workbenchY, shieldRadius, `rgba(255, 170, 68, ${assembleProgress * 0.6})`);
                
                // Shield energy particles converging
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const dist = 60 - assembleProgress * 20;
                    const x = workbenchLeftX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.5 * (1 - assembleProgress);
                    this.drawGlow(ctx, x, y, 4, `rgba(255, 170, 68, ${alpha})`);
                }
                
                // Right: Scanner core (device forming)
                const scannerSize = 30 * assembleProgress;
                ctx.fillStyle = `rgba(255, 107, 0, ${0.5 + assembleProgress * 0.5})`;
                ctx.fillRect(workbenchRightX - scannerSize, workbenchY - scannerSize * 0.5, scannerSize * 2, scannerSize);
                this.drawGlow(ctx, workbenchRightX, workbenchY, scannerSize, `rgba(255, 107, 0, ${assembleProgress * 0.6})`);
                
                // Scanner data particles converging
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const dist = 60 - assembleProgress * 20;
                    const x = workbenchRightX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.5 * (1 - assembleProgress);
                    this.drawGlow(ctx, x, y, 4, `rgba(255, 107, 0, ${alpha})`);
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#ffaa44';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling shield core...', workbenchLeftX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff6b00';
                ctx.shadowColor = '#ff6b00';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling scanner core...', workbenchRightX, workbenchY + 100);
                ctx.shadowBlur = 0;
            }
            
            // Phase 3: Completing structures (60-85%)
            if (buildProgress >= 0.6 && buildProgress < 0.85) {
                const completeProgress = (buildProgress - 0.6) / 0.25;
                
                // Left: Complete Shield (pulsing barrier)
                const shieldPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
                ctx.strokeStyle = 'rgba(255, 170, 68, 1)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(workbenchLeftX, workbenchY, 40 * shieldPulse, 0, Math.PI * 2);
                ctx.stroke();
                this.drawGlow(ctx, workbenchLeftX, workbenchY, 40 * shieldPulse, 'rgba(255, 170, 68, 0.7)');
                
                // Shield layers appearing
                for (let layer = 0; layer < 3; layer++) {
                    if (completeProgress > layer / 3) {
                        const radius = (30 + layer * 10) * shieldPulse;
                        ctx.strokeStyle = `rgba(255, 170, 68, ${0.8 - layer * 0.2})`;
                        ctx.lineWidth = 3 - layer;
                        ctx.beginPath();
                        ctx.arc(workbenchLeftX, workbenchY, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Right: Complete Scanner
                ctx.fillStyle = 'rgba(255, 107, 0, 1)';
                ctx.fillRect(workbenchRightX - 30, workbenchY - 15, 60, 30);
                this.drawGlow(ctx, workbenchRightX, workbenchY, 30, 'rgba(255, 107, 0, 0.7)');
                
                // Scanning beam appearing
                const beamLength = 50 * completeProgress;
                ctx.strokeStyle = `rgba(255, 107, 0, ${0.7 + completeProgress * 0.3})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(workbenchRightX, workbenchY);
                ctx.lineTo(workbenchRightX + beamLength, workbenchY - beamLength * 0.4);
                ctx.stroke();
                this.drawGlow(ctx, workbenchRightX + beamLength/2, workbenchY - beamLength * 0.2, beamLength/2, `rgba(255, 107, 0, ${completeProgress * 0.6})`);
                
                // Enhanced text with glow
                ctx.fillStyle = '#ffaa44';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.fillText('Energizing shield...', workbenchLeftX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff6b00';
                ctx.shadowColor = '#ff6b00';
                ctx.shadowBlur = 10;
                ctx.fillText('Calibrating scanner...', workbenchRightX, workbenchY + 100);
                ctx.shadowBlur = 0;
            }
            
            // Phase 4: Finalizing and testing (85-100%)
            if (buildProgress >= 0.85) {
                const finalizeProgress = (buildProgress - 0.85) / 0.15;
                
                // Left: Complete Shield (fully active with pulsing layers)
                const shieldPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
                for (let layer = 0; layer < 3; layer++) {
                    const radius = (30 + layer * 10) * shieldPulse;
                    ctx.strokeStyle = `rgba(255, 170, 68, ${0.9 - layer * 0.2})`;
                    ctx.lineWidth = 3 - layer;
                    ctx.beginPath();
                    ctx.arc(workbenchLeftX, workbenchY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                this.drawGlow(ctx, workbenchLeftX, workbenchY, 50 * shieldPulse, 'rgba(255, 170, 68, 0.8)');
                
                // Right: Complete Scanner with active beam
                ctx.fillStyle = 'rgba(255, 107, 0, 1)';
                ctx.fillRect(workbenchRightX - 30, workbenchY - 15, 60, 30);
                this.drawGlow(ctx, workbenchRightX, workbenchY, 30, 'rgba(255, 107, 0, 0.8)');
                
                // Active scanning beam
                ctx.strokeStyle = 'rgba(255, 107, 0, 1)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(workbenchRightX, workbenchY);
                ctx.lineTo(workbenchRightX + 50, workbenchY - 20);
                ctx.stroke();
                this.drawGlow(ctx, workbenchRightX + 25, workbenchY - 10, 25, 'rgba(255, 107, 0, 0.8)');
                
                // Scanning animation (beam moving)
                if (finalizeProgress > 0.3) {
                    const scanProgress = (finalizeProgress - 0.3) / 0.7;
                    const scanAngle = scanProgress * Math.PI * 2;
                    const scanLength = 60;
                    const scanX = workbenchRightX + Math.cos(scanAngle) * scanLength;
                    const scanY = workbenchY + Math.sin(scanAngle) * scanLength;
                    ctx.strokeStyle = 'rgba(255, 107, 0, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(workbenchRightX, workbenchY);
                    ctx.lineTo(scanX, scanY);
                    ctx.stroke();
                    this.drawGlow(ctx, scanX, scanY, 8, 'rgba(255, 107, 0, 0.8)');
                }
                
                // Success particles
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2 + this.cutsceneTime * 2;
                    const dist = 60 + Math.sin(this.cutsceneTime * 3 + i) * 20;
                    // Left particles (orange/yellow)
                    const leftX = workbenchLeftX + Math.cos(angle) * dist;
                    const leftY = workbenchY + Math.sin(angle) * dist * 0.7;
                    this.drawGlow(ctx, leftX, leftY, 4, `rgba(255, 170, 68, ${0.6 + Math.sin(this.cutsceneTime * 4 + i) * 0.4})`);
                    // Right particles (orange/red)
                    const rightX = workbenchRightX + Math.cos(angle) * dist;
                    const rightY = workbenchY + Math.sin(angle) * dist * 0.7;
                    this.drawGlow(ctx, rightX, rightY, 4, `rgba(255, 107, 0, ${0.6 + Math.sin(this.cutsceneTime * 4 + i) * 0.4})`);
                }
                
                // Enhanced text with glow
                const textFade = Math.min(1, finalizeProgress * 2);
                ctx.globalAlpha = textFade;
                const leftTextGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
                const rightTextGlow = 0.7 + Math.sin(this.cutsceneTime * 2 + Math.PI) * 0.3;
                this.drawGlow(ctx, workbenchLeftX, workbenchY + 100, 150, `rgba(255, 170, 68, ${leftTextGlow * textFade * 0.2})`);
                this.drawGlow(ctx, workbenchRightX, workbenchY + 100, 150, `rgba(255, 107, 0, ${rightTextGlow * textFade * 0.2})`);
                
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 15;
                ctx.fillText('SHIELD COMPLETE!', workbenchLeftX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff6b00';
                ctx.shadowColor = '#ff6b00';
                ctx.shadowBlur = 15;
                ctx.fillText('SCANNER COMPLETE!', workbenchRightX, workbenchY + 100);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Enhanced connection lines from ship to workbenches with glow
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(shipX + 30, shipY);
            ctx.lineTo(workbenchLeftX - 150, workbenchY);
            ctx.moveTo(shipX + 30, shipY);
            ctx.lineTo(workbenchRightX - 150, workbenchY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;
            
            // Set foreground text for phase 3 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(40);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[3]) {
                    let text = cutsceneData.texts[3].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        }
    }
    
    // Level 50: Building Individual System Model
    drawCutsceneLevel50(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced building blocks appearing - individual system components
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(79, 195, 247, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (cyan theme for individual systems)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced title with multi-layer glow
            const titleFade = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 1));
            const titleGlow = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, centerX, h * 0.15, 200, `rgba(79, 195, 247, ${titleGlow * titleFade * 0.3})`);
            this.drawGlow(ctx, centerX, h * 0.15, 150, `rgba(79, 195, 247, ${titleGlow * titleFade * 0.5})`);
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('INDIVIDUAL SYSTEM MODEL', centerX, h * 0.15);
            ctx.shadowBlur = 0;
            
            // Enhanced building blocks with pulsing, rotation, and convergence animation
            const blockCount = 6;
            for (let i = 0; i < blockCount; i++) {
                const angle = (i / blockCount) * Math.PI * 2;
                const baseDist = 120;
                // Convergence animation - blocks move slightly toward center over time
                const convergence = Math.min(1, (this.cutsceneTime - i * 0.3) / 2);
                const dist = baseDist * (1 - convergence * 0.3);
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const blockFade = Math.min(1, (this.cutsceneTime - i * 0.3) / 1);
                
                // Rotation animation
                const rotation = this.cutsceneTime * 0.5 + i;
                const pulse = 1 + Math.sin(this.cutsceneTime * 2 + i) * 0.15;
                const size = 40 * pulse;
                
                // Save context for rotation
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                // Enhanced block with gradient and multiple glow layers
                const blockGradient = ctx.createLinearGradient(-size/2, -size/2, size/2, size/2);
                blockGradient.addColorStop(0, `rgba(79, 195, 247, ${blockFade})`);
                blockGradient.addColorStop(0.5, `rgba(100, 210, 255, ${blockFade})`);
                blockGradient.addColorStop(1, `rgba(50, 150, 220, ${blockFade})`);
                ctx.fillStyle = blockGradient;
                ctx.fillRect(-size/2, -size/2, size, size);
                
                // Block border with glow
                ctx.strokeStyle = `rgba(79, 195, 247, ${blockFade})`;
                ctx.lineWidth = 3;
                ctx.strokeRect(-size/2, -size/2, size, size);
                
                ctx.restore();
                
                // Multiple glow layers
                this.drawGlow(ctx, x, y, size/2, `rgba(79, 195, 247, ${blockFade * 0.9})`);
                this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${blockFade * 0.6})`);
                this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${blockFade * 0.3})`);
                
                // Energy particles flowing from blocks toward center
                if (blockFade > 0.5) {
                    for (let j = 0; j < 3; j++) {
                        const particleProgress = ((this.cutsceneTime * 0.5 + j * 0.3) % 1);
                        const particleX = x + (centerX - x) * particleProgress;
                        const particleY = y + (centerY - y) * particleProgress;
                        const particleAlpha = (1 - particleProgress) * blockFade * 0.6;
                        const particleSize = 3 + Math.sin(particleProgress * Math.PI * 4) * 2;
                        this.drawGlow(ctx, particleX, particleY, particleSize, `rgba(79, 195, 247, ${particleAlpha})`);
                    }
                }
            }
            
            // Central convergence point glow (where blocks will form the model)
            const centerGlow = Math.min(1, (this.cutsceneTime - 1) / 1);
            if (centerGlow > 0) {
                const centerPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
                this.drawGlow(ctx, centerX, centerY, 30 * centerPulse, `rgba(79, 195, 247, ${centerGlow * 0.4})`);
                this.drawGlow(ctx, centerX, centerY, 50 * centerPulse, `rgba(79, 195, 247, ${centerGlow * 0.2})`);
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(50);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced model forming in center - individual system structure
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(79, 195, 247, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
            ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Formation animation - model appears over time
            const formationProgress = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced central structure with pulsing and multiple layers
            const corePulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.15;
            const coreRadius = 40 * corePulse * formationProgress;
            
            // Core with gradient
            const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreRadius);
            coreGradient.addColorStop(0, '#4fc3f7');
            coreGradient.addColorStop(0.5, '#66d0ff');
            coreGradient.addColorStop(1, '#2a9fd4');
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, coreRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Core border with glow
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(centerX, centerY, coreRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Multiple glow layers for core
            this.drawGlow(ctx, centerX, centerY, coreRadius, 'rgba(79, 195, 247, 0.9)');
            this.drawGlow(ctx, centerX, centerY, coreRadius * 1.5, 'rgba(79, 195, 247, 0.6)');
            this.drawGlow(ctx, centerX, centerY, coreRadius * 2, 'rgba(79, 195, 247, 0.3)');
            
            // Energy rings pulsing outward
            for (let ring = 0; ring < 3; ring++) {
                const ringProgress = (this.cutsceneTime * 0.5 + ring * 0.3) % 1;
                const ringRadius = coreRadius + ringProgress * 80;
                const ringAlpha = (1 - ringProgress) * 0.4;
                ctx.strokeStyle = `rgba(79, 195, 247, ${ringAlpha})`;
            ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Enhanced connecting lines with pulsing energy flow
            const lineCount = 8;
            for (let i = 0; i < lineCount; i++) {
                const angle = (i / lineCount) * Math.PI * 2;
                const lineLength = 100 * formationProgress;
                const endX = centerX + Math.cos(angle) * lineLength;
                const endY = centerY + Math.sin(angle) * lineLength;
                
                // Energy flow animation along lines
                const flowProgress = (this.cutsceneTime * 0.8 + i * 0.2) % 1;
                const flowX = centerX + Math.cos(angle) * lineLength * flowProgress;
                const flowY = centerY + Math.sin(angle) * lineLength * flowProgress;
                
                // Line with glow
                ctx.strokeStyle = `rgba(79, 195, 247, ${0.6 + Math.sin(this.cutsceneTime * 2 + i) * 0.2})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Energy particles flowing along line
                this.drawGlow(ctx, flowX, flowY, 6, `rgba(79, 195, 247, ${0.8 - flowProgress * 0.4})`);
                
                // End node with glow
                const nodePulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.2;
                this.drawGlow(ctx, endX, endY, 8 * nodePulse, `rgba(79, 195, 247, ${0.7})`);
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(endX, endY, 4 * nodePulse, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Enhanced label with glow
            const labelFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (labelFade > 0) {
                const labelGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, centerY - 100, 200, `rgba(79, 195, 247, ${labelGlow * labelFade * 0.2})`);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
                ctx.globalAlpha = labelFade;
            ctx.fillText('Individual System Model', centerX, centerY - 100);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(50);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced path becoming clear - the escape route
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(79, 195, 247, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
            ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
            ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Path revelation animation - path appears over time
            const pathReveal = Math.min(1, this.cutsceneTime / 1.5);
            
            // Enhanced arrow pointing forward with pulsing glow
            const arrowPulse = 0.8 + Math.sin(this.cutsceneTime * 2) * 0.2;
            const arrowStartX = centerX - 150;
            const arrowEndX = centerX + 150;
            const arrowY = centerY;
            
            // Path line with gradient and glow
            const pathGradient = ctx.createLinearGradient(arrowStartX, arrowY, arrowEndX, arrowY);
            pathGradient.addColorStop(0, `rgba(79, 195, 247, ${arrowPulse * pathReveal * 0.6})`);
            pathGradient.addColorStop(0.5, `rgba(79, 195, 247, ${arrowPulse * pathReveal})`);
            pathGradient.addColorStop(1, `rgba(79, 195, 247, ${arrowPulse * pathReveal * 0.8})`);
            
            ctx.strokeStyle = pathGradient;
            ctx.lineWidth = 8;
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(arrowStartX, arrowY);
            ctx.lineTo(arrowEndX, arrowY);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Path glow trail
            this.drawGlow(ctx, centerX, arrowY, 150, `rgba(79, 195, 247, ${arrowPulse * pathReveal * 0.3})`);
            
            // Enhanced arrowhead with pulsing
            const arrowheadSize = 30 * arrowPulse;
            ctx.strokeStyle = `rgba(79, 195, 247, ${arrowPulse * pathReveal})`;
            ctx.lineWidth = 8;
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(arrowEndX, arrowY);
            ctx.lineTo(arrowEndX - arrowheadSize, arrowY - arrowheadSize);
            ctx.moveTo(arrowEndX, arrowY);
            ctx.lineTo(arrowEndX - arrowheadSize, arrowY + arrowheadSize);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Arrowhead glow
            this.drawGlow(ctx, arrowEndX, arrowY, arrowheadSize, `rgba(79, 195, 247, ${arrowPulse * pathReveal * 0.5})`);
            
            // Enhanced particles moving along path with trails and multiple layers
            for (let layer = 0; layer < 2; layer++) {
                const layerSpeed = 0.8 + layer * 0.4;
                const layerCount = 15 + layer * 10;
                const layerSize = 8 + layer * 2;
                for (let i = 0; i < layerCount; i++) {
                    const progress = (this.cutsceneTime * layerSpeed + i * 0.1) % 1;
                    const x = arrowStartX + progress * 300;
                    const y = arrowY + Math.sin(progress * Math.PI * 4) * (5 - layer * 2); // Slight wave motion
                    const alpha = (0.9 - layer * 0.1) - progress * (0.3 - layer * 0.1);
                    const size = layerSize + Math.sin(progress * Math.PI * 6) * 2;
                    
                    if (alpha > 0 && size > 0) {
                        // Main particle
                        this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
                        
                        // Particle trail
                        const trailProgress = Math.max(0, progress - 0.15);
                        const trailX = arrowStartX + trailProgress * 300;
                        const trailY = arrowY + Math.sin(trailProgress * Math.PI * 4) * (5 - layer * 2);
                        this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(79, 195, 247, ${alpha * 0.3})`);
                    }
                }
            }
            
            // Path clearing effect - particles clearing the way
            const clearingProgress = Math.min(1, this.cutsceneTime / 2);
            if (clearingProgress < 1) {
                const clearingX = arrowStartX + clearingProgress * 300;
                const clearingGlow = 0.5 + Math.sin(this.cutsceneTime * 4) * 0.5;
                this.drawGlow(ctx, clearingX, arrowY, 40, `rgba(79, 195, 247, ${clearingGlow * (1 - clearingProgress)})`);
                this.drawGlow(ctx, clearingX, arrowY, 60, `rgba(79, 195, 247, ${clearingGlow * (1 - clearingProgress) * 0.5})`);
            }
            
            // Text labels with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, h * 0.25, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
                ctx.fillStyle = '#4fc3f7';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
                ctx.fillText('The Path to Escape', centerX, h * 0.25);
                ctx.font = '24px Arial';
                ctx.fillText('Sidesteps Bell Entirely!', centerX, h * 0.3);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(50);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        } else if (this.cutscenePhase === 3) {
            // Phase 3: Enhanced Einstein building the Deterministic Engine weapon
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Enhanced animated background grid with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerAlpha = 0.1 - layer * 0.03;
                const layerOffset = layer * 5;
                ctx.strokeStyle = `rgba(139, 0, 255, ${layerAlpha})`;
                ctx.lineWidth = 1 - layer * 0.2;
                const gridCount = 15 + layer * 5;
                for (let i = 0; i < gridCount; i++) {
                    const x = ((i / gridCount) * w) + Math.sin(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    const y = ((i / gridCount) * h) + Math.cos(this.cutsceneTime * 0.3 + layer) * layerOffset;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }
            
            // Quantum field particles (purple theme for deterministic/complete description)
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 10;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 10;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 2 + i) * 0.05;
                const size = 1.5 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(139, 0, 255, ${alpha})`);
            }
            
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship working glow
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(139, 0, 255, ${workGlow * 0.2})`);
            
            // Workbench/construction area (center-right)
            const workbenchX = centerX + 100;
            const workbenchY = centerY;
            const workbenchFade = Math.min(1, this.cutsceneTime / 1.5);
            
            // Enhanced background workbench panel with gradient
            ctx.globalAlpha = workbenchFade;
            const panelGradient = ctx.createLinearGradient(workbenchX - 200, workbenchY - 150, workbenchX - 200, workbenchY + 150);
            panelGradient.addColorStop(0, 'rgba(139, 0, 255, 0.25)');
            panelGradient.addColorStop(0.5, 'rgba(139, 0, 255, 0.2)');
            panelGradient.addColorStop(1, 'rgba(139, 0, 255, 0.15)');
            ctx.fillStyle = panelGradient;
            ctx.fillRect(workbenchX - 200, workbenchY - 150, 400, 300);
            
            // Enhanced panel border with pulsing glow
            const panelGlow = 0.5 + Math.sin(this.cutsceneTime * 3) * 0.3;
            ctx.strokeStyle = `rgba(139, 0, 255, ${panelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchX - 200, workbenchY - 150, 400, 300);
            // Corner glows
            this.drawGlow(ctx, workbenchX - 200, workbenchY - 150, 25, `rgba(139, 0, 255, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY - 150, 25, `rgba(139, 0, 255, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX - 200, workbenchY + 150, 25, `rgba(139, 0, 255, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY + 150, 25, `rgba(139, 0, 255, ${panelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(139, 0, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const x = workbenchX - 200 + (i * 80);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 150);
                ctx.lineTo(x, workbenchY + 150);
                ctx.stroke();
            }
            for (let i = 0; i < 5; i++) {
                const y = workbenchY - 150 + (i * 75);
                ctx.beginPath();
                ctx.moveTo(workbenchX - 200, y);
                ctx.lineTo(workbenchX + 200, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Construction progress (0-1 over time)
            const buildProgress = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 7));
            
            // Phase 1: Enhanced gathering individual system data (0-30%)
            if (buildProgress < 0.3) {
                const gatherProgress = buildProgress / 0.3;
                const particleCount = 30;
                
                // Enhanced particles with multiple layers and trails
                for (let layer = 0; layer < 2; layer++) {
                    const layerCount = particleCount + layer * 10;
                    const layerSpeed = 1 + layer * 0.5;
                    for (let i = 0; i < layerCount; i++) {
                        const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed * 0.1;
                        const startDist = 250 + layer * 30;
                        const endDist = 100 - layer * 20;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                        const alpha = (0.7 - layer * 0.1) * (1 - gatherProgress);
                        const size = (6 - layer) - gatherProgress * (2 - layer);
                        
                    // Purple particles for deterministic/complete description
                        if (alpha > 0 && size > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(139, 0, 255, ${alpha})`);
                            this.drawGlow(ctx, x, y, size * 1.5, `rgba(139, 0, 255, ${alpha * 0.5})`);
                            
                            // Particle trail
                            const trailAngle = angle - 0.1;
                            const trailDist = dist + 20;
                            const trailX = workbenchX + Math.cos(trailAngle) * trailDist;
                            const trailY = workbenchY + Math.sin(trailAngle) * trailDist * 0.7;
                            this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(139, 0, 255, ${alpha * 0.3})`);
                        }
                    }
                }
                
                // Central gathering point glow
                const gatherGlow = 0.4 + Math.sin(this.cutsceneTime * 3) * 0.3;
                this.drawGlow(ctx, workbenchX, workbenchY, 80 * gatherProgress, `rgba(139, 0, 255, ${gatherGlow * gatherProgress * 0.4})`);
                
                // Enhanced text with glow
                ctx.fillStyle = '#8b00ff';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#8b00ff';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering individual system data...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 2: Enhanced assembling engine core (30-60%)
            if (buildProgress >= 0.3 && buildProgress < 0.6) {
                const assembleProgress = (buildProgress - 0.3) / 0.3;
                
                // Central engine core (circular/hexagonal structure) assembling
                const coreRadius = 35 * assembleProgress;
                const corePulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.1;
                
                // Core structure with gradient
                const coreGradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, coreRadius);
                coreGradient.addColorStop(0, `rgba(160, 20, 255, ${0.8 + assembleProgress * 0.2})`);
                coreGradient.addColorStop(0.5, `rgba(139, 0, 255, ${0.6 + assembleProgress * 0.4})`);
                coreGradient.addColorStop(1, `rgba(100, 0, 200, ${0.4 + assembleProgress * 0.3})`);
                
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, coreRadius * corePulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Core border with glow
                ctx.strokeStyle = `rgba(139, 0, 255, ${0.7 + assembleProgress * 0.3})`;
                ctx.lineWidth = 4;
                ctx.shadowColor = '#8b00ff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, coreRadius * corePulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Internal engine structure (hexagonal pattern)
                if (assembleProgress > 0.3) {
                    const hexProgress = (assembleProgress - 0.3) / 0.7;
                    ctx.strokeStyle = `rgba(160, 20, 255, ${hexProgress})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const innerRadius = coreRadius * 0.6 * hexProgress;
                        const x1 = workbenchX + Math.cos(angle) * innerRadius;
                        const y1 = workbenchY + Math.sin(angle) * innerRadius;
                        const x2 = workbenchX + Math.cos(angle + Math.PI / 3) * innerRadius;
                        const y2 = workbenchY + Math.sin(angle + Math.PI / 3) * innerRadius;
                        ctx.beginPath();
                        ctx.moveTo(workbenchX, workbenchY);
                        ctx.lineTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
                
                // Enhanced glow effect with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, coreRadius * corePulse, `rgba(139, 0, 255, ${assembleProgress * 0.9})`);
                this.drawGlow(ctx, workbenchX, workbenchY, coreRadius * corePulse * 1.5, `rgba(139, 0, 255, ${assembleProgress * 0.5})`);
                
                // Energy rotating around core
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + this.cutsceneTime * 2;
                    const dist = coreRadius * 1.3;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist;
                    const alpha = 0.6 * assembleProgress;
                    this.drawGlow(ctx, x, y, 6, `rgba(139, 0, 255, ${alpha})`);
                }
                
                // Enhanced assembly particles with convergence
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    const baseDist = 80;
                    const convergence = assembleProgress;
                    const dist = baseDist * (1 - convergence * 0.6) + Math.sin(this.cutsceneTime * 3 + i) * 20;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.5 * (1 - assembleProgress);
                    const size = 5 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                    if (alpha > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(139, 0, 255, ${alpha})`);
                    }
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#8b00ff';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#8b00ff';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling deterministic engine core...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 3: Enhanced adding energy channels and individual system nodes (60-85%)
            if (buildProgress >= 0.6 && buildProgress < 0.85) {
                const channelProgress = (buildProgress - 0.6) / 0.25;
                
                // Complete engine core (circular structure)
                const coreRadius = 35;
                const corePulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
                
                const coreGradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, coreRadius);
                coreGradient.addColorStop(0, 'rgba(160, 20, 255, 1)');
                coreGradient.addColorStop(0.5, 'rgba(139, 0, 255, 1)');
                coreGradient.addColorStop(1, 'rgba(100, 0, 200, 0.7)');
                
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, coreRadius * corePulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(139, 0, 255, 1)';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#8b00ff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, coreRadius * corePulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Internal hexagonal structure (complete)
                ctx.strokeStyle = 'rgba(160, 20, 255, 0.8)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const innerRadius = coreRadius * 0.6;
                    const x1 = workbenchX + Math.cos(angle) * innerRadius;
                    const y1 = workbenchY + Math.sin(angle) * innerRadius;
                    const x2 = workbenchX + Math.cos(angle + Math.PI / 3) * innerRadius;
                    const y2 = workbenchY + Math.sin(angle + Math.PI / 3) * innerRadius;
                    ctx.beginPath();
                    ctx.moveTo(workbenchX, workbenchY);
                    ctx.lineTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.closePath();
                    ctx.stroke();
                }
                
                // Energy channels radiating outward (5 channels for 5 projectiles)
                const channelCount = 5;
                const channelAngle = (Math.PI * 2) / channelCount;
                for (let i = 0; i < channelCount; i++) {
                    const baseAngle = (i / channelCount) * Math.PI * 2 - Math.PI / 2; // Start from top
                    const channelLength = 70 * channelProgress;
                    const endX = workbenchX + Math.cos(baseAngle) * (coreRadius + channelLength);
                    const endY = workbenchY + Math.sin(baseAngle) * (coreRadius + channelLength);
                    
                    // Channel with gradient
                    const channelGrad = ctx.createLinearGradient(workbenchX, workbenchY, endX, endY);
                    channelGrad.addColorStop(0, `rgba(139, 0, 255, ${0.6 + channelProgress * 0.4})`);
                    channelGrad.addColorStop(0.5, `rgba(160, 20, 255, ${0.7 + channelProgress * 0.3})`);
                    channelGrad.addColorStop(1, `rgba(139, 0, 255, ${0.5 + channelProgress * 0.3})`);
                    
                    ctx.strokeStyle = channelGrad;
                    ctx.lineWidth = 6;
                    ctx.shadowColor = '#8b00ff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(workbenchX + Math.cos(baseAngle) * coreRadius, workbenchY + Math.sin(baseAngle) * coreRadius);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Individual system node at end of channel
                    if (channelProgress > 0.4) {
                        const nodeProgress = (channelProgress - 0.4) / 0.6;
                        const nodePulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.2;
                        const nodeRadius = 8 * nodeProgress * nodePulse;
                        const nodeGradient = ctx.createRadialGradient(endX, endY, 0, endX, endY, nodeRadius);
                        nodeGradient.addColorStop(0, `rgba(160, 20, 255, ${nodeProgress})`);
                        nodeGradient.addColorStop(1, `rgba(139, 0, 255, ${nodeProgress * 0.6})`);
                        ctx.fillStyle = nodeGradient;
                        ctx.beginPath();
                        ctx.arc(endX, endY, nodeRadius, 0, Math.PI * 2);
                        ctx.fill();
                        this.drawGlow(ctx, endX, endY, nodeRadius * 1.5, `rgba(139, 0, 255, ${nodeProgress * 0.7})`);
                    }
                }
                
                // Enhanced energy flowing through channels
                for (let i = 0; i < channelCount; i++) {
                    const baseAngle = (i / channelCount) * Math.PI * 2 - Math.PI / 2;
                    const channelLength = 70 * channelProgress;
                    for (let j = 0; j < 3; j++) {
                        const flowProgress = (this.cutsceneTime * 0.8 + j * 0.3) % 1;
                        const flowDist = coreRadius + flowProgress * channelLength;
                        const flowX = workbenchX + Math.cos(baseAngle) * flowDist;
                        const flowY = workbenchY + Math.sin(baseAngle) * flowDist;
                        const alpha = 0.8 - flowProgress * 0.4;
                        this.drawGlow(ctx, flowX, flowY, 6, `rgba(139, 0, 255, ${alpha})`);
                    }
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#8b00ff';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#8b00ff';
                ctx.shadowBlur = 10;
                ctx.fillText('Installing energy channels and system nodes...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 4: Enhanced finalizing and testing (85-100%)
            if (buildProgress >= 0.85) {
                const finalizeProgress = (buildProgress - 0.85) / 0.15;
                
                // Complete engine core with pulsing
                const coreRadius = 35;
                const corePulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.15;
                
                const coreGradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, coreRadius);
                coreGradient.addColorStop(0, 'rgba(160, 20, 255, 1)');
                coreGradient.addColorStop(0.5, 'rgba(139, 0, 255, 1)');
                coreGradient.addColorStop(1, 'rgba(100, 0, 200, 0.8)');
                
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, coreRadius * corePulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(139, 0, 255, 1)';
                ctx.lineWidth = 5;
                ctx.shadowColor = '#8b00ff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, coreRadius * corePulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Complete internal hexagonal structure
                ctx.strokeStyle = 'rgba(160, 20, 255, 0.9)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const innerRadius = coreRadius * 0.6;
                    const x1 = workbenchX + Math.cos(angle) * innerRadius;
                    const y1 = workbenchY + Math.sin(angle) * innerRadius;
                    const x2 = workbenchX + Math.cos(angle + Math.PI / 3) * innerRadius;
                    const y2 = workbenchY + Math.sin(angle + Math.PI / 3) * innerRadius;
                    ctx.beginPath();
                    ctx.moveTo(workbenchX, workbenchY);
                    ctx.lineTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.closePath();
                    ctx.stroke();
                }
                
                // Complete energy channels (5 channels)
                const channelCount = 5;
                const channelAngle = (Math.PI * 2) / channelCount;
                for (let i = 0; i < channelCount; i++) {
                    const baseAngle = (i / channelCount) * Math.PI * 2 - Math.PI / 2;
                    const channelLength = 70;
                    const endX = workbenchX + Math.cos(baseAngle) * (coreRadius + channelLength);
                    const endY = workbenchY + Math.sin(baseAngle) * (coreRadius + channelLength);
                    
                    // Channel with gradient
                    const channelGrad = ctx.createLinearGradient(workbenchX, workbenchY, endX, endY);
                    channelGrad.addColorStop(0, 'rgba(139, 0, 255, 1)');
                    channelGrad.addColorStop(0.5, 'rgba(160, 20, 255, 1)');
                    channelGrad.addColorStop(1, 'rgba(139, 0, 255, 0.8)');
                    
                    ctx.strokeStyle = channelGrad;
                    ctx.lineWidth = 7;
                    ctx.shadowColor = '#8b00ff';
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.moveTo(workbenchX + Math.cos(baseAngle) * coreRadius, workbenchY + Math.sin(baseAngle) * coreRadius);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Complete individual system nodes
                    const nodePulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                    const nodeRadius = 10 * nodePulse;
                    const nodeGradient = ctx.createRadialGradient(endX, endY, 0, endX, endY, nodeRadius);
                    nodeGradient.addColorStop(0, 'rgba(160, 20, 255, 1)');
                    nodeGradient.addColorStop(1, 'rgba(139, 0, 255, 0.7)');
                    ctx.fillStyle = nodeGradient;
                    ctx.beginPath();
                    ctx.arc(endX, endY, nodeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    this.drawGlow(ctx, endX, endY, nodeRadius * 1.5, 'rgba(139, 0, 255, 0.8)');
                    this.drawGlow(ctx, endX, endY, nodeRadius * 2, 'rgba(139, 0, 255, 0.4)');
                }
                
                // Enhanced complete glow with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, coreRadius * 1.5, 'rgba(139, 0, 255, 0.9)');
                this.drawGlow(ctx, workbenchX, workbenchY, coreRadius * 2.5, 'rgba(139, 0, 255, 0.5)');
                this.drawGlow(ctx, workbenchX, workbenchY, coreRadius * 3.5, 'rgba(139, 0, 255, 0.3)');
                
                // Enhanced test firing animation - deterministic energy streams
                if (finalizeProgress > 0.3) {
                    const fireProgress = (finalizeProgress - 0.3) / 0.7;
                    for (let i = 0; i < channelCount; i++) {
                        const baseAngle = (i / channelCount) * Math.PI * 2 - Math.PI / 2;
                        const channelLength = 70;
                        const startX = workbenchX + Math.cos(baseAngle) * (coreRadius + channelLength);
                        const startY = workbenchY + Math.sin(baseAngle) * (coreRadius + channelLength);
                        const streamLength = 120 * fireProgress;
                        const streamX = startX + Math.cos(baseAngle) * streamLength;
                        const streamY = startY + Math.sin(baseAngle) * streamLength;
                        const alpha = 1 - fireProgress * 0.4;
                        
                        // Deterministic energy stream (straight, precise)
                        ctx.strokeStyle = `rgba(139, 0, 255, ${alpha})`;
                        ctx.lineWidth = 4;
                        ctx.shadowColor = '#8b00ff';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(streamX, streamY);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        // Stream tip with glow
                        const tipPulse = 1 + Math.sin(this.cutsceneTime * 4 + i) * 0.2;
                        this.drawGlow(ctx, streamX, streamY, 10 * tipPulse, `rgba(139, 0, 255, ${alpha})`);
                        this.drawGlow(ctx, streamX, streamY, 15 * tipPulse, `rgba(139, 0, 255, ${alpha * 0.6})`);
                        
                        // Energy particles along stream
                        for (let j = 0; j < 5; j++) {
                            const particleProgress = (j / 5) * fireProgress;
                            const particleX = startX + Math.cos(baseAngle) * streamLength * particleProgress;
                            const particleY = startY + Math.sin(baseAngle) * streamLength * particleProgress;
                            this.drawGlow(ctx, particleX, particleY, 4, `rgba(139, 0, 255, ${alpha * 0.7})`);
                        }
                    }
                }
                
                // Enhanced success particles with multiple layers
                for (let layer = 0; layer < 2; layer++) {
                    const layerCount = 25 + layer * 15;
                    const layerSpeed = 2 + layer;
                    for (let i = 0; i < layerCount; i++) {
                        const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed;
                        const dist = (90 + layer * 20) + Math.sin(this.cutsceneTime * 3 + i) * (30 + layer * 10);
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                        const alpha = (0.7 - layer * 0.1) + Math.sin(this.cutsceneTime * 4 + i) * (0.3 - layer * 0.1);
                        const size = 4 + layer * 2;
                        if (alpha > 0) {
                            this.drawGlow(ctx, x, y, size, `rgba(139, 0, 255, ${alpha})`);
                            this.drawGlow(ctx, x, y, size * 1.5, `rgba(139, 0, 255, ${alpha * 0.5})`);
                        }
                    }
                }
                
                // Enhanced text with glow
                const textFade = Math.min(1, finalizeProgress * 2);
                ctx.globalAlpha = textFade;
                const textGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
                this.drawGlow(ctx, workbenchX, workbenchY + 120, 200, `rgba(139, 0, 255, ${textGlow * textFade * 0.2})`);
                ctx.fillStyle = '#8b00ff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#8b00ff';
                ctx.shadowBlur = 20;
                ctx.fillText('DETERMINISTIC ENGINE COMPLETE!', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
                ctx.font = '18px Arial';
                ctx.fillStyle = 'rgba(139, 0, 255, 0.9)';
                ctx.shadowColor = '#8b00ff';
                ctx.shadowBlur = 12;
                ctx.fillText('Channels complete individual system descriptions', workbenchX, workbenchY + 150);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Enhanced connection line from ship to workbench with glow
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(shipX + 30, shipY);
            ctx.lineTo(workbenchX - 200, workbenchY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;
            
            // Set foreground text for phase 3 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(50);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[3]) {
                    let text = cutsceneData.texts[3].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        }
    }
    
    // Level 55-100: Use similar pattern but with progression themes
    // For brevity, I'll create a few more key ones and use generic for others
    
    // Level 55: Progress in Escaping - Enhanced
    drawCutsceneLevel55(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced progress visualization - molecules breaking free
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0f0510');
            bgGradient.addColorStop(0.6, '#0a0505');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Einstein vs Bell - Mathematical Duel
            // Left side: Einstein's realm (cyan/blue tones)
            const einsteinGradient = ctx.createRadialGradient(w * 0.25, h * 0.5, 0, w * 0.25, h * 0.5, Math.max(w, h) * 0.6);
            einsteinGradient.addColorStop(0, 'rgba(79, 195, 247, 0.15)');
            einsteinGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.08)');
            einsteinGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
            ctx.fillStyle = einsteinGradient;
            ctx.fillRect(0, 0, w * 0.5, h);
            
            // Right side: Bell's realm (red/orange tones) - fading
            const bellFade = Math.max(0, 1 - this.cutsceneTime / 3);
            const bellGradient = ctx.createRadialGradient(w * 0.75, h * 0.5, 0, w * 0.75, h * 0.5, Math.max(w, h) * 0.6);
            bellGradient.addColorStop(0, `rgba(255, 68, 68, ${0.15 * bellFade})`);
            bellGradient.addColorStop(0.5, `rgba(255, 68, 68, ${0.08 * bellFade})`);
            bellGradient.addColorStop(1, `rgba(255, 68, 68, 0)`);
            ctx.fillStyle = bellGradient;
            ctx.fillRect(w * 0.5, 0, w * 0.5, h);
            
            // Central dividing line with mathematical symbols flowing
            const centerLineX = w * 0.5;
            ctx.strokeStyle = `rgba(255, 170, 68, ${0.3 * fade})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(centerLineX, 0);
            ctx.lineTo(centerLineX, h);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Einstein's equations forming geometric patterns (left side)
            const einsteinEquations = ['E=mc²', 'R_μν - ½g_μνR', 'G_μν = 8πT_μν', 'ψ(x,t)', '∂²ψ/∂t²', '∇²ψ'];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + this.cutsceneTime * 0.3;
                const radius = 150 + Math.sin(this.cutsceneTime * 0.5 + i) * 50;
                const x = w * 0.25 + Math.cos(angle) * radius;
                const y = h * 0.5 + Math.sin(angle) * radius;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = angle + Math.PI / 2;
                const scale = 0.7 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${16 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = einsteinEquations[i % einsteinEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 25 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.3})`);
            }
            
            // Bell's equations forming patterns (right side) - fading
            const bellEquations = ['|E(a,b)-E(a,b\')|', '≤ 1+E(a\',b\')', 'P(A,B)', 'P(A)·P(B|A)', '⟨AB⟩', 'λ'];
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2 - this.cutsceneTime * 0.3;
                const radius = 150 + Math.sin(this.cutsceneTime * 0.5 + i) * 50;
                const x = w * 0.75 + Math.cos(angle) * radius;
                const y = h * 0.5 + Math.sin(angle) * radius;
                const alpha = (0.2 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1) * bellFade;
                const rotation = angle - Math.PI / 2;
                const scale = 0.7 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${16 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = bellEquations[i % bellEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 25 * scale, `rgba(255, 68, 68, ${alpha * fade * 0.3})`);
            }
            
            // Connecting lines between Einstein and Bell equations (showing the conflict/escape)
            for (let i = 0; i < 8; i++) {
                const progress = (this.cutsceneTime * 0.2 + i * 0.3) % 1;
                const startX = w * 0.25 + Math.cos((i / 8) * Math.PI * 2) * 100;
                const startY = h * 0.5 + Math.sin((i / 8) * Math.PI * 2) * 100;
                const endX = w * 0.75 - Math.cos((i / 8) * Math.PI * 2) * 100;
                const endY = h * 0.5 - Math.sin((i / 8) * Math.PI * 2) * 100;
                const x = startX + (endX - startX) * progress;
                const y = startY + (endY - startY) * progress;
                const alpha = (1 - progress) * 0.3 * fade;
                
                ctx.strokeStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Particle on line
                this.drawGlow(ctx, x, y, 4, `rgba(255, 170, 68, ${alpha * 0.8})`);
            }
            
            // Large mathematical symbols as artistic elements
            const largeSymbols = [
                { sym: 'ψ', x: w * 0.15, y: h * 0.2, color: 'rgba(79, 195, 247, 0.25)' },
                { sym: 'E', x: w * 0.1, y: h * 0.7, color: 'rgba(79, 195, 247, 0.2)' },
                { sym: '∫', x: w * 0.3, y: h * 0.3, color: 'rgba(79, 195, 247, 0.2)' },
                { sym: 'P', x: w * 0.85, y: h * 0.25, color: 'rgba(255, 68, 68, 0.2)' },
                { sym: '⟨', x: w * 0.9, y: h * 0.7, color: 'rgba(255, 68, 68, 0.2)' },
                { sym: '∑', x: w * 0.7, y: h * 0.35, color: 'rgba(255, 68, 68, 0.2)' }
            ];
            
            for (let i = 0; i < largeSymbols.length; i++) {
                const symbol = largeSymbols[i];
                const pulse = 1 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.3;
                const rotation = this.cutsceneTime * 0.1 + i;
                const alpha = (symbol.color.includes('195') ? 1 : bellFade) * fade;
                
                ctx.save();
                ctx.translate(symbol.x, symbol.y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = symbol.color.replace(/[\d.]+\)$/, `${0.15 * alpha})`);
                ctx.font = `${80 * pulse}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol.sym, 0, 0);
                ctx.restore();
                
                // Large symbol glow
                this.drawGlow(ctx, symbol.x, symbol.y, 50 * pulse, symbol.color.replace(/[\d.]+\)$/, `${0.1 * alpha})`));
            }
            
            // Quantum field particles (orange theme for progress/escape)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha * fade})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced Einstein at chalkboard - Redesigned layout
            const chalkboardX = w * 0.2;
            const chalkboardY = h * 0.4;
            const chalkboardWidth = 380;
            const chalkboardHeight = 320;
            const chalkboardFade = Math.min(1, (this.cutsceneTime - 0.5) / 1);
            
            // Enhanced chalkboard
            if (chalkboardFade > 0) {
                ctx.globalAlpha = chalkboardFade;
                const boardGradient = ctx.createLinearGradient(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardX - chalkboardWidth/2, chalkboardY + chalkboardHeight/2);
                boardGradient.addColorStop(0, 'rgba(40, 30, 20, 0.96)');
                boardGradient.addColorStop(0.5, 'rgba(50, 40, 30, 0.96)');
                boardGradient.addColorStop(1, 'rgba(40, 30, 20, 0.96)');
                ctx.fillStyle = boardGradient;
                ctx.fillRect(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardWidth, chalkboardHeight);
                
                // Chalkboard border with enhanced frame
                ctx.strokeStyle = 'rgba(100, 80, 60, 0.95)';
                ctx.lineWidth = 6;
                ctx.strokeRect(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardWidth, chalkboardHeight);
                
                // Enhanced chalkboard frame
                ctx.fillStyle = 'rgba(60, 45, 30, 0.95)';
                ctx.fillRect(chalkboardX - chalkboardWidth/2 - 12, chalkboardY - chalkboardHeight/2 - 12, chalkboardWidth + 24, chalkboardHeight + 24);
                ctx.fillRect(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardWidth, chalkboardHeight);
                
                // Chalkboard corner decorations
                ctx.strokeStyle = 'rgba(120, 90, 60, 0.8)';
                ctx.lineWidth = 3;
                const cornerSize = 15;
                ctx.beginPath();
                ctx.moveTo(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2 + cornerSize);
                ctx.lineTo(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2);
                ctx.lineTo(chalkboardX - chalkboardWidth/2 + cornerSize, chalkboardY - chalkboardHeight/2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(chalkboardX + chalkboardWidth/2 - cornerSize, chalkboardY - chalkboardHeight/2);
                ctx.lineTo(chalkboardX + chalkboardWidth/2, chalkboardY - chalkboardHeight/2);
                ctx.lineTo(chalkboardX + chalkboardWidth/2, chalkboardY - chalkboardHeight/2 + cornerSize);
                ctx.stroke();
                
                // Writing animation on chalkboard
                const writingProgress = Math.min(1, (this.cutsceneTime - 1) / 4);
                if (writingProgress > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                    ctx.font = '17px Arial';
                    ctx.textAlign = 'left';
                    
                    // Mathematical derivation appearing line by line - compact
                    const lines = [
                        'Individual System:',
                        '',
                        'ψ(x,t) = complete description',
                        '',
                        'For A or B (not pairs):',
                        '',
                        'P(A) = |ψ_A(x,t)|²',
                        'P(B) = |ψ_B(x,t)|²',
                        '',
                        'Bell requires:',
                        'P(A,B) ≠ P(A)·P(B)',
                        '',
                        'But if A or B alone:',
                        '→ No correlation',
                        '→ Bell doesn\'t apply'
                    ];
                    
                    const lineHeight = 19;
                    const startY = chalkboardY - chalkboardHeight/2 + 25;
                    const leftMargin = chalkboardX - chalkboardWidth/2 + 25;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const lineProgress = Math.min(1, (writingProgress * lines.length - i) / 1);
                        if (lineProgress > 0) {
                            ctx.globalAlpha = chalkboardFade * lineProgress;
                            const charsToShow = Math.floor(lines[i].length * lineProgress);
                            const visibleText = lines[i].substring(0, charsToShow);
                            ctx.fillText(visibleText, leftMargin, startY + i * lineHeight);
                        }
                    }
                }
                
                // Einstein character positioned BELOW chalkboard (not covering it)
                const einsteinX = chalkboardX;
                const einsteinY = chalkboardY + chalkboardHeight/2 + 50;
                const einsteinFloat = Math.sin(this.cutsceneTime * 1.5) * 5;
                this.drawEinsteinCharacter(ctx, einsteinX, einsteinY + einsteinFloat, 0.7, chalkboardFade, this.cutsceneTime);
                
                // Writing hand animation
                if (writingProgress > 0 && writingProgress < 1) {
                    const handX = chalkboardX - chalkboardWidth/2 + 25 + Math.cos(this.cutsceneTime * 4) * 3;
                    const handY = chalkboardY - chalkboardHeight/2 + 25 + (writingProgress * (chalkboardHeight - 50)) + Math.sin(this.cutsceneTime * 4) * 2;
                    ctx.fillStyle = `rgba(255, 255, 255, ${chalkboardFade * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(handX, handY, 5, 0, Math.PI * 2);
                    ctx.fill();
                    this.drawGlow(ctx, handX, handY, 8, `rgba(255, 255, 255, ${chalkboardFade * 0.4})`);
                }
                
                ctx.globalAlpha = fade;
            }
            
            // Enhanced title with multi-layer glow
            const titleGlow = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, centerX, h * 0.15, 200, `rgba(255, 170, 68, ${titleGlow * fade * 0.3})`);
            this.drawGlow(ctx, centerX, h * 0.15, 150, `rgba(255, 170, 68, ${titleGlow * fade * 0.5})`);
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PROGRESS IN ESCAPING', centerX, h * 0.15);
            ctx.shadowBlur = 0;
            
            // Molecules breaking free from Bell's statistical thinking
            const moleculeCount = 8;
            for (let i = 0; i < moleculeCount; i++) {
                const angle = (i / moleculeCount) * Math.PI * 2;
                const baseDist = 100;
                // Molecules move outward (breaking free)
                const escapeProgress = Math.min(1, (this.cutsceneTime - i * 0.2) / 2);
                const dist = baseDist + escapeProgress * 150;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const moleculeFade = Math.min(1, (this.cutsceneTime - i * 0.2) / 1);
                
                // Molecule structure (breaking apart)
                const moleculePulse = 1 + Math.sin(this.cutsceneTime * 2 + i) * 0.15;
                const moleculeSize = 15 * moleculePulse;
                
                // Molecule core
                const moleculeGradient = ctx.createRadialGradient(x, y, 0, x, y, moleculeSize);
                moleculeGradient.addColorStop(0, `rgba(255, 170, 68, ${moleculeFade})`);
                moleculeGradient.addColorStop(0.5, `rgba(255, 200, 100, ${moleculeFade})`);
                moleculeGradient.addColorStop(1, `rgba(255, 140, 40, ${moleculeFade * 0.6})`);
                ctx.fillStyle = moleculeGradient;
                ctx.beginPath();
                ctx.arc(x, y, moleculeSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Breaking effect - particles separating
                if (escapeProgress > 0.3) {
                    const breakProgress = (escapeProgress - 0.3) / 0.7;
                    for (let j = 0; j < 3; j++) {
                        const breakAngle = angle + (j - 1) * 0.3;
                        const breakDist = moleculeSize + breakProgress * 30;
                        const breakX = x + Math.cos(breakAngle) * breakDist;
                        const breakY = y + Math.sin(breakAngle) * breakDist;
                        const breakAlpha = moleculeFade * (1 - breakProgress);
                        this.drawGlow(ctx, breakX, breakY, 4, `rgba(255, 170, 68, ${breakAlpha})`);
                    }
                }
                
                // Molecule glow
                this.drawGlow(ctx, x, y, moleculeSize, `rgba(255, 170, 68, ${moleculeFade * 0.8})`);
                this.drawGlow(ctx, x, y, moleculeSize * 1.5, `rgba(255, 170, 68, ${moleculeFade * 0.4})`);
                
                // Escape trail
                if (escapeProgress > 0.1) {
                    const trailProgress = Math.max(0, escapeProgress - 0.2);
                    const trailDist = baseDist + trailProgress * 150;
                    const trailX = centerX + Math.cos(angle) * trailDist;
                    const trailY = centerY + Math.sin(angle) * trailDist;
                    this.drawGlow(ctx, trailX, trailY, moleculeSize * 0.5, `rgba(255, 170, 68, ${moleculeFade * 0.3})`);
                }
            }
            
            // Central Bell's statistical thinking (being broken)
            const bellThinkingAlpha = Math.max(0, 1 - this.cutsceneTime / 3);
            if (bellThinkingAlpha > 0) {
                const bellPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
                const bellGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 80 * bellPulse);
                bellGradient.addColorStop(0, `rgba(255, 68, 68, ${bellThinkingAlpha * 0.3})`);
                bellGradient.addColorStop(1, `rgba(255, 68, 68, ${bellThinkingAlpha * 0.1})`);
                ctx.fillStyle = bellGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 80 * bellPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Cracks appearing
                const crackProgress = Math.min(1, this.cutsceneTime / 2);
                if (crackProgress > 0) {
                    ctx.strokeStyle = `rgba(255, 68, 68, ${bellThinkingAlpha * 0.6})`;
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 6; i++) {
                        const crackAngle = (i / 6) * Math.PI * 2;
                        const crackLength = 60 * crackProgress;
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(centerX + Math.cos(crackAngle) * crackLength, centerY + Math.sin(crackAngle) * crackLength);
                        ctx.stroke();
                    }
                }
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(55);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced breaking free from Bell's statistical thinking
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Einstein vs Bell - Mathematical Duel (Phase 1)
            // Left side: Einstein's realm (cyan/blue tones) - stronger
            const einsteinGradient = ctx.createRadialGradient(w * 0.25, h * 0.5, 0, w * 0.25, h * 0.5, Math.max(w, h) * 0.6);
            einsteinGradient.addColorStop(0, 'rgba(79, 195, 247, 0.2)');
            einsteinGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.1)');
            einsteinGradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
            ctx.fillStyle = einsteinGradient;
            ctx.fillRect(0, 0, w * 0.5, h);
            
            // Right side: Bell's realm (red/orange tones) - fading faster
            const bellFadePhase1 = Math.max(0, 1 - this.cutsceneTime / 2);
            const bellGradient = ctx.createRadialGradient(w * 0.75, h * 0.5, 0, w * 0.75, h * 0.5, Math.max(w, h) * 0.6);
            bellGradient.addColorStop(0, `rgba(255, 68, 68, ${0.2 * bellFadePhase1})`);
            bellGradient.addColorStop(0.5, `rgba(255, 68, 68, ${0.1 * bellFadePhase1})`);
            bellGradient.addColorStop(1, `rgba(255, 68, 68, 0)`);
            ctx.fillStyle = bellGradient;
            ctx.fillRect(w * 0.5, 0, w * 0.5, h);
            
            // Central dividing line with escape particles
            const centerLineX = w * 0.5;
            ctx.strokeStyle = `rgba(255, 170, 68, ${0.4})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([15, 8]);
            ctx.beginPath();
            ctx.moveTo(centerLineX, 0);
            ctx.lineTo(centerLineX, h);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Einstein's equations forming geometric patterns (left side) - stronger
            const einsteinEquations = ['E=mc²', 'R_μν - ½g_μνR', 'G_μν = 8πT_μν', 'ψ(x,t)', '∂²ψ/∂t²', '∇²ψ', 'iℏ∂ψ/∂t'];
            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 180 + Math.sin(this.cutsceneTime * 0.6 + i) * 60;
                const x = w * 0.25 + Math.cos(angle) * radius;
                const y = h * 0.5 + Math.sin(angle) * radius;
                const alpha = 0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = einsteinEquations[i % einsteinEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * 0.4})`);
            }
            
            // Bell's equations forming patterns (right side) - fading
            const bellEquations = ['|E(a,b)-E(a,b\')|', '≤ 1+E(a\',b\')', 'P(A,B)', 'P(A)·P(B|A)', '⟨AB⟩', 'λ', 'CHSH'];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 - this.cutsceneTime * 0.4;
                const radius = 180 + Math.sin(this.cutsceneTime * 0.6 + i) * 60;
                const x = w * 0.75 + Math.cos(angle) * radius;
                const y = h * 0.5 + Math.sin(angle) * radius;
                const alpha = (0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15) * bellFadePhase1;
                const rotation = angle - Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = bellEquations[i % bellEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(255, 68, 68, ${alpha * 0.4})`);
            }
            
            // Escape particles crossing from Bell's side to Einstein's side
            for (let i = 0; i < 12; i++) {
                const progress = (this.cutsceneTime * 0.3 + i * 0.2) % 1;
                const startX = w * 0.75 - Math.cos((i / 12) * Math.PI * 2) * 120;
                const startY = h * 0.5 - Math.sin((i / 12) * Math.PI * 2) * 120;
                const endX = w * 0.25 + Math.cos((i / 12) * Math.PI * 2) * 120;
                const endY = h * 0.5 + Math.sin((i / 12) * Math.PI * 2) * 120;
                const x = startX + (endX - startX) * progress;
                const y = startY + (endY - startY) * progress;
                const alpha = (1 - progress * 0.5) * 0.5;
                
                ctx.strokeStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Particle on line
                this.drawGlow(ctx, x, y, 6, `rgba(255, 170, 68, ${alpha})`);
                this.drawGlow(ctx, x, y, 12, `rgba(255, 170, 68, ${alpha * 0.5})`);
            }
            
            // Large mathematical symbols as artistic elements
            const largeSymbols = [
                { sym: 'ψ', x: w * 0.15, y: h * 0.2, color: 'rgba(79, 195, 247, 0.3)' },
                { sym: 'E', x: w * 0.1, y: h * 0.7, color: 'rgba(79, 195, 247, 0.25)' },
                { sym: '∫', x: w * 0.3, y: h * 0.3, color: 'rgba(79, 195, 247, 0.25)' },
                { sym: 'P', x: w * 0.85, y: h * 0.25, color: `rgba(255, 68, 68, ${0.25 * bellFadePhase1})` },
                { sym: '⟨', x: w * 0.9, y: h * 0.7, color: `rgba(255, 68, 68, ${0.25 * bellFadePhase1})` },
                { sym: '∑', x: w * 0.7, y: h * 0.35, color: `rgba(255, 68, 68, ${0.25 * bellFadePhase1})` }
            ];
            
            for (let i = 0; i < largeSymbols.length; i++) {
                const symbol = largeSymbols[i];
                const pulse = 1 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.4;
                const rotation = this.cutsceneTime * 0.15 + i;
                const alpha = symbol.color.includes('195') ? 1 : bellFadePhase1;
                
                ctx.save();
                ctx.translate(symbol.x, symbol.y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = symbol.color.replace(/[\d.]+\)$/, `${0.2 * alpha})`);
                ctx.font = `${90 * pulse}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol.sym, 0, 0);
                ctx.restore();
                
                // Large symbol glow
                this.drawGlow(ctx, symbol.x, symbol.y, 60 * pulse, symbol.color.replace(/[\d.]+\)$/, `${0.15 * alpha})`));
            }
            
            // Quantum field particles (orange theme for escape)
            for (let i = 0; i < 70; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.6 + i) * 20;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.6 + i) * 20;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.08;
                const size = 2.5 + Math.sin(this.cutsceneTime * 2 + i) * 1.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced Einstein at chalkboard - Redesigned layout
            const chalkboardX = w * 0.2;
            const chalkboardY = h * 0.4;
            const chalkboardWidth = 380;
            const chalkboardHeight = 320;
            
            // Enhanced chalkboard
            const boardGradient = ctx.createLinearGradient(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardX - chalkboardWidth/2, chalkboardY + chalkboardHeight/2);
            boardGradient.addColorStop(0, 'rgba(40, 30, 20, 0.96)');
            boardGradient.addColorStop(0.5, 'rgba(50, 40, 30, 0.96)');
            boardGradient.addColorStop(1, 'rgba(40, 30, 20, 0.96)');
            ctx.fillStyle = boardGradient;
            ctx.fillRect(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardWidth, chalkboardHeight);
            
            // Chalkboard border with enhanced frame
            ctx.strokeStyle = 'rgba(100, 80, 60, 0.95)';
            ctx.lineWidth = 6;
            ctx.strokeRect(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardWidth, chalkboardHeight);
            
            // Enhanced chalkboard frame
            ctx.fillStyle = 'rgba(60, 45, 30, 0.95)';
            ctx.fillRect(chalkboardX - chalkboardWidth/2 - 12, chalkboardY - chalkboardHeight/2 - 12, chalkboardWidth + 24, chalkboardHeight + 24);
            ctx.fillRect(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardWidth, chalkboardHeight);
            
            // Chalkboard corner decorations
            ctx.strokeStyle = 'rgba(120, 90, 60, 0.8)';
            ctx.lineWidth = 3;
            const cornerSize = 15;
            ctx.beginPath();
            ctx.moveTo(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2 + cornerSize);
            ctx.lineTo(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2);
            ctx.lineTo(chalkboardX - chalkboardWidth/2 + cornerSize, chalkboardY - chalkboardHeight/2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(chalkboardX + chalkboardWidth/2 - cornerSize, chalkboardY - chalkboardHeight/2);
            ctx.lineTo(chalkboardX + chalkboardWidth/2, chalkboardY - chalkboardHeight/2);
            ctx.lineTo(chalkboardX + chalkboardWidth/2, chalkboardY - chalkboardHeight/2 + cornerSize);
            ctx.stroke();
            
            // Writing animation on chalkboard
            const writingProgress = Math.min(1, this.cutsceneTime / 5);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
            ctx.font = '17px Arial';
            ctx.textAlign = 'left';
            
            // Mathematical derivation - compact to fit
            const lines = [
                'Breaking Free from Bell:',
                '',
                'Bell\'s Inequality:',
                '|E(a,b) - E(a,b\')| ≤',
                '  1 + E(a\',b\')',
                '',
                'Requires correlated pairs:',
                'P(A,B) = P(A)·P(B|A)',
                '',
                'For individual systems:',
                'P(A) = |ψ_A|²',
                'P(B) = |ψ_B|²',
                '',
                'No correlation:',
                'P(A,B) = P(A)·P(B)',
                '',
                '→ Bell doesn\'t apply!'
            ];
            
            const lineHeight = 19;
            const startY = chalkboardY - chalkboardHeight/2 + 25;
            const leftMargin = chalkboardX - chalkboardWidth/2 + 25;
            
            for (let i = 0; i < lines.length; i++) {
                const lineProgress = Math.min(1, (writingProgress * lines.length - i) / 1);
                if (lineProgress > 0) {
                    const charsToShow = Math.floor(lines[i].length * lineProgress);
                    const visibleText = lines[i].substring(0, charsToShow);
                    ctx.fillText(visibleText, leftMargin, startY + i * lineHeight);
                }
            }
            
            // Einstein character positioned BELOW chalkboard
            const einsteinX = chalkboardX;
            const einsteinY = chalkboardY + chalkboardHeight/2 + 50;
            const einsteinFloat = Math.sin(this.cutsceneTime * 1.5) * 5;
            this.drawEinsteinCharacter(ctx, einsteinX, einsteinY + einsteinFloat, 0.7, 1, this.cutsceneTime);
            
            // Writing hand animation
            if (writingProgress > 0 && writingProgress < 1) {
                const handX = leftMargin + Math.cos(this.cutsceneTime * 4) * 3;
                const handY = startY + (writingProgress * (chalkboardHeight - 50)) + Math.sin(this.cutsceneTime * 4) * 2;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(handX, handY, 5, 0, Math.PI * 2);
                ctx.fill();
                this.drawGlow(ctx, handX, handY, 8, 'rgba(255, 255, 255, 0.4)');
            }
            
            // Bell's statistical thinking (fading/breaking)
            const bellFade = Math.max(0, 1 - this.cutsceneTime / 2);
            if (bellFade > 0) {
                const bellPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
                const bellGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 120 * bellPulse);
                bellGradient.addColorStop(0, `rgba(255, 68, 68, ${bellFade * 0.4})`);
                bellGradient.addColorStop(0.5, `rgba(255, 100, 100, ${bellFade * 0.3})`);
                bellGradient.addColorStop(1, `rgba(255, 68, 68, ${bellFade * 0.1})`);
                ctx.fillStyle = bellGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 120 * bellPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Statistical patterns (fading)
                ctx.strokeStyle = `rgba(255, 68, 68, ${bellFade * 0.3})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + this.cutsceneTime * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + Math.cos(angle) * 100, centerY + Math.sin(angle) * 100);
                    ctx.stroke();
                }
            }
            
            // Breaking free effect - molecules escaping
            const escapeProgress = Math.min(1, this.cutsceneTime / 2);
            const moleculeCount = 10;
            for (let i = 0; i < moleculeCount; i++) {
                const angle = (i / moleculeCount) * Math.PI * 2;
                const baseDist = 80;
                const escapeDist = baseDist + escapeProgress * 200;
                const x = centerX + Math.cos(angle) * escapeDist;
                const y = centerY + Math.sin(angle) * escapeDist;
                const moleculeFade = Math.min(1, (this.cutsceneTime - i * 0.15) / 1);
                
                // Escaping molecule
                const moleculePulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.2;
                const moleculeSize = 12 * moleculePulse;
                const moleculeGradient = ctx.createRadialGradient(x, y, 0, x, y, moleculeSize);
                moleculeGradient.addColorStop(0, `rgba(255, 170, 68, ${moleculeFade})`);
                moleculeGradient.addColorStop(1, `rgba(255, 140, 40, ${moleculeFade * 0.6})`);
                ctx.fillStyle = moleculeGradient;
                ctx.beginPath();
                ctx.arc(x, y, moleculeSize, 0, Math.PI * 2);
                ctx.fill();
                this.drawGlow(ctx, x, y, moleculeSize, `rgba(255, 170, 68, ${moleculeFade * 0.8})`);
                this.drawGlow(ctx, x, y, moleculeSize * 1.5, `rgba(255, 170, 68, ${moleculeFade * 0.4})`);
                
                // Escape trail
                const trailProgress = Math.max(0, escapeProgress - 0.2);
                const trailDist = baseDist + trailProgress * 200;
                const trailX = centerX + Math.cos(angle) * trailDist;
                const trailY = centerY + Math.sin(angle) * trailDist;
                this.drawGlow(ctx, trailX, trailY, moleculeSize * 0.5, `rgba(255, 170, 68, ${moleculeFade * 0.3})`);
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, h * 0.75, 200, `rgba(255, 170, 68, ${textGlow * textFade * 0.2})`);
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 15;
                ctx.fillText('Breaking free from Bell\'s statistical thinking!', centerX, h * 0.75);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(55);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced understanding - individual systems with definite properties
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Einstein's Victory - Individual Systems Realm (Phase 2)
            // Unified background showing Einstein's approach winning
            const victoryGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h) * 0.8);
            victoryGradient.addColorStop(0, 'rgba(79, 195, 247, 0.25)');
            victoryGradient.addColorStop(0.3, 'rgba(79, 195, 247, 0.15)');
            victoryGradient.addColorStop(0.6, 'rgba(255, 170, 68, 0.1)');
            victoryGradient.addColorStop(1, 'rgba(255, 170, 68, 0)');
            ctx.fillStyle = victoryGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Individual system equations forming a unified pattern
            const individualEquations = ['ψ(x,t)', 'P(A) = |ψ_A|²', 'P(B) = |ψ_B|²', 'A or B', 'not pairs', 'No correlation'];
            for (let i = 0; i < 18; i++) {
                const angle = (i / 18) * Math.PI * 2 + this.cutsceneTime * 0.5;
                const radius = 200 + Math.sin(this.cutsceneTime * 0.7 + i) * 80;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.3 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                const rotation = angle + Math.PI / 2;
                const scale = 0.9 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${20 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = individualEquations[i % individualEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 35 * scale, `rgba(255, 170, 68, ${alpha * 0.5})`);
            }
            
            // Central understanding symbol - large and pulsing
            const understandingPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.2;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = 'rgba(255, 170, 68, 0.4)';
            ctx.font = `${120 * understandingPulse}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ψ', 0, 0);
            ctx.restore();
            this.drawGlow(ctx, centerX, centerY, 80 * understandingPulse, 'rgba(255, 170, 68, 0.3)');
            
            // Connecting lines from equations to center (understanding forming)
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = 200;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const connectionAlpha = 0.2 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                
                ctx.strokeStyle = `rgba(255, 170, 68, ${connectionAlpha})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Energy particles along connection
                for (let j = 0; j < 3; j++) {
                    const progress = (this.cutsceneTime * 0.4 + j * 0.3 + i * 0.1) % 1;
                    const px = centerX + Math.cos(angle) * radius * progress;
                    const py = centerY + Math.sin(angle) * radius * progress;
                    this.drawGlow(ctx, px, py, 4, `rgba(255, 170, 68, ${connectionAlpha * (1 - progress)})`);
                }
            }
            
            // Large mathematical symbols as artistic elements - unified theme
            const largeSymbols = [
                { sym: 'ψ', x: w * 0.15, y: h * 0.2, color: 'rgba(255, 170, 68, 0.3)' },
                { sym: 'A', x: w * 0.1, y: h * 0.7, color: 'rgba(255, 170, 68, 0.25)' },
                { sym: 'B', x: w * 0.3, y: h * 0.3, color: 'rgba(255, 170, 68, 0.25)' },
                { sym: '∫', x: w * 0.85, y: h * 0.25, color: 'rgba(255, 170, 68, 0.25)' },
                { sym: '|', x: w * 0.9, y: h * 0.7, color: 'rgba(255, 170, 68, 0.25)' },
                { sym: '²', x: w * 0.7, y: h * 0.35, color: 'rgba(255, 170, 68, 0.25)' }
            ];
            
            for (let i = 0; i < largeSymbols.length; i++) {
                const symbol = largeSymbols[i];
                const pulse = 1 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.4;
                const rotation = this.cutsceneTime * 0.15 + i;
                
                ctx.save();
                ctx.translate(symbol.x, symbol.y);
                ctx.rotate(rotation);
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = symbol.color;
                ctx.font = `${90 * pulse}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol.sym, 0, 0);
                ctx.restore();
                
                // Large symbol glow
                this.drawGlow(ctx, symbol.x, symbol.y, 60 * pulse, symbol.color.replace(/[\d.]+\)$/, '0.15)'));
            }
            
            // Quantum field particles (orange/cyan blend for understanding)
            for (let i = 0; i < 80; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.6 + i) * 25;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.6 + i) * 25;
                const alpha = 0.18 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.1;
                const size = 3 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                // Blend of orange and cyan
                const colorBlend = Math.sin(this.cutsceneTime * 1.5 + i) * 0.5 + 0.5;
                const r = 255 * colorBlend + 79 * (1 - colorBlend);
                const g = 170 * colorBlend + 195 * (1 - colorBlend);
                const b = 68 * colorBlend + 247 * (1 - colorBlend);
                this.drawGlow(ctx, x, y, size * 2, `rgba(${r}, ${g}, ${b}, ${alpha})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced Einstein at chalkboard - Redesigned layout
            const chalkboardX = w * 0.2;
            const chalkboardY = h * 0.4;
            const chalkboardWidth = 380;
            const chalkboardHeight = 320;
            
            // Enhanced chalkboard
            const boardGradient = ctx.createLinearGradient(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardX - chalkboardWidth/2, chalkboardY + chalkboardHeight/2);
            boardGradient.addColorStop(0, 'rgba(40, 30, 20, 0.96)');
            boardGradient.addColorStop(0.5, 'rgba(50, 40, 30, 0.96)');
            boardGradient.addColorStop(1, 'rgba(40, 30, 20, 0.96)');
            ctx.fillStyle = boardGradient;
            ctx.fillRect(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardWidth, chalkboardHeight);
            
            // Chalkboard border with enhanced frame
            ctx.strokeStyle = 'rgba(100, 80, 60, 0.95)';
            ctx.lineWidth = 6;
            ctx.strokeRect(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardWidth, chalkboardHeight);
            
            // Enhanced chalkboard frame
            ctx.fillStyle = 'rgba(60, 45, 30, 0.95)';
            ctx.fillRect(chalkboardX - chalkboardWidth/2 - 12, chalkboardY - chalkboardHeight/2 - 12, chalkboardWidth + 24, chalkboardHeight + 24);
            ctx.fillRect(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2, chalkboardWidth, chalkboardHeight);
            
            // Chalkboard corner decorations
            ctx.strokeStyle = 'rgba(120, 90, 60, 0.8)';
            ctx.lineWidth = 3;
            const cornerSize = 15;
            ctx.beginPath();
            ctx.moveTo(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2 + cornerSize);
            ctx.lineTo(chalkboardX - chalkboardWidth/2, chalkboardY - chalkboardHeight/2);
            ctx.lineTo(chalkboardX - chalkboardWidth/2 + cornerSize, chalkboardY - chalkboardHeight/2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(chalkboardX + chalkboardWidth/2 - cornerSize, chalkboardY - chalkboardHeight/2);
            ctx.lineTo(chalkboardX + chalkboardWidth/2, chalkboardY - chalkboardHeight/2);
            ctx.lineTo(chalkboardX + chalkboardWidth/2, chalkboardY - chalkboardHeight/2 + cornerSize);
            ctx.stroke();
            
            // Complete mathematical derivation on chalkboard - compact to fit
            ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
            ctx.font = '17px Arial';
            ctx.textAlign = 'left';
            
            const lines = [
                'Complete Description:',
                '',
                'ψ(x,t) = complete',
                '  description of',
                '  individual system',
                '',
                'For A or B (not pairs):',
                '',
                'P(A) = |ψ_A(x,t)|²',
                'P(B) = |ψ_B(x,t)|²',
                '',
                'No correlation:',
                'P(A,B) = P(A)·P(B)',
                '',
                'Bell requires:',
                'P(A,B) ≠ P(A)·P(B)',
                '',
                '→ Bell doesn\'t apply!'
            ];
            
            const lineHeight = 18;
            const startY = chalkboardY - chalkboardHeight/2 + 25;
            const leftMargin = chalkboardX - chalkboardWidth/2 + 25;
            
            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], leftMargin, startY + i * lineHeight);
            }
            
            // Einstein character positioned BELOW chalkboard
            const einsteinX = chalkboardX;
            const einsteinY = chalkboardY + chalkboardHeight/2 + 50;
            const einsteinFloat = Math.sin(this.cutsceneTime * 1.5) * 5;
            this.drawEinsteinCharacter(ctx, einsteinX, einsteinY + einsteinFloat, 0.7, 1, this.cutsceneTime);
            
            // Pointing at key equation
            const pointProgress = Math.sin(this.cutsceneTime * 2);
            if (pointProgress > 0) {
                const pointX = leftMargin;
                const pointY = startY + 17 * lineHeight; // Points at "→ Bell doesn't apply!"
                ctx.strokeStyle = `rgba(255, 170, 68, ${pointProgress * 0.8})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(einsteinX, einsteinY - 30);
                ctx.lineTo(pointX + 120, pointY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                this.drawGlow(ctx, pointX + 120, pointY, 8, `rgba(255, 170, 68, ${pointProgress * 0.5})`);
            }
            
            // Individual systems with definite properties appearing
            const systemCount = 6;
            const systemFormation = Math.min(1, this.cutsceneTime / 2);
            for (let i = 0; i < systemCount; i++) {
                const angle = (i / systemCount) * Math.PI * 2;
                const dist = 120;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const systemFade = Math.min(1, (this.cutsceneTime - i * 0.2) / 1.5);
                
                // Individual system with definite properties
                const systemPulse = 1 + Math.sin(this.cutsceneTime * 2 + i) * 0.15;
                const systemSize = 25 * systemPulse;
                
                // System core
                const systemGradient = ctx.createRadialGradient(x, y, 0, x, y, systemSize);
                systemGradient.addColorStop(0, `rgba(255, 170, 68, ${systemFade})`);
                systemGradient.addColorStop(0.5, `rgba(255, 200, 100, ${systemFade})`);
                systemGradient.addColorStop(1, `rgba(255, 140, 40, ${systemFade * 0.6})`);
                ctx.fillStyle = systemGradient;
                ctx.beginPath();
                ctx.arc(x, y, systemSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Definite properties (inner structure)
                if (systemFade > 0.5) {
                    ctx.strokeStyle = `rgba(255, 200, 100, ${systemFade})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, systemSize * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                    // Property indicators
                    for (let j = 0; j < 4; j++) {
                        const propAngle = (j / 4) * Math.PI * 2;
                        const propX = x + Math.cos(propAngle) * systemSize * 0.8;
                        const propY = y + Math.sin(propAngle) * systemSize * 0.8;
                        ctx.fillStyle = `rgba(255, 200, 100, ${systemFade})`;
                        ctx.beginPath();
                        ctx.arc(propX, propY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // System glow
                this.drawGlow(ctx, x, y, systemSize, `rgba(255, 170, 68, ${systemFade * 0.9})`);
                this.drawGlow(ctx, x, y, systemSize * 1.5, `rgba(255, 170, 68, ${systemFade * 0.5})`);
                
                // Connection to center (understanding forming)
                if (systemFade > 0.3) {
                    const connectionAlpha = (systemFade - 0.3) / 0.7;
                    ctx.strokeStyle = `rgba(255, 170, 68, ${connectionAlpha * 0.4})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
            }
            
            // Central understanding point
            const understandingProgress = Math.min(1, (this.cutsceneTime - 1) / 1.5);
            if (understandingProgress > 0) {
                const understandingPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
                const understandingGlow = 0.5 + Math.sin(this.cutsceneTime * 2) * 0.3;
                this.drawGlow(ctx, centerX, centerY, 40 * understandingPulse, `rgba(255, 170, 68, ${understandingGlow * understandingProgress * 0.4})`);
                this.drawGlow(ctx, centerX, centerY, 60 * understandingPulse, `rgba(255, 170, 68, ${understandingGlow * understandingProgress * 0.2})`);
                
                // Understanding text
                ctx.globalAlpha = understandingProgress;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, h * 0.75, 200, `rgba(255, 170, 68, ${textGlow * understandingProgress * 0.2})`);
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 15;
                ctx.fillText('Individual systems have definite properties', centerX, h * 0.75);
                ctx.font = '22px Arial';
                ctx.fillText('Complete descriptions are possible!', centerX, h * 0.8);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(55);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
        }
    }
    
    // Level 65: Transformation Time Problem - Enhanced with Ensemble Bypass
    drawCutsceneLevel65(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced radioactive atom with definite transformation time
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Time and Transformation - Mathematical Realm
            // Time-based equations forming patterns
            const timeEquations = ['t = τ', 'N(t) = N₀e^(-λt)', 'λ = ln(2)/T₁/₂', 'P(t) = 1 - e^(-λt)', 'τ = 1/λ', 'dN/dt = -λN'];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 200 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.7 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${17 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = timeEquations[i % timeEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.4})`);
            }
            
            // Transformation symbols floating
            const transformSymbols = ['τ', 't', 'λ', 'T', 'N', 'P', 'e', 'ln', 'd/dt', '∫'];
            for (let i = 0; i < 25; i++) {
                const symbolIndex = i % transformSymbols.length;
                const symbol = transformSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 35;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 35;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.3})`);
            }
            
            // Large time symbols as artistic elements
            const largeSymbols = [
                { sym: 'τ', x: w * 0.15, y: h * 0.2, color: 'rgba(79, 195, 247, 0.3)' },
                { sym: 't', x: w * 0.1, y: h * 0.7, color: 'rgba(79, 195, 247, 0.25)' },
                { sym: 'λ', x: w * 0.85, y: h * 0.25, color: 'rgba(79, 195, 247, 0.25)' },
                { sym: 'T', x: w * 0.9, y: h * 0.7, color: 'rgba(79, 195, 247, 0.25)' },
                { sym: 'e', x: w * 0.3, y: h * 0.3, color: 'rgba(79, 195, 247, 0.25)' }
            ];
            
            for (let i = 0; i < largeSymbols.length; i++) {
                const symbol = largeSymbols[i];
                const pulse = 1 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.4;
                const rotation = this.cutsceneTime * 0.15 + i;
                
                ctx.save();
                ctx.translate(symbol.x, symbol.y);
                ctx.rotate(rotation);
                ctx.globalAlpha = 0.2 * fade;
                ctx.fillStyle = symbol.color;
                ctx.font = `${90 * pulse}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol.sym, 0, 0);
                ctx.restore();
                
                // Large symbol glow
                this.drawGlow(ctx, symbol.x, symbol.y, 60 * pulse, symbol.color.replace(/[\d.]+\)$/, `${0.15 * fade})`));
            }
            
            // Quantum field particles (cyan theme for transformation)
            for (let i = 0; i < 70; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.6 + i) * 20;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.6 + i) * 20;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.08;
                const size = 2.5 + Math.sin(this.cutsceneTime * 2 + i) * 1.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha * fade})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced title with multi-layer glow
            const titleGlow = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, centerX, h * 0.15, 200, `rgba(79, 195, 247, ${titleGlow * fade * 0.3})`);
            this.drawGlow(ctx, centerX, h * 0.15, 150, `rgba(79, 195, 247, ${titleGlow * fade * 0.5})`);
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TRANSFORMATION TIME', centerX, h * 0.15);
            ctx.shadowBlur = 0;
            
            // Enhanced radioactive atom with pulsing and transformation animation
            const atomX = centerX;
            const atomY = centerY;
            const atomPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.15;
            
            // Atom nucleus with enhanced gradient
            const nucleusGradient = ctx.createRadialGradient(atomX, atomY, 0, atomX, atomY, 40 * atomPulse);
            nucleusGradient.addColorStop(0, '#ffaa44');
            nucleusGradient.addColorStop(0.3, '#ff8800');
            nucleusGradient.addColorStop(0.6, '#ff6600');
            nucleusGradient.addColorStop(1, '#cc5500');
            ctx.fillStyle = nucleusGradient;
            ctx.beginPath();
            ctx.arc(atomX, atomY, 40 * atomPulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Multiple glow layers
            this.drawGlow(ctx, atomX, atomY, 40 * atomPulse, 'rgba(255, 170, 68, 0.9)');
            this.drawGlow(ctx, atomX, atomY, 60 * atomPulse, 'rgba(255, 170, 68, 0.6)');
            this.drawGlow(ctx, atomX, atomY, 80 * atomPulse, 'rgba(255, 170, 68, 0.3)');
            
            // Electrons/orbitals with transformation animation
            const electronCount = 3;
            for (let i = 0; i < electronCount; i++) {
                const angle = (i / electronCount) * Math.PI * 2 + this.cutsceneTime * 2;
                const radius = 70 + Math.sin(this.cutsceneTime * 1.5 + i) * 10;
                const electronX = atomX + Math.cos(angle) * radius;
                const electronY = atomY + Math.sin(angle) * radius;
                const electronPulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                
                // Electron
                ctx.fillStyle = `rgba(255, 170, 68, ${0.8})`;
                ctx.beginPath();
                ctx.arc(electronX, electronY, 6 * electronPulse, 0, Math.PI * 2);
                ctx.fill();
                this.drawGlow(ctx, electronX, electronY, 8 * electronPulse, 'rgba(255, 170, 68, 0.6)');
                
                // Orbital path
                ctx.strokeStyle = `rgba(255, 170, 68, ${0.2})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(atomX, atomY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Transformation particles radiating outward
            const particleCount = 12;
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2 + this.cutsceneTime * 1.5;
                const dist = 50 + (this.cutsceneTime % 2) * 100;
                const x = atomX + Math.cos(angle) * dist;
                const y = atomY + Math.sin(angle) * dist;
                const alpha = 0.8 - (this.cutsceneTime % 2) * 0.4;
                const size = 4 + Math.sin(this.cutsceneTime * 4 + i) * 2;
                
                if (alpha > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha})`);
                    this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 170, 68, ${alpha * 0.5})`);
                }
            }
            
            // Enhanced transformation time display with pulsing
            const timeValue = Math.max(0, (3.7 - this.cutsceneTime * 0.3)).toFixed(1);
            const timePulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.1;
            const timeGlow = 0.6 + Math.sin(this.cutsceneTime * 3) * 0.4;
            this.drawGlow(ctx, atomX, atomY - 60, 150, `rgba(79, 195, 247, ${timeGlow * fade * 0.2})`);
            ctx.fillStyle = '#4fc3f7';
            ctx.font = `bold ${36 * timePulse}px Arial`;
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 20;
            ctx.fillText(`t = ${timeValue} seconds`, atomX, atomY - 60);
            ctx.shadowBlur = 0;
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = fade * textFade;
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 24px Arial';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 12;
            ctx.fillText('Definite transformation time', atomX, atomY + 60);
                ctx.font = '22px Arial';
            ctx.fillText('Psi-function cannot show this', atomX, atomY + 90);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = fade;
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(65);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced show the problem - Psi-function limitation
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Incomplete vs Complete - Mathematical Conflict
            // Left side: Psi-function realm (fading/incomplete)
            const psiFade = Math.max(0, 1 - this.cutsceneTime / 2);
            const psiGradient = ctx.createRadialGradient(w * 0.3, centerY, 0, w * 0.3, centerY, Math.max(w, h) * 0.5);
            psiGradient.addColorStop(0, `rgba(79, 195, 247, ${0.2 * psiFade})`);
            psiGradient.addColorStop(0.5, `rgba(79, 195, 247, ${0.1 * psiFade})`);
            psiGradient.addColorStop(1, `rgba(79, 195, 247, 0)`);
            ctx.fillStyle = psiGradient;
            ctx.fillRect(0, 0, w * 0.6, h);
            
            // Right side: Complete description realm (growing)
            const completeGrow = Math.min(1, this.cutsceneTime / 2);
            const completeGradient = ctx.createRadialGradient(w * 0.7, centerY, 0, w * 0.7, centerY, Math.max(w, h) * 0.5);
            completeGradient.addColorStop(0, `rgba(79, 195, 247, ${0.25 * completeGrow})`);
            completeGradient.addColorStop(0.5, `rgba(79, 195, 247, ${0.15 * completeGrow})`);
            completeGradient.addColorStop(1, `rgba(79, 195, 247, 0)`);
            ctx.fillStyle = completeGradient;
            ctx.fillRect(w * 0.4, 0, w * 0.6, h);
            
            // Psi-function equations (left side) - fading
            const psiEquations = ['Ψ(x,t)', '|Ψ|²', '⟨Ψ|Ψ⟩', 'P = |Ψ|²', 'incomplete'];
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2 + this.cutsceneTime * 0.3;
                const radius = 150 + Math.sin(this.cutsceneTime * 0.5 + i) * 50;
                const x = w * 0.3 + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.2 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1) * psiFade;
                const rotation = angle + Math.PI / 2;
                const scale = 0.7 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${16 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = psiEquations[i % psiEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 25 * scale, `rgba(79, 195, 247, ${alpha * 0.3})`);
            }
            
            // Complete description equations (right side) - growing
            const completeEquations = ['ψ(x,t)', 'complete', 't = τ', 'definite', 'exact time'];
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2 - this.cutsceneTime * 0.3;
                const radius = 150 + Math.sin(this.cutsceneTime * 0.5 + i) * 50;
                const x = w * 0.7 + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.2 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1) * completeGrow;
                const rotation = angle - Math.PI / 2;
                const scale = 0.7 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${16 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = completeEquations[i % completeEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 25 * scale, `rgba(79, 195, 247, ${alpha * 0.3})`);
            }
            
            // Transformation symbols floating
            const transformSymbols = ['τ', 't', 'λ', 'T', 'N', 'P', 'e', 'ln'];
            for (let i = 0; i < 20; i++) {
                const symbolIndex = i % transformSymbols.length;
                const symbol = transformSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${22 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(79, 195, 247, ${alpha * 0.3})`);
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced Psi-function equation (faded/incomplete) with pulsing
            const psiPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            const psiGlow = 0.4 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, centerX, centerY - 50, 150, `rgba(79, 195, 247, ${psiGlow * fade * 0.3})`);
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 25;
            ctx.fillStyle = `rgba(79, 195, 247, ${0.5 * fade})`;
            ctx.font = `bold ${64 * psiPulse}px "Times New Roman", serif`;
            ctx.textAlign = 'center';
            ctx.fillText('Ψ(x,t)', centerX, centerY - 50);
            ctx.shadowBlur = 0;
            
            // Enhanced cross-out line with pulsing
            const crossPulse = 0.8 + Math.sin(this.cutsceneTime * 3) * 0.2;
            ctx.strokeStyle = `rgba(255, 68, 68, ${crossPulse * fade})`;
            ctx.lineWidth = 6;
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(centerX - 100, centerY - 100);
            ctx.lineTo(centerX + 100, centerY);
            ctx.stroke();
            ctx.shadowBlur = 0;
            // Cross-out glow
            this.drawGlow(ctx, centerX, centerY - 50, 5, `rgba(255, 68, 68, ${crossPulse * fade * 0.4})`);
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, centerY + 20, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
            ctx.fillText('Cannot show exact', centerX, centerY + 20);
            ctx.fillText('transformation time', centerX, centerY + 50);
                ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
            ctx.fillText('Incomplete for individual systems', centerX, centerY + 90);
                ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(65);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced the solution - bypassing ensemble limitations
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Bypass Solution - Circuit Patterns
            // Ensemble route equations (fading/blocked)
            const ensembleEquations = ['P(A,B)', 'ensemble', 'statistical', 'incomplete'];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + this.cutsceneTime * 0.2;
                const radius = 180 + Math.sin(this.cutsceneTime * 0.4 + i) * 40;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.15 + Math.sin(this.cutsceneTime * 1.2 + i) * 0.1) * (1 - fade * 0.5);
                const rotation = angle + Math.PI / 2;
                const scale = 0.6 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${15 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = ensembleEquations[i % ensembleEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 25 * scale, `rgba(255, 68, 68, ${alpha * 0.3})`);
            }
            
            // Bypass solution equations (growing/active)
            const bypassEquations = ['bypass', 'individual', 'complete', 't = τ', 'definite'];
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2 - this.cutsceneTime * 0.3;
                const radius = 200 + Math.sin(this.cutsceneTime * 0.5 + i) * 60;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15) * fade;
                const rotation = angle - Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = bypassEquations[i % bypassEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * 0.4})`);
            }
            
            // Circuit symbols floating
            const circuitSymbols = ['→', '⟶', '⟹', '↗', '↘', '⟲', '⟳'];
            for (let i = 0; i < 15; i++) {
                const symbolIndex = i % circuitSymbols.length;
                const symbol = circuitSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.3 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(79, 195, 247, ${alpha * 0.3})`);
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced bypass concept - circuit path with bypass route
            const circuitX = centerX;
            const circuitY = centerY;
            const circuitPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            
            // Main circuit path (ensemble route - blocked) with enhanced visuals
            ctx.strokeStyle = 'rgba(255, 68, 68, 0.6)';
            ctx.lineWidth = 5;
            ctx.setLineDash([12, 6]);
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(circuitX - 120, circuitY);
            ctx.lineTo(circuitX - 30, circuitY);
            ctx.lineTo(circuitX - 30, circuitY - 30);
            ctx.lineTo(circuitX + 30, circuitY - 30);
            ctx.lineTo(circuitX + 30, circuitY);
            ctx.lineTo(circuitX + 120, circuitY);
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.setLineDash([]);
            
            // Blocked indicators on ensemble route
            for (let i = 0; i < 3; i++) {
                const blockX = circuitX - 60 + i * 40;
                const blockY = circuitY - 15;
                ctx.fillStyle = 'rgba(255, 68, 68, 0.4)';
                ctx.fillRect(blockX - 8, blockY - 3, 16, 6);
                this.drawGlow(ctx, blockX, blockY, 8, 'rgba(255, 68, 68, 0.3)');
            }
            
            // Enhanced bypass route (individual system route - active) with pulsing
            const bypassPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.15;
            ctx.strokeStyle = 'rgba(79, 195, 247, 1)';
            ctx.lineWidth = 8 * bypassPulse;
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(circuitX - 30, circuitY);
            ctx.lineTo(circuitX + 30, circuitY);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Enhanced arrow on bypass route with pulsing
            const arrowPulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.2;
            ctx.beginPath();
            ctx.moveTo(circuitX + 30, circuitY);
            ctx.lineTo(circuitX + 18, circuitY - 8 * arrowPulse);
            ctx.moveTo(circuitX + 30, circuitY);
            ctx.lineTo(circuitX + 18, circuitY + 8 * arrowPulse);
            ctx.stroke();
            
            // Enhanced glow on bypass with multiple layers
            this.drawGlow(ctx, circuitX, circuitY, 50 * bypassPulse, 'rgba(79, 195, 247, 0.8)');
            this.drawGlow(ctx, circuitX, circuitY, 70 * bypassPulse, 'rgba(79, 195, 247, 0.5)');
            this.drawGlow(ctx, circuitX, circuitY, 90 * bypassPulse, 'rgba(79, 195, 247, 0.3)');
            
            // Energy particles flowing through bypass
            for (let layer = 0; layer < 2; layer++) {
                const layerSpeed = 0.8 + layer * 0.4;
                for (let i = 0; i < 8; i++) {
                    const progress = (this.cutsceneTime * layerSpeed + i * 0.2) % 1;
                    const x = circuitX - 30 + progress * 60;
                    const y = circuitY + Math.sin(progress * Math.PI * 4) * (3 - layer);
                    const alpha = (0.9 - layer * 0.1) - progress * (0.3 - layer * 0.1);
                    const size = 6 + layer * 2;
                    if (alpha > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
                    }
                }
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, centerY + 60, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
            ctx.fillText('Bypass ensemble limitations', centerX, centerY + 60);
                ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
            ctx.fillText('Sidestep statistical QM', centerX, centerY + 90);
                ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(65);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 3) {
            // Phase 3: Enhanced Einstein building the Ensemble Bypass upgrade
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Bypass Construction - Circuit Patterns
            // Bypass solution equations forming patterns
            const bypassEquations = ['bypass', 'individual', 'complete', 't = τ', 'definite', 'circuit'];
            for (let i = 0; i < 14; i++) {
                const angle = (i / 14) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 220 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = bypassEquations[i % bypassEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * 0.4})`);
            }
            
            // Circuit symbols floating
            const circuitSymbols = ['→', '⟶', '⟹', '↗', '↘', '⟲', '⟳', '⟷', '⇄'];
            for (let i = 0; i < 20; i++) {
                const symbolIndex = i % circuitSymbols.length;
                const symbol = circuitSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.3 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(79, 195, 247, ${alpha * 0.3})`);
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship working glow
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(79, 195, 247, ${workGlow * 0.2})`);
            
            // Workbench/construction area (center-right)
            const workbenchX = centerX + 100;
            const workbenchY = centerY;
            const workbenchFade = Math.min(1, this.cutsceneTime / 1.5);
            
            // Enhanced background workbench panel with gradient
            ctx.globalAlpha = workbenchFade;
            const panelGradient = ctx.createLinearGradient(workbenchX - 200, workbenchY - 150, workbenchX - 200, workbenchY + 150);
            panelGradient.addColorStop(0, 'rgba(79, 195, 247, 0.25)');
            panelGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.2)');
            panelGradient.addColorStop(1, 'rgba(79, 195, 247, 0.15)');
            ctx.fillStyle = panelGradient;
            ctx.fillRect(workbenchX - 200, workbenchY - 150, 400, 300);
            
            // Enhanced panel border with pulsing glow
            const panelGlow = 0.5 + Math.sin(this.cutsceneTime * 3) * 0.3;
            ctx.strokeStyle = `rgba(79, 195, 247, ${panelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchX - 200, workbenchY - 150, 400, 300);
            // Corner glows
            this.drawGlow(ctx, workbenchX - 200, workbenchY - 150, 25, `rgba(79, 195, 247, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY - 150, 25, `rgba(79, 195, 247, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX - 200, workbenchY + 150, 25, `rgba(79, 195, 247, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY + 150, 25, `rgba(79, 195, 247, ${panelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const x = workbenchX - 200 + (i * 80);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 150);
                ctx.lineTo(x, workbenchY + 150);
                ctx.stroke();
            }
            for (let i = 0; i < 5; i++) {
                const y = workbenchY - 150 + (i * 75);
                ctx.beginPath();
                ctx.moveTo(workbenchX - 200, y);
                ctx.lineTo(workbenchX + 200, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Construction progress (0-1 over time)
            const buildProgress = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 7));
            
            // Phase 1: Enhanced gathering bypass data (0-30%)
            if (buildProgress < 0.3) {
                const gatherProgress = buildProgress / 0.3;
                const particleCount = 25;
                
                // Enhanced particles with multiple layers and trails
                for (let layer = 0; layer < 2; layer++) {
                    const layerCount = particleCount + layer * 10;
                    const layerSpeed = 1 + layer * 0.5;
                    for (let i = 0; i < layerCount; i++) {
                        const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed * 0.1;
                        const startDist = 250 + layer * 30;
                        const endDist = 100 - layer * 20;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                        const alpha = (0.7 - layer * 0.1) * (1 - gatherProgress);
                        const size = (6 - layer) - gatherProgress * (2 - layer);
                        
                    // Cyan particles for bypass/individual system
                        if (alpha > 0 && size > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                            this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
                            
                            // Particle trail
                            const trailAngle = angle - 0.1;
                            const trailDist = dist + 20;
                            const trailX = workbenchX + Math.cos(trailAngle) * trailDist;
                            const trailY = workbenchY + Math.sin(trailAngle) * trailDist * 0.7;
                            this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(79, 195, 247, ${alpha * 0.3})`);
                        }
                    }
                }
                
                // Central gathering point glow
                const gatherGlow = 0.4 + Math.sin(this.cutsceneTime * 3) * 0.3;
                this.drawGlow(ctx, workbenchX, workbenchY, 80 * gatherProgress, `rgba(79, 195, 247, ${gatherGlow * gatherProgress * 0.4})`);
                
                // Enhanced text with glow
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering bypass circuit data...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 2: Enhanced assembling circuit paths (30-60%)
            if (buildProgress >= 0.3 && buildProgress < 0.6) {
                const assembleProgress = (buildProgress - 0.3) / 0.3;
                
                // Enhanced main circuit path (ensemble route - blocked) with pulsing
                const blockedPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
                ctx.strokeStyle = `rgba(255, 68, 68, ${0.4 + assembleProgress * 0.2})`;
                ctx.lineWidth = 5 * blockedPulse;
                ctx.setLineDash([12, 6]);
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 80, workbenchY);
                ctx.lineTo(workbenchX - 25, workbenchY);
                ctx.lineTo(workbenchX - 25, workbenchY - 25);
                ctx.lineTo(workbenchX + 25, workbenchY - 25);
                ctx.lineTo(workbenchX + 25, workbenchY);
                ctx.lineTo(workbenchX + 80, workbenchY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.setLineDash([]);
                
                // Blocked indicators
                for (let i = 0; i < 2; i++) {
                    const blockX = workbenchX - 50 + i * 50;
                    const blockY = workbenchY - 15;
                    ctx.fillStyle = `rgba(255, 68, 68, ${0.4 * assembleProgress})`;
                    ctx.fillRect(blockX - 6, blockY - 2, 12, 4);
                    this.drawGlow(ctx, blockX, blockY, 6, `rgba(255, 68, 68, ${0.3 * assembleProgress})`);
                }
                
                // Enhanced bypass route assembling with gradient
                const bypassLength = 50 * assembleProgress;
                const bypassPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.15;
                const bypassGradient = ctx.createLinearGradient(workbenchX - 25, workbenchY, workbenchX - 25 + bypassLength, workbenchY);
                bypassGradient.addColorStop(0, `rgba(79, 195, 247, ${0.5 + assembleProgress * 0.5})`);
                bypassGradient.addColorStop(1, `rgba(100, 210, 255, ${0.7 + assembleProgress * 0.3})`);
                ctx.strokeStyle = bypassGradient;
                ctx.lineWidth = 8 * bypassPulse;
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 25, workbenchY);
                ctx.lineTo(workbenchX - 25 + bypassLength, workbenchY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Enhanced glow on bypass with multiple layers
                this.drawGlow(ctx, workbenchX - 25 + bypassLength/2, workbenchY, bypassLength/2, `rgba(79, 195, 247, ${assembleProgress * 0.9})`);
                this.drawGlow(ctx, workbenchX - 25 + bypassLength/2, workbenchY, bypassLength, `rgba(79, 195, 247, ${assembleProgress * 0.5})`);
                
                // Energy flowing along bypass
                for (let i = 0; i < 3; i++) {
                    const flowProgress = (this.cutsceneTime * 0.8 + i * 0.3) % 1;
                    const flowX = workbenchX - 25 + flowProgress * bypassLength;
                    this.drawGlow(ctx, flowX, workbenchY, 8, `rgba(79, 195, 247, ${0.8 - flowProgress * 0.3})`);
                }
                
                // Enhanced circuit particles with convergence
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const baseDist = 60;
                    const convergence = assembleProgress;
                    const dist = baseDist * (1 - convergence * 0.5) + Math.sin(this.cutsceneTime * 3 + i) * 20;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.5 * (1 - assembleProgress);
                    const size = 5 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                    if (alpha > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                    }
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling bypass circuit...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 3: Enhanced completing bypass mechanism (60-85%)
            if (buildProgress >= 0.6 && buildProgress < 0.85) {
                const completeProgress = (buildProgress - 0.6) / 0.25;
                
                // Enhanced complete main circuit (blocked) with pulsing
                const blockedPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
                ctx.strokeStyle = 'rgba(255, 68, 68, 0.6)';
                ctx.lineWidth = 5 * blockedPulse;
                ctx.setLineDash([12, 6]);
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 80, workbenchY);
                ctx.lineTo(workbenchX - 25, workbenchY);
                ctx.lineTo(workbenchX - 25, workbenchY - 25);
                ctx.lineTo(workbenchX + 25, workbenchY - 25);
                ctx.lineTo(workbenchX + 25, workbenchY);
                ctx.lineTo(workbenchX + 80, workbenchY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.setLineDash([]);
                
                // Blocked indicators
                for (let i = 0; i < 2; i++) {
                    const blockX = workbenchX - 50 + i * 50;
                    const blockY = workbenchY - 15;
                    ctx.fillStyle = 'rgba(255, 68, 68, 0.4)';
                    ctx.fillRect(blockX - 6, blockY - 2, 12, 4);
                    this.drawGlow(ctx, blockX, blockY, 6, 'rgba(255, 68, 68, 0.3)');
                }
                
                // Enhanced complete bypass route with pulsing
                const bypassPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.15;
                const bypassGradient = ctx.createLinearGradient(workbenchX - 25, workbenchY, workbenchX + 25, workbenchY);
                bypassGradient.addColorStop(0, 'rgba(79, 195, 247, 1)');
                bypassGradient.addColorStop(0.5, 'rgba(100, 210, 255, 1)');
                bypassGradient.addColorStop(1, 'rgba(79, 195, 247, 1)');
                ctx.strokeStyle = bypassGradient;
                ctx.lineWidth = 8 * bypassPulse;
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 25, workbenchY);
                ctx.lineTo(workbenchX + 25, workbenchY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Enhanced bypass arrow appearing with pulsing
                if (completeProgress > 0.3) {
                    const arrowPulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(workbenchX + 25, workbenchY);
                    ctx.lineTo(workbenchX + 15, workbenchY - 8 * arrowPulse);
                    ctx.moveTo(workbenchX + 25, workbenchY);
                    ctx.lineTo(workbenchX + 15, workbenchY + 8 * arrowPulse);
                    ctx.stroke();
                    this.drawGlow(ctx, workbenchX + 25, workbenchY, 10 * arrowPulse, `rgba(79, 195, 247, ${completeProgress})`);
                }
                
                // Enhanced glow on bypass with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, 50 * bypassPulse, `rgba(79, 195, 247, ${0.9 + completeProgress * 0.1})`);
                this.drawGlow(ctx, workbenchX, workbenchY, 70 * bypassPulse, `rgba(79, 195, 247, ${0.6 + completeProgress * 0.2})`);
                this.drawGlow(ctx, workbenchX, workbenchY, 90 * bypassPulse, `rgba(79, 195, 247, ${0.3 + completeProgress * 0.1})`);
                
                // Enhanced energy flowing through bypass with multiple layers
                for (let layer = 0; layer < 2; layer++) {
                    const layerCount = 10 + layer * 5;
                    const layerSpeed = 0.8 + layer * 0.3;
                    for (let i = 0; i < layerCount; i++) {
                        const progress = (this.cutsceneTime * layerSpeed + i * 0.1) % 1;
                    const x = workbenchX - 25 + progress * 50;
                        const y = workbenchY + Math.sin(progress * Math.PI * 4) * (2 - layer);
                        const alpha = (0.9 - layer * 0.1) - progress * (0.3 - layer * 0.1);
                        const size = 6 + layer * 2;
                        if (alpha > 0) {
                            this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                            this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
                        }
                    }
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.fillText('Energizing bypass circuit...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 4: Enhanced finalizing and testing (85-100%)
            if (buildProgress >= 0.85) {
                const finalizeProgress = (buildProgress - 0.85) / 0.15;
                
                // Enhanced complete circuit (blocked ensemble route) with pulsing
                const blockedPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
                ctx.strokeStyle = 'rgba(255, 68, 68, 0.6)';
                ctx.lineWidth = 5 * blockedPulse;
                ctx.setLineDash([12, 6]);
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 80, workbenchY);
                ctx.lineTo(workbenchX - 25, workbenchY);
                ctx.lineTo(workbenchX - 25, workbenchY - 25);
                ctx.lineTo(workbenchX + 25, workbenchY - 25);
                ctx.lineTo(workbenchX + 25, workbenchY);
                ctx.lineTo(workbenchX + 80, workbenchY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.setLineDash([]);
                
                // Blocked indicators
                for (let i = 0; i < 2; i++) {
                    const blockX = workbenchX - 50 + i * 50;
                    const blockY = workbenchY - 15;
                    ctx.fillStyle = 'rgba(255, 68, 68, 0.4)';
                    ctx.fillRect(blockX - 6, blockY - 2, 12, 4);
                    this.drawGlow(ctx, blockX, blockY, 6, 'rgba(255, 68, 68, 0.3)');
                }
                
                // Enhanced complete bypass route (active) with pulsing
                const bypassPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
                const bypassGradient = ctx.createLinearGradient(workbenchX - 25, workbenchY, workbenchX + 25, workbenchY);
                bypassGradient.addColorStop(0, 'rgba(79, 195, 247, 1)');
                bypassGradient.addColorStop(0.5, 'rgba(100, 210, 255, 1)');
                bypassGradient.addColorStop(1, 'rgba(79, 195, 247, 1)');
                ctx.strokeStyle = bypassGradient;
                ctx.lineWidth = 10 * bypassPulse;
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 25;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 25, workbenchY);
                ctx.lineTo(workbenchX + 25, workbenchY);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Enhanced bypass arrow with pulsing
                const arrowPulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.25;
                ctx.beginPath();
                ctx.moveTo(workbenchX + 25, workbenchY);
                ctx.lineTo(workbenchX + 12, workbenchY - 10 * arrowPulse);
                ctx.moveTo(workbenchX + 25, workbenchY);
                ctx.lineTo(workbenchX + 12, workbenchY + 10 * arrowPulse);
                ctx.stroke();
                this.drawGlow(ctx, workbenchX + 25, workbenchY, 12 * arrowPulse, 'rgba(79, 195, 247, 0.8)');
                
                // Enhanced glow on bypass with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, 60 * bypassPulse, 'rgba(79, 195, 247, 1)');
                this.drawGlow(ctx, workbenchX, workbenchY, 80 * bypassPulse, 'rgba(79, 195, 247, 0.7)');
                this.drawGlow(ctx, workbenchX, workbenchY, 100 * bypassPulse, 'rgba(79, 195, 247, 0.4)');
                
                // Enhanced energy flowing through bypass with multiple layers
                for (let layer = 0; layer < 3; layer++) {
                    const layerCount = 12 + layer * 4;
                    const layerSpeed = 1 + layer * 0.4;
                    for (let i = 0; i < layerCount; i++) {
                        const progress = (this.cutsceneTime * layerSpeed + i * 0.08) % 1;
                    const x = workbenchX - 25 + progress * 50;
                        const y = workbenchY + Math.sin(progress * Math.PI * 6) * (3 - layer);
                        const alpha = (0.95 - layer * 0.05) - progress * (0.2 - layer * 0.05);
                        const size = 7 + layer * 2;
                        if (alpha > 0) {
                            this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                            this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.6})`);
                        }
                    }
                }
                
                // Success particles radiating outward
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2 + this.cutsceneTime * 2;
                    const dist = 70 + Math.sin(this.cutsceneTime * 3 + i) * 40;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.7 + Math.sin(this.cutsceneTime * 4 + i) * 0.3;
                    const size = 6 + Math.sin(this.cutsceneTime * 2 + i) * 3;
                    this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                    this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
                }
                
                // Enhanced text with glow
                const textFade = Math.min(1, finalizeProgress * 2);
                if (textFade > 0) {
                    ctx.globalAlpha = textFade;
                    const textGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
                    this.drawGlow(ctx, workbenchX, workbenchY + 120, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
                ctx.fillStyle = '#4fc3f7';
                    ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                    ctx.shadowColor = '#4fc3f7';
                    ctx.shadowBlur = 15;
                ctx.fillText('ENSEMBLE BYPASS COMPLETE!', workbenchX, workbenchY + 120);
                    ctx.shadowBlur = 0;
                ctx.font = '18px Arial';
                ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                    ctx.shadowColor = '#4fc3f7';
                    ctx.shadowBlur = 12;
                    ctx.fillText('Bypass circuit ready', workbenchX, workbenchY + 150);
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
            }
            
            // Enhanced connection lines from ship to workbench (Einstein working)
            const connectionFade = Math.min(1, this.cutsceneTime / 1.5);
            if (connectionFade > 0) {
                ctx.globalAlpha = connectionFade * 0.4;
                ctx.strokeStyle = 'rgba(79, 195, 247, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
                ctx.moveTo(shipX + 30, shipY + shipFloat);
            ctx.lineTo(workbenchX - 200, workbenchY);
            ctx.stroke();
            ctx.setLineDash([]);
                
                // Energy particles flowing along connection
                for (let i = 0; i < 8; i++) {
                    const progress = (this.cutsceneTime * 0.5 + i * 0.2) % 1;
                    const x = shipX + 30 + (workbenchX - 200 - shipX - 30) * progress;
                    const y = shipY + shipFloat + (workbenchY - shipY - shipFloat) * progress;
                    this.drawGlow(ctx, x, y, 4, `rgba(79, 195, 247, ${0.6 - progress * 0.3})`);
                }
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 3 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(65);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[3]) {
                    let text = cutsceneData.texts[3].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        }
    }
    
    // Level 70: Completing the Description - Enhanced with Individual System Barrier
    drawCutsceneLevel70(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced complete description puzzle being solved
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Complete Description - Mathematical Completion
            // Complete description equations forming patterns
            const completeEquations = ['ψ(x,t)', 'complete', 'definite', 'exact', 'precise', 'known'];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 200 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.7 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${17 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = completeEquations[i % completeEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.4})`);
            }
            
            // Property symbols floating
            const propertySymbols = ['ψ', 'x', 't', 'τ', 'λ', 'P', 'E', 'p', '=', '→'];
            for (let i = 0; i < 25; i++) {
                const symbolIndex = i % propertySymbols.length;
                const symbol = propertySymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 35;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 35;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.3})`);
            }
            
            // Large completion symbols as artistic elements
            const largeSymbols = [
                { sym: 'ψ', x: w * 0.15, y: h * 0.2, color: 'rgba(79, 195, 247, 0.3)' },
                { sym: '=', x: w * 0.1, y: h * 0.7, color: 'rgba(79, 195, 247, 0.25)' },
                { sym: '✓', x: w * 0.85, y: h * 0.25, color: 'rgba(255, 170, 68, 0.25)' },
                { sym: '●', x: w * 0.9, y: h * 0.7, color: 'rgba(255, 170, 68, 0.25)' }
            ];
            
            for (let i = 0; i < largeSymbols.length; i++) {
                const symbol = largeSymbols[i];
                const pulse = 1 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.4;
                const rotation = this.cutsceneTime * 0.15 + i;
                
                ctx.save();
                ctx.translate(symbol.x, symbol.y);
                ctx.rotate(rotation);
                ctx.globalAlpha = 0.2 * fade;
                ctx.fillStyle = symbol.color;
                ctx.font = `${90 * pulse}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol.sym, 0, 0);
                ctx.restore();
                
                // Large symbol glow
                this.drawGlow(ctx, symbol.x, symbol.y, 60 * pulse, symbol.color.replace(/[\d.]+\)$/, `${0.15 * fade})`));
            }
            
            // Quantum field particles (cyan/orange theme for completion)
            for (let i = 0; i < 70; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.6 + i) * 20;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.6 + i) * 20;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.08;
                const size = 2.5 + Math.sin(this.cutsceneTime * 2 + i) * 1.5;
                const color = i % 2 === 0 ? 'rgba(79, 195, 247' : 'rgba(255, 170, 68';
                this.drawGlow(ctx, x, y, size * 2, `${color}, ${alpha * fade})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced title with multi-layer glow
            const titleGlow = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, centerX, h * 0.15, 200, `rgba(255, 170, 68, ${titleGlow * fade * 0.3})`);
            this.drawGlow(ctx, centerX, h * 0.15, 150, `rgba(255, 170, 68, ${titleGlow * fade * 0.5})`);
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('COMPLETE DESCRIPTION', centerX, h * 0.15);
            ctx.shadowBlur = 0;
            
            // Enhanced puzzle pieces coming together with jigsaw shapes
            const puzzleX = centerX;
            const puzzleY = centerY;
            const pieceCount = 8;
            
            for (let i = 0; i < pieceCount; i++) {
                const angle = (i / pieceCount) * Math.PI * 2;
                const baseDist = 80;
                const dist = baseDist * (1 - Math.min(1, this.cutsceneTime / 2)) + Math.sin(this.cutsceneTime * 2 + i) * 20;
                const x = puzzleX + Math.cos(angle) * dist;
                const y = puzzleY + Math.sin(angle) * dist;
                const pieceFade = Math.min(1, (this.cutsceneTime - i * 0.15) / 1);
                const piecePulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.2;
                
                if (pieceFade > 0) {
                    // Enhanced puzzle piece with jigsaw shape
                    ctx.fillStyle = `rgba(79, 195, 247, ${pieceFade})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 18 * piecePulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Jigsaw tab
                    const tabAngle = angle;
                    const tabX = x + Math.cos(tabAngle) * 18 * piecePulse;
                    const tabY = y + Math.sin(tabAngle) * 18 * piecePulse;
                    ctx.beginPath();
                    ctx.arc(tabX, tabY, 8 * piecePulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Multiple glow layers
                    this.drawGlow(ctx, x, y, 20 * piecePulse, `rgba(79, 195, 247, ${pieceFade * 0.8})`);
                    this.drawGlow(ctx, x, y, 30 * piecePulse, `rgba(79, 195, 247, ${pieceFade * 0.5})`);
                    
                    // Connection line to center
                    if (dist > 30) {
                        ctx.strokeStyle = `rgba(79, 195, 247, ${pieceFade * 0.3})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(puzzleX, puzzleY);
                        ctx.stroke();
                    }
                }
            }
            
            // Enhanced center: Complete description with pulsing
            const completeFade = Math.min(1, this.cutsceneTime / 2);
            const completePulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.15;
            const completeGlow = 0.6 + Math.sin(this.cutsceneTime * 3) * 0.4;
            
            // Multiple glow layers
            this.drawGlow(ctx, puzzleX, puzzleY, 60 * completePulse, `rgba(255, 170, 68, ${completeFade * completeGlow})`);
            this.drawGlow(ctx, puzzleX, puzzleY, 80 * completePulse, `rgba(255, 170, 68, ${completeFade * completeGlow * 0.6})`);
            this.drawGlow(ctx, puzzleX, puzzleY, 100 * completePulse, `rgba(255, 170, 68, ${completeFade * completeGlow * 0.3})`);
            
            // Center circle with gradient
            const centerGradient = ctx.createRadialGradient(puzzleX, puzzleY, 0, puzzleX, puzzleY, 50 * completePulse);
            centerGradient.addColorStop(0, `rgba(255, 170, 68, ${completeFade})`);
            centerGradient.addColorStop(0.5, `rgba(255, 140, 50, ${completeFade})`);
            centerGradient.addColorStop(1, `rgba(255, 120, 40, ${completeFade})`);
            ctx.fillStyle = centerGradient;
            ctx.beginPath();
            ctx.arc(puzzleX, puzzleY, 50 * completePulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Checkmark in center
            if (completeFade > 0.5) {
                ctx.strokeStyle = `rgba(255, 255, 255, ${(completeFade - 0.5) * 2})`;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(puzzleX - 20, puzzleY);
                ctx.lineTo(puzzleX - 5, puzzleY + 15);
                ctx.lineTo(puzzleX + 20, puzzleY - 15);
                ctx.stroke();
            }
            
            // Enhanced text with glow
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 15;
            ctx.fillText('Complete Description', puzzleX, puzzleY + 8);
            ctx.shadowBlur = 0;
            
            // Enhanced text labels
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = fade * textFade;
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 22px Arial';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 12;
            ctx.fillText('Definite properties', centerX, h * 0.65);
                ctx.font = '20px Arial';
            ctx.fillText('Exact values', centerX, h * 0.7);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = fade;
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(70);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced show complete description properties
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Properties and Values - Complete Knowledge
            // Property equations forming patterns
            const propertyEquations = ['P(x)', 'E = definite', 't = exact', 'τ = known', 'λ = precise', 'all properties'];
            for (let i = 0; i < 14; i++) {
                const angle = (i / 14) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 220 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = propertyEquations[i % propertyEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.4})`);
            }
            
            // Value symbols floating
            const valueSymbols = ['=', '→', '✓', '●', '■', '▲', '◆'];
            for (let i = 0; i < 20; i++) {
                const symbolIndex = i % valueSymbols.length;
                const symbol = valueSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${22 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.3})`);
            }
            
            // Quantum field particles (cyan/orange theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                const color = i % 2 === 0 ? 'rgba(79, 195, 247' : 'rgba(255, 170, 68';
                this.drawGlow(ctx, x, y, size * 2, `${color}, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced individual system with complete properties
            const systemX = centerX;
            const systemY = centerY;
            const pulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.15;
            
            // Enhanced system core with multiple gradient layers
            const systemGradient = ctx.createRadialGradient(systemX, systemY, 0, systemX, systemY, 50 * pulse);
            systemGradient.addColorStop(0, '#4fc3f7');
            systemGradient.addColorStop(0.3, '#2196f3');
            systemGradient.addColorStop(0.6, '#1976d2');
            systemGradient.addColorStop(1, '#0d47a1');
            ctx.fillStyle = systemGradient;
            ctx.beginPath();
            ctx.arc(systemX, systemY, 50 * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Multiple glow layers
            this.drawGlow(ctx, systemX, systemY, 50 * pulse, 'rgba(79, 195, 247, 0.9)');
            this.drawGlow(ctx, systemX, systemY, 70 * pulse, 'rgba(79, 195, 247, 0.6)');
            this.drawGlow(ctx, systemX, systemY, 90 * pulse, 'rgba(79, 195, 247, 0.3)');
            
            // Enhanced properties indicators (definite values) with pulsing
            const propertyCount = 8;
            for (let i = 0; i < propertyCount; i++) {
                const angle = (i / propertyCount) * Math.PI * 2 + this.cutsceneTime * 0.5;
                const dist = 80 + Math.sin(this.cutsceneTime * 1.5 + i) * 10;
                const x = systemX + Math.cos(angle) * dist;
                const y = systemY + Math.sin(angle) * dist;
                const propPulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                
                // Property indicator
                ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, 6 * propPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Multiple glow layers
                this.drawGlow(ctx, x, y, 10 * propPulse, 'rgba(79, 195, 247, 0.9)');
                this.drawGlow(ctx, x, y, 15 * propPulse, 'rgba(79, 195, 247, 0.6)');
                
                // Connection line to center
                ctx.strokeStyle = `rgba(79, 195, 247, ${0.3})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(systemX, systemY);
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, h * 0.25, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
            ctx.fillText('Complete Description', centerX, h * 0.25);
                ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
            ctx.fillText('All properties known', centerX, h * 0.75);
            ctx.fillText('Definite values', centerX, h * 0.8);
                ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(70);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced need for protection - individual systems need barriers
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Protection and Barriers - Defense Theme
            // Threat equations (fading/approaching)
            const threatEquations = ['threat', 'attack', 'danger', 'risk', 'vulnerable'];
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2 + this.cutsceneTime * 0.3;
                const radius = 180 + Math.sin(this.cutsceneTime * 0.4 + i) * 40;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.15 + Math.sin(this.cutsceneTime * 1.2 + i) * 0.1) * fade;
                const rotation = angle + Math.PI / 2;
                const scale = 0.6 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${15 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = threatEquations[i % threatEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 25 * scale, `rgba(255, 68, 68, ${alpha * 0.3})`);
            }
            
            // Barrier/protection equations (growing)
            const barrierEquations = ['barrier', 'shield', 'protect', 'defend', 'layered', 'secure'];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 - this.cutsceneTime * 0.3;
                const radius = 200 + Math.sin(this.cutsceneTime * 0.5 + i) * 60;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15) * fade;
                const rotation = angle - Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = barrierEquations[i % barrierEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * 0.4})`);
            }
            
            // Protection symbols floating
            const protectionSymbols = ['🛡', '◉', '○', '●', '⬡', '⬢', '⟲'];
            for (let i = 0; i < 15; i++) {
                const symbolIndex = i % protectionSymbols.length;
                const symbol = protectionSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.3 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.3})`);
            }
            
            // Quantum field particles (cyan/red theme for threat vs protection)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                const color = i % 3 === 0 ? 'rgba(255, 68, 68' : 'rgba(79, 195, 247';
                this.drawGlow(ctx, x, y, size * 2, `${color}, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced individual system in center with pulsing
            const systemX = centerX;
            const systemY = centerY;
            const systemPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            
            // Enhanced system with gradient
            const systemGradient = ctx.createRadialGradient(systemX, systemY, 0, systemX, systemY, 40 * systemPulse);
            systemGradient.addColorStop(0, '#4fc3f7');
            systemGradient.addColorStop(0.5, '#2196f3');
            systemGradient.addColorStop(1, '#1976d2');
            ctx.fillStyle = systemGradient;
            ctx.beginPath();
            ctx.arc(systemX, systemY, 40 * systemPulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Multiple glow layers
            this.drawGlow(ctx, systemX, systemY, 40 * systemPulse, 'rgba(79, 195, 247, 0.9)');
            this.drawGlow(ctx, systemX, systemY, 60 * systemPulse, 'rgba(79, 195, 247, 0.6)');
            this.drawGlow(ctx, systemX, systemY, 80 * systemPulse, 'rgba(79, 195, 247, 0.3)');
            
            // Enhanced threats approaching (particles from outside) with trails
            const threatCount = 16;
            for (let layer = 0; layer < 2; layer++) {
                const layerSpeed = 30 + layer * 10;
                for (let i = 0; i < threatCount; i++) {
                    const angle = (i / threatCount) * Math.PI * 2;
                    const dist = 150 + this.cutsceneTime * layerSpeed;
                const x = systemX + Math.cos(angle) * dist;
                const y = systemY + Math.sin(angle) * dist;
                    const alpha = Math.max(0, (0.7 - layer * 0.1) - (dist - 150) / 100);
                    const size = 6 + layer * 2;
                    
                if (alpha > 0) {
                        // Threat particle
                        this.drawGlow(ctx, x, y, size, `rgba(255, 68, 68, ${alpha})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 68, 68, ${alpha * 0.5})`);
                        
                        // Threat trail
                        const trailDist = dist + 20;
                        const trailX = systemX + Math.cos(angle) * trailDist;
                        const trailY = systemY + Math.sin(angle) * trailDist;
                        this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(255, 68, 68, ${alpha * 0.3})`);
                    }
                }
            }
            
            // Warning indicators
            const warningPulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.3;
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const dist = 120;
                const x = systemX + Math.cos(angle) * dist;
                const y = systemY + Math.sin(angle) * dist;
                this.drawGlow(ctx, x, y, 15 * warningPulse, `rgba(255, 68, 68, ${0.4 * fade})`);
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, h * 0.25, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
            ctx.fillText('Individual systems need', centerX, h * 0.25);
                ctx.shadowBlur = 0;
                const protectGlow = 0.8 + Math.sin(this.cutsceneTime * 3) * 0.2;
                this.drawGlow(ctx, centerX, h * 0.3, 150, `rgba(79, 195, 247, ${protectGlow * textFade * 0.3})`);
                ctx.font = 'bold 28px Arial';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 20;
            ctx.fillText('PROTECTION', centerX, h * 0.3);
                ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
            ctx.fillText('Layered barriers required', centerX, h * 0.75);
                ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(70);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 3) {
            // Phase 3: Enhanced Einstein building the Individual System Barrier shield
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Barrier Construction - Protection Patterns
            // Barrier solution equations forming patterns
            const barrierEquations = ['barrier', 'shield', 'protect', 'defend', 'layered', 'secure', 'guard'];
            for (let i = 0; i < 14; i++) {
                const angle = (i / 14) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 220 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = barrierEquations[i % barrierEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * 0.4})`);
            }
            
            // Barrier symbols floating
            const barrierSymbols = ['◉', '○', '●', '⬡', '⬢', '⟲', '⟳', '◈'];
            for (let i = 0; i < 20; i++) {
                const symbolIndex = i % barrierSymbols.length;
                const symbol = barrierSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.3 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(79, 195, 247, ${alpha * 0.3})`);
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha})`);
            }
            
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship working glow
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(79, 195, 247, ${workGlow * 0.2})`);
            
            // Workbench/construction area (center-right)
            const workbenchX = centerX + 100;
            const workbenchY = centerY;
            const workbenchFade = Math.min(1, this.cutsceneTime / 1.5);
            
            // Enhanced background workbench panel with gradient
            ctx.globalAlpha = workbenchFade;
            const panelGradient = ctx.createLinearGradient(workbenchX - 200, workbenchY - 150, workbenchX - 200, workbenchY + 150);
            panelGradient.addColorStop(0, 'rgba(79, 195, 247, 0.25)');
            panelGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.2)');
            panelGradient.addColorStop(1, 'rgba(79, 195, 247, 0.15)');
            ctx.fillStyle = panelGradient;
            ctx.fillRect(workbenchX - 200, workbenchY - 150, 400, 300);
            
            // Enhanced panel border with pulsing glow
            const panelGlow = 0.5 + Math.sin(this.cutsceneTime * 3) * 0.3;
            ctx.strokeStyle = `rgba(79, 195, 247, ${panelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchX - 200, workbenchY - 150, 400, 300);
            // Corner glows
            this.drawGlow(ctx, workbenchX - 200, workbenchY - 150, 25, `rgba(79, 195, 247, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY - 150, 25, `rgba(79, 195, 247, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX - 200, workbenchY + 150, 25, `rgba(79, 195, 247, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY + 150, 25, `rgba(79, 195, 247, ${panelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const x = workbenchX - 200 + (i * 80);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 150);
                ctx.lineTo(x, workbenchY + 150);
                ctx.stroke();
            }
            for (let i = 0; i < 5; i++) {
                const y = workbenchY - 150 + (i * 75);
                ctx.beginPath();
                ctx.moveTo(workbenchX - 200, y);
                ctx.lineTo(workbenchX + 200, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Construction progress (0-1 over time)
            const buildProgress = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 7));
            
            // Phase 1: Enhanced gathering barrier data (0-30%)
            if (buildProgress < 0.3) {
                const gatherProgress = buildProgress / 0.3;
                
                // Enhanced particles with multiple layers and trails
                for (let layer = 0; layer < 2; layer++) {
                    const layerCount = 25 + layer * 10;
                    const layerSpeed = 1 + layer * 0.5;
                    for (let i = 0; i < layerCount; i++) {
                        const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed * 0.1;
                        const startDist = 250 + layer * 30;
                        const endDist = 100 - layer * 20;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                        const alpha = (0.7 - layer * 0.1) * (1 - gatherProgress);
                        const size = (6 - layer) - gatherProgress * (2 - layer);
                        
                    // Cyan particles for barrier/individual system
                        if (alpha > 0 && size > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                            this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
                            
                            // Particle trail
                            const trailAngle = angle - 0.1;
                            const trailDist = dist + 20;
                            const trailX = workbenchX + Math.cos(trailAngle) * trailDist;
                            const trailY = workbenchY + Math.sin(trailAngle) * trailDist * 0.7;
                            this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(79, 195, 247, ${alpha * 0.3})`);
                        }
                    }
                }
                
                // Central gathering point glow
                const gatherGlow = 0.4 + Math.sin(this.cutsceneTime * 3) * 0.3;
                this.drawGlow(ctx, workbenchX, workbenchY, 80 * gatherProgress, `rgba(79, 195, 247, ${gatherGlow * gatherProgress * 0.4})`);
                
                // Enhanced text with glow
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering barrier protection data...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 2: Enhanced assembling first barrier layer (30-60%)
            if (buildProgress >= 0.3 && buildProgress < 0.6) {
                const assembleProgress = (buildProgress - 0.3) / 0.3;
                
                // Enhanced first barrier layer assembling with pulsing
                const layerPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.15;
                const layerRadius = 30 * assembleProgress;
                const layerGradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, layerRadius);
                layerGradient.addColorStop(0, `rgba(79, 195, 247, ${0.5 + assembleProgress * 0.5})`);
                layerGradient.addColorStop(1, `rgba(100, 210, 255, ${0.7 + assembleProgress * 0.3})`);
                ctx.strokeStyle = layerGradient;
                ctx.lineWidth = 5 * layerPulse;
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, layerRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Enhanced glow with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, layerRadius, `rgba(79, 195, 247, ${assembleProgress * 0.9})`);
                this.drawGlow(ctx, workbenchX, workbenchY, layerRadius * 1.5, `rgba(79, 195, 247, ${assembleProgress * 0.5})`);
                
                // Enhanced barrier energy particles converging
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    const baseDist = 60;
                    const convergence = assembleProgress;
                    const dist = baseDist * (1 - convergence * 0.5);
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 * (1 - assembleProgress);
                    const size = 5 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                    if (alpha > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
                    }
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling barrier layer 1...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 3: Enhanced adding additional layers (60-85%)
            if (buildProgress >= 0.6 && buildProgress < 0.85) {
                const layerProgress = (buildProgress - 0.6) / 0.25;
                const layerPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.15;
                
                // Enhanced first layer (complete) with pulsing
                const layer1Gradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, 30);
                layer1Gradient.addColorStop(0, 'rgba(79, 195, 247, 1)');
                layer1Gradient.addColorStop(1, 'rgba(100, 210, 255, 1)');
                ctx.strokeStyle = layer1Gradient;
                ctx.lineWidth = 5 * layerPulse;
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, 30, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                this.drawGlow(ctx, workbenchX, workbenchY, 30, 'rgba(79, 195, 247, 0.9)');
                this.drawGlow(ctx, workbenchX, workbenchY, 40, 'rgba(79, 195, 247, 0.5)');
                
                // Enhanced second layer appearing with pulsing
                const layer2Radius = 30 + 15 * layerProgress;
                const layer2Gradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, layer2Radius);
                layer2Gradient.addColorStop(0, `rgba(79, 195, 247, ${0.5 + layerProgress * 0.5})`);
                layer2Gradient.addColorStop(1, `rgba(100, 210, 255, ${0.7 + layerProgress * 0.3})`);
                ctx.strokeStyle = layer2Gradient;
                ctx.lineWidth = 4 * layerPulse;
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(workbenchX, workbenchY, layer2Radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
                this.drawGlow(ctx, workbenchX, workbenchY, layer2Radius, `rgba(79, 195, 247, ${layerProgress * 0.7})`);
                this.drawGlow(ctx, workbenchX, workbenchY, layer2Radius * 1.3, `rgba(79, 195, 247, ${layerProgress * 0.4})`);
                
                // Enhanced third layer appearing with pulsing
                if (layerProgress > 0.4) {
                    const layer3Progress = (layerProgress - 0.4) / 0.6;
                    const layer3Radius = 30 + 15 + 15 * layer3Progress;
                    const layer3Gradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, layer3Radius);
                    layer3Gradient.addColorStop(0, `rgba(79, 195, 247, ${0.5 + layer3Progress * 0.5})`);
                    layer3Gradient.addColorStop(1, `rgba(100, 210, 255, ${0.7 + layer3Progress * 0.3})`);
                    ctx.strokeStyle = layer3Gradient;
                    ctx.lineWidth = 3 * layerPulse;
                    ctx.shadowColor = '#4fc3f7';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(workbenchX, workbenchY, layer3Radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    this.drawGlow(ctx, workbenchX, workbenchY, layer3Radius, `rgba(79, 195, 247, ${layer3Progress * 0.6})`);
                    this.drawGlow(ctx, workbenchX, workbenchY, layer3Radius * 1.3, `rgba(79, 195, 247, ${layer3Progress * 0.3})`);
                }
                
                // Enhanced pulsing effect with multiple layers
                const pulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.15;
                this.drawGlow(ctx, workbenchX, workbenchY, 70 * pulse, `rgba(79, 195, 247, ${layerProgress * 0.4})`);
                this.drawGlow(ctx, workbenchX, workbenchY, 90 * pulse, `rgba(79, 195, 247, ${layerProgress * 0.2})`);
                
                // Energy flowing between layers
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + this.cutsceneTime * 2;
                    const progress = (this.cutsceneTime * 0.5 + i * 0.1) % 1;
                    const radius = 30 + progress * 30;
                    const x = workbenchX + Math.cos(angle) * radius;
                    const y = workbenchY + Math.sin(angle) * radius;
                    const alpha = 0.6 - progress * 0.3;
                    this.drawGlow(ctx, x, y, 5, `rgba(79, 195, 247, ${alpha})`);
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 10;
                ctx.fillText('Adding barrier layers...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 4: Enhanced finalizing and testing (85-100%)
            if (buildProgress >= 0.85) {
                const finalizeProgress = (buildProgress - 0.85) / 0.15;
                
                // Enhanced complete barrier with all 3 layers and pulsing
                const barrierPulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.2;
                for (let layer = 0; layer < 3; layer++) {
                    const radius = (30 + layer * 15) * barrierPulse;
                    const layerGradient = ctx.createRadialGradient(workbenchX, workbenchY, 0, workbenchX, workbenchY, radius);
                    layerGradient.addColorStop(0, `rgba(79, 195, 247, ${0.9 - layer * 0.2})`);
                    layerGradient.addColorStop(1, `rgba(100, 210, 255, ${0.95 - layer * 0.15})`);
                    ctx.strokeStyle = layerGradient;
                    ctx.lineWidth = (5 - layer) * barrierPulse;
                    ctx.shadowColor = '#4fc3f7';
                    ctx.shadowBlur = 15 - layer * 3;
                    ctx.beginPath();
                    ctx.arc(workbenchX, workbenchY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Layer glow
                    this.drawGlow(ctx, workbenchX, workbenchY, radius, `rgba(79, 195, 247, ${0.8 - layer * 0.15})`);
                }
                
                // Enhanced outer glow with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, 70 * barrierPulse, 'rgba(79, 195, 247, 0.8)');
                this.drawGlow(ctx, workbenchX, workbenchY, 90 * barrierPulse, 'rgba(79, 195, 247, 0.5)');
                this.drawGlow(ctx, workbenchX, workbenchY, 110 * barrierPulse, 'rgba(79, 195, 247, 0.3)');
                
                // Enhanced test animation - threats being blocked
                if (finalizeProgress > 0.3) {
                    const testProgress = (finalizeProgress - 0.3) / 0.7;
                    // Enhanced threat particles approaching with multiple layers
                    for (let layer = 0; layer < 2; layer++) {
                        const layerCount = 8 + layer * 4;
                        for (let i = 0; i < layerCount; i++) {
                            const angle = (i / layerCount) * Math.PI * 2;
                        const approachDist = 100 - testProgress * 50;
                        const x = workbenchX + Math.cos(angle) * approachDist;
                        const y = workbenchY + Math.sin(angle) * approachDist * 0.7;
                            const size = 6 + layer * 2;
                            
                        // Particles stop at barrier
                        if (approachDist > 60 * barrierPulse) {
                                const alpha = (0.9 - layer * 0.1) - testProgress * (0.3 - layer * 0.1);
                                this.drawGlow(ctx, x, y, size, `rgba(255, 68, 68, ${alpha})`);
                                this.drawGlow(ctx, x, y, size * 1.5, `rgba(255, 68, 68, ${alpha * 0.5})`);
                        } else {
                                // Blocked - show impact with enhanced effects
                                const impactAlpha = (0.9 - layer * 0.1) - testProgress * (0.2 - layer * 0.05);
                                this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${impactAlpha})`);
                                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${impactAlpha * 0.6})`);
                                
                                // Impact ripple
                                const rippleDist = 60 * barrierPulse;
                                const rippleX = workbenchX + Math.cos(angle) * rippleDist;
                                const rippleY = workbenchY + Math.sin(angle) * rippleDist * 0.7;
                                this.drawGlow(ctx, rippleX, rippleY, 15, `rgba(79, 195, 247, ${impactAlpha * 0.4})`);
                            }
                        }
                    }
                }
                
                // Enhanced success particles with multiple layers
                for (let layer = 0; layer < 2; layer++) {
                    const layerCount = 20 + layer * 10;
                    for (let i = 0; i < layerCount; i++) {
                        const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * (2 + layer * 0.5);
                        const dist = 70 + Math.sin(this.cutsceneTime * 3 + i) * (20 + layer * 10);
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                        const alpha = 0.7 + Math.sin(this.cutsceneTime * 4 + i) * (0.3 - layer * 0.1);
                        const size = 5 + layer * 2 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                        this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * 0.5})`);
                    }
                }
                
                // Enhanced text with glow
                const textFade = Math.min(1, finalizeProgress * 2);
                if (textFade > 0) {
                    ctx.globalAlpha = textFade;
                    const textGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
                    this.drawGlow(ctx, workbenchX, workbenchY + 120, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
                ctx.fillStyle = '#4fc3f7';
                    ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                    ctx.shadowColor = '#4fc3f7';
                    ctx.shadowBlur = 15;
                ctx.fillText('BARRIER COMPLETE!', workbenchX, workbenchY + 120);
                    ctx.shadowBlur = 0;
                ctx.font = '18px Arial';
                ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                    ctx.shadowColor = '#4fc3f7';
                    ctx.shadowBlur = 12;
                ctx.fillText('Layered protection ready', workbenchX, workbenchY + 150);
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
            }
            
            // Enhanced connection lines from ship to workbench (Einstein working)
            const connectionFade = Math.min(1, this.cutsceneTime / 1.5);
            if (connectionFade > 0) {
                ctx.globalAlpha = connectionFade * 0.4;
                ctx.strokeStyle = 'rgba(79, 195, 247, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
                ctx.moveTo(shipX + 30, shipY + shipFloat);
            ctx.lineTo(workbenchX - 200, workbenchY);
            ctx.stroke();
            ctx.setLineDash([]);
                
                // Energy particles flowing along connection
                for (let i = 0; i < 8; i++) {
                    const progress = (this.cutsceneTime * 0.5 + i * 0.2) % 1;
                    const x = shipX + 30 + (workbenchX - 200 - shipX - 30) * progress;
                    const y = shipY + shipFloat + (workbenchY - shipY - shipFloat) * progress;
                    this.drawGlow(ctx, x, y, 4, `rgba(79, 195, 247, ${0.6 - progress * 0.3})`);
                }
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 3 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(70);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[3]) {
                    let text = cutsceneData.texts[3].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        }
    }
    
    // Level 80: Near Escape - Enhanced with Individual System Amplifier
    drawCutsceneLevel80(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced escape path becoming clear
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Near Escape - Freedom Path
            // Escape equations forming patterns
            const escapeEquations = ['A or B', 'not pairs', 'escape', 'freedom', 'individual', 'sidestep'];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 200 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.7 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${17 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = escapeEquations[i % escapeEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.4})`);
            }
            
            // Escape symbols floating
            const escapeSymbols = ['→', '⟶', '⟹', '↗', '↘', '↑', 'A', 'B', 'or'];
            for (let i = 0; i < 25; i++) {
                const symbolIndex = i % escapeSymbols.length;
                const symbol = escapeSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 35;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 35;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.3})`);
            }
            
            // Quantum field particles (cyan theme for escape)
            for (let i = 0; i < 70; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.6 + i) * 20;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.6 + i) * 20;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.08;
                const size = 2.5 + Math.sin(this.cutsceneTime * 2 + i) * 1.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha * fade})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced title with multi-layer glow
            const titleGlow = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, centerX, h * 0.3, 200, `rgba(79, 195, 247, ${titleGlow * fade * 0.3})`);
            this.drawGlow(ctx, centerX, h * 0.3, 150, `rgba(79, 195, 247, ${titleGlow * fade * 0.5})`);
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 30;
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('NEAR ESCAPE!', centerX, h * 0.3);
            ctx.shadowBlur = 0;
            
            // Enhanced Einstein's ship with pulsing
            const shipX = centerX - 150;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            const shipPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0 * shipPulse, 1, this.cutsceneTime);
            
            // Ship glow
            this.drawGlow(ctx, shipX, shipY + shipFloat, 60, `rgba(79, 195, 247, ${0.3 * fade})`);
            
            // Enhanced escape path (arrow to freedom) with pulsing
            const arrowPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.15;
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 8 * arrowPulse;
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(centerX - 50, centerY);
            ctx.lineTo(centerX + 200, centerY);
            ctx.lineTo(centerX + 170, centerY - 30);
            ctx.moveTo(centerX + 200, centerY);
            ctx.lineTo(centerX + 170, centerY + 30);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Arrow glow
            this.drawGlow(ctx, centerX + 200, centerY, 40, `rgba(79, 195, 247, ${0.6 * fade})`);
            
            // Enhanced particles along escape path with multiple layers
            for (let layer = 0; layer < 2; layer++) {
                const layerCount = 20 + layer * 10;
                const layerSpeed = 0.5 + layer * 0.2;
                for (let i = 0; i < layerCount; i++) {
                    const progress = (this.cutsceneTime * layerSpeed + i * 0.05) % 1;
                const x = centerX - 50 + progress * 250;
                    const y = centerY + Math.sin(progress * Math.PI * 4) * (10 - layer * 3);
                    const alpha = (0.8 - layer * 0.1) - progress * (0.2 - layer * 0.05);
                    const size = 6 + layer * 2;
                    if (alpha > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha * fade})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * fade * 0.5})`);
                    }
                }
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = fade * textFade;
            ctx.fillStyle = '#4fc3f7';
                ctx.font = 'bold 22px Arial';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
            ctx.fillText('Individual systems: A or B', centerX, h * 0.65);
                ctx.font = '20px Arial';
            ctx.fillText('Not correlated pairs', centerX, h * 0.7);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = fade;
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(80);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced the solution is clear - individual systems amplify power
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Amplification - Power Theme
            // Amplification equations forming patterns
            const ampEquations = ['amplify', 'power', 'boost', 'increase', 'strength', 'energy'];
            for (let i = 0; i < 14; i++) {
                const angle = (i / 14) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 220 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = ampEquations[i % ampEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(0, 255, 255, ${alpha * fade * 0.4})`);
            }
            
            // Power symbols floating
            const powerSymbols = ['↑', '▲', '△', '⟲', '⚡', '→', '⟶'];
            for (let i = 0; i < 20; i++) {
                const symbolIndex = i % powerSymbols.length;
                const symbol = powerSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.3 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(0, 255, 255, ${alpha * fade * 0.3})`);
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                this.drawGlow(ctx, x, y, size * 2, `rgba(0, 255, 255, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced individual system in center with amplifying effect
            const systemX = centerX;
            const systemY = centerY;
            const pulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.25;
            
            // Enhanced system with multiple gradient layers
            const systemGradient = ctx.createRadialGradient(systemX, systemY, 0, systemX, systemY, 50 * pulse);
            systemGradient.addColorStop(0, '#00ffff');
            systemGradient.addColorStop(0.3, '#4fc3f7');
            systemGradient.addColorStop(0.6, '#2196f3');
            systemGradient.addColorStop(1, '#1976d2');
            ctx.fillStyle = systemGradient;
            ctx.beginPath();
            ctx.arc(systemX, systemY, 50 * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Multiple glow layers
            this.drawGlow(ctx, systemX, systemY, 50 * pulse, 'rgba(0, 255, 255, 0.9)');
            this.drawGlow(ctx, systemX, systemY, 70 * pulse, 'rgba(0, 255, 255, 0.6)');
            this.drawGlow(ctx, systemX, systemY, 90 * pulse, 'rgba(0, 255, 255, 0.3)');
            
            // Enhanced amplifying energy waves with multiple layers
            for (let layer = 0; layer < 2; layer++) {
                const layerCount = 4 + layer * 2;
                const layerSpeed = 30 + layer * 10;
                for (let ring = 0; ring < layerCount; ring++) {
                    const radius = 60 + ring * 20 + this.cutsceneTime * layerSpeed;
                    const alpha = Math.max(0, (0.7 - layer * 0.1) - ring * 0.1 - (radius - 60) / 200);
                if (alpha > 0) {
                        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * fade})`;
                        ctx.lineWidth = 2 + layer;
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(systemX, systemY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, h * 0.25, 200, `rgba(0, 255, 255, ${textGlow * textFade * 0.2})`);
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
            ctx.fillText('Individual systems amplify', centerX, h * 0.25);
                ctx.shadowBlur = 0;
                const powerGlow = 0.8 + Math.sin(this.cutsceneTime * 3) * 0.2;
                this.drawGlow(ctx, centerX, h * 0.3, 150, `rgba(0, 255, 255, ${powerGlow * textFade * 0.3})`);
                ctx.font = 'bold 28px Arial';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
            ctx.fillText('POWER', centerX, h * 0.3);
                ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(0, 255, 255, 0.9)';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 12;
            ctx.fillText('Amplification needed', centerX, h * 0.75);
                ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(80);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced amplification concept - power increase
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Amplification Flow - Input to Output
            // Flow equations forming patterns
            const flowEquations = ['input', '→', 'amplify', '→', 'output', 'power'];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + this.cutsceneTime * 0.3;
                const radius = 180 + Math.sin(this.cutsceneTime * 0.4 + i) * 40;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = flowEquations[i % flowEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(0, 255, 255, ${alpha * fade * 0.4})`);
            }
            
            // Flow symbols floating
            const flowSymbols = ['→', '⟶', '⟹', '↑', '▲', '△'];
            for (let i = 0; i < 15; i++) {
                const symbolIndex = i % flowSymbols.length;
                const symbol = flowSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.3 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(0, 255, 255, ${alpha * fade * 0.3})`);
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                this.drawGlow(ctx, x, y, size * 2, `rgba(0, 255, 255, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced power amplification - small input, large output
            const inputX = centerX - 100;
            const outputX = centerX + 100;
            const ampY = centerY;
            
            // Enhanced input (small) with pulsing
            const inputPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            const inputGradient = ctx.createRadialGradient(inputX, ampY, 0, inputX, ampY, 20 * inputPulse);
            inputGradient.addColorStop(0, '#4fc3f7');
            inputGradient.addColorStop(1, '#2196f3');
            ctx.fillStyle = inputGradient;
            ctx.beginPath();
            ctx.arc(inputX, ampY, 20 * inputPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, inputX, ampY, 20 * inputPulse, 'rgba(79, 195, 247, 0.9)');
            this.drawGlow(ctx, inputX, ampY, 30 * inputPulse, 'rgba(79, 195, 247, 0.5)');
            
            // Enhanced amplifier symbol (triangle) in center with pulsing
            const ampX = centerX;
            const ampPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.15;
            ctx.strokeStyle = 'rgba(0, 255, 255, 1)';
            ctx.lineWidth = 5 * ampPulse;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(ampX, ampY - 25 * ampPulse);
            ctx.lineTo(ampX - 20 * ampPulse, ampY + 15 * ampPulse);
            ctx.lineTo(ampX + 20 * ampPulse, ampY + 15 * ampPulse);
            ctx.closePath();
            ctx.stroke();
            ctx.shadowBlur = 0;
            this.drawGlow(ctx, ampX, ampY, 35 * ampPulse, 'rgba(0, 255, 255, 0.8)');
            this.drawGlow(ctx, ampX, ampY, 50 * ampPulse, 'rgba(0, 255, 255, 0.4)');
            
            // Enhanced output (large - amplified) with pulsing
            const outputPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.2;
            const outputSize = (20 + Math.sin(this.cutsceneTime * 2) * 10) * outputPulse;
            const outputGradient = ctx.createRadialGradient(outputX, ampY, 0, outputX, ampY, outputSize);
            outputGradient.addColorStop(0, '#00ffff');
            outputGradient.addColorStop(0.5, '#4fc3f7');
            outputGradient.addColorStop(1, '#2196f3');
            ctx.fillStyle = outputGradient;
            ctx.beginPath();
            ctx.arc(outputX, ampY, outputSize, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, outputX, ampY, outputSize, 'rgba(0, 255, 255, 1)');
            this.drawGlow(ctx, outputX, ampY, outputSize + 20, 'rgba(0, 255, 255, 0.6)');
            this.drawGlow(ctx, outputX, ampY, outputSize + 40, 'rgba(0, 255, 255, 0.3)');
            
            // Enhanced energy flow arrows with particles
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            // Input to amplifier
            ctx.moveTo(inputX + 20, ampY);
            ctx.lineTo(ampX - 20, ampY);
            ctx.lineTo(ampX - 15, ampY - 5);
            ctx.moveTo(ampX - 20, ampY);
            ctx.lineTo(ampX - 15, ampY + 5);
            // Amplifier to output
            ctx.moveTo(ampX + 20, ampY);
            ctx.lineTo(outputX - outputSize, ampY);
            ctx.lineTo(outputX - outputSize - 5, ampY - 5);
            ctx.moveTo(outputX - outputSize, ampY);
            ctx.lineTo(outputX - outputSize - 5, ampY + 5);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Energy particles flowing along arrows
            for (let i = 0; i < 8; i++) {
                const progress = (this.cutsceneTime * 0.8 + i * 0.2) % 1;
                // Input to amplifier
                const flowX1 = inputX + 20 + (ampX - 20 - inputX - 20) * progress;
                this.drawGlow(ctx, flowX1, ampY, 5, `rgba(79, 195, 247, ${0.8 - progress * 0.3})`);
                // Amplifier to output
                const flowX2 = ampX + 20 + (outputX - outputSize - ampX - 20) * progress;
                this.drawGlow(ctx, flowX2, ampY, 6, `rgba(0, 255, 255, ${0.9 - progress * 0.3})`);
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, h * 0.25, 200, `rgba(0, 255, 255, ${textGlow * textFade * 0.2})`);
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
            ctx.fillText('Amplify individual system', centerX, h * 0.25);
            ctx.fillText('properties', centerX, h * 0.3);
                ctx.shadowBlur = 0;
            ctx.font = '20px Arial';
            ctx.fillStyle = 'rgba(0, 255, 255, 0.9)';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 12;
            ctx.fillText('Power amplification required', centerX, h * 0.75);
                ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(80);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 3) {
            // Phase 3: Enhanced Einstein building the Individual System Amplifier upgrade
            // Enhanced background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Amplifier Construction - Power Patterns
            // Amplifier equations forming patterns
            const ampEquations = ['amplifier', 'power', 'boost', 'amplify', 'strength', 'energy', 'gain'];
            for (let i = 0; i < 14; i++) {
                const angle = (i / 14) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 220 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.25 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = ampEquations[i % ampEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(0, 255, 255, ${alpha * 0.4})`);
            }
            
            // Amplifier symbols floating
            const ampSymbols = ['▲', '△', '↑', '⟲', '⚡', '→', '⟶'];
            for (let i = 0; i < 20; i++) {
                const symbolIndex = i % ampSymbols.length;
                const symbol = ampSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.3 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(0, 255, 255, ${alpha * 0.3})`);
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                this.drawGlow(ctx, x, y, size * 2, `rgba(0, 255, 255, ${alpha})`);
            }
            
            const shipX = w * 0.2;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0, 1, this.cutsceneTime);
            
            // Enhanced ship working glow
            const workGlow = 0.3 + Math.sin(this.cutsceneTime * 2) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(0, 255, 255, ${workGlow * 0.2})`);
            
            // Workbench/construction area (center-right)
            const workbenchX = centerX + 100;
            const workbenchY = centerY;
            const workbenchFade = Math.min(1, this.cutsceneTime / 1.5);
            
            // Enhanced background workbench panel with gradient
            ctx.globalAlpha = workbenchFade;
            const panelGradient = ctx.createLinearGradient(workbenchX - 200, workbenchY - 150, workbenchX - 200, workbenchY + 150);
            panelGradient.addColorStop(0, 'rgba(0, 255, 255, 0.25)');
            panelGradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');
            panelGradient.addColorStop(1, 'rgba(0, 255, 255, 0.15)');
            ctx.fillStyle = panelGradient;
            ctx.fillRect(workbenchX - 200, workbenchY - 150, 400, 300);
            
            // Enhanced panel border with pulsing glow
            const panelGlow = 0.5 + Math.sin(this.cutsceneTime * 3) * 0.3;
            ctx.strokeStyle = `rgba(0, 255, 255, ${panelGlow})`;
            ctx.lineWidth = 4;
            ctx.strokeRect(workbenchX - 200, workbenchY - 150, 400, 300);
            // Corner glows
            this.drawGlow(ctx, workbenchX - 200, workbenchY - 150, 25, `rgba(0, 255, 255, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY - 150, 25, `rgba(0, 255, 255, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX - 200, workbenchY + 150, 25, `rgba(0, 255, 255, ${panelGlow * 0.4})`);
            this.drawGlow(ctx, workbenchX + 200, workbenchY + 150, 25, `rgba(0, 255, 255, ${panelGlow * 0.4})`);
            
            // Workbench grid pattern
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                const x = workbenchX - 200 + (i * 80);
                ctx.beginPath();
                ctx.moveTo(x, workbenchY - 150);
                ctx.lineTo(x, workbenchY + 150);
                ctx.stroke();
            }
            for (let i = 0; i < 5; i++) {
                const y = workbenchY - 150 + (i * 75);
                ctx.beginPath();
                ctx.moveTo(workbenchX - 200, y);
                ctx.lineTo(workbenchX + 200, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Construction progress (0-1 over time)
            const buildProgress = Math.max(0, Math.min(1, (this.cutsceneTime - 0.5) / 7));
            
            // Phase 1: Enhanced gathering amplification data (0-30%)
            if (buildProgress < 0.3) {
                const gatherProgress = buildProgress / 0.3;
                
                // Enhanced particles with multiple layers and trails
                for (let layer = 0; layer < 2; layer++) {
                    const layerCount = 25 + layer * 10;
                    const layerSpeed = 1 + layer * 0.5;
                    for (let i = 0; i < layerCount; i++) {
                        const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * layerSpeed * 0.1;
                        const startDist = 250 + layer * 30;
                        const endDist = 100 - layer * 20;
                    const dist = startDist - (startDist - endDist) * gatherProgress;
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                        const alpha = (0.7 - layer * 0.1) * (1 - gatherProgress);
                        const size = (6 - layer) - gatherProgress * (2 - layer);
                        
                        // Cyan particles for amplifier
                        if (alpha > 0 && size > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(0, 255, 255, ${alpha})`);
                            this.drawGlow(ctx, x, y, size * 1.5, `rgba(0, 255, 255, ${alpha * 0.5})`);
                            
                            // Particle trail
                            const trailAngle = angle - 0.1;
                            const trailDist = dist + 20;
                            const trailX = workbenchX + Math.cos(trailAngle) * trailDist;
                            const trailY = workbenchY + Math.sin(trailAngle) * trailDist * 0.7;
                            this.drawGlow(ctx, trailX, trailY, size * 0.5, `rgba(0, 255, 255, ${alpha * 0.3})`);
                        }
                    }
                }
                
                // Central gathering point glow
                const gatherGlow = 0.4 + Math.sin(this.cutsceneTime * 3) * 0.3;
                this.drawGlow(ctx, workbenchX, workbenchY, 80 * gatherProgress, `rgba(0, 255, 255, ${gatherGlow * gatherProgress * 0.4})`);
                
                // Enhanced text with glow
                ctx.fillStyle = '#00ffff';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillText('Gathering amplification data...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 2: Enhanced assembling amplifier core (30-60%)
            if (buildProgress >= 0.3 && buildProgress < 0.6) {
                const assembleProgress = (buildProgress - 0.3) / 0.3;
                
                // Enhanced amplifier triangle assembling with pulsing
                const trianglePulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.15;
                const triangleSize = 30 * assembleProgress;
                const triangleGradient = ctx.createLinearGradient(workbenchX, workbenchY - triangleSize, workbenchX, workbenchY + triangleSize * 0.7);
                triangleGradient.addColorStop(0, `rgba(0, 255, 255, ${0.5 + assembleProgress * 0.5})`);
                triangleGradient.addColorStop(1, `rgba(100, 255, 255, ${0.7 + assembleProgress * 0.3})`);
                ctx.strokeStyle = triangleGradient;
                ctx.lineWidth = 5 * trianglePulse;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(workbenchX, workbenchY - triangleSize);
                ctx.lineTo(workbenchX - triangleSize * 0.8, workbenchY + triangleSize * 0.7);
                ctx.lineTo(workbenchX + triangleSize * 0.8, workbenchY + triangleSize * 0.7);
                ctx.closePath();
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Enhanced glow with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, triangleSize, `rgba(0, 255, 255, ${assembleProgress * 0.9})`);
                this.drawGlow(ctx, workbenchX, workbenchY, triangleSize * 1.5, `rgba(0, 255, 255, ${assembleProgress * 0.5})`);
                
                // Enhanced amplifier energy particles converging
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    const baseDist = 60;
                    const convergence = assembleProgress;
                    const dist = baseDist * (1 - convergence * 0.3);
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                    const alpha = 0.6 * (1 - assembleProgress);
                    const size = 5 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                    if (alpha > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(0, 255, 255, ${alpha})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(0, 255, 255, ${alpha * 0.5})`);
                    }
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#00ffff';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillText('Assembling amplifier core...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 3: Enhanced adding power lines (60-85%)
            if (buildProgress >= 0.6 && buildProgress < 0.85) {
                const powerProgress = (buildProgress - 0.6) / 0.25;
                const powerPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.15;
                
                // Enhanced complete amplifier triangle with pulsing
                const triangleGradient = ctx.createLinearGradient(workbenchX, workbenchY - 30, workbenchX, workbenchY + 20);
                triangleGradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
                triangleGradient.addColorStop(1, 'rgba(100, 255, 255, 1)');
                ctx.strokeStyle = triangleGradient;
                ctx.lineWidth = 5 * powerPulse;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(workbenchX, workbenchY - 30);
                ctx.lineTo(workbenchX - 25, workbenchY + 20);
                ctx.lineTo(workbenchX + 25, workbenchY + 20);
                ctx.closePath();
                ctx.stroke();
                ctx.shadowBlur = 0;
                this.drawGlow(ctx, workbenchX, workbenchY, 30, 'rgba(0, 255, 255, 0.9)');
                this.drawGlow(ctx, workbenchX, workbenchY, 40, 'rgba(0, 255, 255, 0.5)');
                
                // Enhanced power lines appearing with pulsing
                const lineLength = 30 * powerProgress;
                const lineGradient = ctx.createLinearGradient(workbenchX - 15 - lineLength, workbenchY + 5, workbenchX - 15, workbenchY + 5);
                lineGradient.addColorStop(0, `rgba(0, 255, 255, ${0.5 + powerProgress * 0.5})`);
                lineGradient.addColorStop(1, `rgba(100, 255, 255, ${0.7 + powerProgress * 0.3})`);
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 4 * powerPulse;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 12;
                // Left power line
                ctx.beginPath();
                ctx.moveTo(workbenchX - 15, workbenchY + 5);
                ctx.lineTo(workbenchX - 15 - lineLength, workbenchY + 5);
                ctx.stroke();
                // Right power line
                ctx.beginPath();
                ctx.moveTo(workbenchX + 15, workbenchY + 5);
                ctx.lineTo(workbenchX + 15 + lineLength, workbenchY + 5);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Power line glows
                this.drawGlow(ctx, workbenchX - 15 - lineLength/2, workbenchY + 5, lineLength/2, `rgba(0, 255, 255, ${powerProgress * 0.6})`);
                this.drawGlow(ctx, workbenchX + 15 + lineLength/2, workbenchY + 5, lineLength/2, `rgba(0, 255, 255, ${powerProgress * 0.6})`);
                
                // Enhanced energy flowing through power lines with multiple layers
                for (let layer = 0; layer < 2; layer++) {
                    const layerCount = 10 + layer * 5;
                    const layerSpeed = 0.8 + layer * 0.3;
                    for (let i = 0; i < layerCount; i++) {
                        const progress = (this.cutsceneTime * layerSpeed + i * 0.1) % 1;
                        const size = 4 + layer * 2;
                    // Left line
                    const leftX = workbenchX - 15 - progress * lineLength;
                        const leftAlpha = (0.9 - layer * 0.1) - progress * (0.3 - layer * 0.1);
                        if (leftAlpha > 0) {
                            this.drawGlow(ctx, leftX, workbenchY + 5, size, `rgba(0, 255, 255, ${leftAlpha})`);
                        }
                    // Right line
                    const rightX = workbenchX + 15 + progress * lineLength;
                        const rightAlpha = (0.9 - layer * 0.1) - progress * (0.3 - layer * 0.1);
                        if (rightAlpha > 0) {
                            this.drawGlow(ctx, rightX, workbenchY + 5, size, `rgba(0, 255, 255, ${rightAlpha})`);
                        }
                    }
                }
                
                // Enhanced text with glow
                ctx.fillStyle = '#00ffff';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillText('Installing power lines...', workbenchX, workbenchY + 120);
                ctx.shadowBlur = 0;
            }
            
            // Phase 4: Enhanced finalizing and testing (85-100%)
            if (buildProgress >= 0.85) {
                const finalizeProgress = (buildProgress - 0.85) / 0.15;
                const finalPulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.2;
                
                // Enhanced complete amplifier with pulsing
                const triangleGradient = ctx.createLinearGradient(workbenchX, workbenchY - 30, workbenchX, workbenchY + 20);
                triangleGradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
                triangleGradient.addColorStop(1, 'rgba(100, 255, 255, 1)');
                ctx.strokeStyle = triangleGradient;
                ctx.lineWidth = 6 * finalPulse;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(workbenchX, workbenchY - 30);
                ctx.lineTo(workbenchX - 25, workbenchY + 20);
                ctx.lineTo(workbenchX + 25, workbenchY + 20);
                ctx.closePath();
                ctx.stroke();
                ctx.shadowBlur = 0;
                this.drawGlow(ctx, workbenchX, workbenchY, 35, 'rgba(0, 255, 255, 1)');
                this.drawGlow(ctx, workbenchX, workbenchY, 50, 'rgba(0, 255, 255, 0.6)');
                
                // Enhanced complete power lines with pulsing
                const lineGradient = ctx.createLinearGradient(workbenchX - 35, workbenchY + 5, workbenchX - 15, workbenchY + 5);
                lineGradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
                lineGradient.addColorStop(1, 'rgba(100, 255, 255, 1)');
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 5 * finalPulse;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(workbenchX - 15, workbenchY + 5);
                ctx.lineTo(workbenchX - 35, workbenchY + 5);
                ctx.moveTo(workbenchX + 15, workbenchY + 5);
                ctx.lineTo(workbenchX + 35, workbenchY + 5);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Power line glows
                this.drawGlow(ctx, workbenchX - 25, workbenchY + 5, 10, 'rgba(0, 255, 255, 0.8)');
                this.drawGlow(ctx, workbenchX + 25, workbenchY + 5, 10, 'rgba(0, 255, 255, 0.8)');
                
                // Enhanced complete glow with multiple layers
                this.drawGlow(ctx, workbenchX, workbenchY, 60 * finalPulse, 'rgba(0, 255, 255, 1)');
                this.drawGlow(ctx, workbenchX, workbenchY, 80 * finalPulse, 'rgba(0, 255, 255, 0.6)');
                this.drawGlow(ctx, workbenchX, workbenchY, 100 * finalPulse, 'rgba(0, 255, 255, 0.3)');
                
                // Enhanced test animation - amplification effect
                if (finalizeProgress > 0.3) {
                    const testProgress = (finalizeProgress - 0.3) / 0.7;
                    // Enhanced input energy (small) with pulsing
                    const inputX = workbenchX - 60;
                    const inputPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
                    const inputSize = 8 * inputPulse;
                    const inputGradient = ctx.createRadialGradient(inputX, workbenchY, 0, inputX, workbenchY, inputSize);
                    inputGradient.addColorStop(0, 'rgba(79, 195, 247, 0.9)');
                    inputGradient.addColorStop(1, 'rgba(79, 195, 247, 0.7)');
                    ctx.fillStyle = inputGradient;
                    ctx.beginPath();
                    ctx.arc(inputX, workbenchY, inputSize, 0, Math.PI * 2);
                    ctx.fill();
                    this.drawGlow(ctx, inputX, workbenchY, inputSize, 'rgba(79, 195, 247, 0.9)');
                    this.drawGlow(ctx, inputX, workbenchY, inputSize * 1.5, 'rgba(79, 195, 247, 0.5)');
                    
                    // Enhanced energy flowing to amplifier with multiple layers
                    for (let layer = 0; layer < 2; layer++) {
                        const layerCount = 8 + layer * 4;
                        const layerSpeed = 0.8 + layer * 0.3;
                        for (let i = 0; i < layerCount; i++) {
                            const progress = (this.cutsceneTime * layerSpeed + i * 0.15) % 1;
                            const flowX = inputX + (workbenchX - 25 - inputX) * progress;
                            const size = 6 + layer * 2;
                            const alpha = (0.9 - layer * 0.1) - progress * (0.2 - layer * 0.05);
                            if (alpha > 0) {
                                this.drawGlow(ctx, flowX, workbenchY, size, `rgba(0, 255, 255, ${alpha})`);
                                this.drawGlow(ctx, flowX, workbenchY, size * 1.5, `rgba(0, 255, 255, ${alpha * 0.5})`);
                            }
                        }
                    }
                    
                    // Enhanced amplified output (large) with pulsing
                    if (testProgress > 0.4) {
                        const outputX = workbenchX + 60;
                        const outputProgress = (testProgress - 0.4) / 0.6;
                        const outputPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
                        const outputSize = (8 + outputProgress * 20) * outputPulse;
                        const outputGradient = ctx.createRadialGradient(outputX, workbenchY, 0, outputX, workbenchY, outputSize);
                        outputGradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
                        outputGradient.addColorStop(0.5, 'rgba(100, 255, 255, 0.9)');
                        outputGradient.addColorStop(1, 'rgba(0, 255, 255, 0.7)');
                        ctx.fillStyle = outputGradient;
                        ctx.beginPath();
                        ctx.arc(outputX, workbenchY, outputSize, 0, Math.PI * 2);
                        ctx.fill();
                        this.drawGlow(ctx, outputX, workbenchY, outputSize, 'rgba(0, 255, 255, 1)');
                        this.drawGlow(ctx, outputX, workbenchY, outputSize + 20, 'rgba(0, 255, 255, 0.6)');
                        this.drawGlow(ctx, outputX, workbenchY, outputSize + 40, 'rgba(0, 255, 255, 0.3)');
                        
                        // Enhanced amplified energy waves with multiple layers
                        for (let layer = 0; layer < 2; layer++) {
                            const layerCount = 3 + layer * 2;
                            for (let ring = 0; ring < layerCount; ring++) {
                            const radius = outputSize + ring * 10 + outputProgress * 20;
                                const alpha = Math.max(0, (0.7 - layer * 0.1) - ring * 0.1 - outputProgress * (0.15 - layer * 0.05));
                            if (alpha > 0) {
                                ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                                    ctx.lineWidth = 2 + layer;
                                    ctx.shadowColor = '#00ffff';
                                    ctx.shadowBlur = 10;
                                ctx.beginPath();
                                ctx.arc(outputX, workbenchY, radius, 0, Math.PI * 2);
                                ctx.stroke();
                                    ctx.shadowBlur = 0;
                                }
                            }
                        }
                    }
                }
                
                // Enhanced success particles with multiple layers
                for (let layer = 0; layer < 2; layer++) {
                    const layerCount = 25 + layer * 10;
                    for (let i = 0; i < layerCount; i++) {
                        const angle = (i / layerCount) * Math.PI * 2 + this.cutsceneTime * (2 + layer * 0.5);
                        const dist = 80 + Math.sin(this.cutsceneTime * 3 + i) * (30 + layer * 10);
                    const x = workbenchX + Math.cos(angle) * dist;
                    const y = workbenchY + Math.sin(angle) * dist * 0.7;
                        const alpha = 0.7 + Math.sin(this.cutsceneTime * 4 + i) * (0.3 - layer * 0.1);
                        const size = 5 + layer * 2 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                        this.drawGlow(ctx, x, y, size, `rgba(0, 255, 255, ${alpha})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(0, 255, 255, ${alpha * 0.5})`);
                    }
                }
                
                // Enhanced text with glow
                const textFade = Math.min(1, finalizeProgress * 2);
                if (textFade > 0) {
                    ctx.globalAlpha = textFade;
                    const textGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
                    this.drawGlow(ctx, workbenchX, workbenchY + 120, 200, `rgba(0, 255, 255, ${textGlow * textFade * 0.2})`);
                ctx.fillStyle = '#00ffff';
                    ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 15;
                ctx.fillText('AMPLIFIER COMPLETE!', workbenchX, workbenchY + 120);
                    ctx.shadowBlur = 0;
                ctx.font = '18px Arial';
                ctx.fillStyle = 'rgba(0, 255, 255, 0.9)';
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 12;
                ctx.fillText('Individual system power amplified', workbenchX, workbenchY + 150);
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
            }
            
            // Enhanced connection lines from ship to workbench (Einstein working)
            const connectionFade = Math.min(1, this.cutsceneTime / 1.5);
            if (connectionFade > 0) {
                ctx.globalAlpha = connectionFade * 0.4;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
                ctx.moveTo(shipX + 30, shipY + shipFloat);
            ctx.lineTo(workbenchX - 200, workbenchY);
            ctx.stroke();
            ctx.setLineDash([]);
                
                // Energy particles flowing along connection
                for (let i = 0; i < 8; i++) {
                    const progress = (this.cutsceneTime * 0.5 + i * 0.2) % 1;
                    const x = shipX + 30 + (workbenchX - 200 - shipX - 30) * progress;
                    const y = shipY + shipFloat + (workbenchY - shipY - shipFloat) * progress;
                    this.drawGlow(ctx, x, y, 4, `rgba(0, 255, 255, ${0.6 - progress * 0.3})`);
                }
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 3 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(80);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[3]) {
                    let text = cutsceneData.texts[3].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        }
    }
    // Level 85: The Final Realization - Enhanced
    drawCutsceneLevel85(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced final realization - Einstein's argument
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Final Realization - Einstein's Victory
            // Einstein's complete description equations (strong)
            const einsteinEquations = ['ψ(x,t)', 'complete', 'individual', 'definite', 'exact', '1949'];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 200 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.3 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.2;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = einsteinEquations[i % einsteinEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.5})`);
            }
            
            // Ensemble/Psi equations (fading - being overcome)
            const ensembleEquations = ['P(A,B)', 'ensemble', 'statistical', 'correlated'];
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2 - this.cutsceneTime * 0.3;
                const radius = 180 + Math.sin(this.cutsceneTime * 0.4 + i) * 40;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.15 + Math.sin(this.cutsceneTime * 1.2 + i) * 0.1) * (1 - this.cutsceneTime / 3);
                const rotation = angle - Math.PI / 2;
                const scale = 0.6 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${15 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = ensembleEquations[i % ensembleEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 25 * scale, `rgba(255, 68, 68, ${alpha * fade * 0.3})`);
            }
            
            // Realization symbols floating
            const realizationSymbols = ['✓', '●', '→', '⟶', '↑', '★', '✨'];
            for (let i = 0; i < 25; i++) {
                const symbolIndex = i % realizationSymbols.length;
                const symbol = realizationSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 35;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 35;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.15;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.9 + Math.sin(this.cutsceneTime * 2 + i) * 0.3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${26 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 18 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.4})`);
            }
            
            // Quantum field particles (orange/cyan theme for realization)
            for (let i = 0; i < 70; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.6 + i) * 20;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.6 + i) * 20;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.08;
                const size = 2.5 + Math.sin(this.cutsceneTime * 2 + i) * 1.5;
                const color = i % 3 === 0 ? 'rgba(79, 195, 247' : 'rgba(255, 170, 68';
                this.drawGlow(ctx, x, y, size * 2, `${color}, ${alpha * fade})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced title with multi-layer glow
            const titleGlow = 0.8 + Math.sin(this.cutsceneTime * 3) * 0.2;
            this.drawGlow(ctx, centerX, h * 0.2, 250, `rgba(255, 170, 68, ${titleGlow * fade * 0.3})`);
            this.drawGlow(ctx, centerX, h * 0.2, 200, `rgba(255, 170, 68, ${titleGlow * fade * 0.5})`);
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 35;
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 52px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('THE FINAL REALIZATION', centerX, h * 0.2);
            ctx.shadowBlur = 0;
            
            // Enhanced Einstein's ship with realization glow
            const shipX = centerX - 100;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            const shipPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0 * shipPulse, 1, this.cutsceneTime);
            
            // Ship realization glow
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(255, 170, 68, ${0.4 * fade})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat, 100, `rgba(79, 195, 247, ${0.3 * fade})`);
            
            // Realization light rays from ship
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + this.cutsceneTime * 0.5;
                const dist = 100 + Math.sin(this.cutsceneTime * 2 + i) * 50;
                const x = shipX + Math.cos(angle) * dist;
                const y = shipY + shipFloat + Math.sin(angle) * dist;
                const alpha = 0.4 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                ctx.strokeStyle = `rgba(255, 170, 68, ${alpha * fade})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(shipX, shipY + shipFloat);
                ctx.lineTo(x, y);
                ctx.stroke();
                this.drawGlow(ctx, x, y, 8, `rgba(255, 170, 68, ${alpha * fade})`);
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = fade * textFade;
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 20px Arial';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 12;
                ctx.fillText('Einstein\'s argument: 1949', centerX, h * 0.65);
                ctx.font = '18px Arial';
                ctx.fillText('Psi deals with ensembles', centerX, h * 0.7);
                ctx.fillText('Not individual systems', centerX, h * 0.75);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = fade;
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(85);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced complete descriptions needed
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Complete Descriptions - Victory Theme
            // Complete description equations (dominant)
            const completeEquations = ['complete', 'description', 'individual', 'system', 'definite', 'exact'];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 220 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.3 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.2;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${19 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = completeEquations[i % completeEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 35 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.5})`);
            }
            
            // Victory symbols floating
            const victorySymbols = ['✓', '★', '✨', '●', '→', '↑', '▲'];
            for (let i = 0; i < 20; i++) {
                const symbolIndex = i % victorySymbols.length;
                const symbol = victorySymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.15;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.9 + Math.sin(this.cutsceneTime * 2 + i) * 0.3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${26 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 18 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.4})`);
            }
            
            // Quantum field particles (cyan/orange theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                const color = i % 2 === 0 ? 'rgba(79, 195, 247' : 'rgba(255, 170, 68';
                this.drawGlow(ctx, x, y, size * 2, `${color}, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced complete description visualization
            const descX = centerX;
            const descY = centerY;
            const descPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.2;
            
            // Complete description core with multiple gradient layers
            const descGradient = ctx.createRadialGradient(descX, descY, 0, descX, descY, 60 * descPulse);
            descGradient.addColorStop(0, '#4fc3f7');
            descGradient.addColorStop(0.3, '#2196f3');
            descGradient.addColorStop(0.6, '#1976d2');
            descGradient.addColorStop(1, '#0d47a1');
            ctx.fillStyle = descGradient;
            ctx.beginPath();
            ctx.arc(descX, descY, 60 * descPulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Multiple glow layers
            this.drawGlow(ctx, descX, descY, 60 * descPulse, 'rgba(79, 195, 247, 1)');
            this.drawGlow(ctx, descX, descY, 80 * descPulse, 'rgba(79, 195, 247, 0.7)');
            this.drawGlow(ctx, descX, descY, 100 * descPulse, 'rgba(79, 195, 247, 0.4)');
            this.drawGlow(ctx, descX, descY, 120 * descPulse, 'rgba(79, 195, 247, 0.2)');
            
            // Complete description properties radiating
            const propertyCount = 10;
            for (let i = 0; i < propertyCount; i++) {
                const angle = (i / propertyCount) * Math.PI * 2 + this.cutsceneTime * 0.5;
                const dist = 90 + Math.sin(this.cutsceneTime * 1.5 + i) * 15;
                const x = descX + Math.cos(angle) * dist;
                const y = descY + Math.sin(angle) * dist;
                const propPulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                
                // Property indicator
                ctx.fillStyle = 'rgba(79, 195, 247, 1)';
                ctx.beginPath();
                ctx.arc(x, y, 7 * propPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Multiple glow layers
                this.drawGlow(ctx, x, y, 12 * propPulse, 'rgba(79, 195, 247, 1)');
                this.drawGlow(ctx, x, y, 18 * propPulse, 'rgba(79, 195, 247, 0.6)');
                
                // Connection line to center
                ctx.strokeStyle = `rgba(79, 195, 247, ${0.4})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(descX, descY);
                ctx.lineTo(x, y);
                ctx.stroke();
            }
            
            // Victory energy waves
            for (let ring = 0; ring < 5; ring++) {
                const radius = 130 + ring * 25 + this.cutsceneTime * 40;
                const alpha = Math.max(0, 0.7 - ring * 0.1 - (radius - 130) / 250);
                if (alpha > 0) {
                    ctx.strokeStyle = `rgba(79, 195, 247, ${alpha * fade})`;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#4fc3f7';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(descX, descY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
                this.drawGlow(ctx, centerX, h * 0.25, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
                ctx.fillStyle = '#4fc3f7';
                ctx.font = 'bold 26px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 18;
                ctx.fillText('Complete descriptions', centerX, h * 0.25);
                ctx.font = 'bold 24px Arial';
                ctx.fillText('ARE NEEDED', centerX, h * 0.3);
                ctx.shadowBlur = 0;
                ctx.font = '20px Arial';
                ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
                ctx.fillText('For individual systems', centerX, h * 0.75);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(85);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced ready to escape - sidestepping Bell
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Escape Ready - Sidestepping Bell
            // Individual system equations (strong - victory)
            const individualEquations = ['A or B', 'individual', 'not pairs', 'sidestep', 'escape', 'ready'];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 220 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.35 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.25;
                const rotation = angle + Math.PI / 2;
                const scale = 0.9 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${20 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = individualEquations[i % individualEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 35 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.6})`);
            }
            
            // Bell's correlated pairs (fading - being sidestepped)
            const bellEquations = ['P(A,B)', 'correlated', 'pairs', 'Bell'];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 - this.cutsceneTime * 0.3;
                const radius = 160 + Math.sin(this.cutsceneTime * 0.4 + i) * 30;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.1 + Math.sin(this.cutsceneTime * 1.2 + i) * 0.05) * (1 - this.cutsceneTime / 2.5);
                const rotation = angle - Math.PI / 2;
                const scale = 0.5 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.15;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${14 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = bellEquations[i % bellEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 20 * scale, `rgba(255, 68, 68, ${alpha * fade * 0.2})`);
            }
            
            // Escape symbols floating
            const escapeSymbols = ['→', '⟶', '⟹', '↑', '★', '✨', '✓', '🚀'];
            for (let i = 0; i < 25; i++) {
                const symbolIndex = i % escapeSymbols.length;
                const symbol = escapeSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 35;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 35;
                const alpha = 0.25 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.2;
                const rotation = this.cutsceneTime * 0.25 + i;
                const scale = 1 + Math.sin(this.cutsceneTime * 2 + i) * 0.4;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${28 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 20 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.5})`);
            }
            
            // Quantum field particles (cyan/orange theme for escape)
            for (let i = 0; i < 70; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.6 + i) * 20;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.6 + i) * 20;
                const alpha = 0.18 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.1;
                const size = 3 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                const color = i % 2 === 0 ? 'rgba(79, 195, 247' : 'rgba(255, 170, 68';
                this.drawGlow(ctx, x, y, size * 2, `${color}, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced Einstein's ship with escape readiness
            const shipX = centerX - 150;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            const shipPulse = 1 + Math.sin(this.cutsceneTime * 2.5) * 0.15;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0 * shipPulse, 1, this.cutsceneTime);
            
            // Ship escape glow with multiple layers
            this.drawGlow(ctx, shipX, shipY + shipFloat, 90, `rgba(255, 170, 68, ${0.5 * fade})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat, 110, `rgba(79, 195, 247, ${0.4 * fade})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat, 130, `rgba(255, 170, 68, ${0.2 * fade})`);
            
            // Enhanced escape path (arrow to freedom) with pulsing
            const arrowPulse = 1 + Math.sin(this.cutsceneTime * 2.5) * 0.2;
                ctx.strokeStyle = '#ffaa44';
            ctx.lineWidth = 10 * arrowPulse;
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.moveTo(centerX - 30, centerY);
            ctx.lineTo(centerX + 250, centerY);
            ctx.lineTo(centerX + 220, centerY - 40);
            ctx.moveTo(centerX + 250, centerY);
            ctx.lineTo(centerX + 220, centerY + 40);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Arrow glow with multiple layers
            this.drawGlow(ctx, centerX + 250, centerY, 50, `rgba(255, 170, 68, ${0.8 * fade})`);
            this.drawGlow(ctx, centerX + 250, centerY, 70, `rgba(79, 195, 247, ${0.6 * fade})`);
            
            // Enhanced particles along escape path with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerCount = 25 + layer * 10;
                const layerSpeed = 0.6 + layer * 0.3;
                for (let i = 0; i < layerCount; i++) {
                    const progress = (this.cutsceneTime * layerSpeed + i * 0.04) % 1;
                    const x = centerX - 30 + progress * 280;
                    const y = centerY + Math.sin(progress * Math.PI * 6) * (12 - layer * 3);
                    const alpha = (0.9 - layer * 0.1) - progress * (0.2 - layer * 0.05);
                    const size = 7 + layer * 2;
                    if (alpha > 0) {
                        const color = layer % 2 === 0 ? 'rgba(255, 170, 68' : 'rgba(79, 195, 247';
                        this.drawGlow(ctx, x, y, size, `${color}, ${alpha * fade})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `${color}, ${alpha * fade * 0.6})`);
                    }
                }
            }
            
            // Victory celebration particles
            for (let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 2 + this.cutsceneTime * 2;
                const dist = 120 + Math.sin(this.cutsceneTime * 3 + i) * 60;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const alpha = 0.8 + Math.sin(this.cutsceneTime * 4 + i) * 0.2;
                const size = 6 + Math.sin(this.cutsceneTime * 2 + i) * 4;
                const color = i % 2 === 0 ? 'rgba(255, 170, 68' : 'rgba(79, 195, 247';
                this.drawGlow(ctx, x, y, size, `${color}, ${alpha * fade})`);
                this.drawGlow(ctx, x, y, size * 1.5, `${color}, ${alpha * fade * 0.5})`);
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.8 + Math.sin(this.cutsceneTime * 3) * 0.2;
                this.drawGlow(ctx, centerX, h * 0.25, 250, `rgba(255, 170, 68, ${textGlow * textFade * 0.3})`);
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 20;
                ctx.fillText('Individual system model', centerX, h * 0.25);
                ctx.shadowBlur = 0;
                const readyGlow = 1 + Math.sin(this.cutsceneTime * 4) * 0.3;
                this.drawGlow(ctx, centerX, h * 0.3, 200, `rgba(255, 170, 68, ${readyGlow * textFade * 0.4})`);
                ctx.font = 'bold 32px Arial';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 25;
                ctx.fillText('SIDESTEPS BELL!', centerX, h * 0.3);
                ctx.shadowBlur = 0;
                ctx.font = 'bold 24px Arial';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 18;
                ctx.fillText('You\'re ready to ESCAPE!', centerX, h * 0.75);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(85);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        }
    }
    // Level 90: The Escape Path is Clear - Enhanced
    drawCutsceneLevel90(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Enhanced escape path is clear
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Clear Escape Path - Freedom Theme
            // Escape path equations forming patterns
            const escapeEquations = ['escape', 'path', 'clear', 'freedom', 'individual', 'A or B'];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 200 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.3 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.2;
                const rotation = angle + Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = escapeEquations[i % escapeEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.5})`);
            }
            
            // Path symbols floating
            const pathSymbols = ['→', '⟶', '⟹', '↗', '↘', '↑', '★', '✨'];
            for (let i = 0; i < 25; i++) {
                const symbolIndex = i % pathSymbols.length;
                const symbol = pathSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 35;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 35;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.15;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.9 + Math.sin(this.cutsceneTime * 2 + i) * 0.3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${26 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 18 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.4})`);
            }
            
            // Quantum field particles (cyan theme for escape)
            for (let i = 0; i < 70; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.6 + i) * 20;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.6 + i) * 20;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.08;
                const size = 2.5 + Math.sin(this.cutsceneTime * 2 + i) * 1.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha * fade})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced title with multi-layer glow
            const titleGlow = 0.8 + Math.sin(this.cutsceneTime * 3) * 0.2;
            this.drawGlow(ctx, centerX, h * 0.2, 250, `rgba(79, 195, 247, ${titleGlow * fade * 0.3})`);
            this.drawGlow(ctx, centerX, h * 0.2, 200, `rgba(79, 195, 247, ${titleGlow * fade * 0.5})`);
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 35;
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 52px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ESCAPE PATH IS CLEAR', centerX, h * 0.2);
            ctx.shadowBlur = 0;
            
            // Enhanced Einstein's ship with clear path visualization
            const shipX = centerX - 200;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 10;
            const shipPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0 * shipPulse, 1, this.cutsceneTime);
            
            // Ship path glow
            this.drawGlow(ctx, shipX, shipY + shipFloat, 80, `rgba(79, 195, 247, ${0.4 * fade})`);
            
            // Enhanced clear escape path (wide arrow to freedom) with pulsing
            const arrowPulse = 1 + Math.sin(this.cutsceneTime * 2.5) * 0.2;
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 12 * arrowPulse;
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.moveTo(centerX - 50, centerY);
            ctx.lineTo(centerX + 280, centerY);
            ctx.lineTo(centerX + 240, centerY - 50);
            ctx.moveTo(centerX + 280, centerY);
            ctx.lineTo(centerX + 240, centerY + 50);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Path glow with multiple layers
            this.drawGlow(ctx, centerX + 280, centerY, 60, `rgba(79, 195, 247, ${0.9 * fade})`);
            this.drawGlow(ctx, centerX + 280, centerY, 80, `rgba(79, 195, 247, ${0.6 * fade})`);
            this.drawGlow(ctx, centerX + 280, centerY, 100, `rgba(79, 195, 247, ${0.3 * fade})`);
            
            // Path clarity indicators (checkmarks along path)
            for (let i = 0; i < 5; i++) {
                const progress = (i + 1) / 6;
                const x = centerX - 50 + progress * 330;
                const y = centerY;
                const checkFade = Math.min(1, (this.cutsceneTime - i * 0.3) / 0.5);
                if (checkFade > 0) {
                    ctx.strokeStyle = `rgba(79, 195, 247, ${checkFade * fade})`;
                ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                ctx.beginPath();
                    ctx.moveTo(x - 15, y);
                    ctx.lineTo(x - 5, y + 10);
                    ctx.lineTo(x + 15, y - 10);
                ctx.stroke();
                    this.drawGlow(ctx, x, y, 20, `rgba(79, 195, 247, ${checkFade * fade * 0.5})`);
                }
            }
            
            // Enhanced particles along escape path with multiple layers
            for (let layer = 0; layer < 3; layer++) {
                const layerCount = 30 + layer * 15;
                const layerSpeed = 0.5 + layer * 0.25;
                for (let i = 0; i < layerCount; i++) {
                    const progress = (this.cutsceneTime * layerSpeed + i * 0.03) % 1;
                    const x = centerX - 50 + progress * 330;
                    const y = centerY + Math.sin(progress * Math.PI * 8) * (15 - layer * 4);
                    const alpha = (0.9 - layer * 0.1) - progress * (0.2 - layer * 0.05);
                    const size = 8 + layer * 2;
                    if (alpha > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha * fade})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(79, 195, 247, ${alpha * fade * 0.6})`);
                    }
                }
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = fade * textFade;
                ctx.fillStyle = '#4fc3f7';
                ctx.font = 'bold 22px Arial';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
                ctx.fillText('The path forward is clear', centerX, h * 0.65);
                ctx.font = '20px Arial';
                ctx.fillText('Individual systems: A or B', centerX, h * 0.7);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = fade;
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(90);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Enhanced Bell's misattribution
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Misattribution - Bell's Error
            // Bell's correlated pairs equations (left side - misattributed)
            const bellEquations = ['P(A,B)', 'correlated', 'pairs', 'EPR', 'obsessed'];
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2 + this.cutsceneTime * 0.3;
                const radius = 150 + Math.sin(this.cutsceneTime * 0.4 + i) * 40;
                const x = w * 0.3 + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.2 + Math.sin(this.cutsceneTime * 1.2 + i) * 0.1) * fade;
                const rotation = angle + Math.PI / 2;
                const scale = 0.6 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${15 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = bellEquations[i % bellEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 25 * scale, `rgba(255, 68, 68, ${alpha * 0.3})`);
            }
            
            // Einstein's individual system equations (right side - correct)
            const einsteinEquations = ['individual', 'system', 'A or B', 'not pairs', 'later writings'];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 - this.cutsceneTime * 0.3;
                const radius = 180 + Math.sin(this.cutsceneTime * 0.5 + i) * 60;
                const x = w * 0.7 + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.3 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.2) * fade;
                const rotation = angle - Math.PI / 2;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = einsteinEquations[i % einsteinEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(79, 195, 247, ${alpha * 0.4})`);
            }
            
            // Misattribution symbols (cross-out, wrong)
            const misattributionSymbols = ['✗', '×', '≠', '→', '?'];
            for (let i = 0; i < 12; i++) {
                const symbolIndex = i % misattributionSymbols.length;
                const symbol = misattributionSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${24 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(255, 68, 68, ${alpha * fade * 0.3})`);
            }
            
            // Quantum field particles (red/cyan theme for misattribution vs correct)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                const color = i % 3 === 0 ? 'rgba(255, 68, 68' : 'rgba(79, 195, 247';
                this.drawGlow(ctx, x, y, size * 2, `${color}, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced split visualization: Bell's misattribution vs Einstein's actual argument
            // Left: Bell's focus (correlated pairs) - fading/crossed out
            const bellFade = Math.max(0, 1 - this.cutsceneTime / 2);
            const bellX = w * 0.3;
            const bellY = centerY;
            
            // Bell's correlated pairs visualization (fading)
            ctx.strokeStyle = `rgba(255, 68, 68, ${0.6 * bellFade * fade})`;
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(bellX - 40, bellY - 30);
            ctx.lineTo(bellX - 40, bellY + 30);
            ctx.lineTo(bellX + 40, bellY + 30);
            ctx.lineTo(bellX + 40, bellY - 30);
            ctx.closePath();
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Cross-out line
            ctx.strokeStyle = `rgba(255, 68, 68, ${bellFade * fade})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(bellX - 50, bellY - 40);
            ctx.lineTo(bellX + 50, bellY + 40);
            ctx.moveTo(bellX - 50, bellY + 40);
            ctx.lineTo(bellX + 50, bellY - 40);
            ctx.stroke();
            
            // "P(A,B)" label (fading)
            ctx.fillStyle = `rgba(255, 68, 68, ${bellFade * fade})`;
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('P(A,B)', bellX, bellY);
            
            // Right: Einstein's actual argument (individual systems) - growing
            const einsteinGrow = Math.min(1, this.cutsceneTime / 2);
            const einsteinX = w * 0.7;
            const einsteinY = centerY;
            
            // Einstein's individual system visualization (growing)
            const systemPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            const systemGradient = ctx.createRadialGradient(einsteinX, einsteinY, 0, einsteinX, einsteinY, 50 * systemPulse);
            systemGradient.addColorStop(0, `rgba(79, 195, 247, ${einsteinGrow})`);
            systemGradient.addColorStop(1, `rgba(33, 150, 243, ${einsteinGrow})`);
            ctx.fillStyle = systemGradient;
            ctx.beginPath();
            ctx.arc(einsteinX, einsteinY, 50 * systemPulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Multiple glow layers
            this.drawGlow(ctx, einsteinX, einsteinY, 50 * systemPulse, `rgba(79, 195, 247, ${einsteinGrow * 0.9})`);
            this.drawGlow(ctx, einsteinX, einsteinY, 70 * systemPulse, `rgba(79, 195, 247, ${einsteinGrow * 0.6})`);
            
            // "A or B" label
            ctx.fillStyle = `rgba(79, 195, 247, ${einsteinGrow})`;
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 12;
            ctx.fillText('A or B', einsteinX, einsteinY);
            ctx.shadowBlur = 0;
            
            // Connecting arrow showing the correction
            const arrowProgress = Math.min(1, this.cutsceneTime / 2);
            if (arrowProgress > 0.3) {
                const arrowX = bellX + 60;
                const arrowY = centerY;
                ctx.strokeStyle = `rgba(79, 195, 247, ${(arrowProgress - 0.3) / 0.7})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(einsteinX - 60, arrowY);
                ctx.lineTo(einsteinX - 70, arrowY - 10);
                ctx.moveTo(einsteinX - 60, arrowY);
                ctx.lineTo(einsteinX - 70, arrowY + 10);
                ctx.stroke();
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.6 + Math.sin(this.cutsceneTime * 2) * 0.4;
                this.drawGlow(ctx, centerX, h * 0.25, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
            ctx.fillStyle = '#4fc3f7';
                ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
                ctx.fillText('Bell misattributed', centerX, h * 0.25);
                ctx.font = '20px Arial';
                ctx.fillText('Hidden Variables to Einstein', centerX, h * 0.3);
                ctx.shadowBlur = 0;
                ctx.font = '18px Arial';
                ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
                ctx.fillText('Focused on correlated pairs after EPR', centerX, h * 0.75);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(90);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Enhanced Einstein's later writings - different argument
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.3, '#050510');
            bgGradient.addColorStop(0.6, '#030308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Einstein's True Argument - Individual Systems
            // Einstein's individual system equations (dominant)
            const einsteinEquations = ['individual', 'system', 'A or B', 'not pairs', 'no correlation', 'later writings'];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 220 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.35 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.25;
                const rotation = angle + Math.PI / 2;
                const scale = 0.9 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.3;
                
            ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${20 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = einsteinEquations[i % einsteinEquations.length];
                ctx.fillText(eq, 0, 0);
            ctx.restore();
            
                // Equation glow
                this.drawGlow(ctx, x, y, 35 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.6})`);
            }
            
            // EPR/correlations (fading - not relevant)
            const eprEquations = ['EPR', 'correlations', 'pairs'];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 - this.cutsceneTime * 0.2;
                const radius = 140 + Math.sin(this.cutsceneTime * 0.3 + i) * 20;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.1 + Math.sin(this.cutsceneTime * 1 + i) * 0.05) * (1 - this.cutsceneTime / 2);
                const rotation = angle - Math.PI / 2;
                const scale = 0.4 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.1;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${12 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = eprEquations[i % eprEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(255, 68, 68, ${alpha * fade * 0.2})`);
            }
            
            // Truth symbols floating
            const truthSymbols = ['✓', '★', '→', '⟶', '↑', '●'];
            for (let i = 0; i < 20; i++) {
                const symbolIndex = i % truthSymbols.length;
                const symbol = truthSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.15;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.9 + Math.sin(this.cutsceneTime * 2 + i) * 0.3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(79, 195, 247, ${alpha})`;
                ctx.font = `${26 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 18 * scale, `rgba(79, 195, 247, ${alpha * fade * 0.4})`);
            }
            
            // Quantum field particles (cyan theme)
            for (let i = 0; i < 60; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.5 + i) * 15;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.5 + i) * 15;
                const alpha = 0.12 + Math.sin(this.cutsceneTime * 2 + i) * 0.06;
                const size = 2 + Math.sin(this.cutsceneTime * 1.5 + i) * 1;
                this.drawGlow(ctx, x, y, size * 2, `rgba(79, 195, 247, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Enhanced Einstein's later writings visualization
            const writingsX = centerX;
            const writingsY = centerY - 20; // Move document up slightly
            const writingsPulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.15;
            
            // Document/page visualization (normal size, spheres will be outside)
            const docGradient = ctx.createLinearGradient(writingsX - 120, writingsY - 80, writingsX - 120, writingsY + 80);
            docGradient.addColorStop(0, 'rgba(79, 195, 247, 0.3)');
            docGradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.25)');
            docGradient.addColorStop(1, 'rgba(79, 195, 247, 0.2)');
            ctx.fillStyle = docGradient;
            ctx.fillRect(writingsX - 120, writingsY - 80, 240, 160);
            
            // Document border
            ctx.strokeStyle = 'rgba(79, 195, 247, 0.6)';
            ctx.lineWidth = 3;
            ctx.strokeRect(writingsX - 120, writingsY - 80, 240, 160);
            
            // Text lines on document (better spacing to avoid overlap)
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            const lines = [
                'Individual systems',
                'A or B',
                'Not correlations',
                'No semblance to EPR'
            ];
            for (let i = 0; i < lines.length; i++) {
                const lineFade = Math.min(1, (this.cutsceneTime - i * 0.3) / 0.5);
                if (lineFade > 0) {
                    ctx.globalAlpha = lineFade * fade;
                    // Text positioned with better spacing (32px between lines to avoid overlap)
                    ctx.fillText(lines[i], writingsX - 100, writingsY - 50 + i * 32);
                    ctx.globalAlpha = fade;
                }
            }
            ctx.textAlign = 'center';
            ctx.globalAlpha = 1;
            
            // Individual system visualization (A or B) - positioned outside box, just below it
            const systemAX = writingsX - 50;
            const systemBX = writingsX + 50;
            const systemY = writingsY + 100 + 30; // Document bottom is writingsY + 80, so +30 puts it just below
            const systemPulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.2;
            
            // System A
            const systemAGradient = ctx.createRadialGradient(systemAX, systemY, 0, systemAX, systemY, 25 * systemPulse);
            systemAGradient.addColorStop(0, 'rgba(79, 195, 247, 1)');
            systemAGradient.addColorStop(1, 'rgba(33, 150, 243, 1)');
            ctx.fillStyle = systemAGradient;
            ctx.beginPath();
            ctx.arc(systemAX, systemY, 25 * systemPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, systemAX, systemY, 25 * systemPulse, 'rgba(79, 195, 247, 0.9)');
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('A', systemAX, systemY + 6);
            
            // "OR" text (positioned between spheres, with proper spacing)
            ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('OR', writingsX, systemY + 2); // Slightly below center to avoid overlap
            
            // System B
            const systemBGradient = ctx.createRadialGradient(systemBX, systemY, 0, systemBX, systemY, 25 * systemPulse);
            systemBGradient.addColorStop(0, 'rgba(79, 195, 247, 1)');
            systemBGradient.addColorStop(1, 'rgba(33, 150, 243, 1)');
            ctx.fillStyle = systemBGradient;
            ctx.beginPath();
            ctx.arc(systemBX, systemY, 25 * systemPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, systemBX, systemY, 25 * systemPulse, 'rgba(79, 195, 247, 0.9)');
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('B', systemBX, systemY + 6);
            
            // "No correlation" indicator
            const noCorrFade = Math.min(1, (this.cutsceneTime - 1.5) / 0.5);
            if (noCorrFade > 0) {
                ctx.globalAlpha = noCorrFade * fade;
                ctx.strokeStyle = `rgba(79, 195, 247, ${noCorrFade})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(systemAX + 30, systemY);
                ctx.lineTo(systemBX - 30, systemY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = `rgba(79, 195, 247, ${noCorrFade})`;
                ctx.font = '14px Arial';
                ctx.fillText('No correlation', writingsX, systemY + 40);
                ctx.globalAlpha = fade;
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.7 + Math.sin(this.cutsceneTime * 2) * 0.3;
                this.drawGlow(ctx, centerX, h * 0.25, 200, `rgba(79, 195, 247, ${textGlow * textFade * 0.2})`);
                ctx.fillStyle = '#4fc3f7';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
                ctx.fillText('Einstein\'s later writings', centerX, h * 0.25);
                ctx.font = '20px Arial';
                ctx.fillText('Different argument', centerX, h * 0.3);
                ctx.shadowBlur = 0;
                ctx.font = '18px Arial';
                ctx.fillStyle = 'rgba(79, 195, 247, 0.9)';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
                ctx.fillText('Individual systems, not correlations', centerX, h * 0.75);
                ctx.fillText('No semblance to EPR', centerX, h * 0.8);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(90);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        }
    }
    // Level 95: Almost Free - Enhanced (Unique Design)
    drawCutsceneLevel95(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Model Assembly Animation - Components converging
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0a0510');
            bgGradient.addColorStop(0.6, '#050308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Model Assembly Theme
            // Assembly equations forming geometric patterns
            const assemblyEquations = ['model', 'assemble', 'complete', 'individual', 'system', 'A or B'];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2 + this.cutsceneTime * 0.4;
                const radius = 250 + Math.sin(this.cutsceneTime * 0.6 + i) * 70;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.35 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.25;
                const rotation = angle + Math.PI / 2;
                const scale = 0.85 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = assemblyEquations[i % assemblyEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.5})`);
            }
            
            // Assembly symbols floating (geometric shapes)
            const assemblySymbols = ['◉', '⬡', '⬢', '◆', '■', '▲', '●', '○'];
            for (let i = 0; i < 24; i++) {
                const symbolIndex = i % assemblySymbols.length;
                const symbol = assemblySymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.35 + i) * 35;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.35 + i) * 35;
                const alpha = 0.2 + Math.sin(this.cutsceneTime * 1.6 + i) * 0.15;
                const rotation = this.cutsceneTime * 0.2 + i;
                const scale = 0.8 + Math.sin(this.cutsceneTime * 2.2 + i) * 0.3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${26 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 18 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.4})`);
            }
            
            // Quantum field particles (orange theme)
            for (let i = 0; i < 70; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.6 + i) * 20;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.6 + i) * 20;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.08;
                const size = 2.5 + Math.sin(this.cutsceneTime * 2 + i) * 1.5;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha * fade})`);
            }
            
            ctx.globalAlpha = fade;
            
            // Enhanced title with multi-layer glow
            const titleGlow = 0.9 + Math.sin(this.cutsceneTime * 3.5) * 0.1;
            this.drawGlow(ctx, centerX, h * 0.2, 280, `rgba(255, 170, 68, ${titleGlow * fade * 0.35})`);
            this.drawGlow(ctx, centerX, h * 0.2, 220, `rgba(255, 170, 68, ${titleGlow * fade * 0.6})`);
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 40;
            ctx.fillStyle = '#ffaa44';
            ctx.font = 'bold 58px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ALMOST FREE', centerX, h * 0.2);
            ctx.shadowBlur = 0;
            
            // Model assembly animation - components converging to center
            const assemblyProgress = Math.min(1, this.cutsceneTime / 2);
            const numComponents = 8;
            const startRadius = 200;
            const endRadius = 40;
            
            for (let i = 0; i < numComponents; i++) {
                const angle = (i / numComponents) * Math.PI * 2;
                const currentRadius = startRadius * (1 - assemblyProgress) + endRadius * assemblyProgress;
                const x = centerX + Math.cos(angle) * currentRadius;
                const y = centerY + Math.sin(angle) * currentRadius;
                const componentSize = 20 + (1 - assemblyProgress) * 15;
                const componentPulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.2;
                
                // Component shape (hexagon)
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle + this.cutsceneTime * 0.5);
                ctx.fillStyle = `rgba(255, 170, 68, ${0.9 * fade})`;
                ctx.beginPath();
                for (let j = 0; j < 6; j++) {
                    const hexAngle = (j / 6) * Math.PI * 2;
                    const hexX = Math.cos(hexAngle) * componentSize * componentPulse;
                    const hexY = Math.sin(hexAngle) * componentSize * componentPulse;
                    if (j === 0) ctx.moveTo(hexX, hexY);
                    else ctx.lineTo(hexX, hexY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                
                // Component glow
                this.drawGlow(ctx, x, y, componentSize * componentPulse * 1.5, `rgba(255, 170, 68, ${0.7 * fade})`);
                
                // Connection lines to center (fading as they converge)
                if (assemblyProgress < 0.8) {
                    ctx.strokeStyle = `rgba(255, 170, 68, ${(1 - assemblyProgress) * 0.4 * fade})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(centerX, centerY);
                    ctx.stroke();
                }
            }
            
            // Central assembly point (growing as components converge)
            if (assemblyProgress > 0.3) {
                const coreSize = (assemblyProgress - 0.3) / 0.7 * 50;
                const corePulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.3;
                const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize * corePulse);
                coreGradient.addColorStop(0, 'rgba(255, 170, 68, 1)');
                coreGradient.addColorStop(1, 'rgba(255, 130, 30, 0.8)');
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, coreSize * corePulse, 0, Math.PI * 2);
                ctx.fill();
                this.drawGlow(ctx, centerX, centerY, coreSize * corePulse, 'rgba(255, 170, 68, 0.9)');
                this.drawGlow(ctx, centerX, centerY, coreSize * corePulse * 1.5, 'rgba(255, 170, 68, 0.5)');
            }
            
            // Assembly particles (energy flowing to center)
            for (let i = 0; i < 40; i++) {
                const angle = (i / 40) * Math.PI * 2;
                const startDist = 180;
                const progress = (this.cutsceneTime * 0.8 + i * 0.1) % 1;
                const dist = startDist * (1 - progress);
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const alpha = (1 - progress) * 0.8;
                const size = 4 + Math.sin(this.cutsceneTime * 3 + i) * 2;
                if (alpha > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha * fade})`);
                }
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = fade * textFade;
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 24px Arial';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 15;
                ctx.fillText('Model assembling...', centerX, h * 0.65);
                ctx.font = '20px Arial';
                ctx.fillText('Components converging', centerX, h * 0.7);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = fade;
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text for phase 0 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(95);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Geometric Structure Formation - Individual System Model
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0a0510');
            bgGradient.addColorStop(0.6, '#050308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Geometric Structure Theme
            // Individual system equations (dominant)
            const individualEquations = ['individual', 'system', 'A or B', 'complete', 'model', 'no correlation', 'sidestep'];
            for (let i = 0; i < 18; i++) {
                const angle = (i / 18) * Math.PI * 2 + this.cutsceneTime * 0.45;
                const radius = 250 + Math.sin(this.cutsceneTime * 0.7 + i) * 80;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.4 + Math.sin(this.cutsceneTime * 2 + i) * 0.3;
                const rotation = angle + Math.PI / 2;
                const scale = 0.9 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${20 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = individualEquations[i % individualEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 35 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.6})`);
            }
            
            // Correlations (fading - being sidestepped)
            const correlationEquations = ['correlations', 'pairs', 'Bell'];
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 - this.cutsceneTime * 0.2;
                const radius = 140 + Math.sin(this.cutsceneTime * 0.3 + i) * 25;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.1 + Math.sin(this.cutsceneTime * 1 + i) * 0.06) * (1 - this.cutsceneTime / 2);
                const rotation = angle - Math.PI / 2;
                const scale = 0.4 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.12;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${12 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = correlationEquations[i % correlationEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 15 * scale, `rgba(255, 68, 68, ${alpha * fade * 0.2})`);
            }
            
            // Structure symbols floating (geometric)
            const structureSymbols = ['⬡', '⬢', '◆', '■', '▲', '◉', '●', '○'];
            for (let i = 0; i < 22; i++) {
                const symbolIndex = i % structureSymbols.length;
                const symbol = structureSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.35 + i) * 32;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.35 + i) * 32;
                const alpha = 0.22 + Math.sin(this.cutsceneTime * 1.7 + i) * 0.18;
                const rotation = this.cutsceneTime * 0.22 + i;
                const scale = 0.88 + Math.sin(this.cutsceneTime * 2.6 + i) * 0.32;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${28 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 20 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.45})`);
            }
            
            // Quantum field particles (orange theme)
            for (let i = 0; i < 65; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.55 + i) * 18;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.55 + i) * 18;
                const alpha = 0.14 + Math.sin(this.cutsceneTime * 2.3 + i) * 0.07;
                const size = 2.3 + Math.sin(this.cutsceneTime * 1.8 + i) * 1.3;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Geometric structure formation - Individual System Model
            const modelX = centerX;
            const modelY = centerY;
            const structureProgress = Math.min(1, this.cutsceneTime / 2);
            const structurePulse = 1 + Math.sin(this.cutsceneTime * 2.8) * 0.25;
            
            // Central core (hexagon)
            const coreSize = 35 + structureProgress * 20;
            ctx.save();
            ctx.translate(modelX, modelY);
            ctx.rotate(this.cutsceneTime * 0.3);
            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize * structurePulse);
            coreGradient.addColorStop(0, 'rgba(255, 170, 68, 1)');
            coreGradient.addColorStop(0.6, 'rgba(255, 150, 50, 0.9)');
            coreGradient.addColorStop(1, 'rgba(255, 130, 30, 0.7)');
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = Math.cos(angle) * coreSize * structurePulse;
                const y = Math.sin(angle) * coreSize * structurePulse;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // Core glow
            this.drawGlow(ctx, modelX, modelY, coreSize * structurePulse, 'rgba(255, 170, 68, 1)');
            this.drawGlow(ctx, modelX, modelY, coreSize * structurePulse * 1.8, 'rgba(255, 170, 68, 0.6)');
            
            // "A or B" label in center
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 12;
            ctx.fillText('A or B', modelX, modelY);
            ctx.shadowBlur = 0;
            
            // Outer structure nodes (forming geometric pattern)
            const numNodes = 6;
            const nodeRadius = 80 + structureProgress * 30;
            for (let i = 0; i < numNodes; i++) {
                const angle = (i / numNodes) * Math.PI * 2 + this.cutsceneTime * 0.2;
                const nodeX = modelX + Math.cos(angle) * nodeRadius;
                const nodeY = modelY + Math.sin(angle) * nodeRadius;
                const nodeSize = 12 + structureProgress * 8;
                const nodePulse = 1 + Math.sin(this.cutsceneTime * 3 + i) * 0.3;
                
                // Node (small hexagon)
                ctx.save();
                ctx.translate(nodeX, nodeY);
                ctx.rotate(angle + this.cutsceneTime * 0.4);
                ctx.fillStyle = `rgba(255, 170, 68, ${0.9 * fade})`;
                ctx.beginPath();
                for (let j = 0; j < 6; j++) {
                    const hexAngle = (j / 6) * Math.PI * 2;
                    const hexX = Math.cos(hexAngle) * nodeSize * nodePulse;
                    const hexY = Math.sin(hexAngle) * nodeSize * nodePulse;
                    if (j === 0) ctx.moveTo(hexX, hexY);
                    else ctx.lineTo(hexX, hexY);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                
                // Node glow
                this.drawGlow(ctx, nodeX, nodeY, nodeSize * nodePulse * 1.5, `rgba(255, 170, 68, ${0.7 * fade})`);
                
                // Connection lines from core to nodes
                ctx.strokeStyle = `rgba(255, 170, 68, ${0.5 * fade})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(modelX, modelY);
                ctx.lineTo(nodeX, nodeY);
                ctx.stroke();
            }
            
            // Energy flow particles along connections
            for (let i = 0; i < numNodes; i++) {
                const angle = (i / numNodes) * Math.PI * 2;
                const nodeX = modelX + Math.cos(angle) * nodeRadius;
                const nodeY = modelY + Math.sin(angle) * nodeRadius;
                for (let j = 0; j < 3; j++) {
                    const progress = (this.cutsceneTime * 0.6 + j * 0.3 + i * 0.1) % 1;
                    const x = modelX + (nodeX - modelX) * progress;
                    const y = modelY + (nodeY - modelY) * progress;
                    const alpha = (1 - Math.abs(progress - 0.5) * 2) * 0.8;
                    const size = 3 + Math.sin(this.cutsceneTime * 4 + i + j) * 1.5;
                    if (alpha > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha * fade})`);
                    }
                }
            }
            
            // "No correlation" indicator (appearing)
            const noCorrFade = Math.min(1, (this.cutsceneTime - 1) / 0.8);
            if (noCorrFade > 0) {
                ctx.globalAlpha = noCorrFade * fade;
                ctx.strokeStyle = `rgba(255, 170, 68, ${noCorrFade})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]);
                ctx.beginPath();
                ctx.arc(modelX, modelY, nodeRadius + 20, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = `rgba(255, 170, 68, ${noCorrFade})`;
                ctx.font = '16px Arial';
                ctx.fillText('No correlation', modelX, modelY + nodeRadius + 50);
                ctx.globalAlpha = fade;
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.85 + Math.sin(this.cutsceneTime * 2.8) * 0.15;
                this.drawGlow(ctx, centerX, h * 0.25, 230, `rgba(255, 170, 68, ${textGlow * textFade * 0.25})`);
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 26px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 18;
                ctx.fillText('Individual System Model', centerX, h * 0.25);
                ctx.font = '20px Arial';
                ctx.fillText('Completing the program', centerX, h * 0.3);
                ctx.shadowBlur = 0;
                ctx.font = '18px Arial';
                ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 12;
                ctx.fillText('Sidesteps Bell - no correlations!', centerX, h * 0.75);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 1 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(95);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: Separation Animation - A and B breaking from pair
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Enhanced background with depth
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h));
            bgGradient.addColorStop(0, '#1a0a1a');
            bgGradient.addColorStop(0.3, '#0a0510');
            bgGradient.addColorStop(0.6, '#050308');
            bgGradient.addColorStop(1, '#000000');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Artistic background: Separation Theme
            // Individual system equations (strong)
            const individualEquations = ['A or B', 'individual', 'system', 'not pairs', 'breaking', 'free', 'separate'];
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2 + this.cutsceneTime * 0.55;
                const radius = 270 + Math.sin(this.cutsceneTime * 0.85 + i) * 90;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.48 + Math.sin(this.cutsceneTime * 2.3 + i) * 0.32;
                const rotation = angle + Math.PI / 2;
                const scale = 1.05 + Math.sin(this.cutsceneTime * 3.3 + i) * 0.35;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${22 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = individualEquations[i % individualEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 42 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.75})`);
            }
            
            // Correlated pairs (fading - being broken)
            const pairEquations = ['A and B', 'pairs', 'correlated', 'Bell'];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 - this.cutsceneTime * 0.25;
                const radius = 150 + Math.sin(this.cutsceneTime * 0.4 + i) * 35;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = (0.12 + Math.sin(this.cutsceneTime * 1.3 + i) * 0.08) * (1 - this.cutsceneTime / 2);
                const rotation = angle - Math.PI / 2;
                const scale = 0.5 + Math.sin(this.cutsceneTime * 1.7 + i) * 0.18;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.font = `${14 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = pairEquations[i % pairEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow
                this.drawGlow(ctx, x, y, 18 * scale, `rgba(255, 68, 68, ${alpha * fade * 0.25})`);
            }
            
            // Separation symbols floating
            const separationSymbols = ['◉', '⬡', '⬢', '◆', '■', '▲', '●', '○', '✓'];
            for (let i = 0; i < 24; i++) {
                const symbolIndex = i % separationSymbols.length;
                const symbol = separationSymbols[symbolIndex];
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.4 + i) * 38;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.4 + i) * 38;
                const alpha = 0.28 + Math.sin(this.cutsceneTime * 1.9 + i) * 0.22;
                const rotation = this.cutsceneTime * 0.28 + i;
                const scale = 0.95 + Math.sin(this.cutsceneTime * 2.9 + i) * 0.38;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 170, 68, ${alpha})`;
                ctx.font = `${30 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, 0, 0);
                ctx.restore();
                
                // Symbol glow
                this.drawGlow(ctx, x, y, 23 * scale, `rgba(255, 170, 68, ${alpha * fade * 0.55})`);
            }
            
            // Quantum field particles (orange theme)
            for (let i = 0; i < 75; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.65 + i) * 22;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.65 + i) * 22;
                const alpha = 0.18 + Math.sin(this.cutsceneTime * 2.6 + i) * 0.1;
                const size = 2.8 + Math.sin(this.cutsceneTime * 2.3 + i) * 1.8;
                this.drawGlow(ctx, x, y, size * 2, `rgba(255, 170, 68, ${alpha * fade})`);
            }
            
            // Ensure globalAlpha is 1 for all content
            ctx.globalAlpha = 1;
            
            // Separation animation - A and B breaking from pair
            const separationProgress = Math.min(1, this.cutsceneTime / 2);
            const startX = centerX;
            const startY = centerY;
            const separationDistance = 180;
            
            // Initial pair (fading as separation progresses)
            const pairFade = 1 - separationProgress;
            if (pairFade > 0) {
                // Pair bond visualization (breaking)
                ctx.strokeStyle = `rgba(255, 68, 68, ${0.6 * pairFade * fade})`;
                ctx.lineWidth = 4 * (1 - separationProgress);
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(startX - 30, startY);
                ctx.lineTo(startX + 30, startY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Pair container (fading)
                ctx.strokeStyle = `rgba(255, 68, 68, ${0.5 * pairFade * fade})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(startX, startY, 50, 0, Math.PI * 2);
                ctx.stroke();
                
                // "A and B" label (fading)
                ctx.fillStyle = `rgba(255, 68, 68, ${pairFade * fade})`;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('A and B', startX, startY);
            }
            
            // System A (separating left)
            const systemAX = startX - separationDistance * separationProgress;
            const systemAY = startY;
            const systemAPulse = 1 + Math.sin(this.cutsceneTime * 3.2) * 0.3;
            const systemAGradient = ctx.createRadialGradient(systemAX, systemAY, 0, systemAX, systemAY, 40 * systemAPulse);
            systemAGradient.addColorStop(0, 'rgba(255, 170, 68, 1)');
            systemAGradient.addColorStop(0.6, 'rgba(255, 150, 50, 0.95)');
            systemAGradient.addColorStop(1, 'rgba(255, 130, 30, 0.85)');
            ctx.fillStyle = systemAGradient;
            ctx.beginPath();
            ctx.arc(systemAX, systemAY, 40 * systemAPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, systemAX, systemAY, 40 * systemAPulse, 'rgba(255, 170, 68, 0.95)');
            this.drawGlow(ctx, systemAX, systemAY, 60 * systemAPulse, 'rgba(255, 170, 68, 0.6)');
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 12;
            ctx.fillText('A', systemAX, systemAY + 8);
            ctx.shadowBlur = 0;
            
            // System B (separating right)
            const systemBX = startX + separationDistance * separationProgress;
            const systemBY = startY;
            const systemBPulse = 1 + Math.sin(this.cutsceneTime * 3.5) * 0.3;
            const systemBGradient = ctx.createRadialGradient(systemBX, systemBY, 0, systemBX, systemBY, 40 * systemBPulse);
            systemBGradient.addColorStop(0, 'rgba(255, 170, 68, 1)');
            systemBGradient.addColorStop(0.6, 'rgba(255, 150, 50, 0.95)');
            systemBGradient.addColorStop(1, 'rgba(255, 130, 30, 0.85)');
            ctx.fillStyle = systemBGradient;
            ctx.beginPath();
            ctx.arc(systemBX, systemBY, 40 * systemBPulse, 0, Math.PI * 2);
            ctx.fill();
            this.drawGlow(ctx, systemBX, systemBY, 40 * systemBPulse, 'rgba(255, 170, 68, 0.95)');
            this.drawGlow(ctx, systemBX, systemBY, 60 * systemBPulse, 'rgba(255, 170, 68, 0.6)');
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffaa44';
            ctx.shadowBlur = 12;
            ctx.fillText('B', systemBX, systemBY + 8);
            ctx.shadowBlur = 0;
            
            // "OR" text (appearing between separated systems)
            const orFade = Math.min(1, (separationProgress - 0.3) / 0.4);
            if (orFade > 0) {
                ctx.fillStyle = `rgba(255, 170, 68, ${orFade})`;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 15;
                ctx.fillText('OR', centerX, centerY);
                ctx.shadowBlur = 0;
            }
            
            // Separation particles (energy released during separation)
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                const dist = separationProgress * 120 + Math.sin(this.cutsceneTime * 2 + i) * 20;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const alpha = (1 - separationProgress) * 0.7 * (1 - dist / 150);
                const size = 4 + Math.sin(this.cutsceneTime * 4 + i) * 2;
                if (alpha > 0) {
                    this.drawGlow(ctx, x, y, size, `rgba(255, 170, 68, ${alpha * fade})`);
                }
            }
            
            // "Individual" labels (appearing)
            const labelFade = Math.min(1, (separationProgress - 0.5) / 0.3);
            if (labelFade > 0) {
                ctx.fillStyle = `rgba(255, 170, 68, ${labelFade})`;
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Individual', systemAX, systemAY + 70);
                ctx.fillText('Individual', systemBX, systemBY + 70);
            }
            
            // Enhanced text with glow
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.globalAlpha = textFade;
                const textGlow = 0.9 + Math.sin(this.cutsceneTime * 3.2) * 0.1;
                this.drawGlow(ctx, centerX, h * 0.25, 250, `rgba(255, 170, 68, ${textGlow * textFade * 0.3})`);
                ctx.fillStyle = '#ffaa44';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 20;
                ctx.fillText('A or B - Not Pairs!', centerX, h * 0.25);
                ctx.font = '22px Arial';
                ctx.fillText('Bell doesn\'t apply!', centerX, h * 0.3);
                ctx.shadowBlur = 0;
                ctx.font = '20px Arial';
                ctx.fillStyle = 'rgba(255, 170, 68, 0.9)';
                ctx.shadowColor = '#ffaa44';
                ctx.shadowBlur = 15;
                ctx.fillText('You\'re breaking free!', centerX, h * 0.75);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
            
            // Set foreground text for phase 2 with enhanced styling
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(95);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#ffaa44';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(255, 170, 68, 0.9), 0 0 24px rgba(255, 170, 68, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        }
    }
    
    // Level 100: ESCAPE! - Breaking out of Bell's Brain into Bell Labs (CINEMATIC)
    drawCutsceneLevel100(ctx, w, h, data) {
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        if (this.cutscenePhase === 0) {
            // Phase 0: Inside Bell's Brain - The Mental Prison (ENHANCED)
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Deep brain background with multiple layers
            const brainGradient1 = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h) * 0.9);
            brainGradient1.addColorStop(0, 'rgba(120, 60, 140, 0.5)');
            brainGradient1.addColorStop(0.3, 'rgba(100, 50, 120, 0.4)');
            brainGradient1.addColorStop(0.6, 'rgba(80, 40, 100, 0.3)');
            brainGradient1.addColorStop(1, 'rgba(30, 15, 40, 0.2)');
            ctx.fillStyle = brainGradient1;
            ctx.fillRect(0, 0, w, h);
            
            // Brain lobes visualization (organic shapes)
            const brainPulse = 1 + Math.sin(this.cutsceneTime * 1.2) * 0.15;
            const numLobes = 8;
            for (let i = 0; i < numLobes; i++) {
                const angle = (i / numLobes) * Math.PI * 2;
                const lobeX = centerX + Math.cos(angle) * 180;
                const lobeY = centerY + Math.sin(angle) * 120;
                const lobeSize = 60 + Math.sin(this.cutsceneTime * 0.8 + i) * 20;
                const lobeAlpha = 0.25 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.15;
                
                // Brain lobe shape (organic blob)
                ctx.fillStyle = `rgba(150, 80, 180, ${lobeAlpha * fade})`;
                ctx.beginPath();
                for (let j = 0; j < 12; j++) {
                    const lobeAngle = (j / 12) * Math.PI * 2;
                    const radius = lobeSize + Math.sin(lobeAngle * 3 + this.cutsceneTime * 2) * 10;
                    const x = lobeX + Math.cos(lobeAngle) * radius * brainPulse;
                    const y = lobeY + Math.sin(lobeAngle) * radius * brainPulse;
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                this.drawGlow(ctx, lobeX, lobeY, lobeSize * brainPulse, `rgba(150, 80, 180, ${lobeAlpha * fade * 0.6})`);
            }
            
            // Neural network - dense connections
            const numNeurons = 50;
            const neurons = [];
            for (let i = 0; i < numNeurons; i++) {
                const angle = (i / numNeurons) * Math.PI * 2;
                const radius = 100 + Math.sin(this.cutsceneTime * 0.5 + i) * 80;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                neurons.push({ x, y, angle, radius });
                
                // Neuron firing animation
                const fireProgress = (this.cutsceneTime * 2 + i * 0.1) % 1;
                if (fireProgress < 0.3) {
                    const fireAlpha = (1 - fireProgress / 0.3) * 0.8;
                    this.drawGlow(ctx, x, y, 12, `rgba(255, 150, 200, ${fireAlpha * fade})`);
                }
            }
            
            // Synaptic connections (animated)
            for (let i = 0; i < numNeurons; i++) {
                for (let j = i + 1; j < Math.min(i + 4, numNeurons); j++) {
                    const dist = Math.sqrt(
                        Math.pow(neurons[i].x - neurons[j].x, 2) + 
                        Math.pow(neurons[i].y - neurons[j].y, 2)
                    );
                    if (dist < 150) {
                        const pulse = (Math.sin(this.cutsceneTime * 3 + i + j) + 1) / 2;
                        const alpha = (0.1 + pulse * 0.15) * (1 - dist / 150);
                        ctx.strokeStyle = `rgba(180, 120, 200, ${alpha * fade})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(neurons[i].x, neurons[i].y);
                        ctx.lineTo(neurons[j].x, neurons[j].y);
                        ctx.stroke();
                        
                        // Signal traveling along connection
                        const signalProgress = (this.cutsceneTime * 1.5 + i * 0.05) % 1;
                        if (signalProgress < 0.5) {
                            const signalX = neurons[i].x + (neurons[j].x - neurons[i].x) * signalProgress * 2;
                            const signalY = neurons[i].y + (neurons[j].y - neurons[i].y) * signalProgress * 2;
                            this.drawGlow(ctx, signalX, signalY, 6, `rgba(255, 200, 255, ${0.9 * fade})`);
                        }
                    }
                }
            }
            
            // Bell's equations floating (mental prison bars)
            const bellEquations = ['P(A,B)', 'correlations', 'pairs', 'Bell', 'inequality', 'EPR', '|E(a,b)-E(a,b\')|', '≤ 1+E(a\',b\')'];
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2 + this.cutsceneTime * 0.25;
                const radius = 200 + Math.sin(this.cutsceneTime * 0.4 + i) * 90;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const alpha = 0.5 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.35;
                const rotation = angle + Math.PI / 2;
                const scale = 0.85 + Math.sin(this.cutsceneTime * 2.5 + i) * 0.25;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = alpha * fade;
                ctx.fillStyle = `rgba(255, 100, 100, ${alpha})`;
                ctx.font = `bold ${18 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const eq = bellEquations[i % bellEquations.length];
                ctx.fillText(eq, 0, 0);
                ctx.restore();
                
                // Equation glow with multiple layers
                this.drawGlow(ctx, x, y, 30 * scale, `rgba(255, 100, 100, ${alpha * fade * 0.5})`);
                this.drawGlow(ctx, x, y, 45 * scale, `rgba(255, 100, 100, ${alpha * fade * 0.3})`);
            }
            
            // Brain waves (EEG-like patterns)
            for (let wave = 0; wave < 3; wave++) {
                const waveY = h * 0.15 + wave * (h * 0.25);
                ctx.strokeStyle = `rgba(200, 150, 220, ${0.3 * fade})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = 0; x < w; x += 2) {
                    const y = waveY + Math.sin((x / 50) + this.cutsceneTime * 2 + wave) * 15;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // Einstein's ship trapped (struggling animation)
            const shipX = centerX;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 1.5) * 12;
            const shipStruggle = Math.sin(this.cutsceneTime * 4) * 5;
            const shipPulse = 1 + Math.sin(this.cutsceneTime * 2.5) * 0.15;
            this.drawEinsteinShip(ctx, shipX + shipStruggle, shipY + shipFloat, 0.85 * shipPulse, fade, this.cutsceneTime);
            
            // Trapping neural chains
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const chainX = shipX + Math.cos(angle) * 40;
                const chainY = shipY + Math.sin(angle) * 40;
                const anchorX = centerX + Math.cos(angle) * 180;
                const anchorY = centerY + Math.sin(angle) * 120;
                
                ctx.strokeStyle = `rgba(200, 100, 150, ${0.6 * fade})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.moveTo(chainX, chainY);
                ctx.lineTo(anchorX, anchorY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Chain links
                for (let j = 0; j < 5; j++) {
                    const linkProgress = j / 5;
                    const linkX = chainX + (anchorX - chainX) * linkProgress;
                    const linkY = chainY + (anchorY - chainY) * linkProgress;
                    this.drawGlow(ctx, linkX, linkY, 4, `rgba(200, 100, 150, ${0.8 * fade})`);
                }
            }
            
            // Ship struggle glow (pulsing)
            const struggleGlow = 0.5 + Math.sin(this.cutsceneTime * 4) * 0.3;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 70, `rgba(79, 195, 247, ${struggleGlow * fade})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat, 100, `rgba(79, 195, 247, ${struggleGlow * fade * 0.6})`);
            
            // Atmospheric particles (brain matter floating)
            for (let i = 0; i < 80; i++) {
                const x = (i * 37) % w + Math.sin(this.cutsceneTime * 0.3 + i) * 30;
                const y = (i * 23) % h + Math.cos(this.cutsceneTime * 0.3 + i) * 30;
                const alpha = 0.15 + Math.sin(this.cutsceneTime * 1.8 + i) * 0.1;
                const size = 3 + Math.sin(this.cutsceneTime * 2 + i) * 2;
                this.drawGlow(ctx, x, y, size, `rgba(150, 100, 180, ${alpha * fade})`);
            }
            
            // Enhanced title with dramatic effect
            ctx.globalAlpha = fade;
            const titlePulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            this.drawGlow(ctx, centerX, h * 0.15, 300 * titlePulse, `rgba(255, 100, 100, ${0.4 * fade})`);
            this.drawGlow(ctx, centerX, h * 0.15, 250 * titlePulse, `rgba(255, 100, 100, ${0.6 * fade})`);
            ctx.shadowColor = '#ff6b6b';
            ctx.shadowBlur = 40;
            ctx.fillStyle = '#ff6b6b';
            ctx.font = 'bold 56px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('INSIDE BELL\'S BRAIN', centerX, h * 0.15);
            ctx.shadowBlur = 0;
            
            // Enhanced text
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.fillStyle = 'rgba(255, 200, 200, 0.95)';
                ctx.font = 'bold 22px Arial';
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 12;
                ctx.fillText('Trapped in the mental prison', centerX, h * 0.7);
                ctx.font = '20px Arial';
                ctx.fillText('of correlated pairs...', centerX, h * 0.75);
                ctx.shadowBlur = 0;
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(100);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[0]) {
                    let text = cutsceneData.texts[0].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 1) {
            // Phase 1: Breaking Through - Dramatic Escape (ENHANCED)
            const fade = Math.min(1, this.cutsceneTime / 2);
            
            // Brain background (fading with shatter effect)
            const brainFade = 1 - this.cutsceneTime / 2;
            const brainGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(w, h) * 0.8);
            brainGradient.addColorStop(0, `rgba(120, 60, 140, ${0.5 * brainFade})`);
            brainGradient.addColorStop(0.5, `rgba(100, 50, 120, ${0.4 * brainFade})`);
            brainGradient.addColorStop(1, `rgba(30, 15, 40, ${0.2 * brainFade})`);
            ctx.fillStyle = brainGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Major cracks forming (dramatic)
            const crackProgress = Math.min(1, this.cutsceneTime / 2);
            const numCracks = 16;
            for (let i = 0; i < numCracks; i++) {
                const angle = (i / numCracks) * Math.PI * 2;
                const baseLength = 250 * crackProgress;
                const length = baseLength + Math.sin(this.cutsceneTime * 3 + i) * 30;
                const crackWidth = 4 + crackProgress * 3;
                const x1 = centerX + Math.cos(angle) * 40;
                const y1 = centerY + Math.sin(angle) * 40;
                const x2 = centerX + Math.cos(angle) * (40 + length);
                const y2 = centerY + Math.sin(angle) * (40 + length);
                
                // Main crack line
                ctx.strokeStyle = `rgba(79, 195, 247, ${crackProgress * fade})`;
                ctx.lineWidth = crackWidth;
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // Branching cracks
                if (crackProgress > 0.3) {
                    const branchProgress = (crackProgress - 0.3) / 0.7;
                    for (let branch = 0; branch < 2; branch++) {
                        const branchAngle = angle + (branch === 0 ? 0.3 : -0.3);
                        const branchLength = 80 * branchProgress;
                        const branchX = x1 + (x2 - x1) * 0.6;
                        const branchY = y1 + (y2 - y1) * 0.6;
                        const branchX2 = branchX + Math.cos(branchAngle) * branchLength;
                        const branchY2 = branchY + Math.sin(branchAngle) * branchLength;
                        ctx.strokeStyle = `rgba(79, 195, 247, ${branchProgress * crackProgress * fade})`;
                        ctx.lineWidth = crackWidth * 0.6;
                        ctx.beginPath();
                        ctx.moveTo(branchX, branchY);
                        ctx.lineTo(branchX2, branchY2);
                        ctx.stroke();
                    }
                }
                ctx.shadowBlur = 0;
                
                // Crack tip glow
                this.drawGlow(ctx, x2, y2, 30, `rgba(79, 195, 247, ${crackProgress * fade * 0.8})`);
                this.drawGlow(ctx, x2, y2, 50, `rgba(79, 195, 247, ${crackProgress * fade * 0.5})`);
            }
            
            // Light beams breaking through (dramatic)
            for (let i = 0; i < numCracks; i++) {
                const angle = (i / numCracks) * Math.PI * 2;
                const dist = 40 + 250 * crackProgress;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                const lightAlpha = crackProgress * 0.9;
                const beamPulse = 1 + Math.sin(this.cutsceneTime * 5 + i) * 0.3;
                
                // Light beam gradient
                const beamGradient = ctx.createRadialGradient(x, y, 0, x, y, 60 * beamPulse);
                beamGradient.addColorStop(0, `rgba(79, 195, 247, ${lightAlpha * fade})`);
                beamGradient.addColorStop(0.5, `rgba(100, 210, 255, ${lightAlpha * fade * 0.7})`);
                beamGradient.addColorStop(1, `rgba(79, 195, 247, 0)`);
                ctx.fillStyle = beamGradient;
                ctx.beginPath();
                ctx.arc(x, y, 60 * beamPulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Multiple glow layers
                this.drawGlow(ctx, x, y, 50 * beamPulse, `rgba(79, 195, 247, ${lightAlpha * fade})`);
                this.drawGlow(ctx, x, y, 80 * beamPulse, `rgba(79, 195, 247, ${lightAlpha * fade * 0.6})`);
                this.drawGlow(ctx, x, y, 110 * beamPulse, `rgba(79, 195, 247, ${lightAlpha * fade * 0.3})`);
            }
            
            // Central explosion of light (breaking point)
            const explosionProgress = Math.min(1, (crackProgress - 0.5) / 0.5);
            if (explosionProgress > 0) {
                const explosionSize = 100 + explosionProgress * 150;
                const explosionPulse = 1 + Math.sin(this.cutsceneTime * 6) * 0.2;
                const explosionGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, explosionSize * explosionPulse);
                explosionGradient.addColorStop(0, `rgba(79, 195, 247, ${explosionProgress * fade})`);
                explosionGradient.addColorStop(0.3, `rgba(100, 210, 255, ${explosionProgress * fade * 0.8})`);
                explosionGradient.addColorStop(1, `rgba(79, 195, 247, 0)`);
                ctx.fillStyle = explosionGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, explosionSize * explosionPulse, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Einstein's ship breaking through (dramatic)
            const shipX = centerX;
            const shipY = centerY;
            const shipFloat = Math.sin(this.cutsceneTime * 2.5) * 15;
            const shipBreak = crackProgress * 20;
            const shipPulse = 1 + Math.sin(this.cutsceneTime * 4) * 0.25;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat - shipBreak, 1.1 * shipPulse, fade, this.cutsceneTime);
            
            // Breaking through glow (intense)
            const breakGlow = 0.7 + Math.sin(this.cutsceneTime * 5) * 0.3;
            this.drawGlow(ctx, shipX, shipY + shipFloat - shipBreak, 90, `rgba(79, 195, 247, ${breakGlow * fade})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat - shipBreak, 130, `rgba(79, 195, 247, ${breakGlow * fade * 0.7})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat - shipBreak, 170, `rgba(79, 195, 247, ${breakGlow * fade * 0.4})`);
            
            // Energy trails from ship
            for (let i = 0; i < 8; i++) {
                const trailAngle = (i / 8) * Math.PI * 2;
                const trailLength = 40 + crackProgress * 60;
                const trailX = shipX + Math.cos(trailAngle) * trailLength;
                const trailY = shipY + shipFloat - shipBreak + Math.sin(trailAngle) * trailLength;
                const trailAlpha = (1 - crackProgress) * 0.6;
                this.drawGlow(ctx, trailX, trailY, 15, `rgba(79, 195, 247, ${trailAlpha * fade})`);
            }
            
            // Debris and particles escaping (intense)
            for (let layer = 0; layer < 3; layer++) {
                const layerCount = 40 + layer * 20;
                const layerSpeed = 0.9 + layer * 0.3;
                for (let i = 0; i < layerCount; i++) {
                    const angle = (i / layerCount) * Math.PI * 2;
                    const progress = (this.cutsceneTime * layerSpeed + i * 0.03) % 1;
                    const dist = 40 + progress * 280;
                    const x = centerX + Math.cos(angle) * dist;
                    const y = centerY + Math.sin(angle) * dist;
                    const alpha = (1 - progress) * (0.95 - layer * 0.1);
                    const size = 6 + layer * 2 + Math.sin(this.cutsceneTime * 5 + i) * 3;
                    if (alpha > 0) {
                        this.drawGlow(ctx, x, y, size, `rgba(79, 195, 247, ${alpha * fade})`);
                        this.drawGlow(ctx, x, y, size * 1.5, `rgba(100, 210, 255, ${alpha * fade * 0.5})`);
                    }
                }
            }
            
            // Brain fragments breaking off
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const fragmentProgress = Math.min(1, (crackProgress - 0.4) / 0.6);
                if (fragmentProgress > 0) {
                    const dist = 150 + fragmentProgress * 100;
                    const x = centerX + Math.cos(angle) * dist;
                    const y = centerY + Math.sin(angle) * dist;
                    const rotation = this.cutsceneTime * 2 + i;
                    const size = 15 + Math.sin(this.cutsceneTime * 3 + i) * 5;
                    const alpha = fragmentProgress * 0.6;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rotation);
                    ctx.fillStyle = `rgba(150, 80, 180, ${alpha * brainFade * fade})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Enhanced title with dramatic effect
            ctx.globalAlpha = fade;
            const titlePulse = 1 + Math.sin(this.cutsceneTime * 3) * 0.15;
            this.drawGlow(ctx, centerX, h * 0.15, 350 * titlePulse, `rgba(79, 195, 247, ${0.5 * fade})`);
            this.drawGlow(ctx, centerX, h * 0.15, 280 * titlePulse, `rgba(79, 195, 247, ${0.7 * fade})`);
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 45;
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BREAKING THROUGH', centerX, h * 0.15);
            ctx.shadowBlur = 0;
            
            // Enhanced text
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.fillStyle = 'rgba(79, 195, 247, 0.95)';
                ctx.font = 'bold 24px Arial';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 15;
                ctx.fillText('Cracks shattering the mental prison...', centerX, h * 0.7);
                ctx.font = '22px Arial';
                ctx.fillText('Light breaking through!', centerX, h * 0.75);
                ctx.shadowBlur = 0;
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(100);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[1]) {
                    let text = cutsceneData.texts[1].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        } else if (this.cutscenePhase === 2) {
            // Phase 2: BELL LABS - Detailed Laboratory (CINEMATIC)
            const fade = Math.min(1, this.cutsceneTime / 2);
            const labAppear = Math.min(1, this.cutsceneTime / 2);
            
            // Laboratory background (realistic)
            const labBgGradient = ctx.createLinearGradient(0, 0, 0, h);
            labBgGradient.addColorStop(0, `rgba(25, 35, 45, ${0.9 * labAppear})`);
            labBgGradient.addColorStop(0.3, `rgba(30, 40, 50, ${0.8 * labAppear})`);
            labBgGradient.addColorStop(0.7, `rgba(35, 45, 55, ${0.7 * labAppear})`);
            labBgGradient.addColorStop(1, `rgba(20, 30, 40, ${0.6 * labAppear})`);
            ctx.fillStyle = labBgGradient;
            ctx.fillRect(0, 0, w, h);
            
            // Fluorescent ceiling lights
            for (let i = 0; i < 4; i++) {
                const lightX = w * 0.2 + i * (w * 0.6 / 3);
                const lightY = h * 0.15;
                const lightPulse = 0.8 + Math.sin(this.cutsceneTime * 2 + i) * 0.2;
                
                // Light fixture
                ctx.fillStyle = `rgba(200, 200, 200, ${0.7 * labAppear * fade})`;
                ctx.fillRect(lightX - 40, lightY - 5, 80, 8);
                
                // Light glow
                const lightGradient = ctx.createRadialGradient(lightX, lightY + 50, 0, lightX, lightY + 50, 200);
                lightGradient.addColorStop(0, `rgba(200, 220, 255, ${0.3 * lightPulse * labAppear * fade})`);
                lightGradient.addColorStop(1, `rgba(200, 220, 255, 0)`);
                ctx.fillStyle = lightGradient;
                ctx.fillRect(lightX - 200, lightY, 400, 200);
            }
            
            // Lab benches (multiple levels)
            const benchY1 = h * 0.6;
            const benchY2 = h * 0.75;
            const benchY3 = h * 0.9;
            
            // Bench 1 (main workbench)
            const benchGradient1 = ctx.createLinearGradient(0, benchY1, 0, benchY1 + 25);
            benchGradient1.addColorStop(0, `rgba(70, 60, 50, ${0.8 * labAppear * fade})`);
            benchGradient1.addColorStop(1, `rgba(50, 40, 30, ${0.9 * labAppear * fade})`);
            ctx.fillStyle = benchGradient1;
            ctx.fillRect(0, benchY1, w, 25);
            
            // Bench shadow
            ctx.fillStyle = `rgba(0, 0, 0, ${0.3 * labAppear * fade})`;
            ctx.fillRect(0, benchY1 + 25, w, 5);
            
            // Bench 2 (secondary)
            const benchGradient2 = ctx.createLinearGradient(0, benchY2, 0, benchY2 + 20);
            benchGradient2.addColorStop(0, `rgba(65, 55, 45, ${0.7 * labAppear * fade})`);
            benchGradient2.addColorStop(1, `rgba(45, 35, 25, ${0.8 * labAppear * fade})`);
            ctx.fillStyle = benchGradient2;
            ctx.fillRect(0, benchY2, w, 20);
            
            // Bench 3 (floor level)
            ctx.fillStyle = `rgba(60, 50, 40, ${0.6 * labAppear * fade})`;
            ctx.fillRect(0, benchY3, w, 15);
            
            // Left side equipment
            const leftX = w * 0.15;
            
            // Oscilloscope
            const scopeX = leftX;
            const scopeY = benchY1 - 80;
            ctx.fillStyle = `rgba(40, 40, 40, ${labAppear * fade})`;
            ctx.fillRect(scopeX - 35, scopeY - 25, 70, 50);
            ctx.strokeStyle = `rgba(100, 200, 100, ${labAppear * fade})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(scopeX - 35, scopeY - 25, 70, 50);
            // Screen
            ctx.fillStyle = `rgba(0, 30, 0, ${labAppear * fade})`;
            ctx.fillRect(scopeX - 25, scopeY - 15, 50, 30);
            // Waveform
            ctx.strokeStyle = `rgba(0, 255, 0, ${labAppear * fade})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = scopeX - 25; x < scopeX + 25; x += 2) {
                const y = scopeY + Math.sin((x - scopeX) / 5 + this.cutsceneTime * 2) * 10;
                if (x === scopeX - 25) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Computer monitor
            const compX = leftX + 100;
            const compY = benchY1 - 60;
            ctx.fillStyle = `rgba(30, 30, 30, ${labAppear * fade})`;
            ctx.fillRect(compX - 40, compY - 30, 80, 60);
            ctx.fillStyle = `rgba(20, 20, 40, ${labAppear * fade})`;
            ctx.fillRect(compX - 35, compY - 25, 70, 50);
            // Screen glow
            const screenPulse = 0.7 + Math.sin(this.cutsceneTime * 3) * 0.3;
            this.drawGlow(ctx, compX, compY, 30, `rgba(79, 195, 247, ${screenPulse * labAppear * fade * 0.4})`);
            
            // Center equipment (main focus)
            const centerX = w * 0.5;
            
            // Large microscope
            const microX = centerX - 80;
            const microY = benchY1 - 100;
            // Base
            ctx.fillStyle = `rgba(180, 180, 180, ${labAppear * fade})`;
            ctx.fillRect(microX - 20, microY + 60, 40, 30);
            // Arm
            ctx.fillStyle = `rgba(200, 200, 200, ${labAppear * fade})`;
            ctx.fillRect(microX - 8, microY + 30, 16, 35);
            // Head
            ctx.fillStyle = `rgba(220, 220, 220, ${labAppear * fade})`;
            ctx.fillRect(microX - 25, microY, 50, 35);
            // Eyepiece
            ctx.fillStyle = `rgba(40, 40, 40, ${labAppear * fade})`;
            ctx.beginPath();
            ctx.arc(microX, microY + 10, 8, 0, Math.PI * 2);
            ctx.fill();
            // Objective lens
            ctx.fillStyle = `rgba(100, 150, 200, ${0.6 * labAppear * fade})`;
            ctx.beginPath();
            ctx.arc(microX, microY + 70, 12, 0, Math.PI * 2);
            ctx.fill();
            // Microscope glow
            this.drawGlow(ctx, microX, microY + 70, 20, `rgba(79, 195, 247, ${0.5 * labAppear * fade})`);
            
            // Beakers and flasks (center)
            const flaskPositions = [
                { x: centerX - 40, y: benchY1 - 50, size: 20, r: 100, g: 150, b: 200 },
                { x: centerX, y: benchY1 - 60, size: 25, r: 150, g: 100, b: 200 },
                { x: centerX + 40, y: benchY1 - 55, size: 22, r: 200, g: 150, b: 100 },
                { x: centerX + 100, y: benchY1 - 45, size: 18, r: 100, g: 200, b: 150 }
            ];
            
            for (let i = 0; i < flaskPositions.length; i++) {
                const flask = flaskPositions[i];
                // Flask body
                ctx.strokeStyle = `rgba(200, 200, 200, ${labAppear * fade})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(flask.x, flask.y, flask.size, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = `rgba(${flask.r}, ${flask.g}, ${flask.b}, ${0.4 * labAppear * fade})`;
                ctx.fill();
                // Neck
                ctx.strokeStyle = `rgba(200, 200, 200, ${labAppear * fade})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(flask.x - 5, flask.y - flask.size);
                ctx.lineTo(flask.x - 5, flask.y - flask.size - 15);
                ctx.lineTo(flask.x + 5, flask.y - flask.size - 15);
                ctx.lineTo(flask.x + 5, flask.y - flask.size);
                ctx.closePath();
                ctx.stroke();
                // Bubbling animation
                const bubbleProgress = (this.cutsceneTime * 0.5 + i * 0.2) % 1;
                if (bubbleProgress < 0.5) {
                    const bubbleY = flask.y - flask.size - 20 + bubbleProgress * 40;
                    this.drawGlow(ctx, flask.x, bubbleY, 3, `rgba(200, 220, 255, ${(1 - bubbleProgress * 2) * labAppear * fade})`);
                }
            }
            
            // Right side equipment
            const rightX = w * 0.85;
            
            // Electronic equipment rack
            const rackX = rightX;
            const rackY = benchY1 - 120;
            ctx.fillStyle = `rgba(35, 35, 35, ${labAppear * fade})`;
            ctx.fillRect(rackX - 30, rackY, 60, 100);
            // Rack panels
            for (let i = 0; i < 4; i++) {
                ctx.strokeStyle = `rgba(100, 100, 100, ${labAppear * fade})`;
                ctx.lineWidth = 1;
                ctx.strokeRect(rackX - 28, rackY + 5 + i * 23, 56, 20);
                // LED indicators
                const ledPulse = (Math.sin(this.cutsceneTime * 2 + i) + 1) / 2;
                this.drawGlow(ctx, rackX - 20, rackY + 15 + i * 23, 3, `rgba(0, 255, 0, ${ledPulse * labAppear * fade})`);
            }
            
            // Test equipment
            const testX = rightX - 80;
            const testY = benchY1 - 70;
            ctx.fillStyle = `rgba(50, 50, 50, ${labAppear * fade})`;
            ctx.fillRect(testX - 25, testY - 15, 50, 30);
            ctx.strokeStyle = `rgba(150, 150, 150, ${labAppear * fade})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(testX - 25, testY - 15, 50, 30);
            // Display
            ctx.fillStyle = `rgba(0, 50, 0, ${labAppear * fade})`;
            ctx.fillRect(testX - 20, testY - 10, 40, 20);
            // Digital readout
            ctx.fillStyle = `rgba(0, 255, 0, ${labAppear * fade})`;
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('3.14159', testX, testY + 5);
            
            // Einstein's ship entering the lab
            const shipX = centerX + (labAppear - 0.5) * w * 0.4;
            const shipY = centerY - 50;
            const shipFloat = Math.sin(this.cutsceneTime * 1.8) * 6;
            const shipPulse = 1 + Math.sin(this.cutsceneTime * 2.5) * 0.1;
            this.drawEinsteinShip(ctx, shipX, shipY + shipFloat, 1.0 * shipPulse, fade, this.cutsceneTime);
            
            // Ship arrival glow
            const arrivalGlow = 0.6 + Math.sin(this.cutsceneTime * 3) * 0.2;
            this.drawGlow(ctx, shipX, shipY + shipFloat, 70, `rgba(79, 195, 247, ${arrivalGlow * fade})`);
            this.drawGlow(ctx, shipX, shipY + shipFloat, 100, `rgba(79, 195, 247, ${arrivalGlow * fade * 0.5})`);
            
            // Lab atmosphere particles (dust, light reflections)
            for (let i = 0; i < 60; i++) {
                const x = (i * 47) % w + Math.sin(this.cutsceneTime * 0.2 + i) * 20;
                const y = (i * 31) % h + Math.cos(this.cutsceneTime * 0.2 + i) * 20;
                const alpha = 0.1 + Math.sin(this.cutsceneTime * 1.5 + i) * 0.05;
                const size = 2 + Math.sin(this.cutsceneTime * 2 + i) * 1;
                this.drawGlow(ctx, x, y, size, `rgba(200, 220, 255, ${alpha * labAppear * fade})`);
            }
            
            // "BELL LABS" sign
            const signY = h * 0.1;
            ctx.fillStyle = `rgba(200, 200, 200, ${labAppear * fade})`;
            ctx.fillRect(centerX - 80, signY - 15, 160, 30);
            ctx.strokeStyle = `rgba(79, 195, 247, ${labAppear * fade})`;
            ctx.lineWidth = 3;
            ctx.strokeRect(centerX - 80, signY - 15, 160, 30);
            ctx.fillStyle = `rgba(79, 195, 247, ${labAppear * fade})`;
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BELL LABS', centerX, signY + 8);
            
            // Enhanced title
            ctx.globalAlpha = fade;
            const titlePulse = 1 + Math.sin(this.cutsceneTime * 2) * 0.1;
            this.drawGlow(ctx, centerX, h * 0.05, 300 * titlePulse, `rgba(79, 195, 247, ${0.4 * fade})`);
            ctx.shadowColor = '#4fc3f7';
            ctx.shadowBlur = 35;
            ctx.fillStyle = '#4fc3f7';
            ctx.font = 'bold 54px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ESCAPE TO BELL LABS', centerX, h * 0.05);
            ctx.shadowBlur = 0;
            
            // Enhanced text
            const textFade = Math.max(0, Math.min(1, (this.cutsceneTime - 1) / 1));
            if (textFade > 0) {
                ctx.fillStyle = 'rgba(79, 195, 247, 0.95)';
                ctx.font = 'bold 22px Arial';
                ctx.shadowColor = '#4fc3f7';
                ctx.shadowBlur = 12;
                ctx.fillText('You\'ve broken free!', centerX, h * 0.95);
                ctx.font = '20px Arial';
                ctx.fillText('From mental prison to physical reality', centerX, h * 0.98);
                ctx.shadowBlur = 0;
            }
            
            ctx.globalAlpha = 1;
            
            // Set foreground text
            if (this.cutsceneText) {
                const cutsceneData = this.getCutsceneData(100);
                if (cutsceneData && cutsceneData.texts && cutsceneData.texts[2]) {
                    let text = cutsceneData.texts[2].replace(/^Level \d+:\s*/i, '');
                    this.cutsceneText.textContent = text;
                    this.cutsceneText.style.color = cutsceneData.textColor || '#4fc3f7';
                    this.cutsceneText.style.textShadow = '0 0 12px rgba(79, 195, 247, 0.9), 0 0 24px rgba(79, 195, 247, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8)';
                    this.cutsceneText.style.fontSize = '24px';
                    this.cutsceneText.style.fontWeight = '500';
                    this.cutsceneText.style.opacity = '1';
                    this.cutsceneText.classList.add('visible');
                }
            }
            
        }
    }

    gameLoop() {
        const now = performance.now();
        
        // Check if game is paused or in a menu state
        const isGamePaused = (this.isPaused && this.gameState === 'playing') || 
                             this.gameState === 'levelup' || 
                             this.levelUpState ||
                             this.gameState === 'inventory' ||
                             this.gameState === 'crafting' ||
                             this.gameState === 'shop';
        
        // Cutscenes need real-time deltaTime for proper timing (not fixed frame time)
        const isCutscene = this.gameState === 'cutscene';
        
        // Only update lastTime if game is actually running
        // This prevents huge deltaTime when unpausing
        if (!isGamePaused && !isCutscene) {
        let deltaTime = Math.min((now - this.lastTime) / 1000, 0.1);
            
            // Resume smoothing: Gradually increase deltaTime over first few frames after unpausing
            // This prevents lag spikes when many effects/bullets resume at once
            if (this.resumeSmoothing.active) {
                this.resumeSmoothing.framesRemaining--;
                if (this.resumeSmoothing.framesRemaining <= 0) {
                    this.resumeSmoothing.active = false;
                } else {
                    // Gradually increase from small to normal deltaTime over 3 frames
                    const smoothingProgress = 1 - (this.resumeSmoothing.framesRemaining / 3);
                    deltaTime = Math.min(deltaTime, this.resumeSmoothing.targetDeltaTime * (0.3 + smoothingProgress * 0.7));
                }
            }
            
        this.lastTime = now;

        // Apply dev mode speed multiplier
        if (this.devMode) {
            deltaTime *= this.devSpeedMultiplier;
        }

        this.update(deltaTime);
        } else if (isCutscene) {
            // Cutscenes: Use real-time deltaTime for accurate timing
            // This ensures cutscenes progress at the correct speed regardless of frame rate
            let deltaTime = Math.min((now - this.lastTime) / 1000, 0.1);
            
            // Initialize lastTime if not set (first frame of cutscene)
            if (!this.lastTime || this.lastTime === 0) {
                this.lastTime = now;
                deltaTime = 0.016; // Use standard frame time for first frame
            }
            
            // DO NOT apply dev mode speed multiplier to cutscenes - they should always play at normal speed
            // Cutscenes are timed for human reading speed and should not be affected by dev mode
            
            this.lastTime = now;
            this.update(deltaTime);
        } else {
            // When paused, still update with minimal deltaTime to keep UI responsive
            // But don't update lastTime, so when unpausing, deltaTime will be small
            this.update(0.016); // Use standard frame time
        }
        
        this.draw();

        requestAnimationFrame(() => this.gameLoop());
    }

    // ========== DEV MODE FUNCTIONS ==========
    
    devTogglePanel() {
        console.log('[DEV] devTogglePanel called');
        const panel = document.getElementById('devPanel');
        console.log('[DEV] Panel element found:', panel);
        
        if (!panel) {
            console.error('[DEV] Dev panel element not found!');
            console.error('[DEV] Searching for all elements with "dev" in id...');
            const devElements = Array.from(document.querySelectorAll('[id*="dev"]'));
            console.error('[DEV] Found dev elements:', devElements.map(el => ({ id: el.id, tag: el.tagName })));
            return;
        }
        
        const wasActive = panel.classList.contains('active');
        console.log('[DEV] Panel was active:', wasActive);
        
        panel.classList.toggle('active');
        const isActive = panel.classList.contains('active');
        console.log('[DEV] Panel is now active:', isActive);
        
        // Force visibility with inline style
        if (isActive) {
            panel.style.display = 'block';
            panel.style.visibility = 'visible';
            panel.style.opacity = '1';
            console.log('[DEV] Panel forced to visible');
            console.log('[DEV] Panel computed display:', window.getComputedStyle(panel).display);
            console.log('[DEV] Panel computed visibility:', window.getComputedStyle(panel).visibility);
            console.log('[DEV] Panel computed opacity:', window.getComputedStyle(panel).opacity);
            console.log('[DEV] Panel computed z-index:', window.getComputedStyle(panel).zIndex);
            console.log('[DEV] Panel position:', panel.getBoundingClientRect());
        } else {
            panel.style.display = 'none';
            console.log('[DEV] Panel hidden');
        }
        
        console.log('[DEV] Dev panel toggled:', isActive ? 'OPEN' : 'CLOSED');
    }

    devSetLevel() {
        const input = document.getElementById('devLevelInput');
        if (input) {
            const newLevel = parseInt(input.value) || 1;
            const targetLevel = Math.max(1, newLevel);
            const oldLevel = this.level;
            
            // Exit boss mode if we're in it
            if (this.bossMode) {
                this.exitBossMode();
            }
            
            // Close level-up menu if open
            if (this.levelUpState || this.gameState === 'levelup') {
                this.continueFromLevelUp();
            }
            
            // Update level
            this.level = targetLevel;
            
            // Update time to match the level (so normal progression continues correctly)
            // Level is calculated as: Math.floor(this.time / 30) + 1
            // So time should be: (level - 1) * 30
            this.time = (this.level - 1) * 30;
            
            // Update spawn rates based on new level
            this.targetSpawnRate = Math.max(500, 2000 - this.level * 100);
            this.obstacleSpawnRate = Math.max(1000, 3000 - this.level * 150);
            
            // Ensure game is in playing state
            if (this.gameState !== 'playing') {
                this.gameState = 'playing';
                this.levelUpState = false;
            }
            
            // If level increased, trigger level-up state (like normal progression)
            if (targetLevel > oldLevel) {
                this.triggerLevelUp();
            } else {
                // Just update UI if level decreased or same
                this.updateDevUI();
                console.log(`[DEV] Jumped to level ${this.level}`);
            }
        }
    }

    devNextLevel() {
        console.log('[DEV] devNextLevel called');
        
        // Exit boss mode if we're in it (manually to avoid showing level-up menu)
        if (this.bossMode) {
            console.log('[DEV] Exiting boss mode');
            this.bossMode = false;
            this.currentBoss = null;
            this.bossPuzzleState = {};
            
            // Re-enable mode switching buttons
            document.querySelectorAll('.mode-btn')?.forEach(btn => {
                btn.style.pointerEvents = 'auto';
                btn.style.opacity = '1';
            });
            
            // Return to individual mode
            this.setMode('individual');
            
            // Clear boss-specific entities
            this.obstacles = this.obstacles.filter(o => !o.isBoss);
            
            // Return to main music
            this.audio.playMusic('main', true, true);
        }
        
        // Close level-up menu if open
        if (this.levelUpState || this.gameState === 'levelup') {
            console.log('[DEV] Closing existing level-up menu');
            this.continueFromLevelUp();
        }
        
        // Increment level
        const oldLevel = this.level;
        this.level++;
        console.log(`[DEV] Level changed from ${oldLevel} to ${this.level}`);
        
        // Update time to match the level (so normal progression continues correctly)
        this.time = (this.level - 1) * 30;
        
        // Update spawn rates based on new level
        this.targetSpawnRate = Math.max(500, 2000 - this.level * 100);
        this.obstacleSpawnRate = Math.max(1000, 3000 - this.level * 150);
        
        // Ensure game is in playing state before triggering level-up
        this.gameState = 'playing';
        this.levelUpState = false;
        
        // Trigger level-up state (like normal progression)
        console.log('[DEV] Triggering level-up');
        try {
            this.triggerLevelUp();
        } catch (error) {
            console.error('[DEV] Error in triggerLevelUp:', error);
        }
    }

    devPrevLevel() {
        const oldLevel = this.level;
        this.level = Math.max(1, this.level - 1);
        
        // Update time to match the level
        this.time = (this.level - 1) * 30;
        
        // Update spawn rates based on new level
        this.targetSpawnRate = Math.max(500, 2000 - this.level * 100);
        this.obstacleSpawnRate = Math.max(1000, 3000 - this.level * 150);
        
        // Don't trigger level-up when going backwards, just update
        this.updateDevUI();
        console.log(`[DEV] Level: ${this.level}`);
    }
    
    // Helper method to trigger level-up (extracted from normal progression logic)
    triggerLevelUp() {
        // Don't trigger level-up if we're in a cutscene
        if (this.gameState === 'cutscene') {
            console.log(`[DEV] triggerLevelUp called but gameState is 'cutscene', ignoring`);
            return;
        }
        
        console.log(`[DEV] triggerLevelUp called for level ${this.level}`);
        
        // Check if this is a boss level (every 15 levels: 15, 30, 45, 60, etc.)
        const isBossLevel = this.level % 15 === 0;
        
        if (isBossLevel && !this.bossMode) {
            console.log(`[DEV] Level ${this.level} is a boss level, entering boss mode`);
            // Enter boss mode - combines all three modes
            this.enterBossMode();
            // Don't show level-up menu during boss battle - boss must be defeated first
            this.updateDevUI();
            console.log(`[DEV] Level ${this.level} - Boss level! Entering boss mode.`);
            return;
        }
        
        // Check if we should show a cutscene at this level (every 5 levels: 5, 10, 20, 25, 35, 40, 50, 55, 65, 70, 80, 85, 90, 95, 100)
        // Always show cutscenes when reaching these levels (can be skipped with double-click)
        const cutsceneLevels = [5, 10, 20, 25, 35, 40, 50, 55, 65, 70, 80, 85, 90, 95, 100];
        if (cutsceneLevels.includes(this.level)) {
            const cutsceneId = `level${this.level}`;
            console.log(`[Cutscene] Level ${this.level} - Showing cutscene: ${cutsceneId}`);
            this.startLevelCutscene(cutsceneId);
            return; // Don't show level-up menu yet, wait for cutscene to finish
        }
        
        // Reset boss spawn flag when level changes (for old level 150 boss)
        if (this.level !== 150) {
            this.bossSpawned = false;
        }
        
        // Level up! Open crafting/shop menu (only if not in boss mode)
        console.log(`[DEV] Triggering level-up menu for level ${this.level}`);
        try {
            this.audio.playSFX('levelUp', 1.0);
        } catch (e) {
            console.warn('[DEV] Could not play level-up sound:', e);
        }
        
        this.levelUpState = true;
        this.gameState = 'levelup'; // New state for level-up menu
        
        try {
            this.showLevelUpMenu();
            console.log('[DEV] Level-up menu shown successfully');
        } catch (e) {
            console.error('[DEV] Error showing level-up menu:', e);
            // Fallback: just update state without showing menu
            this.levelUpState = false;
            this.gameState = 'playing';
        }
        
        this.updateDevUI();
        console.log(`[DEV] Level ${this.level} - Level up! Showing level-up menu.`);
    }
    
    // Start a level-based cutscene
    startLevelCutscene(cutsceneId) {
        console.log(`[Cutscene] startLevelCutscene called with: ${cutsceneId}`);
        this.cutsceneId = cutsceneId;
        this.cutscenePhase = 0;
        this.cutsceneTime = 0;
        this.gameState = 'cutscene';
        this.startCutscene();
    }

    devToggleGodMode() {
        this.devGodMode = !this.devGodMode;
        const btn = document.getElementById('devGodMode');
        if (btn) {
            btn.textContent = `God Mode: ${this.devGodMode ? 'ON' : 'OFF'}`;
            btn.classList.toggle('active', this.devGodMode);
        }
        console.log(`[DEV] God Mode: ${this.devGodMode ? 'ON' : 'OFF'}`);
    }

    devToggleInfiniteAmmo() {
        this.devInfiniteAmmo = !this.devInfiniteAmmo;
        const btn = document.getElementById('devInfiniteAmmo');
        if (btn) {
            btn.textContent = `Infinite Ammo: ${this.devInfiniteAmmo ? 'ON' : 'OFF'}`;
            btn.classList.toggle('active', this.devInfiniteAmmo);
        }
        console.log(`[DEV] Infinite Ammo: ${this.devInfiniteAmmo ? 'ON' : 'OFF'}`);
    }

    devHealPlayer() {
        if (this.playerStats) {
            this.playerStats.health = this.playerStats.maxHealth || 100;
            if (this.playerStats.shield !== undefined) {
                this.playerStats.shield = this.playerStats.maxShield || 0;
            }
            this.updateStats();
            console.log('[DEV] Player fully healed');
        }
    }

    devMaxShield() {
        if (this.playerStats && this.playerStats.maxShield) {
            this.playerStats.shield = this.playerStats.maxShield;
            this.updateStats();
            console.log('[DEV] Shield maxed');
        }
    }

    devMaxHunger() {
        this.hunger = this.maxHunger || 100;
        this.updateStats();
        console.log(`[DEV] Hunger maxed to ${this.hunger}`);
    }

    devAddMaterials(amount = null) {
        const input = document.getElementById('devMaterialsInput');
        const addAmount = amount || (input ? parseInt(input.value) || 1000 : 1000);
        
        // Add to all material types in inventory
        if (!this.inventory) {
            this.inventory = {
                quantumParticles: 0,
                energyCores: 0,
                metalScraps: 0,
                crystals: 0,
                tokens: 0
            };
        }
        
        this.inventory.quantumParticles += addAmount;
        this.inventory.energyCores += addAmount;
        this.inventory.metalScraps += addAmount;
        this.inventory.crystals += addAmount;
        
        this.updateStats();
        console.log(`[DEV] Added ${addAmount} to all materials. Quantum: ${this.inventory.quantumParticles}, Energy: ${this.inventory.energyCores}, Metal: ${this.inventory.metalScraps}, Crystals: ${this.inventory.crystals}`);
    }

    devAddCredits(amount = null) {
        const input = document.getElementById('devCreditsInput');
        const addAmount = amount || (input ? parseInt(input.value) || 10000 : 10000);
        
        // Add to tokens (credits) in inventory
        if (!this.inventory) {
            this.inventory = {
                quantumParticles: 0,
                energyCores: 0,
                metalScraps: 0,
                crystals: 0,
                tokens: 0
            };
        }
        
        this.inventory.tokens += addAmount;
        this.updateStats();
        console.log(`[DEV] Added ${addAmount} tokens. Total: ${this.inventory.tokens}`);
    }

    devMaxResources() {
        // Initialize inventory if it doesn't exist
        if (!this.inventory) {
            this.inventory = {
                quantumParticles: 0,
                energyCores: 0,
                metalScraps: 0,
                crystals: 0,
                tokens: 0
            };
        }
        
        // Max all inventory resources
        this.inventory.quantumParticles = 999999;
        this.inventory.energyCores = 999999;
        this.inventory.metalScraps = 999999;
        this.inventory.crystals = 999999;
        this.inventory.tokens = 999999;
        
        this.updateStats();
        console.log('[DEV] Maxed all resources:', this.inventory);
    }

    devAddFoodMaterials() {
        // Initialize inventory if it doesn't exist
        if (!this.inventory) {
            this.inventory = {
                quantumParticles: 0,
                energyCores: 0,
                metalScraps: 0,
                crystals: 0,
                tokens: 0,
                // Biological components for survival system
                atp: 0,
                aminoAcids: 0,
                simpleSugars: 0,
                fattyAcids: 0,
                nucleotides: 0,
                vitamins: 0,
                minerals: 0
            };
        }
        
        // Add abundant food materials (1000 of each)
        const amount = 1000;
        this.inventory.atp = (this.inventory.atp || 0) + amount;
        this.inventory.aminoAcids = (this.inventory.aminoAcids || 0) + amount;
        this.inventory.simpleSugars = (this.inventory.simpleSugars || 0) + amount;
        this.inventory.fattyAcids = (this.inventory.fattyAcids || 0) + amount;
        this.inventory.nucleotides = (this.inventory.nucleotides || 0) + amount;
        this.inventory.vitamins = (this.inventory.vitamins || 0) + amount;
        this.inventory.minerals = (this.inventory.minerals || 0) + amount;
        
        this.updateStats();
        console.log('[DEV] Added food materials:', {
            atp: this.inventory.atp,
            aminoAcids: this.inventory.aminoAcids,
            simpleSugars: this.inventory.simpleSugars,
            fattyAcids: this.inventory.fattyAcids,
            nucleotides: this.inventory.nucleotides,
            vitamins: this.inventory.vitamins,
            minerals: this.inventory.minerals
        });
    }

    devSpawnBoss() {
        // Ensure level is at least 15 for boss spawning
        if (this.level < 15) {
            this.level = 15;
            console.log('[DEV] Level set to 15 for boss spawn');
        }
        
        // Ensure game is in playing state
        if (this.gameState !== 'playing') {
            this.gameState = 'playing';
            this.levelUpState = false;
            console.log('[DEV] Game state set to playing');
        }
        
        // Ensure canvas is ready
        if (this.canvas.width === 0 || this.canvas.height === 0) {
            console.warn('[DEV] Canvas not ready, resizing...');
            this.resize();
        }
        
        console.log('[DEV] Canvas size:', this.canvas.width, 'x', this.canvas.height);
        console.log('[DEV] Entering boss mode for level:', this.level);
        
        // Clear any existing obstacles/enemies BEFORE entering boss mode
        this.obstacles = [];
        this.enemyShips = [];
        this.targets = [];
        this.pairs = [];
        
        // Enter boss mode (this will spawn the boss)
        this.enterBossMode();
        
        // Verify boss was spawned
        setTimeout(() => {
            const bossObstacles = this.obstacles.filter(o => o.isBoss);
            console.log('[DEV] Boss mode entered');
            console.log('[DEV] Current level:', this.level);
            console.log('[DEV] Boss number:', Math.floor(this.level / 15));
            console.log('[DEV] Total obstacles:', this.obstacles.length);
            console.log('[DEV] Boss obstacles:', bossObstacles.length);
            if (bossObstacles.length > 0) {
                console.log('[DEV] Boss spawned successfully!');
                bossObstacles.forEach((boss, i) => {
                    console.log(`[DEV] Boss part ${i + 1}:`, {
                        part: boss.bossPart || 'unknown',
                        type: boss.bossType || 'unknown',
                        x: boss.x,
                        y: boss.y,
                        size: boss.size,
                        health: boss.health,
                        maxHealth: boss.maxHealth,
                        hasNodes: !!boss.nodes,
                        nodesCount: boss.nodes ? boss.nodes.length : 0
                    });
                });
            } else {
                console.error('[DEV] ERROR: Boss failed to spawn!');
                console.error('[DEV] Attempting manual spawn...');
                // Try manual spawn
                const bossNumber = Math.floor(this.level / 15);
                this.spawnBossByNumber(bossNumber);
                const retryBoss = this.obstacles.filter(o => o.isBoss);
                console.log('[DEV] After manual spawn, boss obstacles:', retryBoss.length);
            }
        }, 200);
    }
    
    devSpawnSpecificBoss() {
        const select = document.getElementById('devBossSelect');
        if (!select) {
            console.error('[DEV] Boss select element not found!');
            return;
        }
        
        const bossNumber = parseInt(select.value);
        if (isNaN(bossNumber) || bossNumber < 1) {
            console.error('[DEV] Invalid boss number:', select.value);
            return;
        }
        
        // Ensure game is in playing state
        if (this.gameState !== 'playing') {
            this.gameState = 'playing';
            this.levelUpState = false;
            console.log('[DEV] Game state set to playing');
        }
        
        console.log(`[DEV] Spawning boss ${bossNumber}...`);
        
        // Enter boss mode with specific boss number
        this.enterBossMode(bossNumber);
        
        // Verify boss was spawned
        setTimeout(() => {
            const bossObstacles = this.obstacles.filter(o => o.isBoss);
            console.log(`[DEV] Boss ${bossNumber} spawn attempt complete`);
            console.log('[DEV] Boss obstacles:', bossObstacles.length);
            if (bossObstacles.length > 0) {
                console.log(`[DEV] Boss ${bossNumber} spawned successfully!`);
                bossObstacles.forEach((boss, i) => {
                    console.log(`[DEV] Boss part ${i + 1}:`, boss.bossPart || 'unknown', 'at', boss.x, boss.y, 'size:', boss.size);
                });
            } else {
                console.error(`[DEV] ERROR: Boss ${bossNumber} failed to spawn!`);
            }
        }, 100);
    }

    devKillBoss() {
        // Kill all boss obstacles
        const bossObstacles = this.obstacles.filter(o => o.isBoss);
        if (bossObstacles.length > 0) {
            bossObstacles.forEach(boss => {
                boss.health = 0;
            });
            console.log(`[DEV] Killed ${bossObstacles.length} boss parts`);
        } else if (this.currentBoss) {
            this.currentBoss.health = 0;
            console.log('[DEV] Boss killed via currentBoss reference');
        } else {
            console.log('[DEV] No boss active');
        }
    }

    devSkipToBoss() {
        // Jump to next boss level
        const nextBossLevel = Math.ceil(this.level / 15) * 15;
        this.level = nextBossLevel || 15;
        this.updateDevUI();
        console.log(`[DEV] Skipped to boss level: ${this.level}`);
    }

    devSetSpeed() {
        const input = document.getElementById('devSpeedInput');
        if (input) {
            this.devSpeedMultiplier = parseFloat(input.value) || 1.0;
            console.log(`[DEV] Speed multiplier: ${this.devSpeedMultiplier}x`);
        }
    }

    devResetSpeed() {
        this.devSpeedMultiplier = 1.0;
        const input = document.getElementById('devSpeedInput');
        if (input) {
            input.value = '1.0';
        }
        console.log('[DEV] Speed reset to 1.0x');
    }

    devToggleDebug() {
        this.devShowDebug = !this.devShowDebug;
        const btn = document.getElementById('devShowDebug');
        if (btn) {
            btn.textContent = `Show Debug: ${this.devShowDebug ? 'ON' : 'OFF'}`;
            btn.classList.toggle('active', this.devShowDebug);
        }
    }

    devPlayCutscene() {
        // Prevent multiple simultaneous calls
        if (this.gameState === 'cutscene') {
            console.log('[DEV] Cutscene already playing, ignoring duplicate call');
            return;
        }
        
        const select = document.getElementById('devCutsceneSelect');
        if (!select) {
            console.error('[DEV] Cutscene select element not found');
            return;
        }
        
        const cutsceneId = select.value;
        if (!cutsceneId) {
            console.error('[DEV] No cutscene selected');
            return;
        }
        
        console.log(`[DEV] Playing cutscene: ${cutsceneId}`);
        console.log(`[DEV] Current gameState: ${this.gameState}`);
        console.log(`[DEV] Cutscene elements:`, {
            overlay: !!this.cutsceneOverlay,
            canvas: !!this.cutsceneCanvas,
            text: !!this.cutsceneText,
            ctx: !!this.cutsceneCtx
        });
        
        // Mark as manual cutscene (won't trigger level-up menu after)
        this.cutsceneIsManual = true;
        
        // Close any open menus before starting cutscene
        if (this.gameState === 'levelup') {
            this.continueFromLevelUp(); // Use continueFromLevelUp to properly close menus
        }
        
        // Re-initialize cutscene elements if they're missing (in case DOM wasn't ready during constructor)
        if (!this.cutsceneCanvas) {
            this.cutsceneCanvas = document.getElementById('cutsceneCanvas');
            if (this.cutsceneCanvas) {
                this.cutsceneCtx = this.cutsceneCanvas.getContext('2d');
                this.cutsceneCanvas.width = window.innerWidth;
                this.cutsceneCanvas.height = window.innerHeight;
                console.log('[DEV] Re-initialized cutscene canvas');
            }
        }
        if (!this.cutsceneOverlay) {
            this.cutsceneOverlay = document.getElementById('cutsceneOverlay');
            console.log('[DEV] Re-initialized cutscene overlay');
        }
        if (!this.cutsceneText) {
            this.cutsceneText = document.getElementById('cutsceneText');
            console.log('[DEV] Re-initialized cutscene text');
        }
        
        // Start the selected cutscene
        if (cutsceneId === 'opening') {
            this.cutsceneId = 'opening';
            this.cutscenePhase = 0;
            this.cutsceneTime = 0;
            this.gameState = 'cutscene';
            console.log(`[DEV] Starting opening cutscene, gameState: ${this.gameState}, cutsceneId: ${this.cutsceneId}`);
            this.startCutscene();
        } else if (cutsceneId.startsWith('level')) {
            console.log(`[DEV] Starting level cutscene: ${cutsceneId}`);
            this.startLevelCutscene(cutsceneId);
        } else {
            console.error(`[DEV] Unknown cutscene ID: ${cutsceneId}`);
        }
        
        // Update dev UI once after starting cutscene (level won't change during cutscene)
        this.updateDevUI();
    }
    
    devResetCutscenes() {
        // Clear cutscene progress
        this.cutscenesShown = [];
        localStorage.removeItem('cutscenesShown');
        console.log('[DEV] Cutscene progress reset - all cutscenes will show again');
        alert('Cutscene progress reset! All cutscenes will show again at their respective levels.');
    }
    
    devLogState() {
        console.log('[DEV] Game State:', {
            level: this.level,
            score: this.score,
            inventory: this.inventory || {},
            playerHealth: this.playerStats?.health,
            playerShield: this.playerStats?.shield,
            gameState: this.gameState,
            bossMode: this.bossMode,
            currentBoss: this.currentBoss,
            bossObstacles: this.obstacles.filter(o => o.isBoss).length,
            weapons: this.currentWeapons,
            mode: this.mode,
            canvasSize: `${this.canvas.width}x${this.canvas.height}`
        });
    }

    devClearAll() {
        this.bullets = [];
        this.enemyBullets = [];
        this.targets = [];
        this.pairs = [];
        this.obstacles = [];
        this.enemyShips = [];
        this.items = [];
        this.particles = [];
        console.log('[DEV] All entities cleared');
    }

    devKillAllEnemies() {
        this.enemyShips = [];
        this.targets = [];
        this.obstacles = this.obstacles.filter(o => o.isBoss); // Keep bosses
        console.log('[DEV] All enemies killed');
    }

    updateDevUI() {
        // Only update if level actually changed to prevent flashing
        const levelDisplay = document.getElementById('devCurrentLevel');
        if (levelDisplay) {
            const currentDisplay = parseInt(levelDisplay.textContent) || 0;
            if (currentDisplay !== this.level) {
                levelDisplay.textContent = this.level;
            }
        }
        const levelInput = document.getElementById('devLevelInput');
        if (levelInput) {
            const currentInput = parseInt(levelInput.value) || 0;
            if (currentInput !== this.level) {
                levelInput.value = this.level;
            }
        }
    }

    // Initialize dev mode UI
    initDevMode() {
        if (!this.devMode) return;
        
        // Verify dev panel exists
        const panel = document.getElementById('devPanel');
        if (panel) {
            console.log('[DEV] Dev panel found in DOM');
            console.log('[DEV] Panel initial state - display:', window.getComputedStyle(panel).display);
        } else {
            console.error('[DEV] WARNING: Dev panel not found in DOM!');
        }

        // Update UI on interval (but not during cutscenes)
        setInterval(() => {
            if (this.gameState !== 'cutscene') {
                this.updateDevUI();
            }
        }, 1000);

        // Initialize button states
        const godBtn = document.getElementById('devGodMode');
        if (godBtn) {
            godBtn.textContent = `God Mode: ${this.devGodMode ? 'ON' : 'OFF'}`;
            godBtn.classList.toggle('active', this.devGodMode);
        }

        const ammoBtn = document.getElementById('devInfiniteAmmo');
        if (ammoBtn) {
            ammoBtn.textContent = `Infinite Ammo: ${this.devInfiniteAmmo ? 'ON' : 'OFF'}`;
            ammoBtn.classList.toggle('active', this.devInfiniteAmmo);
        }

        const debugBtn = document.getElementById('devShowDebug');
        if (debugBtn) {
            debugBtn.textContent = `Show Debug: ${this.devShowDebug ? 'ON' : 'OFF'}`;
            debugBtn.classList.toggle('active', this.devShowDebug);
        }

        console.log('[DEV] Developer mode enabled');
    }
    
    drawDebugInfo() {
        const ctx = this.ctx;
        const x = 10;
        let y = 30;
        const lineHeight = 18;
        const fontSize = 12;
        
        ctx.font = `${fontSize}px monospace`;
        ctx.fillStyle = 'rgba(255, 102, 0, 0.9)';
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.lineWidth = 2;
        
        const debugInfo = [
            `Level: ${this.level}`,
            `Score: ${this.score}`,
            `FPS: ${Math.round(1 / (this.lastTime ? (performance.now() - this.lastTime) / 1000 : 0.016))}`,
            `Entities: ${this.bullets.length + this.targets.length + this.obstacles.length + this.enemyShips.length}`,
            `Bullets: ${this.bullets.length}`,
            `Targets: ${this.targets.length}`,
            `Obstacles: ${this.obstacles.length}`,
            `Enemy Ships: ${this.enemyShips.length}`,
            `Mode: ${this.mode}`,
            `Boss Mode: ${this.bossMode}`,
            `God Mode: ${this.devGodMode ? 'ON' : 'OFF'}`,
            `Infinite Ammo: ${this.devInfiniteAmmo ? 'ON' : 'OFF'}`,
            `Speed: ${this.devSpeedMultiplier}x`
        ];
        
        debugInfo.forEach((info, i) => {
            ctx.strokeText(info, x, y + i * lineHeight);
            ctx.fillText(info, x, y + i * lineHeight);
        });
    }
}

window.addEventListener('load', () => {
    console.log('Starting Beyond Bell Space Shooter...');
    try {
        const game = new SpaceShooterGame();
        window.game = game;
        console.log('Game initialized!');
        console.log('Controls: WASD to move, Click/Space to shoot, C for crafting, S for shop');
    } catch (error) {
        console.error('Error:', error);
        alert('Error loading game. Check console.');
    }
});

